<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2023-11-20T15:53:38.008Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>领域驱动设计_实现领域驱动设计-第二章</title>
    <link href="https://agmtopy.gitee.io/2023/10/28/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://agmtopy.gitee.io/2023/10/28/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-10-28T14:08:00.000Z</published>
    <updated>2023-11-20T15:53:38.008Z</updated>
    
    <content type="html"><![CDATA[<h1>如何理解领域、子域和限界上下文</h1><p>从三个问题开始:</p><ol><li>什么是领域?</li><li>什么是子域?</li><li>什么是限界上下文?</li></ol><h2 id="什么是领域"><a class="header-anchor" href="#什么是领域"></a>什么是领域?</h2><blockquote><p>从广义上来讲,<B>领域</B>是一个组织所做的事情以及其中包含的一切;</p></blockquote><p>这段话的解释应该是,领域是公司或组织所要提供的服务所对应的所有事情,这些事情就是领域;</p><p><B>领域</B>这个词的范围很大,承载太多的含义,领域既可以表示整个系统,也可以标识其中的某个核心域或者支撑子域;在DDD中一个领域被划分为多个<B>子域</B>,领域模型在<B>限界上下文</B>上下文中完成设计/开发;</p><p><img src="https://github.com/agmtopy/noteBook/blob/99706f9bc20ab65b10cc39b038f0b4248b599af3/png/s-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9B%BE2.1%E4%B8%80%E4%B8%AA%E5%90%AB%E6%9C%89%E5%AD%90%E5%9F%9F%E5%92%8C%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E9%A2%86%E5%9F%9F,%E6%A8%A1%E5%9E%8B.png?raw=true" alt=""></p><p>看一个含有子域和限界上下文的领域模型例子:</p><p>最外层中最大的实线表示的就是这个领域驱动模型中的<B>领域</B>,这个领域表示的是一个电子商务系统的领域是由于多个子域和限界上下文组成;<br>在内层中用虚线划分出来的就是<B>子域</B>,可以看到在<B>电子商务系统</B>的领域下有产品目录子域、订单子域、发票子域、物流子域;<br>在内层中还可以看到实线划分出来的<B>界限上下文</B>,界限上下文将不同的子域连接在了一起;</p><p>从上述的例子中<B>电子商务系统</B>就是一个领域,它表示的是电商公司的核心业务,这样我们可以得出领域即业务的结论;</p><h2 id="什么是子域"><a class="header-anchor" href="#什么是子域"></a>什么是子域;</h2><p>从上面的例子中可以看到子域就是更小的范围,子域并不是一定要做的很大,并且包含很多的功能;有些时候,子域可以简单到只包含一套算法,这套算法可能对于业务系统来说非常重要,但是并不包含在这套系统的核心域中;</p><p>子域又可以被划分成:<B>核心域</B>、<B>支撑域</B>、<B>通用域</B>三个部分;</p><p><img src="https://github.com/agmtopy/noteBook/blob/36f56f3815b4b3b5abcf5231aa48ae19410365d3/png/s-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9B%BE2.2%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E5%AD%90%E5%9F%9F%E5%92%8C%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png?raw=true" alt=""></p><p><B>核心域</B>是最高优先级、最资深的领域转换和最优秀的开发团队进行主导,在实施DDD的过程中,需要关注核心域;<br><B>支撑域</B>通常是用来支撑我们的业务的,虽然对于业务的某些方面重要,但是不是核心;<br><B>通用域</B>指的是可以被应用与整个业务系统,类似于基础框架,底层模型;</p><p>实施DDD的过程中应该尽量避免将关注点聚焦在<B>实体</B>、<B>值对象</B>之上,这样会导致缺少一种更广阔的视野,会导致不同的核心杂糅在一起,导致他们将两个模型创建成一个;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;如何理解领域、子域和限界上下文&lt;/h1&gt;
&lt;p&gt;从三个问题开始:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是领域?&lt;/li&gt;
&lt;li&gt;什么是子域?&lt;/li&gt;
&lt;li&gt;什么是限界上下文?&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;什么是领域&quot;&gt;&lt;a class=&quot;header-ancho</summary>
      
    
    
    
    <category term="领域驱动" scheme="https://agmtopy.gitee.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="领域驱动" scheme="https://agmtopy.gitee.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码分析(一)</title>
    <link href="https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/20.Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/20.Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/</id>
    <published>2023-06-27T15:14:13.000Z</published>
    <updated>2023-07-30T08:21:47.088Z</updated>
    
    <content type="html"><![CDATA[<h1>Netty源码分析(一)</h1><h2 id="简述"><a class="header-anchor" href="#简述"></a>简述</h2><p>从IO到NIO体现了java对于流操作的一个变迁,在到构建Netty,这一个系列文章主要讲述的就是Netty框架,第一篇文章从NIO出发;<br>主要分为:<br>Socket编程、IO模型、Netty简介、Netty示例,下面就开始今天的学习吧!</p><h2 id="Socket编程"><a class="header-anchor" href="#Socket编程"></a>Socket编程</h2><p>Socket最早是在4.3BSD UNIX中内置的’Berkeley Socket’演化而来,主要是用于实现进程间的通信;</p><h3 id="Socket通信模型"><a class="header-anchor" href="#Socket通信模型"></a>Socket通信模型</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.Socket%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B.png?raw=true" alt="Socket通信模型"></p><p>Socket通信模型如上图所示,Socket是作为应用层与传输层之间协议,对应用层来说只要按照Socket设计的协议进行调用就可以进行通信了;</p><p>常用的Socket类型有两种:“Stream Sockets”(串流式 Sockets)和&quot;Datagram Sockets&quot;(讯息式 Sockets),Stream Sockets底层使用的是TCP协议,Datagram Sockets底层使用的是UDP协议;</p><blockquote><p>CP 会在传输层对将上层送来的过大数据分割成多个 TCP 段（TCP segments），而 UDP 本身不会，UDP 是信息导向的（message oriented），若 UDP 信息过大时（整体数据包长度超过 MTU），则会由 host 或 router 在 IP 层对数据包进行分割，将一个 IP packet 分割成多个 IP fragments。IP fragmention 的缺点是，到达端的系统需要做 IP 数据包的重组，将多个 fragments 重组合并为原本的 IP 数据包，同时也会增加数据包遗失的可能性。如将一个 IP packet 分割成多个 IP fragments，只要其中一个 IP fragment 遗失了，到达端就会无法顺利重组 IP 数据包，因而造成数据包的遗失，若是高可靠度的应用，则上层协议需重送整个 packet 的数据。</p></blockquote><h3 id="简单示例"><a class="header-anchor" href="#简单示例"></a>简单示例</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/HttpServer01.kt">HttpServer01.kt</a></p><p>开启8880端口,然后返回字符串&quot;socket&quot;,通过这个程序可以看到影响程序响应的因素是在于对响应的一个处理速度,示例中的程序是采用new Thread的方式,但是在还有很多改进的空间:使用线程池;</p><p>这种I/O模型是标准的select/poll模型,有以下这些缺点:</p><ol><li>每次调用需要将数据从用户态拷贝到内核态</li><li>select需要遍历内核态传递进来的全部fd（file descriptor）是指向一个打开的文件或I/O设备的数字标识符</li><li>select支持的文件描述符只有1024个</li></ol><h2 id="NIO模型"><a class="header-anchor" href="#NIO模型"></a>NIO模型</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.IO%E6%A8%A1%E5%9E%8B.png?raw=true" alt="IO模型"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.IO%E6%A8%A1%E5%9E%8B.png?raw=true" alt="IO复用"></p><h2 id="Netty模型"><a class="header-anchor" href="#Netty模型"></a>Netty模型</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.Netty%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png?raw=true" alt="Netty整体流程"></p><p>下面根据这个整体流程先写一个简单示例;</p><h3 id="Netty基本组件"><a class="header-anchor" href="#Netty基本组件"></a>Netty基本组件</h3><h4 id="NioEventLoop组件"><a class="header-anchor" href="#NioEventLoop组件"></a>NioEventLoop组件</h4><p>NioEventLoop同时处理<B>客户端连接</B>、<B>读写客户端发送过来的数据</B></p><h4 id="Channel组件"><a class="header-anchor" href="#Channel组件"></a>Channel组件</h4><h4 id="ByteBuf"><a class="header-anchor" href="#ByteBuf"></a>ByteBuf</h4><h4 id="Pipeline"><a class="header-anchor" href="#Pipeline"></a>Pipeline</h4><p>使用逻辑链,来解析数据</p><h4 id="Channel-Handler"><a class="header-anchor" href="#Channel-Handler"></a>Channel Handler</h4><h3 id="执行过程"><a class="header-anchor" href="#执行过程"></a>执行过程</h3><h4 id="服务端执行流程"><a class="header-anchor" href="#服务端执行流程"></a>服务端执行流程</h4><ol><li><p>创建服务端Channel<br>bind():用户代码入口 -&gt;   initAndRegister():初始化并注册  -&gt;  newChannel():创建服务端Channel</p></li><li><p>初始化服务端Channel</p><p>NioServerSocketChannel.class初始化方法:<br>1. newSocket()通过JDK来创建原生Channel<br>2. NioServerSockerChannelConfig配置TCP参数<br>3. AbstractNioChannel<br>3.1 configureBlocking 设置阻塞/非阻塞模式<br>3.2 AbstractChannel创建id/unsafe/pipeline</p></li></ol><p>添加 ServerBootstrapAcceptor -&gt; ServerBootstrapAcceptor.init()</p><p>添加Handler,</p><ol start="3"><li>注册selector</li></ol><p>在创建和注册channel完成以后,会调用EventLoopGroup接口的实现类进行注册;</p><p>整体流程:</p><ol><li>bind()作为入口</li><li>AbstractBootstrap#initAndRegister作为实现方法</li><li>通过EventLoopGroup的子类,NioEventLoopGroup的父类MultithreadEventLoopGroup实现的<B>register()</B>实现</li></ol><p>register()执行的时候是通过MultithreadEventExecutorGroup#next()方法获取事件处理器,next()方法是通过<a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorChooserFactory.java#L34">DefaultEventExecutorChooserFactory#newChooser</a>来进行选择,选择EventExecutor[] executors数组中的元素时,对于偶数和奇数的处理方式不同;</p><p>register()方法<B>EventLoopGroup#register(Channel channel)</B>接口定义的将传入的channel注册到EvetLoop的方法;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    channel<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> promise<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java#L188">EmbeddedEventLoop</a></p><p>EventLoopGroup通过调用<B>channel.register</B>方法来进行处理;</p><ol start="4"><li>端口绑定<ol><li>AbstractBootstrap#doBind</li><li>AbstractBootstrap#doBind0</li><li>AbstractUnsafe#bind</li><li>NioSocketChannel#doBind</li><li>NioSocketChannel#doBind0</li><li>SocketUtils#bind</li><li>事件广播</li></ol></li></ol><p>'端口绑定’这个功能分为两个动作:1-操作端口绑定、2-绑定事件进行广播</p><p>上述1~6的步骤都是将Netty将设置的端口通过JDK底层方法进行绑定,在绑定完成后是通过后续<B>事件广播</B>功能将这一事件广播出去</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//端口绑定完成以后isActive()返回true</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasActive <span class="token operator">&amp;&amp;</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//广播事件 @TODO</span>            pipeline<span class="token punctuation">.</span><span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>pipeline.fireChannelActive()</B>方法会调用到<B>HeadContext#channelActive</B></p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><h2 id="NioEventLoop组件-v2"><a class="header-anchor" href="#NioEventLoop组件-v2"></a>NioEventLoop组件</h2><ol><li>默认情况下,Netty服务端会启动多少线程?什么时候启动?</li><li>Netty如何解决JDK空轮询问题?</li><li>Netty如何保证异步串行无锁化?</li></ol><h3 id="NioEventLoop创建过程"><a class="header-anchor" href="#NioEventLoop创建过程"></a>NioEventLoop创建过程</h3><h4 id="创建核心线程数"><a class="header-anchor" href="#创建核心线程数"></a>创建核心线程数</h4><p>在我们的示例代码中可以看到</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> bossGroup <span class="token operator">=</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> workerGroup <span class="token operator">=</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>NioEventLoopGroup有两种构造方法,一种传参,一种不传参数,进入构造方法可以看到:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置线程数量</span><span class="token keyword">public</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//不设置线程数量时</span><span class="token keyword">protected</span> <span class="token class-name">MultithreadEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">Executor</span> executor<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>nThreads <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> DEFAULT_EVENT_LOOP_THREADS <span class="token operator">:</span> nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_EVENT_LOOP_THREADS<span class="token punctuation">;</span><span class="token comment">//设置线程数量为配置参数值或默认当前核心数*2</span><span class="token keyword">static</span> <span class="token punctuation">&#123;</span>    DEFAULT_EVENT_LOOP_THREADS <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">SystemPropertyUtil</span><span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>            <span class="token string">"io.netty.eventLoopThreads"</span><span class="token punctuation">,</span> <span class="token class-name">NettyRuntime</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"-Dio.netty.eventLoopThreads: &#123;&#125;"</span><span class="token punctuation">,</span> DEFAULT_EVENT_LOOP_THREADS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建线程执行器"><a class="header-anchor" href="#创建线程执行器"></a>创建线程执行器</h4><h3 id="NioEventLoop启动过程"><a class="header-anchor" href="#NioEventLoop启动过程"></a>NioEventLoop启动过程</h3><h3 id="NioEventLoop执行逻辑"><a class="header-anchor" href="#NioEventLoop执行逻辑"></a>NioEventLoop执行逻辑</h3><ol start="4"><li>业务逻辑:对数据包进行拆包 -&gt; 数据类型处理器</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.kancloud.cn/luoyoub/network-programming/2237006">Socket通信模型</a><br><a href="https://beej-zhcn.netdpi.net/whatissocket/liang_zhong_internet_sockets">Beej’s Guide to Network Programming简体中文</a><br><a href="https://www.cnblogs.com/ZhuChangwu/p/11237899.html">Netty中的策略模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Netty源码分析(一)&lt;/h1&gt;
&lt;h2 id=&quot;简述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;
&lt;p&gt;从IO到NIO体现了java对于流操作的一个变迁,在到构建Netty,这一个系列文章主要讲述的就是Netty框</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Netty" scheme="https://agmtopy.gitee.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty实战第一章</title>
    <link href="https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/25.Netty%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/25.Netty%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2023-06-27T15:14:13.000Z</published>
    <updated>2023-10-23T14:50:02.682Z</updated>
    
    <content type="html"><![CDATA[<h1>Netty实战第一章</h1><h2 id="简述"><a class="header-anchor" href="#简述"></a>简述</h2><p>在学习Netty源码的过程中,十分吃力看来还是需要先从<B>使用</B>在到<B>研究</B>过程,因此将《Netty实战》一书重新拾起,以下是相关笔记;</p><h2 id="Netty基础组件"><a class="header-anchor" href="#Netty基础组件"></a>Netty基础组件</h2><ol><li>Channel;</li><li>回调</li><li>Future</li><li>事件和ChannelHandler</li></ol><h3 id="Channel"><a class="header-anchor" href="#Channel"></a>Channel</h3><p>Channel是对Java NIO的一个抽象;</p><blockquote><p>代表一个到实体(例如硬件设备、文件、网络套接字)的开发连接,可以执行<B>读操作</B>和<B>写操作</B>,可以把Channel看作传入或传出数据的载体.因此它们可以被打开或关闭;</p></blockquote><h3 id="回调"><a class="header-anchor" href="#回调"></a>回调</h3><p>一个<B>回调</B>其实就是一个方法,一个指向已经被提供给另外一个方法的方法的引用,这使得后者方法可以在适当的时候来回调前者;</p><h3 id="Future"><a class="header-anchor" href="#Future"></a>Future</h3><p><B>Future</B>提供了另外一种在操作完成时通知应用程序的方式.这个对象可以看作是一个异步操作的结果的<B>占位符</B>;它将在未来的某个时刻完成,并提供对其结果的访问;在JDK中提供的已有的Future实现,需要手动检查对于操作是否完成或者需要柱塞,十分繁琐;因此在Netty提供了<B>ChannelFuture</B>实现,用于在执行异步操作的时候使用;</p><h3 id="事件和ChannelHandler"><a class="header-anchor" href="#事件和ChannelHandler"></a>事件和ChannelHandler</h3><p>Netty中使用不同的事件来通知我们状态的改变或者操作的状态,如下图所示的事件驱动</p><p>!(ChannelHandler链的入站和出站事件)[]</p><hr><ul><li><p>Future、回调和ChannelHandler<br>Netty的异步编程模型是建立在Future和回调的概念之上的,而将事件分派到ChannelHandler的方法则是建立在这个基础之上更高层的概念;</p></li><li><p>选择器、事件和EventLoop<br>Netty通过触发事件将Selector从应用程序中抽象出来,简化了原来需要手动编写的派发代码.在netty内部会为每一个Channel分配一个EventLoop用于处理所有事件,包括:</p></li></ul><ol><li>注册感兴趣的事件</li><li>将事件派发给ChannelHandler</li><li>安排进一步动作</li></ol><p>EventLoop本身就是一个线程驱动,其处理了一个Channel的所有I/O事件,并且在该EventLoop的整个生命周期内都不会发生改变;</p><h2 id="Netty的Hello-World"><a class="header-anchor" href="#Netty的Hello-World"></a>Netty的Hello World</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.Echo%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8.png?raw=true" alt="Echo客户端与服务端"></p><p>服务端是可以同时处理多个客户端连接的,客户端在建立一个连接之后,它会先服务端发送一个或者多个消息,反过来,服务器邮费将每个消息发回客户端,这就是典型的<B>请求⇌响应</B>模式;</p><h3 id="服务端代码"><a class="header-anchor" href="#服务端代码"></a>服务端代码</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoServerHandler.kt">EchoServerHandler</a></p><ul><li>EchoServerHandler实现了业务处理逻辑</li></ul><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoServer.kt">EchoServer</a></p><p>EchoServer创建引导过程:</p><ul><li>创建一个ServerBootstrap的实例来进行引导和绑定服务器</li><li>创建并分配一个<B>NioEventLoopGroup</B>实例以进行事件的处理,如接受新连接以及读写数据</li><li>指定服务器绑定的本地InetSocketAddress</li><li>使用一个EchoServerHandler实例初始化每一个新的Channel</li><li>调用ServerBootstrap.bind()方法以绑定服务器</li></ul><h3 id="客户端代码"><a class="header-anchor" href="#客户端代码"></a>客户端代码</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoClient.kt">EchoClient.kt</a><br><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoClientHandler.kt">EchoClientHandler.kt</a></p><p>EchoClientHandler业务逻辑:</p><ul><li>channelActive - 在到服务器的连接已经建立之后将被调用</li><li>channelRead - 当从服务器收到一条消息时被调用</li><li>exceptionCaught - 在处理过程中引发异常时将被调用</li></ul><p><B>channelRead</B>方法,每当接收到数据时,都会调用这个方法,需要注意的是,它在接受服务器发送的消息时可能会被<B>分段接收</B>;<br>举一个例子就是,当服务器发送5 Byte时,客户端不能保证这5 Byte会被一次性全部接收,可能是第一次接受到3 Byte,第二次接受到2 Byte;或者反之亦然;</p><p>TCP协议作为一个面向流的协议,它会保证数据流会按照服务端的发送顺序来进行接收;</p><p>EchoClient引导逻辑:</p><ul><li>与服务端引导逻辑类似</li><li>创建BootStrap,客户端这里是<B>BootStrap</B>,不是ServerBootStrap</li><li>指定EventLoopGroup处理客户端事件</li><li>选择NIO传输的Channel类型</li><li>设置服务端的地址</li><li>设置业务处理链</li></ul><h3 id="执行结果"><a class="header-anchor" href="#执行结果"></a>执行结果</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.Echo%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png?raw=true" alt="Echo客户端与服务器执行结果"></p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>通过Echo服务端与客户端的配合,我们初步了解到了创建一个Netty程序需要有两部分组成:<B>引导程序</B>、<B>业务处理</B>,接下来我们详细的了解一下Netty的组件和设计;</p><h2 id="Netty的组件和设计"><a class="header-anchor" href="#Netty的组件和设计"></a>Netty的组件和设计</h2><p>Netty的组件设计可以分为两个大类:<B>Netty网络抽象的代表</B>和<B>管理数据流和业务逻辑组件</B>;</p><p>Netty网络抽象的代表:</p><ul><li>Channel - 对Socket的抽象</li><li>EventLoop - 控制流、多线程处理、并发</li><li>ChannelFuture - 异步通知</li></ul><p>管理数据流和业务逻辑组件:</p><ul><li>ChannelHandler - 业务程序逻辑的容器</li><li>ChannelPipeline - 事件处理链</li></ul><h3 id="Channel接口"><a class="header-anchor" href="#Channel接口"></a>Channel接口</h3><p>Channel是对Socket的抽象接口,提供的API用于简化Socket类使用的复杂性,常见的实现类有:</p><ul><li>EmbeddedChannel</li><li>LocalServerChannel</li><li>NioDatagramChannel</li><li>NioSctpChannel</li><li>NioSocketChannel</li></ul><h3 id="EventLoop接口"><a class="header-anchor" href="#EventLoop接口"></a>EventLoop接口</h3><blockquote><p>EventLoop接口是Netty的核心抽象,用于处理连接的生命周期中所发生的事件;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.EventLoop%E6%8E%A5%E5%8F%A3%E7%B1%BB.png?raw=true" alt="EventLoop接口类"></p><h3 id="ChannelFuture"><a class="header-anchor" href="#ChannelFuture"></a>ChannelFuture</h3><p>在Netty中所有的I/O操作都是异步进行处理的,因为一个操作可能不会立即返回结果,所以Netty中定义了<B>一种用于在之后某个事件点确定其结果的方法</B>,这个结果就是<B>ChannelFuture</B>,其addListener方法注册了一个ChannelFutureListener,以便在某个操作完成时得到通知;</p><h3 id="ChannelPipeline"><a class="header-anchor" href="#ChannelPipeline"></a>ChannelPipeline</h3><p>ChannelPipeline为ChannelHandler链提供了容器,并定义了用于在该链上传播入站和出站事件流的API.当Channel被创建时,它被自动分配到它专属的ChannelPipenlines上;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.ChannelInboundHandler%E4%B8%8EChannelOutboundHandler.png?raw=true" alt="ChannelHandler的in/out实现接口"></p><p>ChannelHandler安装到ChannelPipeline中的过程如下所示:</p><ul><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中</li><li>当ChannelInitializer.initChannel()方法被调用时,ChannelInitializer将在ChannelPipline中安装一组自定义的ChannelHandler</li><li>ChannelInitializer将它自己从ChannelPipeline中移除</li></ul><p>源代码如下:</p><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/ChannelInitializer.java#L126">ChannelInitializer.java</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initMap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Guard against re-entrance.</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span>            <span class="token comment">// We do so to prevent multiple calls to initChannel(...).</span>            <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ctx<span class="token punctuation">.</span><span class="token function">isRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ctx<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/a12a0124efc418438a7179a42d4826f5db5676ba/src/main/kotlin/simple/echo/EchoClient.kt#L24">EchoClient</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>object <span class="token operator">:</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    override fun <span class="token function">initChannel</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> <span class="token class-name">SocketChannel</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ctx<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">EchoClientHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ChannelInitializer.initChannel()将一组自定义的ChannelHandler注册到ChannelPipeline链上;ChannelHandler是专门为支持广泛的用途而设计,可以将它看作为是处理往来ChannelPipeline事件的任何代码的通用容器;使得事件流经ChannelPipline是ChannelHandler的工作,它们是在应用程序的初始化或者引导阶段被安装的;</p><h3 id="ChannelHandler"><a class="header-anchor" href="#ChannelHandler"></a>ChannelHandler</h3><p>在Netty中以适配器的形式提供了大量默认的ChannelHandler实现类,用于简化应用程序处理逻辑的开发过程;常用的适配器类有:<B>ChannelHandlerAdapter</B>、<B>ChannelInboundHandlerAdapter</B>、<B>ChannelOutboundHandlerAdapter</B>、<B>ChannelDuplexHandler</B></p><ul><li>编码器和解码器</li></ul><blockquote><p>当你通过Netty发送或接收一个消息的时候,就将会发生一次数据转换,也就是说字节码会转换为另外一种格式,通常就是一个java对象;如果是出站消息,则会发生相反方向的转换:它将从它的当前格式被编码为字节;Netty为编码器和解码器提供了不同类型的抽象类;</p></blockquote><p>Netty提供的编码器和解码器适配器类都实现了<B>ChannelOutboundHandler接口</B>或者<B>ChannelInboundHandler接口</B></p><h3 id="引导程序"><a class="header-anchor" href="#引导程序"></a>引导程序</h3><p>从上面的例子中可以看到,我们在设置Netty的客户端或者服务端配置时,首先选择引导类<B>BootStrap</B>或者<B>ServerBootStrap</B>,下面是这两种引导类下一些区别;</p><table><thead><tr><th>类别</th><th>BootStrap</th><th>ServerBootStrap</th></tr></thead><tbody><tr><td>网络编程的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td>EventLoopGroup的数目</td><td>1</td><td>2</td></tr></tbody></table><p><img src="https://github.com/agmtopy/noteBook/blob/e1480b344e9bbe0242507dc79c7fdef266030bef/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E5%85%B7%E6%9C%89%E4%B8%A4%E4%B8%AAEventLoopGroup%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8.png?raw=true" alt="具有两个EventLoopGroup的服务器"></p><p>服务器设置两组不同的Channel,第一组只包含服务器自身的已绑定到某个本地端口的正在监听的套接字、第二组将包含所有已创建的用来处理传入的客户端连接的Channel;<br>与ServerChannel相关联的EventLoopGroup将分配一个负责为传入连接请求创建Channel的EventLoop;一旦连接被接受,第二个EventLoopGroup将会给它的Channel分配一个EventLoop;</p><h2 id="传输"><a class="header-anchor" href="#传输"></a>传输</h2><p>Netty中最为重要的知识,传输-可以使用<B>阻塞传输</B>、<B>异步传输</B>、Local等方式,在Netty中它为所有的传输实现都提供了通用的API;</p><h3 id="例子"><a class="header-anchor" href="#例子"></a>例子</h3><ol><li>JDK阻塞处理的例子</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/PlainOioServer.kt">PlainOioServer.java</a></p><p>在这段代码在每次接受连接时都会创建一个新的线程。这会导致大量的线程被创建和销毁，消耗大量的系统资源。为了避免这种情况，可以使用线程池来管理线程，重复使用现有的线程来处理新的连接、或者使用非柱塞的方式来进行,下面是一个非阻塞的例子;</p><ol start="2"><li>JDK非阻塞的例子</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/PlainNioServer.kt">PlainNioServer.java</a></p><p>从阻塞切换到非阻塞的代码十分复杂,下面看一下Netty是如何屏蔽这部分差异的</p><ol start="3"><li>使用Netty的阻塞网络处理</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/NettyOioServer.kt">NettyOioServer.java</a></p><ol start="4"><li>使用Netty的非阻塞网络处理</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/NettyNioServer.kt#L18C1-L18C1">NettyNioServer.java</a></p><p>可以看到Netty切换网络通道只需要调整<B>NioEventLoopGroup</B>、<B>NioServerSocketChannel</B>即可;</p><h3 id="传输API"><a class="header-anchor" href="#传输API"></a>传输API</h3><blockquote><p>传输API的核心是interface Channel,它被用于所有的I/O操作,Channel类的层次结构如下所示:</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/e1480b344e9bbe0242507dc79c7fdef266030bef/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.Channel%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png?raw=true" alt="Channel接口的层次结构"></p><p>每一个Channel都会被分配一个<B>ChannelPipeline</B>和<B>ChannelConfig</B>,ChannelConfig中包含了该Channel的所有配置设置,并且<B>支持热更新</B>;<br>由于Channel是独一无二的,所以为了保证顺序Channel实现了Comparable接口;</p><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/Channel.java#L77">Channel.java</a></p><p>ChannelPipeline是用于持有处理入站和出站以及业务处理事件的<B>ChannelHandler</B>实例,在代码中主要是add/remove/get等方法;<br>ChannelPipeline是典型的过滤器模式,数据经过不同的ChannelHandler进行处理;</p><p>在上一个步骤中引出了一个重要的类<B>ChannelHandler</B>,它实现了所有应用程序用于处理状态变化以及数据处理的逻辑,常用的类型有:</p><ol><li>数据格式转换,将数据同二进制格式转换为业务格式,反之亦然</li><li>提供异常的通知</li><li>提供Channel变为活动的或者非活动的通知</li><li>提供当Channel注册到EventLoop或者从EventLoop注销时的通知</li><li>提供有关用户自定义事件的通知</li></ol><p>channel重要的方法列表:</p><p><img src="https://github.com/agmtopy/noteBook/blob/f979c8e58879f1619e010dc459ca4e67871ece33/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.Channel%E7%9A%84%E6%96%B9%E6%B3%95.png?raw=true" alt="channel的方法"></p><p>channel是<B>线程安全</B>的,可以多个线程同时操作;</p><h3 id="内置的传输类型"><a class="header-anchor" href="#内置的传输类型"></a>内置的传输类型</h3><p>Netty内置了一些开箱即用的传输;这些传输包括jdk、linux等的特殊类型;</p><table><thead><tr><th>名称</th><th>包</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.nio</td><td>使用java.nio.channels包作为基础,基于选择器的方式</td></tr><tr><td>Epooll</td><td>io.netty.channel.epoll</td><td>由JNI驱动的epoll()和非阻塞I/O,这个传输支持只有在Linux上可用的多种特性.如SO_REUSEPORT,比NIO传输更快,并且是完全非阻塞的;</td></tr><tr><td>OIO</td><td>io.netty.channel.socket.oio</td><td>使用java.net包作为基础,使用的是阻塞流</td></tr><tr><td>Local</td><td>io.netty.channel.local</td><td>在JVM内部通过管道进行通信的本地传输形式</td></tr><tr><td>Embedded</td><td>io.netty.channel.embedded</td><td>测试channelHandler使用</td></tr></tbody></table><h4 id="NIO-非阻塞I-O"><a class="header-anchor" href="#NIO-非阻塞I-O"></a>NIO-非阻塞I/O</h4><p>NIO提供了一个所有I/O操作的全异步的实现,它是基于JDK1.4引入的NIO子系统中的选择器API来进行实现;</p><p>选择器背后的基本概念是充当一个<B>注册表</B>,在哪里你将可以请求在Channel的状态发生变化时得到通知,可能发生的状态变化有:</p><ul><li>新的Channel已被接受并且就绪</li><li>Channel连接已经完成</li><li>Channel有已经就绪的可供读取的数据</li><li>Channel可用于写数据</li></ul><p>选择器运行在一个检查状态变化并对其做出相应响应的线程上,在应用程序对状态的改变做出响应之后,选择器状态会被重置,然后继续重复这过程;</p><p><img src="https://github.com/agmtopy/noteBook/blob/4e4b9a4baccf9ccc5a16f77baa36b9117dc23f1e/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E9%80%89%E6%8B%A9%E5%B9%B6%E5%A4%84%E7%90%86%E7%8A%B6%E6%80%81%E7%9A%84%E5%8F%98%E5%8C%96%E8%BF%87%E7%A8%8B.png?raw=true" alt="选择并处理状态的变化"></p><p><img src="https://github.com/agmtopy/noteBook/blob/4e4b9a4baccf9ccc5a16f77baa36b9117dc23f1e/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.%E9%9B%B6%E6%8B%B7%E8%B4%9D.png?raw=true" alt="零拷贝"></p><p>零拷贝其实在Windows下有API进行支持;</p><h4 id="Epooll-用于Linux的本地非阻塞传输"><a class="header-anchor" href="#Epooll-用于Linux的本地非阻塞传输"></a>Epooll-用于Linux的本地非阻塞传输</h4><p>Netty为Linux提供了一组NIO API,其以一种和它本身的设计更加一致的方式使用epoll,实现类是<B>EpollEventLoopGroup</B></p><h4 id="OIO-旧的阻塞I-O"><a class="header-anchor" href="#OIO-旧的阻塞I-O"></a>OIO-旧的阻塞I/O</h4><blockquote><p>Netty的OIO传输实现代表了一种折中的办法;它可以通过常规的传输API使用,但是由于它是建立在java.net包的阻塞实现之上的,所以它不是异步的;Netty利用<B>SO_TIMEOUT</B>这个Socket标识,它指定了等待一个I/O操作完成的最大毫秒数.如果这个操作在指定时间间隔内没有完成,则将会抛出一个<B>SocketTimeout_Exception</B>,Netty将捕获这个异常并继续循环处理,在下次运行EventLoop时,它将再次尝试;</p></blockquote><p><img src="" alt="OIO的处理逻辑"></p><h4 id="用于JVM内部通信的Local传输"><a class="header-anchor" href="#用于JVM内部通信的Local传输"></a>用于JVM内部通信的Local传输</h4><blockquote><p>Netty提供了一个Local传输,用于在同一个JVM中运行的客户端和服务端程序之间的异步通信.在这个传输中,和服务器Channel相关联的SocketAddress并没有绑定物理网络地址;</p></blockquote><h4 id="Embedded-传输"><a class="header-anchor" href="#Embedded-传输"></a>Embedded 传输</h4><blockquote><p>Netty提供了一种额外的传输方式,使得你可以将一组ChannelHandler作为帮助器嵌入到其他的ChannelHandler内部;</p></blockquote><h2 id="ByteBuf"><a class="header-anchor" href="#ByteBuf"></a>ByteBuf</h2><p>网络数据的基本单位是字节,Java NIO提供了<B>ByteBuffer&lt;/B作为它的字节容器,但是这个类使用过于复杂;因此Netty在内部进行了分封装,通过API提供了两个类:<B>ByteBuf</B>和<B>ByteBufHolder</B>;</p><p>ByteBuf内部会维护两个不同的<B>索引</B>,一个用于读取,一个用于写入,当你从ByteBuf中读取数据时,它的readderIndex将会递增已经被读取过的字节数.同样的,当你写入ByteBuf时,它的writeIndex也会进行递增;</p><ol><li><p>堆缓冲区<br>最常用的ByteBuf模式就是将数据存储在JVM的堆空间中;</p></li><li><p>直接缓冲区<br><B>直接缓存区</B>是另外一种ByteBuf模式,我们期望用用于对象创建的内存分配永远都来自于堆中,但这并不是必须的,在JDK 1.4中引入的ButeBuffer类允许JVM实现通过本地调用来分配内存;这样可以避免每次在调用本地I/O操作之前将缓冲区的内容复制到一个中间缓冲区中;<br>“直接缓冲区的内存将驻留在常规的会被垃圾回收的堆内存之外”,直接缓冲区的主要缺点是<B>相对与基于堆内存的缓冲区,它们的分配和释放都比较昂贵</B></p></li><li><p>复合缓冲区<br><B>复合缓冲区</B>指的是,它为多个ByteBuf提供一个聚合视图,通过这个聚合视图可以根据需要进行添加和删除ByteBuf实例,用于补充JDK中的ByteBuffer中缺失的这个特性;<br>Netty中通过ByteBuf的子类 -&gt; CompositeByteBuf来实现这个功能,它提供了一个将多个缓冲区聚合成为单个合并缓冲区的虚拟实现;</p></li></ol><h2 id="字节级操作"><a class="header-anchor" href="#字节级操作"></a>字节级操作</h2><ol><li>随机访问索引</li><li>顺序访问索引</li><li>可丢弃字节</li><li>可读字节</li><li>可写字节</li><li>索引管理</li><li>查找操作</li><li>派生缓冲区</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Netty实战第一章&lt;/h1&gt;
&lt;h2 id=&quot;简述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;
&lt;p&gt;在学习Netty源码的过程中,十分吃力看来还是需要先从&lt;B&gt;使用&lt;/B&gt;在到&lt;B&gt;研究&lt;/B&gt;过程,因此将《Net</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Netty" scheme="https://agmtopy.gitee.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>G1GC的算法与实现之实现篇笔记</title>
    <link href="https://agmtopy.gitee.io/2023/05/06/20.%E7%AC%94%E8%AE%B0/41.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2023/05/06/20.%E7%AC%94%E8%AE%B0/41.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-05T21:32:23.000Z</published>
    <updated>2023-06-26T15:24:52.567Z</updated>
    
    <content type="html"><![CDATA[<h1>《深入Java虚拟机：JVM G1GC的算法与实现》-实现篇笔记</h1><p>在上一篇文章中我们记录了G1GC的算法包括<B>内存结构</B>、<B>标记位图</B>、<B>SATB本地队列</B>、<B>转移专用记忆集合</B>等关键组成部分,接下我们会对HotSpotVM的具体实现方法进行分析;</p><h2 id="HotSpot的代码结构"><a class="header-anchor" href="#HotSpot的代码结构"></a>HotSpot的代码结构</h2><p>HotSpot的源码位于src/hotspot下,如下所示</p><table><thead><tr><th>文件夹</th><th>说明</th></tr></thead><tbody><tr><td>cpu</td><td>依赖CPU的代码</td></tr><tr><td>os</td><td>依赖操作系统的代码</td></tr><tr><td>os_cpu</td><td>依赖操作系统和CPU的代码</td></tr><tr><td>share</td><td>通用代码</td></tr></tbody></table><p>在share下又划分为以下文件结构</p><table><thead><tr><th>文件夹</th><th>说明</th></tr></thead><tbody><tr><td>ci</td><td>C1编译器</td></tr><tr><td>classfile</td><td>Java类文件的定义</td></tr><tr><td>gc</td><td>GC部分</td></tr><tr><td>interpreter</td><td>Java解释器</td></tr><tr><td>oops</td><td>对象结构的定义</td></tr><tr><td>runtime</td><td>VM运行时所需库</td></tr></tbody></table><p>参考<a href="https://github.com/openjdk/jdk/tree/master/src/hotspot/share">openjdk</a></p><p>HotSpot内部的大部分代码都是继承与以下两个类中的一个:</p><ul><li>CheapObj类</li><li>AllStatic类</li></ul><p>下面对这两个类进行分析:</p><ul><li>CheapObj类</li></ul><blockquote><p>CheapObj类是一个由C的堆内存空间来管理的类,CheapObj类的子类实例都会被分配到C的堆内存上;</p></blockquote><ul><li>AllStatic类</li></ul><blockquote><p>AllStatic类是一个&quot;仅带有静态信息&quot;的特殊类,继承AllStatic的类不需要创建实例;</p></blockquote><p>由于HotSpotVM需要运行于各种操作系统之上.因此,开发者为HotSpotVM设计了一种巧妙的结构(接口),使得它能够通过统一的接口来处理各种操作系统的API;</p><ul><li>os.hpp</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">class os<span class="token operator">:</span> AllStatic <span class="token punctuation">&#123;</span>  friend class VMStructs<span class="token punctuation">;</span>  friend class JVMCIVMStructs<span class="token punctuation">;</span>  friend class MallocTracker<span class="token punctuation">;</span><span class="token comment">//省略</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>os类中定义的成员函数在HotSpotVM中都有对应的各种操作系统实现:</p><ol><li>os/posix/vm/os_posix.cpp</li><li>os/linux/vm/os_linux.cpp</li><li>os/windows/vm/os_windows.cpp</li><li>os/solaris/vm/os_solaris.cpp<br>在构建OpenJDK时,hotspot会从以上文件中,选择与当前系统对应的文件进行编译和链接;</li></ol><p>当VM调用os.hpp时,对于操作系统下的实现类就会执行具体方法;</p><ul><li>os_windows.cpp</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef _DEBUG#include &lt;crtdbg.h&gt;#endif#include &lt;windows.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;stat.h&gt;#include &lt;sys&#x2F;timeb.h&gt;#include &lt;objidl.h&gt;#include &lt;shlobj.h&gt;&#x2F;&#x2F;省略....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>os_windows.cpp</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef _DEBUG#include &lt;crtdbg.h&gt;#endif&#x2F;&#x2F; put OS-includes here# include &lt;sys&#x2F;types.h&gt;# include &lt;sys&#x2F;mman.h&gt;# include &lt;sys&#x2F;stat.h&gt;# include &lt;sys&#x2F;select.h&gt;# include &lt;pthread.h&gt;# include &lt;signal.h&gt;# include &lt;endian.h&gt;# include &lt;errno.h&gt;# include &lt;dlfcn.h&gt;&#x2F;&#x2F;省略....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在不同的实现下引入了不同的<B>.h</B>文件;</p><h2 id="堆结构"><a class="header-anchor" href="#堆结构"></a>堆结构</h2><p>堆结构大体上可以划分为两个部分:</p><ol><li>程序员选择的GC算法所使用的内存空间</li><li>常驻内存空间</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/VM%E5%A0%86%E5%88%92%E5%88%86.png?raw=true" alt="VM堆划分"></p><p>常驻内存空间通常是用于分配类型信息或方法信息等永久存在的对象,该空间几乎不会随着GC算法的变化而变化;</p><blockquote><p>在 JDK 8 及之后的版本中，永久代已经被移除，被一个称为元空间（Metaspace）的区域所取代。因此，可以说 JDK 8 及之后的版本中没有永久代这一概念。不过，元空间和永久代的作用类似，都是用于存放类信息等元数据的区域，只不过它们的实现方式和内存模型不同。 元空间和永久代最大的不同在于，元空间使用本地内存（native memory）存储元数据，而不是像永久代一样使用虚拟机内存（Java heap）来存储。这样的好处是可以避免永久代出现的内存溢出问题，因为元空间的大小可以根据需要动态调整，并且可以使用操作系统的内存分配器来管理内存。另外，元空间与永久代相比还有一些其他的不同点，例如元空间可以通过命令行参数来配置大小、元空间的垃圾回收机制与永久代不同等等。但是，从常驻内存空间的角度来说，可以认为元空间已经取代了永久代，成为了 Java 虚拟机中存放类信息等元数据的常驻内存区域。</p></blockquote><p>在JVM中是通过<B>Universe:initialize_heap</B>来实现创建堆内存的功能,如下所示,会根据<B>create_heap()</B>、<B>initialize()</B>方法选择不同的实现;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%88%9B%E5%BB%BA%E5%A0%86%E5%86%85%E5%AD%98%E9%80%89%E6%8B%A9%E6%89%A7%E8%A1%8C%E7%B1%BB.png?raw=true" alt="创建堆内存选择执行类"></p><p>下面详细看一下<B>G1CollectedHeap</B>,其中有三个重要的成员变量:</p><ol><li><B>_hrs</B>:通过数组维护所有的HeapRegion</li><li><B>_young_list</B>:新生代HeapRegion的链表</li><li><B>_free_region_list</B>:空闲HeapRegion的链表</li></ol><blockquote><p>管理各个区域是通过<B>HeapRegion</B>类来实现的,在G1CollectedHeap中为了快速找到每一个HeapRegion,因此用HeapRegionSeq（Heap Region Sequence）是用于表示堆区域（Heap Region）的序列或集合的地址,_hrs就是指向HeapRegionSeq的指针;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC%E5%A0%86%E7%BB%93%E6%9E%84.png?raw=true" alt="G1GC堆的结构"></p><h2 id="分配器"><a class="header-anchor" href="#分配器"></a>分配器</h2><h3 id="内存分配的流程"><a class="header-anchor" href="#内存分配的流程"></a>内存分配的流程</h3><p>Vm堆空间申请 -&gt; VM堆空间分配 -&gt; 对象的分配<br>下图展示这个过程</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%B5%81%E7%A8%8B.png?raw=true" alt="内存分配的流程"></p><p>需要注意的是在Linux上,用于实现内存申请和分配的是<B>mmap()</B>,在Linux中没有申请内存空间的概念,调用mmap()后就会分配内存空间,不过并不是立即分配物理空间,在这这中间还有一层虚拟内存;只有在分配到的内存空间被访问时才会实际发生物理内存分配;</p><h3 id="对象分配的流程"><a class="header-anchor" href="#对象分配的流程"></a>对象分配的流程</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.jpg?raw=true" alt="对象分配的流程"></p><h3 id="TLAB"><a class="header-anchor" href="#TLAB"></a>TLAB</h3><p>TLAB(Thread Local Allocation Buffer,线程本地分配缓冲区)是对象分配的要点之一;<br>VM是所有线程共享的内存空间,因此当需要在VM堆上分配对象时,必须锁定整个堆,以防止其他线程同时分配对象;<br>但是为了让不同线程工作于不同的CPU核心上时需要分配对象时不用等待VM堆上的锁释放,因此引入了TLAB的概念,解决思路就是让各个线程拥有自己的专用对象分配缓冲区,从而减少锁定次数;<br>当一个线程第一次分配对象时,它会从VM堆中得到一定大小的内存空间,然后作为它自己的缓冲区保存下来,当这个线程需要分配对象时,优先从这块专用区域进行分配;</p><h2 id="对象结构"><a class="header-anchor" href="#对象结构"></a>对象结构</h2><ul><li>oopDesc类</li></ul><blockquote><p>oopDesc类是所有GC目标对象的抽象基类,继承自oopDesc的类实例都是GC的目标对象;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/429872403e969e497aff2255a0064c748a8385e8/png/j-jvm/oopDesc%E7%B1%BB.png?raw=true" alt="oopDesc类"></p><blockquote><p>在第第56行代码中的_mark变量是对象头,_mark中不仅保存了标记-清除算法的标记,还保存了对象所需的其他各种信息;在oopDesc中有一个指向自己类的指针,在代码的<br>第57行_metadata.在大部分情况下,这个联合体中保存的是_klass变量的值,kass保存的是指向对象类的指针.</p></blockquote><ul><li>klass<br>klass继承于oopDesc,用来表示类型信息,Klass的实例是作为klassOop的一部分创建出来的;</li></ul><h2 id="HotSpot的线程管理"><a class="header-anchor" href="#HotSpot的线程管理"></a>HotSpot的线程管理</h2><p>在Windws和Linux中都有用于调用操作系统线程的库,在Windows上我们使用的是Windows Api调用线程,在Linux上我们使用的是POSIX线程标准的Pthreads库来调用线程;</p><p>在HotSpotVm内可以使用相同的方式调用不同操作系统得益于设计出来’线程抽象层’,最重要的就是<B>Thread</B>;</p><h3 id="Thread类"><a class="header-anchor" href="#Thread类"></a>Thread类</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/Thread%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png?raw=true" alt="Thread类的继承关系"></p><p>在Thread类中通过定义<B>虚函数run()</B>,子类进行实现,其中<B>JavaThread</B>表示的就是Java语言级别运行的线程,<B>NameThread类</B>是支持线程命名的,我们可以通过为对NameThread实例设置一个唯一名字;</p><h3 id="线程的什么周期"><a class="header-anchor" href="#线程的什么周期"></a>线程的什么周期</h3><ol><li>创建Thread类的实例</li><li>创建线程(调用os:create_thread)</li><li>开始线程处理(调用os:start_thread)</li><li>结束线程处理</li><li>释放Thread类实例</li></ol><p>一个windows下创建线程的例子:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadFunc(LPVOID);int main()&#123;    HANDLE hThread;    DWORD threadId;    hThread &#x3D; CreateThread(NULL, 0, ThreadFunc, 0, 0, &amp;threadId); &#x2F;&#x2F; 创建线程    printf(&quot;我是主线程， pid &#x3D; %d\n&quot;, GetCurrentThreadId());      &#x2F;&#x2F; 输出主线程pid    Sleep(2000);&#125;DWORD WINAPI ThreadFunc(LPVOID p)&#123;    printf(&quot;我是子线程， pid &#x3D; %d\n&quot;, GetCurrentThreadId()); &#x2F;&#x2F; 输出子线程pid    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程的互斥处理"><a class="header-anchor" href="#线程的互斥处理"></a>线程的互斥处理</h3><ul><li>什么是互斥处理?</li></ul><blockquote><p>如果线程共享内存空间,那么就会出现多个线程同时在一个地址上进行读写的情况.有些数据会被其他线程所改变,并且这样的改变是意料之外的;对于这样被修改的对象,被称为&quot;临界区&quot;.对于&quot;临界区&quot;的处理必须要按照原子操作;</p></blockquote><ul><li>如何实现互斥处理?</li></ul><ol><li><p>使用互斥量<br>互斥量可以是全局锁/标识/互斥原语等,个人理解互斥量主要是两个特点:全局可见和唯一持有</p></li><li><p>监视器<br>线程之间通过监视器来完成互斥和协助,在jvm中监视器是由Object中的monitor对象头来进行实现,</p></li></ol><blockquote><p><B>互斥方式可以避免线程使用共享数据时被其它线程干扰，而协作方式则帮助多个线程共同完成同一个目标</B></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《深入Java虚拟机：JVM G1GC的算法与实现》-实现篇笔记&lt;/h1&gt;
&lt;p&gt;在上一篇文章中我们记录了G1GC的算法包括&lt;B&gt;内存结构&lt;/B&gt;、&lt;B&gt;标记位图&lt;/B&gt;、&lt;B&gt;SATB本地队列&lt;/B&gt;、&lt;B&gt;转移专用记忆集合&lt;/B&gt;等关键组成部分,接下我们会对HotSp</summary>
      
    
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/categories/jvm/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记</title>
    <link href="https://agmtopy.gitee.io/2023/04/05/20.%E7%AC%94%E8%AE%B0/40.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2023/04/05/20.%E7%AC%94%E8%AE%B0/40.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-05T08:55:33.000Z</published>
    <updated>2023-04-27T14:49:25.448Z</updated>
    
    <content type="html"><![CDATA[<h1>《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记</h1><p>这一篇文章主要是用于记录《深入Java虚拟机：JVM G1GC的算法与实现》一书中<B>算法篇</B>部分的笔记,主要分为引子、并发标记、转移、软实时性、分代G1GC模式;</p><h2 id="G1-GC是什么"><a class="header-anchor" href="#G1-GC是什么"></a>G1 GC是什么?</h2><p>在G1GC之前JVM中存在的垃圾收集器主要是<B>Parallel Scavenge</B>和<B>Parallel Old</B>,在jdk9将G1设置为默认处理器后,截至现在的jdk 20都是默认的垃圾收集器,目前G1GC就是JDK平台跨最多版本的默认垃圾收集器;</p><p>G1GC设计的出发点与之前的GC收集器有明显的不同,之前的不管是串行的Serial还是并发Paraller都是基于<B>吞吐量</B>和<B>缩短最大暂停时间</B>来进行设计的;<br>目前JVM的生态或者说面向的应用还是偏向于Web处理方面的,这一类应用的特点短、快,因此需要具有<B>软实时性</B>和<B>高吞吐量</B>的垃圾收集器;</p><blockquote><p>软实时性指的是处理时间可以超出最后期限,但是超出最后期限的频率很重要.只有超出的频率在用户能够容忍的范围之内,才能称之为&quot;软实时性&quot;<br>举一个栗子: 公司都允许每个考勤周期内迟到2或者3次,公司可以容忍这种情况发生,但是超过规定的次数之后就不能忍受了,这种行为就叫&quot;软实时性&quot;;与之相反的&quot;硬实时性&quot;,例如&quot;职务侵占&quot;公司就一次都不能忍受;</p></blockquote><p>咱们已经了解了为什么需要重头开始设计一个GC算法了,下面就看一下具体的内存结构和算法实现.</p><h3 id="G1GC的内存结构"><a class="header-anchor" href="#G1GC的内存结构"></a>G1GC的内存结构</h3><ul><li>内存布局</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png?raw=true" alt="G1GC内存布局"></p><p>首先G1GC的内存布局最大的特点是抛弃了内存中对于老年代和年轻代的内存范围划分,而是采用区域(region),默认大小为1MB的形式进行划分.<br>对于region内存的大小用户可以随意设置,但是在内部会将用户设置的值向上调整为2的指数幂(2^n),1000kb-&gt;1024kb;</p><ul><li>对象引用</li></ul><p>这里的对象引用指的不是对象与对象之间的引用,而是在GC查找对象时持有的引用关系,一个典型的栗子就是老年代中引用年轻代存储关系的<B>记忆集</B>;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png?raw=true" alt="G1GC 跨代引用布局"></p><ul><li>Card Table</li></ul><blockquote><p>Card Tables and Concurrent Phases  If a garbage collector does not collect the entire heap (an incremental collection), the garbage collector needs to know where there are pointers from the uncollected part of the heap into the part of the heap that is being collected. This is typically for a generational garbage collector in which the uncollected part of the heap is usually the old generation, and the collected part of the heap is the young generation. The data structure for keeping this information (old generation pointers to young generation objects), is a remembered set. A card table is a particular type of remembered set. Java HotSpot VM uses an array of bytes as a card table. Each byte is referred to as a card. A card corresponds to a range of addresses in the heap. Dirtying a card means changing the value of the byte to a dirty value; a dirty value might contain a new pointer from the old generation to the young generation in the address range covered by the card. 如果垃圾收集器不收集整个堆而是进行增量收集，则垃圾收集器需要知道从堆的未收集部分到正在收集的堆部分的指针在哪里。 这通常适用于分代垃圾收集器，其中堆的未收集部分通常是老年代，堆中已收集的部分是新生代。 保存此信息的数据结构（指向年轻代对象的老年代指针）是一个记忆集(RS)。 Card Table是一种特殊类型的记忆集。 Java HotSpot VM 使用字节数组作为卡片表。 每个字节称为一张卡片。 一张卡片对应堆中的一个地址范围。 弄脏一张卡片意味着将字节的值更改为脏值； 一个脏值可能包含一个新的指针，在卡覆盖的地址范围内从老一代到年轻一代。</p></blockquote><p>Card Table是用于简化年轻代收集,类似与一个被老年代持有年轻代对象的索引,在年轻代进行垃圾收集时按图索骥就可以把这些被跨代引用的对象找出来,之后会详细的讲述一下执行过程;</p><h3 id="执行过程"><a class="header-anchor" href="#执行过程"></a>执行过程</h3><p>G1GC底层算法是<B>标记-压缩</B>算法,这样的话它的执行步骤可以划分为两个部分:</p><ol><li>并发标记阶段<br>并发标记阶段主要是在尽量不暂停mutator线程(即访问和修改Manage Object的线程,如所有Java Thread及其Attach到JVM的thread)的情况下标记出存活的对象,而且在标记过程中会记录下每个区域(region)内存活的对象数量;</li><li>转移压缩阶段<br>转移压缩阶段主要是将待回收区域内的存活对象复杂到其他空闲区域中,然后将空闲出来的区域标记为空闲状态,类似于GC算法,但是是以单位进行的;</li></ol><p>需要注意的是<B>并发标记</B>和<B>转移压缩</B>在处理顺序上是没有先后顺序的,并发标记的结果对于转移压缩阶段也不是必须的.</p><hr><p>上面简单的描述了一下G1GC的执行过程,下面我们来详细的看一下<B>并发标记阶段</B>做的事情</p><h2 id="并发标记阶段"><a class="header-anchor" href="#并发标记阶段"></a>并发标记阶段</h2><h3 id="标记位图"><a class="header-anchor" href="#标记位图"></a>标记位图</h3><p>首先解释&quot;并发标记&quot;是在标记什么?</p><blockquote><p>并发标记是在标记所有的存活对象和可以回收的对象,并发标记并不是直接在对象内存上添加标记,而是在<B>标记位图</B>上</p></blockquote><p>标记位图如图所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/74172d16f52935f2a49645d6f14132e0b6d966f5/png/j-jvm/%E6%A0%87%E8%AE%B0%E4%BD%8D%E5%9B%BE.png?raw=true" alt="标记位图"></p><p>标记位图是对<B>region</B>中分配的对象进行一个类似于索引标记的数据结构,每个bit位对应一个对象,默认最小的对象为8字节,0代表活动对象;</p><p>每个region都有两个<B>标记位图</B>分别是nextBitMap和prevBitMap用于保存本次的位图和上一次的位图;</p><p>由于在并发标记阶段Mutator线程可以继续分配对象或者yuang GC,会破坏已经进行过标记的内存区域,因此需要用4个标记位来确定,分别是<B>bottom</B>、<B>TOP</B>、<B>prevTAMS</B>、<B>nextTAMS</B></p><p>bottom-TOP范围表示的开始标记前的某个区域的底部和顶部<br>TAMS(Top-at-Mark-Start,标记开始时的top)，prevTAMS和nextTAMS即上/下一次的标记的top</p><p>nextTAMS-TOP范围表示就就是标记过程中新产生的对象所占用的区域</p><h3 id="执行步骤"><a class="header-anchor" href="#执行步骤"></a>执行步骤</h3><p>并发标记过程包括以下5个步骤:</p><ol><li>初始标记阶段</li><li>并发标记阶段</li><li>最终标记阶段</li><li>存活对象计数阶段</li><li>收尾阶段</li></ol><h4 id="初始标记阶段"><a class="header-anchor" href="#初始标记阶段"></a>初始标记阶段</h4><ol><li>创建标记位图<blockquote><p>在初始化阶段,GC线程会首先创建Next MarkBitmap</p></blockquote></li><li>对GC Root可达对象进行扫描和标记,为了防止GC Root对象变化,<B>Mutator是暂停执行的</B>,这里需要注意的是初始标记阶段有且只会对GC Root的可达对象进行标记</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png?raw=true" alt="初始标记阶段结果"></p><h4 id="并发标记阶段-v2"><a class="header-anchor" href="#并发标记阶段-v2"></a>并发标记阶段</h4><blockquote><p>并发标记阶段,GC线程会继续扫描在初始化阶段被标记过的对象,分析它们的引用关系,完成大部分存活对象的标记</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png?raw=true" alt="并发标记阶段结果"></p><p>在并发标记阶段GC线程和Mutator线程是并发执行的,那么是如何解决<B>标记遗漏</B>问题的楠?</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5_%E6%A0%87%E8%AE%B0%E9%81%97%E6%BC%8F.png?raw=true" alt="标记遗漏"></p><p>首先说一下<B>标记遗漏</B>产生的原因,从上图中可以看到我们的GC线程已经标记到第二层对象,这个时候Mutator线程将Obj1-Obj3直接的引用关系去除,并且GCRoot-Obj3产生新的引用关系,由于Obj1标记完成后已经没有下属的任何引用那么就不会在标记Obj3,就发生了标记遗漏,可以看到发生标记遗漏的两个条件:</p><ul><li>新产生一条或多条从黑色对象(已标记对象)到白色对象(未标记对象)的新引用;</li><li>删除灰色对象(正在标记对象)到白色对象的引用关系;</li></ul><p>那么解决标记遗漏的问题就在于对这两个关系的破坏或者记录:</p><blockquote><p>在CMS中采用的是增量更新(Incremental Update)方案,破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次;</p></blockquote><blockquote><p>在G1GC中采用的是原始快照(Snapshot At The Beginning,SATB)方案,破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次;</p></blockquote><p>这里重新扫描的是灰色对象,然后是在快照中扫描,快照指的是GC在开始时对象之间的引用关系,这里会产生一个问题,将本来已经可以进行回收的对象标记为活动的,系统设计上应该是要保证没有漏掉的对象,防止不能回收掉这些内存.</p><p>G1GC采用的是<B>写屏障</B>技术来记录对象之间引用关系的变化,对于新分配的对象直接认为这部分对象是已经标记完成;</p><h4 id="最终标记阶段"><a class="header-anchor" href="#最终标记阶段"></a>最终标记阶段</h4><p>最终标记阶段是对<B>SATB本地队列</B>进行扫描,因为在并发标记介绍以后本地的SATB队列容量可能不满,不会刷新到全局SATB队列中,因此需要全局暂停来处理这些&quot;残留的SATB本地队列&quot;;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%85%A8%E5%B1%80SATB%E7%BB%93%E6%9E%84.png?raw=true" alt="全局SATB与局部SATB之间的关系"></p><p>最终标记处理的就是上图中mutator1线程和mutator2线程对于的局部SATB队列;</p><h4 id="存活对象计数阶段"><a class="header-anchor" href="#存活对象计数阶段"></a>存活对象计数阶段</h4><p>通过上面三个标记步骤(初始、并发、最终)将本次GC需要进行内存收集的对象标记出来了,这个时候就需要扫描各个区域的<B>next标记位图</B>,统计各个区域内存活对象的字节数目;<br>这个计数步骤可以和mutator是并发执行的,但是不能和转移线程(Remembered set)线程并行执行,因为如果并行执行会破坏region内的计数正确性;</p><h4 id="收尾阶段"><a class="header-anchor" href="#收尾阶段"></a>收尾阶段</h4><p>在上面两个步骤(标记、计数)中我们已经得到GC所需的最重要的两个信息:</p><ol><li>标记完成后存活对象和死亡对象之间的区分(标记位图)</li><li>存活对象的内存占用(内存占用字节数量)</li></ol><p>有上面俩组数据之后,才能进行</p><ul><li>转移压缩</li></ul><p>转移压缩过程中涉及到一个比较重要的概念<B>转移效率</B>,指的是&quot;死亡对象的字节数 % 转移所需时间&quot;,换句话说,转移效率指的是<B>转移1个字节所需时间</B>;</p><p>这里的转移指的是是对于存活对象转移的耗时,因为在一个需要对象回收比较多的region区域内,只需要将少量的存活对象转移出去,这块region就可以进行回收了;</p><p>通过<B>历史转移效率</B>的数据,就可以尝试预测下次内存需要进行回收的时间;</p><h4 id="小结"><a class="header-anchor" href="#小结"></a>小结</h4><p>在标记阶段主要是通过两种数据结构<B>标记位图</B>、<B>SATB</B>来实现对region的标识和计数,流程上分为:</p><ol><li>初始标记阶段 -&gt; GCRoot出发</li><li>并发标记阶段 -&gt; 上一步中散发的引用的对象</li><li>最终标记阶段 -&gt; 标记局部SATB中的对象</li><li>计数/收尾阶段 -&gt; 计数统计和转移</li></ol><p>对局部SATB的操作使用的是前置写屏障技术来实现的;</p><p>下面详细用一节来介绍一下转移的具体过程;</p><h2 id="GC的转移功能"><a class="header-anchor" href="#GC的转移功能"></a>GC的转移功能</h2><h3 id="转移的先决条件"><a class="header-anchor" href="#转移的先决条件"></a>转移的先决条件</h3><p>首先说一下为什么需要转移,由于内存特性会出现碎片化,因此需要对内存进行整理,才能继续分配对象,整理这个步骤具体的操作就是通过转移来实现的;</p><p>转移功能是通过具体的<B>转移专用记忆集合</B>来快速索引对象的,记录的是区域与区域之间的对象间的引用关系;通过使用转移专用记忆集合,在转移时即使不扫描所有区域内的对象,也可以查询到待转移对象<br>所在区域被其他区域引用的情况,从而简化单个区域回收的转移处理步骤;</p><blockquote><p>G1GC是通过卡表(card table)来进行实现转移专用记忆集合的元素的;</p></blockquote><p>在上图&quot;G1GC 跨代引用布局&quot;图列中的<B>Remembered Set</B>就是<B>转移专用记忆集合</B>,记录的元素就是card table的元素地址,如下所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E8%BD%AC%E7%A7%BB%E4%B8%93%E7%94%A8%E8%AE%B0%E5%BF%86%E9%9B%86%E5%90%88%E7%9A%84%E6%9E%84%E9%80%A0.png?raw=true" alt="转移专用记忆集合"></p><blockquote><p>每个区域都有一个<B>转移专业记忆集合</B>,它是通过hash列表实现的,key为引用本区域的其他区域地址,value为一个数组,元素是引用区域对应的<B>卡表</B>中的元素;<br>通过RS和Card Table这样的数据结构,在进行跨代引用对象的转移时可以快速的根据数据来进行查找;</p></blockquote><p>RS的写入是由专用的<B>转移专用记忆集合维护线程</B>来进行维护的,可以和mutator线程并发执行;</p><h3 id="转移的执行步骤"><a class="header-anchor" href="#转移的执行步骤"></a>转移的执行步骤</h3><p>转移的执行步骤可以分为以下三个:</p><ol><li><p>选择回收集合<br>指的是根据上述标记阶段得到的信息来选择被转移的区域.被选中的区域被称为<B>回收集合</B>;</p></li><li><p>根转移<br>指的是将回收集合中的由GC Root对象直接引用的对象和被其他区域引用的对象转移到其他空间中;</p></li><li><p>转移<br>指的是以2步骤中转移的对象作为起点扫描其子孙对象,然后将这些对象转移到其他空间中;</p></li></ol><h4 id="选择回收集合"><a class="header-anchor" href="#选择回收集合"></a>选择回收集合</h4><p>这个步骤是G1GC算法的核心部分,在选择需要进行回收的集合时,是按照两个原则来进行选择:</p><ul><li><B>转移效率高</B>的区域优先</li><li>整体区域转移预测的暂停时间需要在用户的容忍范围之内</li></ul><p>在标记的最后一个步骤<B>收尾阶段</B>中我们介绍了什么是<B>转移效率</B>的概念,简单的理解就是存活的对象越少,这个region的转移效率就越高;<br>然后根据转移效率对所有region进行排序,就可以得到一个region数组;<br>每一个region都有一个预测的转移暂停时间,G1GC在选择本次的<B>回收集合</B>就是从region数据从上到下依次累积预测暂停时间,直到大于等于用户的容忍时间阀值,这个子集就是<br>本次需要进行回收的集合;</p><blockquote><p>G1GC中的G1是Garbage First的简称,翻译成中文指的是&quot;垃圾优先的垃圾回收&quot;算法,而<B>转移效率从高到低的顺序</B>就是垃圾优先的具体实现方法;</p></blockquote><h4 id="根转移步骤"><a class="header-anchor" href="#根转移步骤"></a>根转移步骤</h4><p><B>根转移</B>指的是将对象或者引用转移到其他区域,包括三类数据:</p><ol><li>由根直接引用的对象</li><li>并发标记处理中的对象</li><li>由其他区域对象直接引用的回收集合内的对象</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E7%A7%BB.png?raw=true" alt="对象转移"></p><p>对象转移分为三类:</p><ol><li>对于引用到回收集合内的对象,将该对象添加到<B>转移队列</B>中,然后进行回收;</li><li>对于引用到回收集合外的对象,将更新其他对象的转移专用记忆集合;</li><li>对于其他对象引用到回收对象时,更新回收对象的转移专用记忆集合;</li></ol><h4 id="转移"><a class="header-anchor" href="#转移"></a>转移</h4><blockquote><p>在完成根转移之后,哪些被转移队列引用的对象将会<B>依次进行转移</B>.直到转移队列都被清空,转移就全部完成了;至此,回收集合内所有存活的对象都被成功转移到存活区域了;</p></blockquote><h4 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h4><p>在<B>转移阶段</B>是整个G1GC最核心的思想实现,一个是&quot;垃圾优先的垃圾回收&quot;算法的实现,一个是&quot;根对象转移算法&quot;的实现;</p><h2 id="软实时性"><a class="header-anchor" href="#软实时性"></a>软实时性</h2><p>G1GC是如何实现软实时性的?</p><p>在G1GC中用户可以设置以下三个值:</p><ol><li><p>可用内存的上限<br>通过Xmn/xmx来指定堆空间最小/最大值,避免内存被过度占用,Xmn不建议使用,这个值会破坏我们对于暂停时间上限的配置</p></li><li><p>G1GC暂停时间上限<br>使用-XX:MaxGCPauseMillis=200 为所需的最大暂停时间设置目标值,默认值为 200 毫秒.这里有一个前提是在一个GC单位时间内的暂停时间上限;</p></li><li><p>GC单位时间<br>对于GC单位时间的配置,没有找到相关资料,但是肯定是有这个概念的;避免通过频繁的GC来达到暂停时间少的目的;</p></li></ol><p>G1GC是根据<B>预测转移时间</B>和<B>预测可信度</B>这两个计算结果来实现软实时性的;</p><blockquote><p>在G1GC内部有一个<B>调度队列</B>,其中的元素是暂停处理的开始时间和结束时间的组合.G1GC使用这个队列来高效的调度GC的暂停任务.调度队列中保存了最近一次<br>暂停处理的开始时间和介绍时间.调度队列中的元素有上限,如果添加元素时超过上限,队列头部最早添加的元素就会被删除;</p></blockquote><p>如下展示一下<B>GC暂停处理的调度过程</B></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E6%9A%82%E5%81%9C%E5%A4%84%E7%90%86%E7%9A%84%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png?raw=true" alt="GC暂停处理的调度过程"></p><p>图中<B>1</B>表示的是在当前时间开始预测下一次发生GC的暂停时间为X,第2步表示如果此时开始GC,在一个GC的单位时间之内会超过设定的GC暂停时间的上限,因此不进行暂停;<br>在第3步中,如果将暂停时间延迟,在GC的单位时间内不会超过设定的GC暂停时间上限;<br>需要注意的是<B>调度程序会保证在任意截取的GC单位时间内,总的GC暂停时间都不会超过用户设置的GC暂停时间上限</B>,当然在某些特殊情况下也会超出设置的暂停时间上限,这就是G1GC所保证的&quot;乱实时性&quot;,这些特殊情况包括但是不限于&quot;GC的预测时间不准确&quot;和&quot;堆内存空间不足&quot;等;</p><h2 id="分代G1GC模式"><a class="header-anchor" href="#分代G1GC模式"></a>分代G1GC模式</h2><p>在上述的<B>并发标记阶段</B>、<B>转移阶段</B>都是介绍的G1GC的进行GC时的算法和实现,在G1GC的实现中是引入了<B>分代</B>的概念的,下面来介绍一下G1GC的分代;</p><h3 id="为什么要进行分代"><a class="header-anchor" href="#为什么要进行分代"></a>为什么要进行分代?</h3><blockquote><p>分代:通过给对象引入&quot;年龄&quot;的做法来标记对象的重要程度,从而提升GC的效率;</p></blockquote><h3 id="GC模式划分"><a class="header-anchor" href="#GC模式划分"></a>GC模式划分</h3><ul><li>纯G1GC模式</li><li>分代G1GC模式</li></ul><p>两者之间的不同点:</p><p>内存划分的不同:</p><ul><li>区域是分代的</li><li>回收集合的选择是分代的</li></ul><blockquote><p>在分代G1GC模式中,区域会被划分成<B>新生代区域</B>和<B>老年代区域</B>两类;和其他分代算法类似,分代G1GC的对象也保存了自身在各次转移中存活下来的次数.新生代区域存放新生代对象,老年代区域存放老年代对象;</p></blockquote><p>在G1GC中新生代区域GC被称为<B>完全新生代GC</B>,老年代区域GC被称为部分新生代GC,他们之间的区别在于回收集合的选择,完全新生代GC是将<B>所有的新生代区域</B>选入回收集合,部分新生代GC是将<B>所有的新生代区域以及一部分老年代区域</B>选入回收集合中;</p><p>回收方式的不同:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E6%96%B0%E7%94%9F%E4%BB%A3GC%E7%9A%84%E8%BF%87%E7%A8%8B.jpg?raw=false" alt="新生代GC的过程"></p><p>从上图中可以看到部分新生代GC会将一部分老年代区域中的对象进行回收;</p><h3 id="新生代区域"><a class="header-anchor" href="#新生代区域"></a>新生代区域</h3><p>新生代区域会被划分成两类:</p><ul><li>创建区域</li><li>存活区域</li></ul><p>创建区域指的是用于存放刚刚生成一次都没有经历过转移的对象,存活区域用来保存至少转移过一次的对象;</p><p>在新生代区域中不会应用<B>转移转移写屏障</B>,因为新生代中的对象都是会被回收的,因此被引用方不会保存新生代的专用写屏障;</p><h2 id="算法篇的总结"><a class="header-anchor" href="#算法篇的总结"></a>算法篇的总结</h2><p><img src="https://raw.githubusercontent.com/agmtopy/noteBook/master/png/j-jvm/mutator%E5%92%8CGC%E7%9A%84%E6%89%A7%E8%A1%8C%E5%85%B3%E7%B3%BB.png" alt="mutator和GC的执行关系"></p><p>在大多数时候转移专用记忆集维护线程都是和mutator并发执行的,但是在GC的存活对象计数阶段记忆维护线程也是暂停的.888888</p><p>G1GC的优点:</p><ol><li>G1GC具备软实时性,可以由用户控制GC的暂停时间</li><li>能够充分发挥高配置机器的性能,做到并发执行</li><li>通过写屏障将处理粒度调整为更粗维度的卡片粒度,从而降低了写屏障发生的频率</li><li>通过对象的转移,实现了区域内没有内存碎片</li></ol><p>G1GC的缺点:</p><ol><li>适用与多核处理器的设备;</li><li>区域内不会出现碎片化,但是整个堆会按照区域出现碎片化;</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><ul><li>《深入Java虚拟机：JVM G1GC的算法与实现》中村成洋(作者) 吴炎昌,杨文轩 (译者)</li><li>《垃圾回收的算法与实现》中村成洋,相川光,竹内郁雄 (作者) 丁灵 (译者)<br><a href="https://wiki.openjdk.org/display/HotSpot/G1GC+Feedback">G1GC Feedback</a><br><a href="https://www.huminxi.com/2022/07/06/java%208%20vs%20java%2017%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">Java 8 vs Java 17 垃圾收集器</a><br><a href="https://www.bilibili.com/video/BV15B4y1972U/">G1GC最初的设计思路（上）</a><br><a href="https://developer.aliyun.com/article/1097566">JVM垃圾回收-记忆集和卡表</a><br><a href="https://zhuanlan.zhihu.com/p/444691935">图解 Remembered Set、Card Table、Write Barrier</a><br><a href="https://tech.meituan.com/2016/09/23/g1.html">Java Hotspot G1 GC的一些关键技术</a><br><a href="https://docs.oracle.com/en/java/javase/18/gctuning/garbage-first-g1-garbage-collector1.html#GUID-58968F63-9EAF-487E-A884-CF0831EA6D31">HotSpot Virtual Machine Garbage Collection Tuning Guide</a><br><a href="https://zhuanlan.zhihu.com/p/115501055">Java Memory：认识SafeRegion</a><br><a href="https://tschatzl.github.io/2022/08/04/concurrent-marking.html">Concurrent Marking in G1</a><br><a href="http://www.noobyard.com/article/p-smfxguqn-od.html">最清晰易懂的G1GC资料</a><br><a href="https://segmentfault.com/a/1190000039300766">SATB的一些理解</a><br><a href="https://www.zhihu.com/question/456166411">G1并发标记的原始快照（SATB）的过程是怎样的？</a><br><a href="https://www.jfokus.se/jfokus17/preso/Write-Barriers-in-Garbage-First-Garbage-Collector.pdf">Write Barriers in Garbage First Garbage Collector</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记&lt;/h1&gt;
&lt;p&gt;这一篇文章主要是用于记录《深入Java虚拟机：JVM G1GC的算法与实现》一书中&lt;B&gt;算法篇&lt;/B&gt;部分的笔记,主要分为引子、并发标记、转移、软实时性、分代G1GC模式;&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/categories/jvm/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java性能权威指南-性能测试的方法和工具</title>
    <link href="https://agmtopy.gitee.io/2023/03/24/20.%E7%AC%94%E8%AE%B0/30.Java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://agmtopy.gitee.io/2023/03/24/20.%E7%AC%94%E8%AE%B0/30.Java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2023-03-24T13:44:02.000Z</published>
    <updated>2023-04-05T08:53:03.580Z</updated>
    
    <content type="html"><![CDATA[<h1>Java性能权威指南-性能测试的方法和工具</h1><h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><p>记录在阅读《Java性能权威指南》过程中的一些笔记和感悟,主要会分为一下几个部分:性能测试方式方法、影响性能的原因、如何进行调优;下面第一部分就是对<B>性能测试方式方法</B>进行分析</p><h2 id="性能测试的四项原则"><a class="header-anchor" href="#性能测试的四项原则"></a>性能测试的四项原则</h2><p>当一个应用出现性能瓶颈或者性能方面的问题时，往往不能一眼发现问题的根源，会从多个方向去猜测原因,毫无头绪，因此对应用进行性能测试是了解当前阀值的一个好方法;</p><p>性能测试时有几项原则，可以更好的帮助我们进行分析</p><ol><li>测试真实的应用</li></ol><p>在真实的应用上进行性能测试,因为如果你的测试目标和真实的应用不是同一个时,很多影响性能的因素会导致判断错误;</p><ol start="2"><li>理解批处理流逝时间、吞吐量和响应时间</li></ol><ul><li>批处理流逝时间指的是<B>一个批处理作业从开始运行到结束的时间间隔</B></li><li>吞吐量指的是单位时间内完成的工作量,常见的指标有:TPS(事务数/1s)、RPS(请求数/1s)、OPS(操作数/1s)</li></ul><ol start="3"><li><p>用统计方法应对性能的变化<br>在小样本的数据下结果会存在较大的差异,因此要采用大量的数据集来消除这种差异;</p></li><li><p>尽早的开始测试<br>这一点对于性能测试来说个人不太认同,尽早的开始测试应该是对应用代码进行测试,来保证业务上的正确性;</p></li></ol><h2 id="性能测试的种类"><a class="header-anchor" href="#性能测试的种类"></a>性能测试的种类:</h2><ol><li>微基准测试</li></ol><blockquote><p>用来测量微小代码单元的性能<br>主要是用于测试代码片段的性能,有两个问题:测试代码复杂/对于性能准确性会因为偏差造成不准</p></blockquote><ol start="2"><li>宏基准测试</li></ol><blockquote><p>宏基准测试是以真实世界中的业务为测试目标来进行测试的一种方法，是用于评估系统的整体性能;</p></blockquote><ol start="3"><li>介基准测试</li></ol><blockquote><p>介基准测试是微基准测试和宏基准测试之间的测试方法,是用于评估组成真实业务规则中的一系列子方法;</p></blockquote><h2 id=""><a class="header-anchor" href="#"></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java性能权威指南-性能测试的方法和工具&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;记录在阅读《Java性能权威指南》过程中的一些笔记和感悟,主要会分为一下几个部分:性能测试方</summary>
      
    
    
    
    <category term="性能" scheme="https://agmtopy.gitee.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cola4.0的工程实践</title>
    <link href="https://agmtopy.gitee.io/2022/12/24/1.%E6%9D%82%E8%AE%B0/Cola4.0%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/12/24/1.%E6%9D%82%E8%AE%B0/Cola4.0%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-24T03:30:46.000Z</published>
    <updated>2023-01-28T03:14:34.853Z</updated>
    
    <content type="html"><![CDATA[<h1>Cola4.0的工程实践</h1><p>cola在今年迎来了4.0版本,在最新的版本中对<B>包结构</B>进行了调整以及将COLA项目整体划分为两个部分<B>COLA架构</B>和<B>COLA组件</B>;<br>下面先简单的介绍COLA的改变,再介绍CLOA4.0的工程实践</p><h2 id="COLA的改变"><a class="header-anchor" href="#COLA的改变"></a>COLA的改变</h2><p>COLA4.0的改变主要是聚焦与COLA架构和COLA组件两个部分:</p><ol><li>COLA架构：关注应用架构的定义和构建，提升应用质量。</li><li>COLA组件：提供应用开发所需要的可复用组件，提升研发效率。<br>作者Frank画了两张图很好的表现出来</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/COLA4.0%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png?raw=true" alt="COLA4.0分层模型"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/COLA%E6%9E%B6%E6%9E%84%E6%8A%BD%E8%B1%A1.png?raw=true" alt="COLA架构抽象"></p><h2 id="COLA-4-0d的实践"><a class="header-anchor" href="#COLA-4-0d的实践"></a>COLA 4.0d的实践</h2><h3 id="创建项目"><a class="header-anchor" href="#创建项目"></a>创建项目</h3><p>创建项目命令与之前的相同还是执行以下命令即可:</p><blockquote><p>mvn archetype:generate  -DgroupId=com.agmtopy.demo  -DartifactId=cola-demo  -Dversion=1.0.0-SNAPSHOT  -Dpackage=com.agmtopy.demo  -DarchetypeArtifactId=cola-framework-archetype-web  -DarchetypeGroupId=com.alibaba.cola  -DarchetypeVersion=4.3.1</p></blockquote><p>稍微注意修改 #groupId#/#artifactId#/#package#;<br>这个命令在PowerShell不能执行,参数传递错误,需要在CMD或者shell下执行</p><p>创建完成项目后可以看到项目目录如下:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_pom.jpg?raw=true" alt="cola项目结构_maven"></p><p>使用<B>gradle init</B>将maven转换成gradle项目</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_gradle.jpg?raw=true" alt="cola项目结构_gradle"></p><p>在maven项目转换成gradle项目时遇到几个问题:</p><ol><li>gradle ext定义常量在使用kotlin定义时,方式为<B>val</B></li><li>主build.gradle.kts引入BOM,子项目使用组件版本问题未解决,现在还是通过在子项目中直接引入的目标组件</li></ol><p>项目build成功后,通过<B>Application.main</B>启动即可访问</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola_helloworld.jpg?raw=true" alt="cola_helloworld"></p><h3 id="项目结构"><a class="header-anchor" href="#项目结构"></a>项目结构</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_gradle.jpg?raw=true" alt="cola项目结构_gradle"></p><p>通过<B>cola-framework-archetype-web</B>创建出来的项目结构如上所示,这个结构比较符合标准项目的定义;<br>在实际使用中结合目前团队现有方案我进行了部分调整,调整后的结构如下所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5.png?raw=true" alt="项目实践"></p><pre class="line-numbers language-none"><code class="language-none">├‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧integrationtest‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧┤├╌╌╌╌╌╌╌╌╌api&#x2F;app╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌batch╌╌╌╌╌╌╌╌╌╌╌╌╌┤                           ├╌╌╌╌╌╌╌╌╌╌joblay╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌business&#x2F;configure╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌domain╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌infrastructure&#x2F;common╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个结构中调整的地方如下:<br>新增:<B>integrationtest</B>作为通用测试的模块<br>新增:<B>configure</B>作为业务配置的模块,专门处理业务配置<br>改变:<B>adapter</B>模块扩充为<B>api/app/batch</B>三个模块,其中app和batch作为实例的启动入口<br>改变:<B>app</B>模块扩充为<B>joblay/business/configure</B>三个模块,作为业务处理<br>改变:<B>infrastructure</B>层新增加<B>common</B>模块,承载通用处理和工具类的职能<br>删除:删除<B>start</B>模块,将启动模块下沉到<B>app</B>和<B>batch</B>中</p><p>在这个模块设计中<B>joblay</B>存在的意义是用来实现批量业务领域内的功能;由于<B>app</B>和<B>batch</B>都只是承担start的功能;</p><p>项目地址为<B><a href="https://github.com/agmtopy/cola-demo">https://github.com/agmtopy/cola-demo</a></B></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/significantfrank/article/details/110934799?spm=1001.2014.3001.5502">COLA 4.0：应用架构的最佳实践</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Cola4.0的工程实践&lt;/h1&gt;
&lt;p&gt;cola在今年迎来了4.0版本,在最新的版本中对&lt;B&gt;包结构&lt;/B&gt;进行了调整以及将COLA项目整体划分为两个部分&lt;B&gt;COLA架构&lt;/B&gt;和&lt;B&gt;COLA组件&lt;/B&gt;;&lt;br&gt;
下面先简单的介绍COLA的改变,再介绍CLOA4.</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="cola" scheme="https://agmtopy.gitee.io/tags/cola/"/>
    
  </entry>
  
  <entry>
    <title>Groowy脚本实现业务场景下动态性规则的实践</title>
    <link href="https://agmtopy.gitee.io/2022/12/16/1.%E6%9D%82%E8%AE%B0/Groowy%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8A%A8%E6%80%81%E6%80%A7%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/12/16/1.%E6%9D%82%E8%AE%B0/Groowy%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8A%A8%E6%80%81%E6%80%A7%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-16T13:39:20.000Z</published>
    <updated>2023-01-04T16:56:04.305Z</updated>
    
    <content type="html"><![CDATA[<h1>Groowy脚本实现业务场景下动态性规则的实践</h1><h2 id="前言："><a class="header-anchor" href="#前言："></a>前言：</h2><p>在复杂的业务中我们往往会采用分层的思想来降低每一层的复杂度，应用层还会采用一些设计模式来预留出对于未来的扩展；在面对<br>复杂和易变的业务场景下，作为开发者，我们更期望程序框架底座能够保持稳定，而对”<B>扩展</B>”更期望可以做到能快速响应业务需求的变化和做到隔离性；<br>由于程序语言的特性，有些语言不能做到实时热编译和部署，需要借助其他工具来实现这一个效果，在jvm平台上Groovy脚本语言就非常适合这种场景。<br>接下来以一个具体的业务需求来作为“引子”，来展开是这个需求实现过程中的一些思考和实践;</p><h2 id="需求背景"><a class="header-anchor" href="#需求背景"></a>需求背景</h2><p>原始需求简化后得出的核心目标就是对业务数据进行巡检,本身从功能上来讲比较简单;在系统设计出发的时候就明确了本次的功能目标:</p><ol><li>向上会抽象出<B>巡检功能</B>的核心领域,并且支持扩展</li><li>向下会设计出基础设施层来作为支撑</li></ol><p>向上这一部分工作开展的比较顺利,因为是基于现实诉求抽象公共特性/接口;但是向下这一部分设计在落地的时候遇到一些问题,有三个阶段分别是:</p><ol><li>采用手动编译java代码</li><li>采用开源框架编译加载java代码</li><li>使用Groovy动态脚本</li></ol><h3 id="设计评审"><a class="header-anchor" href="#设计评审"></a>设计评审</h3><p>在实现这个需求的时候,做技术方案设计评审的时候,我提供了两种实现基础设施层的技术方案:<br>第一种是通过easy-rules提供出一个一个散列开的业务校验规则执行器,这样做的优点是在于技术成本最低,且代码可读性好,但是没有动态编译执行的能力<br>第二种是通过引入动态语言实现,这样做的优点是程序具有动态编译执行的能力,缺点是在于技术成本略高,Groovy脚本语言需要一定的学习成本</p><p>最后的技术评审经过大家的沟通交流最后决定采用第一种方案来进行实现;</p><h3 id="方案实施"><a class="header-anchor" href="#方案实施"></a>方案实施</h3><p>在按照第一种方案进行实施的时候,遇到一个问题,代码的重复度太高;因为业务需求的本质就只是<B>对比</B>,因此最开始想采用反射来降低代码的重复度,将需要检查的字段放在Map进行处理;<br>在继续沿着这方面思考,就想到了既然是用Map来获取校验规则,那可不可以将校验规则写入配置中心或者数据库,再进行动态加载楠;<br>沿着这个思路开始查找java文件进行动态编译的框架<a href="https://github.com/jOOQ/jOOR">joor</a>,在进行快速验证的时候发现joor可以做到对java文件的动态编译,但是在JDK8上有部分编译错误无法实现业务的扩展性;<br>这个时候似乎只有一种选择了,就是采用<B>Groovy</B>来进行实现</p><h2 id="Groovy使用"><a class="header-anchor" href="#Groovy使用"></a>Groovy使用</h2><h3 id="整体执行流程"><a class="header-anchor" href="#整体执行流程"></a>整体执行流程</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/excalidraw/Untitled-2022-09-08-1533.png?raw=true" alt="整体执行流程"></p><p>在流程中抽象的比较方法是作为所有动态脚本的父类,默认采用了反射的反射来或者Object中指定的字段</p><h3 id="DynamicUtil的设计"><a class="header-anchor" href="#DynamicUtil的设计"></a>DynamicUtil的设计</h3><p>从四个问题开始入手:</p><ol><li>如何简化Groovy的学习成本,从而推广出去?</li><li>如何保证性能?</li><li>如何保证动态脚本的安全性?</li><li>如何保证动态脚本的代码质量(动态脚本的单元测试如何进行)?</li></ol><h4 id="对于如何简化Groovy的学习成本"><a class="header-anchor" href="#对于如何简化Groovy的学习成本"></a>对于如何简化Groovy的学习成本?</h4><p>项目初期可以采用<B>GroovyClassLoader</B>来执行<B>Java脚本</B></p><ul><li>DynamicUtil</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">GroovyClassLoader</span> groovyClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroovyClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> helloScript <span class="token operator">=</span> <span class="token string">"package com.agmtopy.source.groovy;\n"</span> <span class="token operator">+</span>                <span class="token string">"\n"</span> <span class="token operator">+</span>                <span class="token string">"class Hello &#123;\n"</span> <span class="token operator">+</span>                <span class="token string">"    public String method(String name) &#123;\n"</span> <span class="token operator">+</span>                <span class="token string">"        System.out.println(\"hello, \" + name);\n"</span> <span class="token operator">+</span>                <span class="token string">"        return name;\n"</span> <span class="token operator">+</span>                <span class="token string">"    &#125;\n"</span> <span class="token operator">+</span>                <span class="token string">"&#125;\n"</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span> helloClass <span class="token operator">=</span> groovyClassLoader<span class="token punctuation">.</span><span class="token function">parseClass</span><span class="token punctuation">(</span>helloScript<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">GroovyObject</span> object <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">GroovyObject</span><span class="token punctuation">)</span> helloClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> ret <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">invokeMethod</span><span class="token punctuation">(</span><span class="token string">"method"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 控制台输出"hello, world"</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印world</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Hello.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>agmtopy<span class="token punctuation">.</span>source<span class="token punctuation">.</span>groovy</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在上面这个例子中,我们执行的脚本就是java语法规则的脚本;这样如何简化Groovy脚本的问题就可以得到解决;<br>在整个执行框架稳定以后,还是需要推广Groovy脚本,java语法的脚本只是一个中间过渡方案!</p><h4 id="如何保证脚本的执行性能"><a class="header-anchor" href="#如何保证脚本的执行性能"></a>如何保证脚本的执行性能?</h4><p>这里的性能指的是两方面:<B>编译</B>和<B>执行</B>,我们先来看Groovy是如何编译脚本的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Class</span> <span class="token function">parseClass</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">GroovyCodeSource</span> codeSource<span class="token punctuation">,</span> <span class="token keyword">boolean</span> shouldCacheSource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CompilationFailedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取cacheKey:scriptTest+name 进行MD5</span>    <span class="token class-name">String</span> cacheKey <span class="token operator">=</span> <span class="token function">genSourceCacheKey</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//sourceCache是一个类似与Map类型的类</span>    <span class="token keyword">return</span> sourceCache<span class="token punctuation">.</span><span class="token function">getAndPut</span><span class="token punctuation">(</span>            cacheKey<span class="token punctuation">,</span>            key <span class="token operator">-></span> <span class="token function">doParseClass</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">,</span>            shouldCacheSource    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">Class</span> <span class="token function">doParseClass</span><span class="token punctuation">(</span><span class="token class-name">GroovyCodeSource</span> codeSource<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">validate</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span> answer<span class="token punctuation">;</span>  <span class="token comment">// Was neither already loaded nor compiling, so compile and add to cache.</span>    <span class="token class-name">CompilationUnit</span> unit <span class="token operator">=</span> <span class="token function">createCompilationUnit</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> codeSource<span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//省略...</span>        <span class="token comment">//创建ClassCollector,class类属性相关的收集对象</span>    <span class="token class-name">ClassCollector</span> collector <span class="token operator">=</span> <span class="token function">createCollector</span><span class="token punctuation">(</span>unit<span class="token punctuation">,</span> su<span class="token punctuation">)</span><span class="token punctuation">;</span>    unit<span class="token punctuation">.</span><span class="token function">setClassgenCallback</span><span class="token punctuation">(</span>collector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开始执行编译命令</span>    unit<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>goalPhase<span class="token punctuation">)</span><span class="token punctuation">;</span>    answer <span class="token operator">=</span> collector<span class="token punctuation">.</span>generatedClass<span class="token punctuation">;</span>    <span class="token class-name">String</span> mainClass <span class="token operator">=</span> su<span class="token punctuation">.</span><span class="token function">getAST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMainClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token operator">:</span> collector<span class="token punctuation">.</span><span class="token function">getLoadedClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token class-name">String</span> clazzName <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">definePackageInternal</span><span class="token punctuation">(</span>clazzName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置到classCache中</span>        <span class="token function">setClassCacheEntry</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置为answer</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazzName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mainClass<span class="token punctuation">)</span><span class="token punctuation">)</span> answer <span class="token operator">=</span> clazz<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> answer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中,执行流程如下</p><p>doParseClass() -&gt; createCollector() -&gt; unit.compile(goalPhase) -&gt; ClassCollector.call() -&gt; ClassCollector.createClass()</p><p>创建class对象的过程是在<B>ClassCollector.createClass</B>方法中,在这个方法中可以看到最后是调用的java.security.SecureClassLoader#defineClass()</p><ul><li>ClassCollector.createClass</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span> <span class="token function">createClass</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> code<span class="token punctuation">,</span> <span class="token class-name">ClassNode</span> classNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BytecodeProcessor</span> bytecodePostprocessor <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytecodePostprocessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fcode <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytecodePostprocessor<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fcode <span class="token operator">=</span> bytecodePostprocessor<span class="token punctuation">.</span><span class="token function">processBytecode</span><span class="token punctuation">(</span>classNode<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//GroovyClassLoader extends SecureClassLoader</span>    <span class="token class-name">GroovyClassLoader</span> cl <span class="token operator">=</span> <span class="token function">getDefiningClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//这里通过SecureClassLoader.defineClass 来进行加载</span>    <span class="token class-name">Class</span> theClass <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>classNode<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fcode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fcode<span class="token punctuation">.</span>length<span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">getAST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadedClasses<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>theClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//省略...</span>    <span class="token keyword">return</span> theClass<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里还有一个点是在创建<B>GroovyClassLoader</B>时,都是通过<B>new InnerLoader</B>的方式来创建</p><blockquote><p>return java.security.AccessController.doPrivileged((PrivilegedAction<InnerLoader>) () -&gt; new InnerLoader(GroovyClassLoader.this));</p></blockquote><p>这是因为Class对象是通过ClassLoader+class的方式来定位确定唯一一个类的,InnerLoader每次都会创建一个新的对象,这样可能会导致Metaspace内存溢出,虽然在Groovy3.0以后针对这个问题已经进行过优化了,但是还是强烈建议通过内存将脚本编译后的<B>GroovyObject</B>缓存下来,本身脚本的再次编译和加载都是一个较为消耗性能的动作;</p><p>我们下面继续对<B>执行性能</B>来进行分析,在网上大多数资料对于Groovy的脚本执行性能的分析,github中关于这方面的issue也比较少,并且大部分是针对与Groovy和Java进行对比的;<br>下面有几个关于Groovy脚本执行的建议:</p><ol><li>尽量使用静态类型,由于Groovy是动态语言,在将动态特性编译成为静态语言时是比较消耗性能的</li><li>oracle官方对于Groovy的5条性能建议</li></ol><h4 id="如何保证动态脚本的安全性"><a class="header-anchor" href="#如何保证动态脚本的安全性"></a>如何保证动态脚本的安全性?</h4><p>如何保证动态脚本的安全性?其实也是分为两个方面考虑的:</p><ol><li>执行安全性</li></ol><blockquote><p>执行安全性指的是在执行脚本时是否会影响到我的宿主进程?如何规避这种风险?</p></blockquote><ol start="2"><li>脚本本身的安全性</li></ol><blockquote><p>脚本本身的安全性指的是脚本语义是否正确/正常以及可信</p></blockquote><p>下面对着两方面进行分析和设计:</p><p><B>脚本执行的安全性</B>方面最主要的考虑是错误的脚本是否会影响到主进程的执行?主要从下面几个方面考虑:</p><ol><li>内存<blockquote><p>内存主要还是考虑堆栈内存即可,一个是成员变量的空间分配,一个是while造成死循环使栈溢出等;可以在定义<B>GroovyClassLoader</B>时进行排除</p></blockquote></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">SecureASTCustomizer</span> secure <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecureASTCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建SecureASTCustomizer</span>secure<span class="token punctuation">.</span><span class="token function">setClosuresAllowed</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 禁止使用闭包</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tokensBlacklist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tokensBlacklist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Types</span><span class="token punctuation">.</span>*<span class="token operator">*</span>KEYWORD_WHILE<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加关键字黑名单 while和goto</span>tokensBlacklist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Types</span><span class="token punctuation">.</span>*<span class="token operator">*</span>KEYWORD_GOTO<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setTokensBlacklist</span><span class="token punctuation">(</span>tokensBlacklist<span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setIndirectImportCheckEnabled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置直接导入检查</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"com.alibaba.fastjson.JSONObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setImportsBlacklist</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>线程</li></ol><blockquote><p>对与线程方面的考虑主要是执行线程需要使用单独的线程池进行处理,这样做的目的是防止动态脚本的执行线程阻塞业务线程;第二个是动态脚本中应该禁止使用线程池来进行处理,这方面的考量主要是基于脚本业务代码尽量的要简单高效和可读性,引入线程池会增加脚本的复杂度和可维护性</p></blockquote><ol start="3"><li>数据库/资源的管理</li></ol><blockquote><p>对与数据库和其他资源的访问,我是持有拒绝的态度,主要观点还是和脚本中实现线程池类似,还有一点是脚本中进行数据变更和资源处理缺少了代码版本控制这一个环节;</p></blockquote><p><B>脚本本身的安全性</B>主要指的是脚本开发/提测/上线整个流程的安全和监控性,在这方面Vivo提供了一套内部使用的流程如下:</p><p><img src="https://static001.geekbang.org/infoq/ac/acf787602d9e4bf20abded0c80525565.png" alt="Groovy整体流程"></p><p>在这个过程中,除了code review部分需要开发者进行参与,其他部分都可以依托CI/CD工具实现自动化执行;<br>有了这样一个流程,其实是可以解决脚本本身的安全性的问题的;</p><h4 id="如何保证动态脚本的代码质量"><a class="header-anchor" href="#如何保证动态脚本的代码质量"></a>如何保证动态脚本的代码质量?</h4><p>动态脚本的代码质量如何进行保证,一方面是可以通过良好的code review机制来提高质量,另外一方面是需要建设好单元测试框架;<br>如何建立好动态脚本的单元测试?<br>首先是方便,在开发人员的角度一个工具只有在足够的简单方便的情况下才会乐意去进行使用,其次是流程规范.<br>目前执行的过程是在特定的测试包下,开发脚本,然后进行单元测试,在单元测试通过后在写入数据库中;<br>后续实践出更好的方案在进行更新</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>以上通过Groovy实现了动态特性的同时引入了一些尚未解决的问题:<br>执行性能/单元测试,后续在实践过程中也会对这些问题持续的进行更新.</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/en/cloud/paas/app-builder-cloud/visual-builder-groovy/best-practices-for-groovy-performance.html">oracle官方对于Groovy 性能的最佳实践</a><br><a href="https://www.huangchaoyu.com/2021/10/16/groovy%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%AE%B9%E6%98%93%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/">groovy静态编译容易引发的问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Groowy脚本实现业务场景下动态性规则的实践&lt;/h1&gt;
&lt;h2 id=&quot;前言：&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;
&lt;p&gt;在复杂的业务中我们往往会采用分层的思想来降低每一层的复杂度，应用层还会采用一些设计</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="guava" scheme="https://agmtopy.gitee.io/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>Class文件格式与加载</title>
    <link href="https://agmtopy.gitee.io/2022/12/03/12.JVM/9.Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8A%A0%E8%BD%BD/"/>
    <id>https://agmtopy.gitee.io/2022/12/03/12.JVM/9.Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-12-03T15:02:44.000Z</published>
    <updated>2022-12-04T10:14:51.378Z</updated>
    
    <content type="html"><![CDATA[<h1>Class文件格式与加载</h1><h2 id="类文件结构"><a class="header-anchor" href="#类文件结构"></a>类文件结构</h2><ul><li>类文件结构也就是Class文件的结构<ul><li>魔数:用于标识Class文件的版本</li><li>常量池:主要用于保存<strong>字面量(类似于字符串等)</strong> 和 <strong>符号引用(类和接口的全限定名\字段名称以及描述符\方法名称和描述符);</strong> 由于jvm在加载Class文件时才会进行<B>动态连接</B>,因此需要保存这些方法或接口的信息</li><li>访问标识:标识这个Class的类型(接口/类/public/abstract/final等)</li><li>类索引、父类索引与接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul></li></ul><h2 id="虚拟机类加载机制"><a class="header-anchor" href="#虚拟机类加载机制"></a>虚拟机类加载机制:</h2><ul><li>虚拟机把描述类的数据从Class文件加载到内存中,并对数据进行校验、转换解析、初始化的过程,最终形成可以被虚拟机之间使用的Java类型对象,就是虚拟机类的加载过程.</li></ul><h3 id="类加载的步骤"><a class="header-anchor" href="#类加载的步骤"></a>类加载的步骤</h3><ol><li>加载</li><li>连接:验证→准备→解析</li><li>初始化</li><li>使用</li><li>卸载</li></ol><p>在执行顺序上:加载→验证→准备→解析→初始化,这五个步骤的顺序是固定的;</p><h4 id="加载"><a class="header-anchor" href="#加载"></a>加载</h4><ol><li>通过类的全限定名来获取定义此类的二进制字节流</li><li>将二进制字节流转换为方法区运行时的数据结构</li><li>在内存中创建这个类的Class对象,作为方法区类结构的方法映射</li></ol><ul><li>对于HotSpot虚拟机而言,Class对象比较特殊,它虽然是对象,但是存放在方法区内,作为访问类结构的对象接口</li></ul><h4 id="验证"><a class="header-anchor" href="#验证"></a>验证</h4><ol><li>文件格式的验证:文件格式\运行版本等</li><li>元数据的验证:对字节码语义信息的分析,</li><li>字节码内容的验证:通过程序来校验方法块中的内容是否正确</li></ol><p>验证阶段贯穿[加载、准备、解析]，并不是严格的线性的顺序</p><h4 id="准备"><a class="header-anchor" href="#准备"></a>准备</h4><ol><li>为类变量分配内存并设置初始值的过程，对于类变量也仅仅是进行类型初始值的赋值(零值)</li><li>final修饰的类变量在这个阶段会直接进行赋实际值的过程，因为final修饰的值会被当作常量</li></ol><h4 id="解析"><a class="header-anchor" href="#解析"></a>解析</h4><ul><li>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程<ol><li>解析阶段会触发类的加载，当为找到Class对象时会根据类的全限定明进行加载</li><li>对字段会按照继承顺序从下先上进行查找，并校验访问权限</li><li>对类方法和接口方法的解析与字段类似</li></ol></li></ul><h4 id="初始化"><a class="header-anchor" href="#初始化"></a>初始化</h4><p>初始化就是在执行<B>clint()</B>的过程</p><p><B>clint()</B>是编译器自动收集类中所有的类变量赋值动作和静态语句块合并生成的</p><p>静态代码块可以对在它之后的类变量进行赋值，但是不能进行访问；因为类变量在<strong>准备阶段</strong>就完成的零值的赋值</p><p>虚拟机内部保证了在执行器之类的<B>clint()</B>方法之前先执行父类的<B>clint()</B>方法</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/ClassLoader_flow.jpg?raw=true" alt="Class文件整体加载结构"></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.geeksforgeeks.org/classloader-in-java/">java中的类加载器</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Class文件格式与加载&lt;/h1&gt;
&lt;h2 id=&quot;类文件结构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#类文件结构&quot;&gt;&lt;/a&gt;类文件结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类文件结构也就是Class文件的结构
&lt;ul&gt;
&lt;li&gt;魔数:用于标识Class</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>性能监控与故障处理工具</title>
    <link href="https://agmtopy.gitee.io/2022/12/01/1.%E6%9D%82%E8%AE%B0/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://agmtopy.gitee.io/2022/12/01/1.%E6%9D%82%E8%AE%B0/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2022-12-01T15:11:20.000Z</published>
    <updated>2022-12-03T14:59:38.223Z</updated>
    
    <content type="html"><![CDATA[<h1>性能监控与故障处理工具</h1><p>介绍处理jvm的相关问题办法以及相关工具的一个持续更新的集合</p><h2 id="📚-经验"><a class="header-anchor" href="#📚-经验"></a>📚 经验</h2><h3 id="CPU占用率高"><a class="header-anchor" href="#CPU占用率高"></a>CPU占用率高</h3><ul><li>通过jvm工具排查</li></ul><ol><li>通过<strong>top</strong>命令查询进程号</li><li>通过<strong>top -Hp <pid></strong> 查到线程号,转换成为<strong>16进制</strong></li><li>通过<strong>jstack <pid> |grep 16进制线程号 -A 10</strong> 找到CPU当前执行的方法堆栈</li></ol><ul><li>通过arthas排查</li></ul><ol><li>thread</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看线程状态(默认只显示10个线程)</span>thread <span class="token comment"># 查看全部线程状态</span>thread --all<span class="token comment"># 查看指定线程执行状态</span>thread --pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="OOM问题"><a class="header-anchor" href="#OOM问题"></a>OOM问题</h3><ol><li>启动命令中设置</li></ol><blockquote><p><B>-XX:+HeapDumpOnOutOfMemoryError</B> 配合<B> -XX:HeapDumpPath</B><br>在OOM时生成dump文件</p></blockquote><ol start="2"><li>线上命令</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#生成堆转储快照dump文件命令</span>  jmap -dump:format<span class="token operator">=</span>b,file<span class="token operator">=</span>heapdump.hprof pid<span class="token comment"># 生成堆栈信息文件命令</span>  jstack -l pid <span class="token operator">>></span> stack.txt<span class="token comment"># Arthas命令</span>  heapdump<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程问题"><a class="header-anchor" href="#线程问题"></a>线程问题</h3><ul><li>线程池提交任务不执行</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># arthas排查</span><span class="token comment"># 获取ClassLoad Hash</span>sc -d com.agmtopy.source.executer.ExecutorServiceUtil<span class="token comment"># 获取对象</span>ognl -x <span class="token number">1</span> <span class="token string">'@com.agmtopy.source.executer.ExecutorServiceUtil@threadPoolExecutor'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>线程死锁</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> <span class="token comment"># arthas排查</span>Thread -b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="⚙-工具"><a class="header-anchor" href="#⚙-工具"></a>⚙ 工具</h2><p><B>Arthas</B>强烈推荐</p><h2 id="📒-常用命令"><a class="header-anchor" href="#📒-常用命令"></a>📒 常用命令</h2><h3 id="网络"><a class="header-anchor" href="#网络"></a>网络</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 采样tcp连接</span><span class="token function">lsof</span> -p 进程号 <span class="token operator">></span> /tmp/进程号_lsof.txt<span class="token comment"># 查看指定端口</span><span class="token function">netstat</span> -tnlp <span class="token operator">|</span> <span class="token function">grep</span> :8080ss -tunlp <span class="token operator">|</span><span class="token function">grep</span> :8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排查网络问题步骤:</p><ol><li>ping 目标地址</li><li>丢包<br>a. 链路中断<br>b. 抖动<br>c. 出口堵塞</li><li>能通<br>a. 检查dns和域名解析</li></ol><blockquote><p>/etc/resolv.conf 或者 dig 或者 nslookup :url</p></blockquote><p>b. 检查端口</p><blockquote><p>telnet -&gt; 如果全部端口不通检查<B>安全组策略</B>;部分端口不通检查<B>负载均衡白名单</B></p></blockquote><ol start="3"><li>不通<br>检查ip设置/网卡驱动/物理链路</li></ol><h3 id="内存"><a class="header-anchor" href="#内存"></a>内存</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 系统内存分布</span>pmap -pid<span class="token comment"># 内存占用</span>jmap -heap 进程号 <span class="token operator">></span> /tmp/进程号_jmap_heap.txt<span class="token comment"># 保存进程堆栈</span>jmap -dump:format<span class="token operator">=</span>b,file<span class="token operator">=</span>/tmp/进程号_jmap_dump.hprof 进程号<span class="token comment"># 内存对象占比</span>jmap -histo <span class="token number">1</span> <span class="token operator">|</span><span class="token function">more</span><span class="token comment"># GC</span>jstat -gcutil 进程号 <span class="token operator">></span> /tmp/进程号_jstat_gc.txtjstat -gcutil <span class="token number">1</span> 1s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CPU"><a class="header-anchor" href="#CPU"></a>CPU</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统上下文切换</span><span class="token function">vmstat</span> -w <span class="token number">1</span><span class="token comment"># 查看进程上下文切换</span>pidstat -p /PID -wtu  <span class="token number">5</span><span class="token comment"># 打印系统负载快照</span><span class="token function">top</span> -b -n <span class="token number">2</span> <span class="token operator">></span> /tmp/top.txt<span class="token function">top</span> -H -n <span class="token number">1</span> -p pid <span class="token operator">></span> /tmp/pid_top.txt<span class="token comment"># 进程列表</span><span class="token function">ps</span> -mp-o THREAD,tid,time <span class="token operator">|</span> <span class="token function">sort</span> -k2r <span class="token operator">></span> /tmp/进程号_threads.txt<span class="token comment"># 线程信息</span>jstack -l 进程号 <span class="token operator">></span> /tmp/进程号_jstack.txt<span class="token comment"># Arthas</span>thread thread -tidthread -all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="I-O"><a class="header-anchor" href="#I-O"></a>I/O</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">strace</span> -p pidiotop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;性能监控与故障处理工具&lt;/h1&gt;
&lt;p&gt;介绍处理jvm的相关问题办法以及相关工具的一个持续更新的集合&lt;/p&gt;
&lt;h2 id=&quot;📚-经验&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#📚-经验&quot;&gt;&lt;/a&gt;📚 经验&lt;/h2&gt;
&lt;h3 id=&quot;CPU占</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="工具" scheme="https://agmtopy.gitee.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jvm-垃圾回收器及算法基础</title>
    <link href="https://agmtopy.gitee.io/2022/12/01/12.JVM/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://agmtopy.gitee.io/2022/12/01/12.JVM/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-12-01T14:02:27.000Z</published>
    <updated>2022-12-03T14:59:41.787Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收器及算法基础</h1><h2 id="前提介绍"><a class="header-anchor" href="#前提介绍"></a>前提介绍</h2><p>垃圾回收器(GC)的理论研究在很早直接就开始了,大概是在60年代lisp语言就开始使用内存分配和垃圾回收机制来管理程序的内存了,近现代这一方向也是保持着极高的研究热度,从G1-&gt;ZGC</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/excalidraw/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80.png?raw=true" alt="大纲"></p><h2 id="算法基础"><a class="header-anchor" href="#算法基础"></a>算法基础</h2><p>对内存空间的回收首先需要解决一个问题那些是需要进行回收的对象,针对这个问题有两种处理方案:</p><ul><li><p>引用计数算法<br>引用计数是通过对对象被引用次数来标识是否有效,存在循环引用问题,可以通过可达性分析的步骤来解决</p></li><li><p>根标记算法,从<strong>GC Roots</strong>开始遍历整个内存对象是否可达的方式来标记需要回收的对象</p><p>首先<strong>GC Roots</strong>对象包括以下的几种:</p><ul><li>虚拟机栈中引用指向的对象(reference)</li><li>方法区中类静态属性引用的对象(静态属性对象,虽然不在栈帧中)</li><li>方法区常量引用的对象(例如常量池中的对象)</li><li>本地方法栈中引用的对象</li></ul></li></ul><h2 id="对象"><a class="header-anchor" href="#对象"></a>对象</h2><ul><li><p>对象的回收</p><p>对象的回收是一个非常严肃的动作,错误的回收将会是一场对用户的灾难,因此在JVM的实现中,对于GC线程的优先级设置的非常低,其次是在标记对象不可达后,还会声明会执行一次<strong>对象</strong>的**finalize()**方法,对于这个方法是否执行完成不做保证(防止死循环/wait time)</p><ul><li>finalize():用于GC回收前对象最后一次自救的方法,但是只会执行一次,防止内存溢出</li></ul></li><li><p>对象的分配</p><p>对象的分配与垃圾收集器的选择有关,对象是优先在Eden区进行分配,</p><p>进入老年代的几种场景:</p><ol><li>大对象直接进入老年代</li><li>长期存活的对象(16次GC)</li><li>动态对象年龄判断(一半相同年龄的对象直接进入老年代)</li></ol></li></ul><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><ul><li><p>标记类</p><p>标记-清除算法/标记-整理算法/复制算法</p><ul><li>标记整理算法是通过时间换空间形式的一种体现,通过整理回收后的内存碎片来达到可以继续分配的目的</li><li>复制算法是空间换时间的体现,通过预留一倍的空间来达到内存回收完成后没有内存碎片的问题</li></ul></li><li><p>分代类</p><p>分代算法主要是根据对象的存活周期,将对象划分为不同区域,在不同的区域上采取不同的算法来处理</p></li></ul><h2 id="HotSopt实现"><a class="header-anchor" href="#HotSopt实现"></a>HotSopt实现</h2><ul><li><p>枚举根节点</p><p>通过<strong>OopMap</strong>的的方式来快速查找GC Roots枚举</p></li><li><p>安全点</p><p>由于引用关系的变化会不断的影响GC Roots,因此HotSpot不是每条指令都会生成OopMap,而只在特定的位置才会产生OopMap,这种特殊的位置被称为<strong>Safe pint</strong>,有两种进入Safe point的方式:</p><ul><li>抢占式</li><li>主动中断式:主动中断的方式是通过设置<strong>中断标记</strong></li></ul></li><li><p>安全区域</p><p>安全区域被称为Safe Region,指的是一段不会改变引用关系的代码,在执行GC时是不会处理已进入Safe Region的线程,当这些线程在离开Sefe Region时也会检查GC是否完成</p></li></ul><h2 id="垃圾收集器"><a class="header-anchor" href="#垃圾收集器"></a>垃圾收集器</h2><ul><li><p>Parallel Scavenge收集器</p></li><li><p>Parallel  Old收集器</p><p>两种Parallel收集器分别是jdk8中默认是年轻代和老年代的垃圾收集器</p><ul><li><p>Parallel Scavenge收集器</p><p>用于<strong>新生代,<strong>关注</strong>吞吐量</strong>的多线程并行收集器</p><p>CMS是关注于停顿时间,尽可能的缩短用户线程的停顿时间,适合于有交互的web系统</p><p>Parallel是关注于吞吐量尽可能的在单位时间内多执行用户代码,缩小GC时间,适用于后台任务</p></li><li><p>Parallel Old收集器</p><p>是老年代的标记-整理算法的多线程垃圾收集器</p></li><li><p>CMS收集器(<strong>三标一清</strong>)</p><p>CMS收集器是以最短停顿时间为目标的垃圾收集器,是基于标记-清除算法演化而来,分为:</p><ol><li>初始标记阶段</li><li>并发标记阶段</li><li>重新标记阶段</li><li>并发清除阶段</li></ol><p>在初始标记和重新标记阶段会STW的方式来进行,因为初始化标记是查找**GC Roots,**重新标记是对并发标记阶段结果修正也需要STW;</p><p>整个CMS中最耗时的<strong>并发标记</strong>和<strong>并发清理阶段</strong>都可以和用户线程一起执行</p><p>CMS垃圾收集器的问题:</p><ol><li>参与线程过高,按照(coreSize+3)/4的方式分配</li><li>无法处理浮动垃圾,对于在重新标记后产生的垃圾只能在下一次GC时进行处理,占用空间,当老年代达到一个阈值后会出发full GC,当CMS在运行时产生内存不足会激活serial GC</li><li>内存碎片问题,通过full GC的方式解决</li></ol></li><li><p>G1收集器</p><ul><li>从jdk9开始G1就作为默认的垃圾处理器</li><li>在整体上G1是标记-整理算法,局部上是标记-复制算法</li></ul></li><li><p>Shenandoah/ZGC收集器</p><ul><li>亚毫秒级</li><li>无分区设计</li></ul></li></ul></li></ul><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.baeldung.com/jvm-zgc-garbage-collector">ZGC简介:可扩展的实验性低延迟 JVM 垃圾收集器</a><br><a href="https://xie.infoq.cn/article/586f901cf8f38dd2f63b54a44">ZGC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收器及算法基础&lt;/h1&gt;
&lt;h2 id=&quot;前提介绍&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提介绍&quot;&gt;&lt;/a&gt;前提介绍&lt;/h2&gt;
&lt;p&gt;垃圾回收器(GC)的理论研究在很早直接就开始了,大概是在60年代lisp语言就开始使用内存分配和垃圾回</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm-内存布局设计</title>
    <link href="https://agmtopy.gitee.io/2022/11/30/12.JVM/7.%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/"/>
    <id>https://agmtopy.gitee.io/2022/11/30/12.JVM/7.%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-11-30T14:13:23.000Z</published>
    <updated>2022-12-03T14:57:50.139Z</updated>
    
    <content type="html"><![CDATA[<h1>内存布局设计</h1><p>JVM的内存设计上是划分为两个大的区域的<B>启动时向操作系统分配的程序内存区域</B>、<B>直接对系统内存进行操作的区域</B>,后者不属于JVM管理,我们主要是分析前者</p><h2 id="大体结构"><a class="header-anchor" href="#大体结构"></a>大体结构</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/jvm%E6%80%BB%E8%A7%88.png?raw=true" alt="JVM架构图"></p><ol><li>程序计数器<ol><li><p>程序计数器是用来记录当前线程所执行的字节码的行号指示器,字节码解释器在工作时就是通过改变这个计数器的值来记录当前执行的指令.</p><p>它是JVM层次的指令执行记录与硬件层次的指令地址寄存器(IR)的区别在于程序计数器只是一段内存区域,通过软件实现的记录虚拟机字节码的执行地址,当执行Native方法时,该区域值为空</p></li><li><p>为什么要有程序计数器?</p><ol><li>在于jvm提交给CPU执行的指令不是一次性全部提交过去的,而是根据java的业务逻辑通过jvm编译在提交给CPU相应的指令,所以需要对IR进行抽象</li></ol></li></ol></li><li>Java虚拟机栈<ol><li>虚拟机栈描述的是Java方法执行时候的内存模型:线程在执行方法时都会创建相应独立的栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息;</li><li>虚拟机栈是由一个个栈帧组成的</li><li>局部变量表用于存储编译器可知的各种基本数据类型的值引用、对象引用、returnAddres类型(指向一个指令的类型,指的是方法返回的指令地址)</li></ol></li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E7%BA%BF%E7%A8%8B%E5%B8%A7%E6%A0%88.png?raw=true" alt="栈帧"></p><ol><li><p>本地方法栈</p><p>本地方法栈是用于表示对本地方法(native)执行的’c stack’</p></li><li><p>java堆</p><p>java堆是java进程管理的最大的一块内存区域,这个区域允许所有线程访问,作用是在这个区域分配对象实例空间;堆所分配的内存空间不需要是连续的(物理/逻辑上都是一样),在HotSpot中堆空间在默认情况下是申请的连续分配</p></li><li><p>方法区</p><p>方法区用于虚拟机加载类信息、常量池、静态变量、即时编译器编译后的代码数据等</p></li><li><p>常量池</p><p>常量池用于存放在编译期产生的各种字符串、符号引用以及允许运行期动态添加</p></li><li><p>直接内存</p></li></ol><p>直接内存指的是通过Native方法直接分配的堆外内存部分</p><h2 id="堆上内存分配过程"><a class="header-anchor" href="#堆上内存分配过程"></a>堆上内存分配过程</h2><p>堆上内存分配过程约等于对象的堆内存分配过程,堆上内存分配需要并发分配的问题,目前有两种处理方案:</p><ol><li>通过CAS机制加上失败重试来保证操作的原子性</li><li>通过本地线程分配缓冲(TLAB)的方式来保证,核心思想就是通过预先划分线程独占的内存空间来<strong>尽量避免从堆上直接分配内存从而避免频繁的锁竞争</strong></li></ol><h2 id="对象的内存布局"><a class="header-anchor" href="#对象的内存布局"></a>对象的内存布局</h2><p>对象的内存布局可以划分为三个区域:对象头(Header)、实例数据、对齐填充部分</p><ol><li><p>header</p><ol><li>Mark Word:通过标识来复用同一地址空间,列如对象哈希码/锁指针/偏向锁信息等</li><li>类型指针:用于标识对象的类元数据,其中数组类型要表示元素的类型以及元素的个数</li></ol></li><li><p>实例数据</p><ol><li>实例数据部分是用于存储业务数据的部分,在分配内存时会尽量遵守相同类型(宽度)的数据分配到一起</li></ol></li><li><p>对齐部分</p><ol><li>对齐部分不一定存在,由于jvm虚拟机分配内存是8个字节的整数倍,header部分设计是就遵守此规范,但是实例数据部分不一定能恰好遵循,因此需要进行数据填充来符合此规范</li></ol><h2 id="对象的访问定位"><a class="header-anchor" href="#对象的访问定位"></a>对象的访问定位</h2><p>在栈帧中通过<strong>reference</strong>来表示对象的指针,然后通过refernce查找对象的方式可以分为两种实现方案:</p><ol><li>直接通过指针来返回</li><li>通过句柄的方式来返回</li></ol><p>HotSpot是通过第二种方式来进行访问的,优点是**快,**缺点是在GC时需要修改栈帧中的reference数据</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.png?raw=true" alt="对象地址"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;内存布局设计&lt;/h1&gt;
&lt;p&gt;JVM的内存设计上是划分为两个大的区域的&lt;B&gt;启动时向操作系统分配的程序内存区域&lt;/B&gt;、&lt;B&gt;直接对系统内存进行操作的区域&lt;/B&gt;,后者不属于JVM管理,我们主要是分析前者&lt;/p&gt;
&lt;h2 id=&quot;大体结构&quot;&gt;&lt;a class=&quot;heade</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>多线程是否会影响执行效率</title>
    <link href="https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/"/>
    <id>https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/</id>
    <published>2022-11-15T14:50:30.000Z</published>
    <updated>2022-11-18T12:51:34.947Z</updated>
    
    <content type="html"><![CDATA[<h1>多线程是否会影响执行效率</h1><h2 id="前提"><a class="header-anchor" href="#前提"></a>前提</h2><p>今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的</p><blockquote><p>在同一机器/操作系统上,使用n个线程处理X个任务是不是和使用n*m个线程处理X个任务效率相同?</p></blockquote><p>这样的观点是基于<B>RR-时间片轮转</B>来进行推导的;我不太认同这种观点,直觉上认为参与处理的任务过多或过少都会影响执行效率;下面先进行这两种观点的推导然后在进行实际的验证</p><h2 id="时间片轮转"><a class="header-anchor" href="#时间片轮转"></a>时间片轮转</h2><p>假设前提:</p><ol><li>操作系统对进程的调度是采用的<B>时间片轮转</B>算法来进行处理的,时间片划分的大小为1s;</li><li>每个Task需要消耗单核CPU执行0.5s</li><li>不考虑线程上下文切换耗时</li></ol><p>根据以上的前提可以得出下面这个运行图例:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%201%20%E9%A1%B5.drawio.png?raw=true" alt="2Thread执行示例"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%202%20%E9%A1%B5.drawio.png?raw=true" alt="4Thread执行示例"></p><p>从上图中可以看到无论是2Thread来进行执行还是4Thread来进行执行对于任务的执行耗时其实都是没有任何影响的,因为这其实是1000个Task与2个执行core之间的关系;</p><p>这种说法正确的前提必须是满足<B>假设前提</B>中的3点</p><h2 id="线程过多过少都会影响执行效率"><a class="header-anchor" href="#线程过多过少都会影响执行效率"></a>线程过多过少都会影响执行效率</h2><p>这种观点主要是基于《Java并发编程实战》一书中的观点:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F.jpg?raw=true" alt="推算线程池大小"></p><p>N<sub>cpu</sub> ：指的是执行机器上的物理核心数,额外注意使用容器启动的核心数<br>U<sub>cpu</sub> ：指的期望的对CPU的使用率<br>W/C ：指的是等待时间与计算时间的比例,对于计算密集型与IO密集型这个值还有所区别</p><p>例子:</p><p>N<sub>Thread</sub> = 2 * 0.8 * (1 + 10/2) = 8</p><p>如果需要N<sub>Thread</sub>持续增长时需要<B>W/C</B>比例更大,这是不可能实现的,由于w/c是由于Task决定的;<br>以上是通过反证法的方式来解释提高N<sub>Thread</sub> 并不能增加并发执行效率的原因;</p><p>实际在运用过程中还需要注意<B>Amdahl定律</B>和线程引入造成的性能开销</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/amdahl%E5%AE%9A%E5%BE%8B.jpg?raw=true" alt="Amdahl定律"></p><p>Amdahl定律就是表达并发执行线程池数并不能提高效率,而是并发度提高才能提高执行效率</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%BC%95%E5%85%A5%E7%9A%84%E5%BC%80%E9%94%80.jpg?raw=true" alt="线程引入造成的性能开销"></p><p>频繁的线程切换会引起性能损耗</p><h2 id="实例分析"><a class="header-anchor" href="#实例分析"></a>实例分析</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecutorServiceUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> taskNum <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">LinkedBlockingQueue</span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span>taskNum <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">8192</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]正在执行... %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> st <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">extracted</span><span class="token punctuation">(</span>latch<span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> et <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]执行耗时[%s]ms %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> et <span class="token operator">-</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>            QUEUE<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">extracted</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> taskNum<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>latch<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> taskId<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>        <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">,</span> <span class="token keyword">int</span> taskId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> latch<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>taskId <span class="token operator">=</span> taskId<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> min<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">isPrime2</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPrime2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> sqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqrt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/jvmsource/blob/master/src/main/java/com/agmtopy/source/executer/ExecutorServiceUtil.java">ExecutorServiceUtil.java</a></p><p>这是一个循环求解0~10W之间的素数的程序,下面是分别在Windows/Linux上执行的结果</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux.jpg?raw=true" alt="Linux下的执行结果"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows.jpg?raw=true" alt="Windows下的执行结果"></p><p>操作系统的线程调度策略还是会影响性能的.Linux的线程调度要稍微比Windows的优秀一点点,下面使用<B>vmstat</B>和<B>pidstat</B>分析</p><ul><li>vmstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vmstat</span> -w <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vmstat.jpg?raw=true" alt="vmstat执行结果"></p><ul><li>pidstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pidstat -p /PID -wtu  <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pidstat.jpg?raw=true" alt="pidstat执行结果"></p><p>主要关心<B>cswch/s</B>和<B>nvcswch/s</B>、<B>in</B>和<B>cs</B>指标，表示的是<B>线程上下文切换</B>的一个频率,在线程不断的增加以后可以看到这几个指标在快速的向上增长<br>不管是从windows还是linux的一个执行结果来看，线程的增加都会导致程序的下降,但是这种下降并不是很明显，也许是得益于现代操作系统对线程切换的不断优化吧</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>一个线程池中核心线程数与最大线程数的数量是会受到多个方面因素共同影响的，例如<B>操作系统</B>、<B>物理核心逻辑线程</B> 以及任务类型(计算密集型/IO密集型)都有关系,因此在使用线程池时对于线程池的<B>6个</B>参数一定要有思考以后在进行创建相应的线程池;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/13834692/threads-configuration-based-on-no-of-cpu-cores/13958877#13958877">Threads configuration based on no. of CPU-cores</a><br><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a><br><a href="https://research.cs.wisc.edu/multifacet/amdahl/">Amdahl’s Law in the Multicore Era</a><br><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html">Linux vmstat命令实战详解</a><br><a href="https://timzhouyes.github.io/2020/04/29/Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/">Java常见的性能问题和排查</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;多线程是否会影响执行效率&lt;/h1&gt;
&lt;h2 id=&quot;前提&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;
&lt;p&gt;今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在同一机</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="多线程" scheme="https://agmtopy.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(三)</title>
    <link href="https://agmtopy.gitee.io/2022/11/14/20.%E7%AC%94%E8%AE%B0/22.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%89)/"/>
    <id>https://agmtopy.gitee.io/2022/11/14/20.%E7%AC%94%E8%AE%B0/22.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%89)/</id>
    <published>2022-11-14T15:50:10.000Z</published>
    <updated>2022-11-14T16:17:50.611Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(三)</h1><h2 id="Redis数据结构"><a class="header-anchor" href="#Redis数据结构"></a>Redis数据结构</h2><p>Redis的数据结构可以划分为下图所示:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.drawio.png?raw=true" alt="Redis的数据结构"></p><p>可以看到Redis底层采用的也是Map的方式来保存key以及value;</p><p>Redis主要的数据类型分为<B>String</B>、<B>list</B>、<B>set</B>、<B>map</B>、<B>sorted-set</B>等</p><p>下面会依次介绍这几种类型对象的底层实现原理</p><h2 id="String类型"><a class="header-anchor" href="#String类型"></a>String类型</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(三)&lt;/h1&gt;
&lt;h2 id=&quot;Redis数据结构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Redis数据结构&quot;&gt;&lt;/a&gt;Redis数据结构&lt;/h2&gt;
&lt;p&gt;Redis的数据结构可以划分为下图所示:&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TiDB数据库之简介</title>
    <link href="https://agmtopy.gitee.io/2022/11/05/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/41.TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <id>https://agmtopy.gitee.io/2022/11/05/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/41.TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%AE%80%E4%BB%8B/</id>
    <published>2022-11-05T07:30:55.000Z</published>
    <updated>2022-11-06T15:36:16.589Z</updated>
    
    <content type="html"><![CDATA[<h1>TiDB数据库之简介</h1><blockquote><p>TiDB 是 PingCAP 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processing, HTAP) 的融合型分布式数据库产品，具备水平扩容或者缩容、金融级高可用、实时 HTAP、云原生的分布式数据库、兼容 MySQL 5.7 协议和 MySQL 生态等重要特性。目标是为用户提供一站式 OLTP (Online Transactional Processing)、OLAP (Online Analytical Processing)、HTAP 解决方案。</p></blockquote><p>简单的说就是一款分布式数据库.</p><h2 id="五大特性"><a class="header-anchor" href="#五大特性"></a>五大特性</h2><ol><li><p>支持水平扩容或缩容<br>这一点在传统的RDBMS上不容易实现,传统的RDBMS通常是数据存储和计算没有进行分离的;</p></li><li><p>金融级高可用<br>采用<B> Multi-Raft 协议</B>来进行保证的</p></li><li><p>实时 HTAP<br>同时支持OLAP和OLTP处理</p></li><li><p>云原生的分布式数据库</p></li><li><p>兼容MySQL 5.7协议<br>支持MySQL协议这是一大优点</p></li></ol><h2 id="四大核心应用场景"><a class="header-anchor" href="#四大核心应用场景"></a>四大核心应用场景</h2><ol><li>对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高的金融行业属性的场景</li></ol><p>也就是适合需要高性能/高可用/高扩展性的场景</p><ol start="2"><li>对存储容量、可扩展性、并发要求较高的海量数据及高并发的 OLTP 场景</li></ol><blockquote><p>随着业务的高速发展，数据呈现爆炸性的增长，传统的单机数据库无法满足因数据爆炸性的增长对数据库的容量要求，可行方案是采用分库分表的中间件产品或者 NewSQL 数据库替代、采用高端的存储设备等，其中性价比最大的是 NewSQL 数据库，例如：TiDB。TiDB 采用计算、存储分离的架构，可对计算、存储分别进行扩容和缩容，计算最大支持 512 节点，每个节点最大支持 1000 并发，集群容量最大支持 PB 级别。</p></blockquote><ol start="3"><li><p>HTAP场景<br>一套数据库支持全部场景</p></li><li><p>OLAP场景<br>TiDB在实现上比ETL + Hadddoop简单和高效低本,并且可以直接用SQL实现分析统计功能</p></li></ol><h2 id="快速上手"><a class="header-anchor" href="#快速上手"></a>快速上手</h2><p>本次快速上手实验的环境主要是: WSL2+Ubunta</p><ol><li>下载安装脚本</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span class="token comment"># 下载完成后会展示安装脚本路径  'Shell profile:'后面的就是 $&#123;your_shell_profile&#125; 替换量</span><span class="token builtin class-name">source</span> <span class="token variable">$&#123;your_shell_profile&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_1.jpg?raw=true" alt="下载安装脚本"></p><ol start="2"><li>启动集群</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 默认TiDB、TiKV、PD 和 TiFlash 实例各一个</span>tiup playground<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_%E5%90%AF%E5%8A%A8.jpg?raw=true" alt="启动"></p><ol start="3"><li>TiDB的相关操作</li></ol><ul><li>连接TiDB</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用TiDB clinet</span>tiup client<span class="token comment"># 使用MySQL 协议</span>mysql --host <span class="token number">127.0</span>.0.1 --port <span class="token number">4000</span> -u root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_tidb%E5%8D%8F%E8%AE%AE%E7%99%BB%E9%99%86.jpg?raw=true" alt="TiDB clinet"></p><p>在使用MySQL客户端连接的时候,因为TiDB默认没有为root用户分配密码的,可以通过TiDB clint 登陆后使用<B>set password for root=‘123456’;</B>来修改密码</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_4_%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81.jpg?raw=true" alt="修改root 密码"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_5_%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.jpg?raw=true" alt="MySQL 协议连接成功"></p><ul><li>退出/清理</li></ul><ol><li><p>按下 Control+C 键停掉上述启用的 TiDB 服务。</p></li><li><p>等待服务退出操作完成后，执行以下命令：</p></li></ol><blockquote><p>tiup clean --all</p></blockquote><ul><li>管控平台/性能分析后台</li></ul><ol><li>dashboard</li></ol><p>可以看到TiDB的后台管理页面比较现代,支持各种功能包括<B>集群信息</B>、<B>慢SQL分析</B>、<B>日志查询</B>、<B>性能诊断</B>等</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_6_dashboard.jpg?raw=true" alt="dashboard"></p><h2 id="HTAP功能对比"><a class="header-anchor" href="#HTAP功能对比"></a>HTAP功能对比</h2><p>HTAOP功能就是在线分析功能,在传统的数据库使用过程中通常会伴随着这样的使用场景,下面用<B>TiFlash</B>和MySQL之间来对比</p><h3 id="准备数据"><a class="header-anchor" href="#准备数据"></a>准备数据</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用以下命令安装数据生成工具</span>tiup <span class="token function">install</span> bench<span class="token comment"># 使用以下命令生成数据</span>tiup bench tpch --sf<span class="token operator">=</span><span class="token number">1</span> prepare<span class="token operator">!</span><span class="token punctuation">[</span>准备数据<span class="token punctuation">]</span><span class="token punctuation">(</span>https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_1.jpg?raw<span class="token operator">=</span>true<span class="token punctuation">)</span><span class="token comment"># 运行以下 SQL 语句查看生成的数据量</span>SELECT CONCAT<span class="token punctuation">(</span>table_schema,<span class="token string">'.'</span>,table_name<span class="token punctuation">)</span> AS <span class="token string">'Table Name'</span>, table_rows AS <span class="token string">'Number of Rows'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">(</span>data_length/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS <span class="token string">'Data Size'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">(</span>index_length/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS <span class="token string">'Index Size'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">((</span>data_length+index_length<span class="token punctuation">)</span>/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS<span class="token string">'Total'</span>FROM information_schema.TABLES WHERE table_schema LIKE <span class="token string">'test'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_2_%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B1%95%E7%A4%BA.jpg?raw=true" alt="数据行数"></p><h3 id="执行SQL"><a class="header-anchor" href="#执行SQL"></a>执行SQL</h3><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT    l_orderkey,    SUM(        l_extendedprice * (1 - l_discount)    ) AS revenue,    o_orderdate,    o_shippriorityFROM    customer,    orders,    lineitemWHERE    c_mktsegment &#x3D; &#39;BUILDING&#39;AND c_custkey &#x3D; o_custkeyAND l_orderkey &#x3D; o_orderkeyAND o_orderdate &lt; DATE &#39;1996-01-01&#39;AND l_shipdate &gt; DATE &#39;1996-02-01&#39;GROUP BY    l_orderkey,    o_orderdate,    o_shippriorityORDER BY    revenue DESC,    o_orderdatelimit 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="同步列存数据"><a class="header-anchor" href="#同步列存数据"></a>同步列存数据</h3><p>TiFlash 部署完成后并不会自动同步 TiKV 数据，你可以在 MySQL 客户端向 TiDB 发送以下 DDL 命令指定需要同步到 TiFlash 的表。指定后，TiDB 将创建对应的 TiFlash 副本。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE test.customer SET TIFLASH REPLICA 1;ALTER TABLE test.orders SET TIFLASH REPLICA 1;ALTER TABLE test.lineitem SET TIFLASH REPLICA 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="分析对比性能差异"><a class="header-anchor" href="#分析对比性能差异"></a>分析对比性能差异</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_%E4%B8%8D%E4%BD%BF%E7%94%A8TiFlash.jpg?raw=true" alt="传统关系数据引擎"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_%E4%BD%BF%E7%94%A8TiFlash.jpg?raw=true" alt="TiFlash引擎"></p><p>可以看到TiFlash执行的耗时非常的少</p><h2 id="SQL-基本操作"><a class="header-anchor" href="#SQL-基本操作"></a>SQL 基本操作</h2><h2 id="SQL-基本操作-v2"><a class="header-anchor" href="#SQL-基本操作-v2"></a>SQL 基本操作</h2><p>TODO</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.pingcap.com/zh/tidb/dev/quick-start-with-tidb#%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4">TiDB官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;TiDB数据库之简介&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;TiDB 是 PingCAP 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processin</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="TiDB" scheme="https://agmtopy.gitee.io/tags/TiDB/"/>
    
  </entry>
  
  <entry>
    <title>git workflow的几种最佳实践方式</title>
    <link href="https://agmtopy.gitee.io/2022/10/29/1.%E6%9D%82%E8%AE%B0/git-workflow%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%B9%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2022/10/29/1.%E6%9D%82%E8%AE%B0/git-workflow%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%B9%E5%BC%8F/</id>
    <published>2022-10-29T02:54:10.000Z</published>
    <updated>2022-10-30T17:34:20.744Z</updated>
    
    <content type="html"><![CDATA[<h1>git workflow的几种最佳实践方式</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>现有的版本控制系统大多选择使用Git来进行管理/协作;不同的团队有会根据各自的情况选择不同的协助方式,常见的<B>git workflow</B>主要分为三种:</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow<br>常见的分支模式也可以大致划分为两种:</li><li>主干分支模式</li><li>特性分支模式</li></ul><p>下面就先介绍特性分支模式下的三种 Git WorkFlow特点与优劣;</p><h2 id="Git-flow"><a class="header-anchor" href="#Git-flow"></a>Git flow</h2><blockquote><p><B>Git flow</B>最早是由Vincent Driessen在2010年左右提出来的<B><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">《一个成功的 Git 分支模型》</a></B>一文中介绍他自己的分支管理模式;主要核心思想就是会存在两类分支:</p></blockquote><ul><li><p>长期分支:</p><ul><li><B>master</B></li><li><B>develop</B></li></ul></li><li><p>临时分支:</p><ul><li><B>hotfixs branch</B></li><li><B>release branch</B></li><li><B>feature branch</B></li></ul></li></ul><p>长期分支是一直存在的,临时分支只是会存在与一个迭代或一次hotfix的过程中,他们之间的关系如下所示:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/git_flow.png?raw=true" alt="git flow "></p><p>也可以看下面这个简化的git flow流程<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/git-flow%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png?raw=true" alt="git flow "></p><p>可以从上面两个图中看到开发者其实是站着<B>develop branch</B>一侧的,feature branch分支通常存在于本地,开发完成后执行<B>merge request(MR)</B>合并到<B>develop branch</B>(通常使用的是git merge --no–ff feature-branch的方式);同时发布分支(release branch)是从develop branch上切出来的,测试通过后mr到master中;</p><p>git flow中进行code review的判定点:</p><ul><li>尝试从私有分支合并代码到公有分支(develop, release/<em>, hotfix/</em>, master)中时</li></ul><p>例如从feature branch -&gt; develop branch,hotfixs branch -&gt; master/develop时是需要进行code review;<br>从develop -&gt; master时是不需要进行code review的;</p><h3 id="优点"><a class="header-anchor" href="#优点"></a>优点</h3><ul><li><p>严谨的合并流程<br>所有进入公共分支的代码都需要进行审核,确保代码问题;这样的合并流程适用于已有的成熟项目开发流程,可以尽量在前置协作过程中发现避免问题;</p></li><li><p>适用于开源项目(曾经)<br>各个贡献者都是在各自的repository(存储库)中工作,需要提出PR经过审核后才能提交代码到主库中</p></li></ul><h3 id="缺点"><a class="header-anchor" href="#缺点"></a>缺点</h3><ul><li><p>繁琐<br>在开发过程中,会持续维护两个长期分支<B>develop</B>和<B>master</B>,并且这两个分支的实际含义还有所重合(develop-拥有不稳定的全部代码的分支/master-拥有全部稳定代码的分支);</p></li><li><p>持续交付困难<br>所有的功能开发必须是在一个周期或多个周期内完成,造成master中的代码不是最新的,因此很难进行CD;也有基于git flow开进行CD的方案,但是有点舍本求末的感觉在里面了,CI/CD应该是在’每个人每天都致力于master上工作’的前提</p></li></ul><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>git flow的开发模式过于繁琐来保证较高的代码质量,需要去维护多个长期分支;繁琐也是相对于下面两种模式而言的;git flow的作者目前也是建议大家基于团队/项目来选择和更简单的GitHub flow;</p><h2 id="GitHub-flow"><a class="header-anchor" href="#GitHub-flow"></a>GitHub flow</h2><p>GitHub flow最早是由GitHub的技术经理scott chacon提出来的<a href="http://scottchacon.com/2011/08/31/github-flow.html">GitHub Flow</a>,是基于Github内部使用Git工作的一种流程;</p><blockquote><p>GitHub flow主要有以下几个特征:<br>- master branch中的代码是在任何时候都是可以进行部署的<br>- 功能分支名称需要用描述功能特性来进行命名的<br>- 即时将本地代码push/pull到服务器上<br>- 使用PR来进行协作(反馈/帮助/合并)<br>- 完成master合并后立即部署</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/github%20flow.jpg?raw=true" alt="github flow"></p><p>这是一个简易的GitHub flow的流程,可以看到所有去请求在进行审核之后都会被合并到Master分支中;<br>在实践中GitHub flow是一个一直向前的流程,对于master分支几乎不会进行回滚操作(通过新的提交抵消错误需要进行回滚的合并)</p><h3 id="优点-v2"><a class="header-anchor" href="#优点-v2"></a>优点</h3><ul><li><p>分支模型简单<br>这个分支模型简单是相对于Git flow来说的,只用维护一个长期分支<B>master</B>,利于后续的CI/CD</p></li><li><p>PR<br>这个是GitHub flow的一个创新,PR不止是合并代码而是一种协作方式,可以进行评论/审查/帮助,这个是跨地域进行大规模协作的基础,改变了以前通过邮件的方式;</p></li><li><p>可以最大限度减少未发布代码的数量<br>master branch 在合并代码后就会进入持续交付阶段,这样会最大限度的降低未发布代码的数量</p></li></ul><h3 id="缺点-v2"><a class="header-anchor" href="#缺点-v2"></a>缺点</h3><ul><li><p>无法应对版本的延迟发布<br>在实际开发工作中,持续交付不一定能实现,毕竟大多数技术开发还是以业务为导向的;</p></li><li><p>无法处理多版本交付<br>开发环境/测试环境/预发环境甚至生产多版本部署的场景</p></li></ul><h3 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h3><p>GitHub flow在简化Git flow的基础上支持开源软件的开发模式,但是自身也有一些问题.</p><h2 id="GitLab-flow"><a class="header-anchor" href="#GitLab-flow"></a>GitLab flow</h2><p>GitLab flow是由极狐公司提出在<B><a href="https://docs.gitlab.cn/jh/topics/gitlab_flow.html">GitLab Flow介绍</a></B>一文实践的分支管理方式;</p><p>GitLab flow的设计遵寻两个原则:</p><ul><li>单一主分支</li></ul><blockquote><p>单一主分支原则与GitHub Flow所保留的Master分支一致</p></blockquote><ul><li>上游优先</li></ul><blockquote><p>上游优先原则指的是只存在一个主分支master,它是所有其他分支的<B>上游</B>.只有上游分支采纳的代码变化,才能应用到其他分支。对于<B>持续发布</B>的项目，它建议在master分支以外，再建立不同的环境分支。比如,<B>开发环境</B>的分支是master,<B>预发环境</B>的分支是pre-* ,<B>生产环境</B>的分支是pro-*;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%201.png?raw=true" alt="上游优先流程"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%202.png?raw=true" alt="生产分支的切出"></p><p>从上述的流程中可以看到GitLab flow在分支上选择是多分支的管理方式,但是是一种基于<B>上游优先</B>策略下的多分支管理方式,并不是像Git flow那样同时维护多个长期分支,对于后续的发布分支流程,GitLab采用的也是从Master branch中切分支或者打tag的方式:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%203.jpg?raw=true" alt="GitLab 发布分支"></p><p>在GitLab的实践中,通常<B>Master branch</B>都是受保护的,这样大部分开发者不能对其进行直接修改;<br>其中在他们的实践中也认可践行(PR/MR)的协助方式,分支的命名也是采用的功能命名的方式,合并后立即删除,以便其他人重新开始这个功能的议题;issues是工作的开始,MR是工作的结束;</p><h3 id="优点-v3"><a class="header-anchor" href="#优点-v3"></a>优点</h3><ul><li><p>支持多版本部署<br>支持pre-* /pro-*的多分支部署方式</p></li><li><p>可以支持延迟发布<br>开发分支和发布分支可以并行</p></li></ul><h2 id="小结-v3"><a class="header-anchor" href="#小结-v3"></a>小结</h2><p>由于GitLab flow出现的时间比git flow/gitlab flow都要晚一些,因此吸收了这两种风格的特点(支持多分支/PR模式);<br>大多数开发模式都是让代码审查通过后直接进入Master branch,因为这样可以尽早的解决冲突;</p><p>以上三种代码分支的管理方式都是基于<B>功能开发</B>(先有需求驱动的开发模式),并不是GitLab flow就一定比Git flow要更好,只有更适合的,下面介绍三种简单的区分方式仅供参考:</p><ul><li>工作中会使用到多个版本 -&gt; Git flow</li></ul><blockquote><p>如果代码库在工作中有多个版本(即典型的软件产品,如操作系统、Office 软件包、自定义应用程序等);可以使用git-flow,主要原因是在开发下一个版本的同时,需要在生产中持续支持以前的版本,并且有一个较长的迭代周期;</p></blockquote><ul><li>工作中只会使用到一个版本 -&gt; GitHub flow</li></ul><blockquote><p>如果代码库始终只有一个生产版本（即网站、Web 服务等），可以使用 github flow。主要原因是您不需要为开发人员复杂的事情。一旦开发人员完成一项功能或完成错误修复，它就会立即升级为生产版本。</p></blockquote><ul><li>生产中的单一版本但非常复杂的软件 -&gt; Gitlab-flow</li></ul><blockquote><p>在商业大型软件或者是以提供服务的项目上，在生产中可能需要在您的分支和主分支之间来回部署,并且在不同版本都需要进行CI/CD。推荐就使用Gitlab-flow</p></blockquote><h2 id="基于主干的开发模式"><a class="header-anchor" href="#基于主干的开发模式"></a>基于主干的开发模式</h2><p>在基于主干的开发模式中,所有开发人员都在一个开放的分支上进行工作。一般是使用master分支.他们直接向Master提交代码并运行;开发人员会创建短暂的功能分支。一旦他们分支上的代码编译并通过所有测试，他们就会直接将其合并到master. 确保开发是真正连续的，并防止开发人员创建难以解决的合并冲突;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/%E5%9F%BA%E4%BA%8E%E4%B8%BB%E5%B9%B2%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png?raw=true" alt="基于主干开发流程"></p><p>可以看到<B>基于主干的开发流程</B>非常的简单,任何人都可以直接向Master branch 合并代码,能够做到快速交付/迭代;缺点是没有人来进行功能性code review,只能进行完整的源代码检查(这是一种灾难😰);</p><p>基于主干的开发模式适用于:<B>项目开始的早期</B>、<B>拥有的都是老手</B>(😖)或者是<B>基础架构强/持续集成工具集成度高/TDD和自动化测试覆盖完善场景</B>下;</p><p>其实还有其他的开发模式例如<B>集中式</B>、<B>Forking</B>等工作流程,有兴趣的可以了解一下;</p><h2 id="使用Git的几个约定"><a class="header-anchor" href="#使用Git的几个约定"></a>使用Git的几个约定</h2><p>在使用Git过程中,其实每个团队的风格不同,都有一些比较好的值得借鉴的地方,以下可能是我自己的一个使用习惯</p><ol><li><p><B>使用rebase -i整理需要提交的commit</B><br>每次大功能向master/develop等公开分支提交时,会首先将同一需求的多个commit压缩合并成为一个有具体含义的commit后在发起PR;这样做的原因是基于我认为提交的MR应该是一个完整的功能/补丁/操作的log,可以让之后进行阅读的人知道这一行代码是为那个需求/修复而写的,而不应该是一个需求中的一个小点添加的;第二点是便于回滚/Cherry-pick,一个commit的操作要比多个commit的操作更简单;</p></li><li><p><B>基于最新的共享分支进行MR</B><br>这一点是基于Code review来说的,基于过时的分支合并到共享分支中是会夹杂大量代码差异,不利于code review的进行;对于rebase的使用,坚持一个原则<B>私有分支操作使用rebase,共享分支操作使用merge</B></p></li><li><p><B>使用stash</B><br>暂存区配合分支切换可以较好的完成,工作区的分支切换/代码存储合并的动作</p></li></ol><h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2><ul><li><p>Code Review如何让每一个人参与其中?</p></li><li><p>CI耗时过程问题以及是否需要进行CI?</p></li></ul><blockquote><p>需要,非常需要;gradle cache;</p></blockquote><ul><li>代码文件冲突/合并的问题?</li></ul><blockquote><p>产生的原因是与长期分支脱节、需求划分的不合理、没有及时的协作解决冲突等等</p></blockquote><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.gitlab.cn/jh/topics/gitlab_flow.html">GitLab Flow 介绍</a><br><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a><br><a href="https://nvie.com/posts/a-successful-git-branching-model/">一个成功的Git分支模式</a><br><a href="http://dockone.io/article/2350">gitLab Flow的11条建议</a><br><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">atlassian Bitbucket</a><br><a href="https://about.gitlab.com/topics/version-control/what-is-git-workflow/">what-is-git-workflow</a><br><a href="https://www.toptal.com/software/trunk-based-development-git-flow">trunk based developmentgit flow</a><br><a href="https://medium.com/burdaforward/state-of-ci-cd-and-the-dreaded-git-flow-fce92d04fb07">State of CI/CD and the omnipresent git flow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;git workflow的几种最佳实践方式&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;现有的版本控制系统大多选择使用Git来进行管理/协作;不同的团队有会根据各自的情况选择不同的</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://agmtopy.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库系统原理</title>
    <link href="https://agmtopy.gitee.io/2022/09/27/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/31.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>https://agmtopy.gitee.io/2022/09/27/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/31.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2022-09-27T15:11:06.000Z</published>
    <updated>2022-11-05T07:31:16.606Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式数据库系统原理</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><blockquote><p>为什么需要分布式?</p></blockquote><ul><li><B>处理逻辑</B></li><li><B>功能</B></li><li><B>数据</B></li><li><B>控制</B></li></ul><p>对于这个的理解应该是:</p><ul><li>处理逻辑:对应应用实例或者算法之类的,单点无法满足某些需求(AP)</li><li>功能:对于功能的分布式划分主要是体现在微服务的拆分上,不同的功能拆分成为不同的服务</li><li>数据:对于数据的拆分主要是单点数据服务无法满足要求的情况下,进行拆库拆表</li><li>控制:<font color="#dddd00">这个暂时不能理解?控制是否为程序或者算法的同义楠?</font></li></ul><blockquote><p>什么是分布式数据库?<br>物理上分布不同地方,通过计算机网络逻辑上相互关联的数据库</p></blockquote><h3 id="主要的问题"><a class="header-anchor" href="#主要的问题"></a>主要的问题</h3><ul><li>数据如何选择分片?</li><li>分布式事务的实现?</li><li>性能问题?</li></ul><p>如下图:</p><p><img src="https://raw.githubusercontent.com/agmtopy/noteBook/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.jpg" alt="分布式数据问题之间的联系"></p><h3 id="集中式数据库模型与分布式数据库模型"><a class="header-anchor" href="#集中式数据库模型与分布式数据库模型"></a>集中式数据库模型与分布式数据库模型</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E9%9B%86%E4%B8%AD%E5%BC%8FDBMS%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.jpg?raw=true" alt="集中式DBMS分层架构"></p><p>可以看到集中式数据库就是一个标准的应用分层,以MySql为例</p><p>界面: 提供不同语音的MySql Drive<br>控制: 连接校验<br>编译: sql解析<br>执行: innodb存储引擎处理<br>数据访问:MySql内核处理<br>一致性: 各种Lock和log</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpg?raw=true" alt="分布式数据库结构"></p><p>可以看到分布式数据库系统需要从三个不同的方面进行考虑:<B>物理分布</B>&lt;B&gt;异构性</B>&lt;B&gt;自治性</B></p><ul><li>物理分布:指的是组成分布式系统的服务可以在物理上隔离,可以不需要在通一台硬件机器上运行</li><li>异构性:指的是各个服务允许使用各自的协议来提供服务,这一点在工业级的分布式数据库上应该没有实现,还是遵守相同协议来降低软件复杂度</li><li>自洽性:各个服务本身就可以单独对外提供服务,不用依赖其他系统,这一点常用的分布式系统较为不同</li></ul><h3 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h3><ul><li>DBMS</li></ul><blockquote><p>DBMS-关系数据库的概念是一组结构化的数据,它是出于我们对现实世界建模的映射,一个关系数据库是以表格形式表达数据的数据库.</p></blockquote><h2 id="分布式数据库设计"><a class="header-anchor" href="#分布式数据库设计"></a>分布式数据库设计</h2><p>有两种分布式数据库的设计方法:<B>自顶向下的方法</B>和<B>自底向上的方法</B>,这也是软件领域设计的两种通用设计方法,例如我们在设计系统的时候基于底层功能实现还是上层战略定位来进行的往往会得到不同的演进路线;</p><ul><li>自顶向下:指的是在设计的时候就考虑不同的实例去支持局部的全局概念模型</li><li>自底向上:指的是将多个数据库中的信息集成为一个紧密相连的多数据库系统,常用于<B>数据仓库/数据湖</B></li></ul><h3 id="分布设计的研究问题"><a class="header-anchor" href="#分布设计的研究问题"></a>分布设计的研究问题</h3><ul><li>如何得到正确的分片结果?<br>首先,数据分片有两种维度来进行,一种是垂直分片按照业务领域进行划分,一种是水平进行分片按照特定规则来进行划分;我们会重点研究采用水平模式的设计方案.</li></ul><p>专业的分布式数据库的数据划分好复杂,会去考虑数据的分片是按照某些条件来进行的,既要保证数据的分片又要保证数据的’亲和性’;一大段一大段的高阶函数~😳😳😳</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式数据库系统原理&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要分布式?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;B&gt;处理逻辑</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-内存管理篇</title>
    <link href="https://agmtopy.gitee.io/2022/09/24/20.%E7%AC%94%E8%AE%B0/12.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/09/24/20.%E7%AC%94%E8%AE%B0/12.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/</id>
    <published>2022-09-24T09:09:44.000Z</published>
    <updated>2022-09-25T14:22:14.661Z</updated>
    
    <content type="html"><![CDATA[<h1>现代操作系统原理与实现-内存管理篇</h1><p>一晃而过距离上一篇<B>硬件结构</B>已经过去了一个月有余了.最近一直在整理<B>Notion</B>上的笔记,把《深入理解Java虚拟机》的相关笔记也在notion上写和整理去了,对《现代操作系统原理与实现》的笔记也耽搁了许久;这本书应该是本年度最佳书籍了,会争取在今年把第一遍阅读的相关笔记完成,时间过的真的很快,跑题感慨了一下,下面继续有关内存部分的整理和理解吧!</p><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>在上一章中了解到物理内存是组成操作系统的重要部分,这一章节就是介绍操作系统是如何管理和使用内存的;</p><h3 id="内存管理"><a class="header-anchor" href="#内存管理"></a>内存管理</h3><p>内存管理主要是对物理内存的管理,在早期程序是直接分配在物理内存上运行的,那个时候操作系统都不存在,这样分配会产生几个问题例如程序直接操作物理内存无法做到隔离/分配内存空间的碎片化/无法处理超过物理容量限制的分配</p><p>针对这个些问题,提出了<B>虚拟内存</B>的概念,大概是在1956年的一位德国物理学家提出的,感觉这个时间过了好久了啊,但是在翻阅资料查这些的时候发现计算机的发明居然还没有80年,太不可思议了</p><p><img src="http://www.isolves.com/d/file/p/2020/03-17/bbd1470ef6879e2f6e4847b7444fde35.jpg" alt="虚拟内存技术发展时间线"></p><h4 id="虚拟内存"><a class="header-anchor" href="#虚拟内存"></a>虚拟内存</h4><blockquote><p>虚拟内存作为物理内存和应用程序之间的一个抽象层;应用程序不在直接运行在物理内存之上,而是运行在虚拟内存之上;应用程序在运行时只知道虚拟内存地址,cpu或者硬件负责将虚拟地址转换为物理地址,操作系统负责设置虚拟地址与物理地址之间的映射;每个应用程序只能看到属于自己的虚拟内存地址,并且看到的虚拟内存地址是同一的、连续的;</p></blockquote><ul><li>虚拟内存的结构<br>下面是一张有关CPU如何将虚拟地址转换为物理地址的图:</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/x-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/CPU%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio.png?raw=true" alt="CPU虚拟地址翻译示意图"></p><p>可以看到操作系统向CPU发生虚拟地址访问请求后,传给MMU在通过TLB转换后,将物理地址发送给操作总线,从而访问到物理内存地址;</p><p>现代操作系统都是通过分页的形式采用页表来实现的,<B>TLB</B>缓存了虚拟页号到物理页号之间的映射关系,TLB的设计非常简单就是做映射,但是却十分的高效,因为在内存数据的访问遵守<B>时空局部性原理</B></p><ul><li>虚拟内存中的换页</li></ul><p>在前面说到物理内存无法自动处理分配超过实际容量限制的场景.而虚拟内存可以做到,就是通过换页机制来实现的,具体流程如下:</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/143273007">操作系统之内存管理</a><br><a href="https://ewikizh.top/wiki/Virtual_memory#cite_note-10">虚拟内存</a><br><a href="https://www.isolves.com/it/rj/jy/2020-03-17/14226.html">虚拟内存技术的前世今生</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;现代操作系统原理与实现-内存管理篇&lt;/h1&gt;
&lt;p&gt;一晃而过距离上一篇&lt;B&gt;硬件结构&lt;/B&gt;已经过去了一个月有余了.最近一直在整理&lt;B&gt;Notion&lt;/B&gt;上的笔记,把《深入理解Java虚拟机》的相关笔记也在notion上写和整理去了,对《现代操作系统原理与实现》的笔记也</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-硬件结构篇</title>
    <link href="https://agmtopy.gitee.io/2022/08/14/20.%E7%AC%94%E8%AE%B0/11.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/08/14/20.%E7%AC%94%E8%AE%B0/11.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2022-08-14T06:39:04.000Z</published>
    <updated>2022-09-24T09:10:19.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>操作系统是建立在硬件结构基础上的软件实现,这一章节我们来介绍计算机的硬件结构.</p><h2 id="CPU与指令集架构"><a class="header-anchor" href="#CPU与指令集架构"></a>CPU与指令集架构</h2><blockquote><p>指令集架构是cpu与软件之间的桥梁,包括指令集\特权级\寄存器\执行模式\安全扩展\性能加速等等</p></blockquote><h3 id="指令集"><a class="header-anchor" href="#指令集"></a>指令集</h3><p>指令集包括<B>精简指令集(RISC)</B>和<B>复杂指令集(CISC)</B>两种.</p><ul><li><p>精简指令集<br>指的是没有寄存器的指令集,通过指令来模拟寄存器的操作,常见的安卓和苹果的A系/M系芯片都是使用的这种指令集</p></li><li><p>复杂指令集<br>指的是有寄存器的指令集,通过使用寄存器来执行指令,常见的Intel的X86芯片都是使用的这种指令集</p></li></ul><p>目前在生产中并没有严格隔离指令集,CISC也在集成RISC的相关指令</p><p>常用的指令类型分为4种:</p><ul><li>数据搬移指令(mov等)</li><li>寄存器计算指令(add/sub等)</li><li>内存读写指令(ldr-加载/str-读写等)</li><li>调整指令(b)</li><li>过程调用指令(bl/ret)</li><li>特权指令(mrs/msr)</li></ul><h2 id="特权级"><a class="header-anchor" href="#特权级"></a>特权级</h2><p>指的是指令运行的级别,分别是El0,El1,El2,El3</p><ul><li><p>El0<br>指的是最低特权级,应用程序通常运行在这一级别上,也可以称为<B>用户态</B></p></li><li><p>EL1<br>操作系统通常运行在这一级别上,也称为<B>内核态</B></p></li><li><p>El2<br>指的是次高特权级,操作系统通常运行在这一级别上,也称为<B>高级内核态</B>,通常虚拟机监控器需要运行在这一状态</p></li><li><p>El3<br>负责普通世界与安全世界的切换,安全世界是<B>AArch64</B>提出来的一个管理硬件交互的级别,EL3在级别上是最高的,因为可以直接操作硬件</p></li></ul><blockquote><p>EL0 &lt; EL1 &lt; EL3 &lt; EL3</p></blockquote><p>程序在运行过程中大量的发生EL0 &lt;=&gt; EL1转换,其实就是用户进程与内核进程在不断的进行切换的过程;这里需要注意一点的是<B>中断</B>是运行在EL1级别上的</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2.jpg?raw=true" alt="中断切换"></p><h2 id="寄存器"><a class="header-anchor" href="#寄存器"></a>寄存器</h2><p>寄存器是指令集中的一种数据结构,用于存储数据,比如寄存器中存储的是指令的地址,寄存器中存储的是指令的参数等等.它们是cpu的基本架构组成部分,参与指令的执行和计算过程.现代CPU往往会使用大量专用的寄存器来做专业的事情,比如帧指针寄存器,连接寄存器等</p><h2 id="物理内存与CPU缓存"><a class="header-anchor" href="#物理内存与CPU缓存"></a>物理内存与CPU缓存</h2><ul><li>物理缓存</li></ul><blockquote><p>CPU在执行的过程中,可以通过访存指令不断的向物理内存中读写数据;CPU使用物理内存的方式很简单:通过<B>总线</B>向物理内存发生一个读写请求,其中包括目标地址,物理内存在接收到请求后,会根据请求的类型进行读写操作,并返回相应的结果</p></blockquote><p>通过以上的描述可以得知CPU在进行执行时都是通过总线与内存进行交互\cpu从内存中取值后会放到私有的区域(CPU缓存)中,其实这样的设计也加大了应用人员开发出健壮/正确的并发代码难度,在编写并发相关代码时一定要仔细</p><ul><li>CPU缓存</li></ul><blockquote><p>CPU缓存是一个私有的区域,用于存储CPU执行过程中的数据;由若干个<B>缓存行</B>组成.每个缓存行包含:一个<B>有序位标识</B>标识数据是否有效和一个<B>标记地址</B>用于标记其对应的物理地址;</p></blockquote><blockquote><p>CPU以缓存行(常见的是64bit大小)为单位把物理内存读取到缓存中,也就是说如果只需要一个bit的数据,但是还是需要把该字节对应的缓存行数据全部读取到缓存中,写入反之亦然也是每次需要写出64bit大小的数据</p></blockquote><p>对于CPU缓存行最熟悉的一个作用是<B>禁止指令重排</B>,在java中我们知道valitate的一个作用是可见性,就是根据基于缓存行的<B>缓存一致性协议-MESI协议</B>来实现的</p><p>volatile的另外一个作用是可以解决编译器层面的可见性与重排序问题。而内存屏障则解决了硬件层面的可见性与重排序问题</p><h2 id="设备与中端"><a class="header-anchor" href="#设备与中端"></a>设备与中端</h2><p>常见的设备指的是输入与输出设备,常见的内存映射输入输出设备,常见的中断设备,比如硬盘,光驱,键盘,鼠标等</p><p><B>中断</B>机制是提供设备主动通知CPU的能力.设备通过向CPU发送中断来打断CPU的执行.</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>本章主要介绍<B>精简指令集</B>&lt;B&gt;特权级</B>&lt;B&gt;寄存器</B>&lt;B&gt;内存与缓存</B>等硬件基本结构<br>多核CPU缓存的设计遵守<B>缓存一致性协议</B>这个是valotail可见性的基础</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/MrLiuZF/p/15054855.html">CPU缓存</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;操作系统是建立在硬件结构基础上的软件实现,这一章节我们来介绍计算机的硬件结构.&lt;/p&gt;
&lt;h2 id=&quot;CPU与指令集架构&quot;&gt;&lt;a class=&quot;head</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(一)</title>
    <link href="https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%80)/</id>
    <published>2022-08-08T15:45:00.000Z</published>
    <updated>2022-11-14T15:51:04.370Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(一)</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>是《深入分布式缓存-从原理到实践》一书的一些记录</p><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><blockquote><p>cache这个词,据说来自于法语,本意是当CPU处理数据时先到cache中去寻找,如果数据在之前的操作与i就读取而被暂存其中,就不需要从主内存中去读取了.后来cache的范围有所扩展,泛指凡是位于速度相差比较大的两种硬件之间,用于协调两者数据传输差异的结构,都称为cache.</p></blockquote><p>凡是通过两种查询速度较大的方式来查询同一对象都称为cache</p><blockquote><p>缓存:存储在计算机上的一个原始数据复制集,以便用于访问   -wiki</p></blockquote><p>常见的一些缓存:</p><ul><li>CPU多级缓存</li><li>TLB(Translation lookaside buffer) -最新的虚拟内存-&gt;物理内存的转换</li></ul><p>缓存分类:</p><ul><li>按缓存位置划分<ul><li>客户端缓存</li><li>服务器端缓存</li><li>网络中的缓存</li></ul></li><li>按部署方式划分<ul><li>单体缓存</li><li>集群缓存</li><li>分布式缓存</li></ul></li></ul><h3 id="网络中的缓存"><a class="header-anchor" href="#网络中的缓存"></a>网络中的缓存</h3><ul><li>web代理缓存</li></ul><p>使用正向代理的方式将web服务器上的数据进行缓存,客户端请求后之间返回不需要重新先web服务器请求</p><ul><li>边缘缓存</li></ul><p>边缘缓存是通过反向代理的方式与用户处于同一网络,向用户提供静态内容的缓存,典型应用就是CDN缓存</p><h3 id="缓存算法"><a class="header-anchor" href="#缓存算法"></a>缓存算法</h3><p>LRU:最近最少使用算法<br>LFU:最少使用算法(会统计一段时间内每个缓存的访问次数)<br>SIZE:缓存大小算法(按照缓存的大小进行算法)</p><h2 id="分布式系统理论"><a class="header-anchor" href="#分布式系统理论"></a>分布式系统理论</h2><ul><li>并向与并发</li></ul><blockquote><p>并发指的是两个事情或多个事情在同一个时间段内间隔发生;并行指的是两个事情或多个事情在同一个时刻同时发生;</p></blockquote><ul><li>CAP</li></ul><blockquote><p>CAP理论提出一致性\可用性\分区容错性的取舍问题</p></blockquote><p>一致性©:指的是在同一时刻访问所有节点得到的数据相同<br>可用性(U):指的是在同一时刻访问所有节点得到的数据都可用<br>分区容错性§:指的是节点一定会发生故障,但是不会影响整个系统的正常运行</p><h3 id="分布式系统设计策略"><a class="header-anchor" href="#分布式系统设计策略"></a>分布式系统设计策略</h3><p>分布式系统设计策略指的是对于设计分布式系统常见的几个问题的处理策略:</p><ul><li>如何检测你还活着?</li><li>如何保障高可用?</li><li>容错机制的设计?</li><li>重试机制?</li><li>负载均衡?</li></ul><p>下面详细对每一个问题进行解答:</p><h4 id="如何检测你还活着"><a class="header-anchor" href="#如何检测你还活着"></a>如何检测你还活着?</h4><p>在分布式系统中如何检测当前节点是否存活?<br>在大多数分布式中间件中都是通过<B>心跳检测</B>的机制来检测当前节点是否存活的,例如在zk的client与server之间的心跳检测保持连接\redis哨兵架构中的哨兵与master/slave之间的心跳检测</p><p><B>φ-accrual 故障检测器</B>是通过滑动窗口的时间算法来统计结果</p><p><B>Gossip分发</B>(流言算法)通过消息的传递确定节点是否应该停止服务的算法</p><p>小结:<br>存活检测有两个方法:一个是从通信链路入手检测目标节点的网络是否异常\一种是通过检测当前状态是否符合预期状态来检测目标节点是否存活</p><h4 id="如何保障高可用"><a class="header-anchor" href="#如何保障高可用"></a>如何保障高可用?</h4><p>在分布式系统中保障高可用的核心就是数据备份,通过多个节点的备份来在任何节点故障的情况下提供服务<br>按照提供服务的节点时机可以分为<B>主备(Master/Slave)</B>&lt;B&gt;互备(Failover)</B>&lt;B&gt;集群(Cluster)</B>这三种方式</p><ul><li><p>主备(Master/Slave)模式<br>主备模式多用于要求严格提供C(一致性)\A(可用性)的场景中,MySQL的主备模式\Redis的哨兵模式</p></li><li><p>互备(Failover)模式<br>互备模式指的是各个节点提供的数据和服务是相同的,常见的RocketMQ的注册中心NameServer就是多个节点提供相同的服务</p></li><li><p>集群(Cluster)模式<br>集群模式指的是服务在多个节点运行,不同的节点运行不同的任务,比如Redis的集群模式;集群模式与主备模式/互备模式的区别在于集群模式是仅对服务进行高可用的设计,另外两种设计既有对服务和数据的双重含义</p></li></ul><h4 id="容错机制的设计"><a class="header-anchor" href="#容错机制的设计"></a>容错机制的设计</h4><p>容错机制指的是在系统设计中需要对一些异常场景的兼容,例如在Raft的一些实现中就会对CommitId进行CRC32的容错机制校验</p><h4 id="重试机制"><a class="header-anchor" href="#重试机制"></a>重试机制</h4><p>重试机制指的是系统调用失败后,由于无法确定是否网络异常,或者是否是系统调用的问题,可以重试一定次数,如果重试次数超过限制,则抛出异常;这种设计是基于网络异常和系统异常的区别的基础上来进行设计的,在一般认为中网络异常是频繁且持续的,因此可以重试机制下,重试一定次数<br>重试机制又会引出接口幂等的场景,因此在分布式系统设计中,接口一定要提供幂等</p><h4 id="负载均衡"><a class="header-anchor" href="#负载均衡"></a>负载均衡</h4><p>负载均衡类似于集群模式通过一个总的调度器来对任务进行分配,常用的负载均衡方案Nginx,LB</p><h3 id="分布式系统的几个通用问题"><a class="header-anchor" href="#分布式系统的几个通用问题"></a>分布式系统的几个通用问题</h3><ul><li>全局id的生成</li><li>hash取模分配</li><li>路由表</li><li>一致性hash算法</li><li>数据拆分</li><li>分布式锁的解决方案</li><li>分布式事务的解决方案</li></ul><h4 id="全局Id的生成方案"><a class="header-anchor" href="#全局Id的生成方案"></a>全局Id的生成方案</h4><p>分布式Id的产生是基于数据服务大都采用集群的模式提供服务,在这种模式下不同的节点如果产生的id不进行相互协调的话会造成id的冲突,因此需要一个全局的id生成方案来保证id的唯一性</p><p>有两种实现思路:</p><ul><li>基于节点执行不同规则的id生成</li><li>基于全局协调器的id生成</li></ul><p>下面分别来介绍一下这两种不同的方案</p><ul><li>基于节点执行不同规则的id生成</li></ul><p>是通过值得数据节点的id生成规则来实现的,例如对id设置初始值和步长,然后每个节点都会计算出自己的id,这样就可以保证id的唯一性</p><ul><li><p>基于全局协调器的id生成<br>基于全局协调器的id生成方案实现比较多,例如通过一张id表的方式来进行实现\通过分布式id生成器的号段模式来实现\通过分布式id生成器的雪花算法来实现</p></li><li><p>snowflake的id生成方案</p></li></ul><p>64bit = 41bit(时间戳) + 10bit(节点id) + 12bit(自增id)<br>时间戳精确到毫秒<br>12位自增id每个节点最多产生4096个id</p><h4 id="hash取模-路由表-一致性hash算法"><a class="header-anchor" href="#hash取模-路由表-一致性hash算法"></a>hash取模\路由表\一致性hash算法</h4><p>hash取模\路由表\一致性hash算法都是为了解决数据或服务的一个寻址过程,例如对于一个数据库来说,如果数据库有多个节点,那么对于某个数据来说,可以通过hash取模的方式来寻址到对应的节点,这样就可以保证数据的一致性</p><p>hash取模是指的是对数据进行hash取模,然后根据模的值来寻址到对应的节点,这样就可以保证数据的分片性</p><p>路由表是通过预设的路由表来寻址到对应的节点,这样就也可以保证数据的分片性;路由表还有一个优点是对于有序增加的场景下可以通过递增预设的路由表数据来寻址到对应的节点,还不影响之前的数据,但是这样有一个路由表单点问题,需要做好数据的备份和failover</p><h4 id="数据拆分"><a class="header-anchor" href="#数据拆分"></a>数据拆分</h4><p>数据的拆分主要指的是将数据分片到不同的节点上,这样就可以保证数据的一致性;前面已经介绍数据拆分的原理;<br>常用的数据拆分方案是mycat/shardingsphere等</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>这一章节主要给我们介绍<B>分布式系统设计策略</B>&lt;B&gt;分布式系统的几个通用问题</B>的解决方案</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(一)&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;是《深入分布式缓存-从原理到实践》一书的一些记录&lt;/p&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a clas</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
