<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2025-07-18T17:17:17.074Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CompletableFuture常用方法总结</title>
    <link href="https://agmtopy.gitee.io/2025/07/18/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/17.CompletableFuture%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://agmtopy.gitee.io/2025/07/18/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/17.CompletableFuture%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-17T16:06:48.000Z</published>
    <updated>2025-07-18T17:17:17.074Z</updated>
    
    <content type="html"><![CDATA[<h1>CompletableFuture常用方法总结</h1><p>下文对CompletableFuture类中的常用方法进行了总结,以备不时之需;</p><h2 id="创建方法"><a class="header-anchor" href="#创建方法"></a>创建方法</h2><h3 id="示例"><a class="header-anchor" href="#示例"></a>示例</h3><ol><li>supplyAsync()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token label symbol">@supplyAsync</span> FutureTask<span class="token punctuation">.</span><span class="token function">printlnWithString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>runAsync()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">    <span class="token keyword">fun</span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> future <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">runAsync</span> <span class="token punctuation">&#123;</span><span class="token comment">//            return@runAsync printlnWithString()</span>            FutureTask<span class="token punctuation">.</span><span class="token function">printlnWithVoid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//返回结果为null</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>completedFuture()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 返回设定值,不会启用线程池去提交任务 */</span><span class="token keyword">fun</span> <span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token label symbol">@completedFuture</span> FutureTask<span class="token punctuation">.</span><span class="token function">printlnWithString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//返回结果为null</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点"><a class="header-anchor" href="#特点"></a>特点:</h3><table><thead><tr><th>方法名</th><th>描述</th><th>是否返回结果</th><th>返回异常</th><th>同组方法</th></tr></thead><tbody><tr><td>supplyAsync</td><td>supplyAsync提交任务</td><td>返回结果</td><td>抛出ExecutionException</td><td>supplyAsync(Runnable runnable, Executor executor)</td></tr><tr><td>runAsync</td><td>runAsync提交任务</td><td>无返回结果</td><td>抛出ExecutionException</td><td>runAsync(Runnable runnable, Executor executor)</td></tr><tr><td>completedFuture</td><td>设置默认返回值</td><td>返回结果</td><td>不会抛出异常</td><td>无</td></tr></tbody></table><h3 id="指定线程执行"><a class="header-anchor" href="#指定线程执行"></a>指定线程执行</h3><p><B>supplyAsync</B><br><B>runAsync</B></p><h2 id="链式调用"><a class="header-anchor" href="#链式调用"></a>链式调用</h2><h3 id="示例-v2"><a class="header-anchor" href="#示例-v2"></a>示例</h3><ol><li>thenApply()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenApply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">//将fn的结果传递到consumer_future函数中</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">thenApply</span> <span class="token punctuation">&#123;</span> fn_result <span class="token operator">-></span> FutureTask<span class="token punctuation">.</span><span class="token function">consumer_future</span><span class="token punctuation">(</span>fn_result<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>thenAccept()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenAccept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">thenAccept</span> <span class="token punctuation">&#123;</span> fn_result <span class="token operator">-></span> FutureTask<span class="token punctuation">.</span><span class="token function">consumer_future</span><span class="token punctuation">(</span>fn_result<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>thenRun()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">thenRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn_result:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>thenCompose()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenCompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">thenCompose</span> <span class="token punctuation">&#123;</span> fn_result <span class="token operator">-></span> FutureTask<span class="token punctuation">.</span><span class="token function">consumer_future</span><span class="token punctuation">(</span>fn_result<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>exceptionally()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">exceptionally</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">exceptionally</span> <span class="token punctuation">&#123;</span> ex <span class="token operator">-></span>        <span class="token keyword">var</span> threadName <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,异常堆栈为:"</span></span> <span class="token operator">+</span> ex<span class="token punctuation">.</span>message<span class="token punctuation">)</span>        <span class="token string-literal singleline"><span class="token string">"返回错误信息"</span></span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>whenComplete()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">    <span class="token keyword">fun</span> <span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//        val fn = FutureTask.create_future_exception()</span>        <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">whenComplete</span> <span class="token punctuation">&#123;</span> fn_result<span class="token punctuation">,</span> ex <span class="token operator">-></span>            <span class="token keyword">var</span> threadName <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,fn执行成功,返回结果为:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn_result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,fn执行失败,异常堆栈为:"</span></span> <span class="token operator">+</span> ex<span class="token punctuation">.</span>message<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>handle()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//        val fn = FutureTask.create_future_exception()</span>        <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">handle</span> <span class="token punctuation">&#123;</span> fn_result<span class="token punctuation">,</span> ex <span class="token operator">-></span>            <span class="token keyword">var</span> threadName <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,fn执行成功,返回结果为:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn_result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,fn执行失败,异常堆栈为:"</span></span> <span class="token operator">+</span> ex<span class="token punctuation">.</span>message<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span><span class="token label symbol">@handle</span> <span class="token string-literal singleline"><span class="token string">"handle执行完成"</span></span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点-v2"><a class="header-anchor" href="#特点-v2"></a>特点:</h3><table><thead><tr><th>方法名</th><th>描述</th><th>是否返回结果</th><th>返回异常</th><th>同组方法</th></tr></thead><tbody><tr><td>thenApply</td><td>fn2处理fn1的处理结果,适用于结果转换</td><td>返回结果</td><td>抛出ExecutionException</td><td>thenApplyAsync(Function action, Executor executor)</td></tr><tr><td>thenAccept</td><td>fn2处理fn1的处理结果</td><td>无返回结果</td><td>抛出ExecutionException</td><td>thenAcceptAsync(Function action, Executor executor)</td></tr><tr><td>thenRun</td><td>fn执行完成后执行Runnable,不关心fn的返回值</td><td>抛出ExecutionException</td><td>thenRunAsync(Runnable action,Executor executor)</td><td></td></tr><tr><td>thenCompose</td><td>fn执whenComplete</td><td>返回fn同类型的返回值</td><td>抛出ExecutionException</td><td>thenComposeAsync(Function action, Executor executor)</td></tr><tr><td>exceptionally</td><td>用于处理fn的异常</td><td>有返回值</td><td>抛出ExecutionException</td><td>thenComposeAsync(Function action, Executor executor)</td></tr><tr><td>whenComplete</td><td>处理fn返回的结果或者执行异常</td><td>有返回值</td><td>抛出ExecutionException</td><td>whenComplete(Function action, Executor executor)</td></tr><tr><td>handle()</td><td>处理fn返回的结果或者执行异常</td><td>无返回值</td><td>抛出ExecutionException</td><td>handleAsync(Function action, Executor executor)</td></tr></tbody></table><p>需要注意的是<B>thenApply</B>和<B>thenCompose</B>的区别:</p><ol><li>thenApply返回的是<B>CompletableFuture</B>对象,thenCompose的返回值与fn原有的返回值</li></ol><h2 id="组合"><a class="header-anchor" href="#组合"></a>组合</h2><h3 id="示例-v3"><a class="header-anchor" href="#示例-v3"></a>示例</h3><ol><li>allOf()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">allOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> allFuture <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>        FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">val</span> result <span class="token operator">=</span> allFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>thenCombine()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenCombine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenCombine</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r1<span class="token punctuation">,</span> r2 <span class="token operator">-></span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"BiFunction threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        <span class="token string-literal singleline"><span class="token string">"fn1的result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r1</span></span><span class="token string">,fn2的result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r2</span></span><span class="token string">,"</span></span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> combineResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">combineResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>thenAcceptBoth()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenAcceptBoth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAcceptBoth</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r1<span class="token punctuation">,</span> r2 <span class="token operator">-></span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"BiFunction threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string-literal singleline"><span class="token string">",fn1的result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r1</span></span><span class="token string">,fn2的result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r2</span></span><span class="token string">,"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>runAfterBoth()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">runAfterBoth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">runAfterBoth</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Runnable threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>applyToEither()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">applyToEither</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">applyToEither</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r1 <span class="token operator">-></span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Runnable threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string-literal singleline"><span class="token string">",fn1或fn2执行结果为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r1</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>        r1    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>acceptEither()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">acceptEither</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acceptEither</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r1 <span class="token operator">-></span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Runnable threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string-literal singleline"><span class="token string">",fn1或fn2执行结果为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r1</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>runAfterEither()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">runAfterEither</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">runAfterEither</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Runnable threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点-v3"><a class="header-anchor" href="#特点-v3"></a>特点:</h3><table><thead><tr><th>方法名</th><th>描述</th><th>是否返回结果</th><th>同组方法</th></tr></thead><tbody><tr><td>allOf</td><td>组合多个Future</td><td>无结果</td><td>anyOf:入参为可变数组或数组</td></tr><tr><td>thenCombine</td><td>将fn1的结果和fn2的结果传递到BiFunction中</td><td>有返回值为BiFunction</td><td>thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn,Executor executor)</td></tr><tr><td>thenAcceptBoth</td><td>fn1的结果和fn2的结果传递到BiFunction中</td><td>无返回值</td><td>thenAcceptBothAsync</td></tr><tr><td>runAfterBoth</td><td>fn1执行完成后执行fn2,然后执行Runnable执行线程默认为fn2的执行线程</td><td>无返回值</td><td>runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action)</td></tr><tr><td>applyToEither</td><td>将fn1的结果和fn2的结果,二者任一一个结果传递到Function中</td><td>有返回值为BiFunction</td><td>applyToEitherAsync(CompletionStage&lt;? extends U&gt; other,Function&lt;? super T, U&gt; fn,Executor executor)</td></tr><tr><td>acceptEither</td><td>fn1或fn2执行完成,执行fn3</td><td>无返回值</td><td>acceptEitherAsync</td></tr><tr><td>runAfterEither</td><td>fn1或fn2执行完成,执行fn3</td><td>无返回值</td><td>runAfterEitherAsync</td></tr></tbody></table><p>需要注意的是<B>thenCombine</B>和<B>applyToEither</B>的区别:</p><ol><li>thenCombine是两个fn都完成后才执行fn3,applyToEither是任一一个fn完成后就执行fn3</li></ol><h2 id="获取结果"><a class="header-anchor" href="#获取结果"></a>获取结果</h2><h3 id="示例-v4"><a class="header-anchor" href="#示例-v4"></a>示例</h3><ol><li>get()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> result0 <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> future_exception <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> result1 <span class="token operator">=</span> future_exception<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>join()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> list <span class="token operator">=</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"1"</span></span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">&#123;</span> item <span class="token operator">-></span>        <span class="token keyword">val</span> result0 <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"result0:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result0</span></span><span class="token string">,item:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">item</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> future1 <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    future1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>getNow()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"defaultValue"</span></span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"create_future_time3s result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">val</span> future1 <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    future1<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"exception"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>isDone()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> done <span class="token operator">=</span> future<span class="token punctuation">.</span>isDone    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"future是否完成:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">done</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点-v4"><a class="header-anchor" href="#特点-v4"></a>特点:</h3><table><thead><tr><th>方法名</th><th>描述</th><th>是否支持lambda调用</th></tr></thead><tbody><tr><td>get</td><td>阻塞的方式获取结果</td><td>不支持lambda方式进行调用</td></tr><tr><td>join</td><td>阻塞的方式获取结果</td><td>支持lambda方式进行调用</td></tr><tr><td>getNow</td><td>立即尝试获取结果,如果future未完成就返回默认值,非阻塞的方式</td><td>不支持lambda方式进行调用</td></tr><tr><td>isDone</td><td>判断是否执行完成</td><td>支持lambda方式进行调用</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CompletableFuture常用方法总结&lt;/h1&gt;
&lt;p&gt;下文对CompletableFuture类中的常用方法进行了总结,以备不时之需;&lt;/p&gt;
&lt;h2 id=&quot;创建方法&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#创建方法&quot;&gt;&lt;/a&gt;创建方</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="CompletableFuture" scheme="https://agmtopy.gitee.io/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar发送消息分析</title>
    <link href="https://agmtopy.gitee.io/2025/07/08/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/51.Pulsar%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2025/07/08/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/51.Pulsar%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%86%E6%9E%90/</id>
    <published>2025-07-08T13:45:54.000Z</published>
    <updated>2025-07-17T16:05:47.590Z</updated>
    
    <content type="html"><![CDATA[<h1>Pulsar发送消息分析</h1><p>Pulsar提供的多种发送消息的模式,分别是:send(msg)-同步消息,sendAsync(msg)-异步消息;</p><h2 id="简单示例"><a class="header-anchor" href="#简单示例"></a>简单示例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SampleProducer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PulsarClient</span> client <span class="token operator">=</span> <span class="token class-name">PulsarClient</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serviceUrl</span><span class="token punctuation">(</span><span class="token string">"pulsar://localhost:6650"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Producer</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> producer <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">newProducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token string">"persistent://my-tenant/my-ns/my-topic"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token class-name">String</span> msg <span class="token operator">=</span>  <span class="token string">"my-message: "</span><span class="token operator">+</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">ISO_LOCAL_DATE_TIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">sendAsync</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="源码分析"><a class="header-anchor" href="#源码分析"></a>源码分析</h2><h3 id="send"><a class="header-anchor" href="#send"></a>send()</h3><p>Producer是生产者的顶级接口,这个接口中定义了三类方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 发送消息API</span>    <span class="token class-name">MessageId</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">T</span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span><span class="token punctuation">;</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageId</span><span class="token punctuation">></span></span> <span class="token function">sendAsync</span><span class="token punctuation">(</span><span class="token class-name">T</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取信息</span>    <span class="token class-name">String</span> <span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">getProducerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ProducerStats</span> <span class="token function">getStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 管理生产者</span>    <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><B>MessageBuilder</B>是重要的抽象,先mark一下,后面会讲到;</li></ul><p><B>producer</B>的实现类是ProducerImpl.java</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/P-pulsar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ProducerImpl.png?raw=true" alt="ProducerImpl继承关系"></p><p>从图中可以看到,ProducerImpl.java继承于<B>ProducerBase</B>,其中send()方法是使用ProducerBase中的实现;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">MessageId</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">T</span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">newMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中ewMessage().value(message)对应的类是<B>TypedMessageBuilderImpl</B>,其中send()方法如下:</p><ul><li>TypedMessageBuilderImpl.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">MessageId</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// enqueue the message to the buffer</span>        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageId</span><span class="token punctuation">></span></span> sendFuture <span class="token operator">=</span> <span class="token function">sendAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sendFuture<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// the send request wasn't completed yet (e.g. not failing at enqueuing), then attempt to triggerFlush</span>            <span class="token comment">// it out</span>            producer<span class="token punctuation">.</span><span class="token function">triggerFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sendFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token class-name">PulsarClientException</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>send()方法底层是通过sendAsyn()方法将消息暂存到缓冲区,然后通过<B>triggerFlush()</B>发送消息;</p><ul><li>TypedMessageBuilderImpl.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageId</span><span class="token punctuation">></span></span> <span class="token function">sendAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> message <span class="token operator">=</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageId</span><span class="token punctuation">></span></span> sendFuture<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>txn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sendFuture <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">internalSendWithTxnAsync</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>        txn<span class="token punctuation">.</span><span class="token function">registerSendOp</span><span class="token punctuation">(</span>sendFuture<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        sendFuture <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">internalSendAsync</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sendFuture<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中,txn是处理事务消息的分支,internalSendAsync为内部异步发送方法</p><p>ProducerImpl.internalSendAsync() -&gt; ProducerImpl.sendAsync() -&gt; ProducerImpl.serializeAndSendMessage()</p><p>其中在sendAsync()中,设置了单个消息的最大长度为5Mb,其中最重要的方法在<B>synchronized(this)</B>的保护之下;</p><ul><li>ProducerImpl</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">serializeAndSendMessage</span><span class="token punctuation">(</span><span class="token class-name">MessageImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> msg<span class="token punctuation">,</span>                                         <span class="token class-name">ByteBuf</span> payload<span class="token punctuation">,</span>                                         <span class="token keyword">long</span> sequenceId<span class="token punctuation">,</span>                                         <span class="token class-name">String</span> uuid<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> chunkId<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> totalChunks<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> readStartIndex<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> chunkMaxSizeInBytes<span class="token punctuation">,</span>                                         <span class="token class-name">ByteBuf</span> compressedPayload<span class="token punctuation">,</span>                                         <span class="token keyword">boolean</span> compressed<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> compressedPayloadSize<span class="token punctuation">,</span>                                         <span class="token class-name">SendCallback</span> callback<span class="token punctuation">,</span>                                         <span class="token class-name">ChunkedMessageCtx</span> chunkedMessageCtx<span class="token punctuation">,</span>                                         <span class="token class-name">MessageId</span> messageId<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//省略batch数据块的内容....</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//将消息添加到缓存中</span>        <span class="token keyword">boolean</span> isBatchFull <span class="token operator">=</span> batchMessageContainer<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        lastSendFuture <span class="token operator">=</span> callback<span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置netty批量延迟发起访问</span>        <span class="token function">triggerSendIfFullOrScheduleFlush</span><span class="token punctuation">(</span>isBatchFull<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        payload<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    isLastSequenceIdPotentialDuplicated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在完成插入缓存后,紧接着执行的是<B>producer.triggerFlush()</B></p><ul><li>ProducerImpl</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">triggerFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBatchMessagingEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//对ProducerImpl对象进行加锁</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">ProducerImpl</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">batchMessageAndSend</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ProducerImpl</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">batchMessageAndSend</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> shouldScheduleNextBatchFlush<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>batchMessageContainer<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断是否有消息,此处的消息是在batchMessageContainer.add(msg, callback)中暂存的</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            lastBatchSendNanoTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OpSendMsg</span><span class="token punctuation">></span></span> opSendMsgs<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>batchMessageContainer<span class="token punctuation">.</span><span class="token function">isMultiBatches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                opSendMsgs <span class="token operator">=</span> batchMessageContainer<span class="token punctuation">.</span><span class="token function">createOpSendMsgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                opSendMsgs <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>batchMessageContainer<span class="token punctuation">.</span><span class="token function">createOpSendMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            batchMessageContainer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">OpSendMsg</span> opSendMsg <span class="token operator">:</span> opSendMsgs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//正式开始发送消息</span>                <span class="token function">processOpSendMsg</span><span class="token punctuation">(</span>opSendMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ProducerImpl</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//核心方法</span>cnx<span class="token punctuation">.</span><span class="token function">ctx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">WriteInEventLoopCallback</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> cnx<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码的作用是将消息发送操作提交到 Netty 的事件循环线程（EventLoop）中异步执行,详细步骤:</p><ol><li>cnx.ctx().channel().eventLoop()<br>cnx 是一个与 Pulsar Broker 建立的连接对象。<br>ctx() 返回的是 Netty 的上下文（ChannelHandlerContext），用于网络 I/O 操作。<br>channel() 获取底层的 Netty Channel，表示当前的网络连接。<br>eventLoop() 获取该 Channel 绑定的 Netty EventLoop 线程。<br>Netty 使用 EventLoop 来处理所有 I/O 操作，确保对 Channel 的操作是线程安全的。</li><li>execute(…)<br>将一个任务（Runnable）提交给 Netty 的 EventLoop 线程去执行。这样可以保证所有的网络操作都在同一个线程中串行化执行，避免并发问题。</li><li>WriteInEventLoopCallback.create(…)<br>创建了一个实现了 Runnable 接口的任务对象 WriteInEventLoopCallback。该任务封装了消息发送的具体逻辑：<br>调用 cnx.ctx().writeAndFlush(cmd, cnx.ctx().voidPromise()) 发送消息。</li></ol><p>通过调用WriteInEventLoopCallback.run()方法进行发送消息</p><ul><li>WriteInEventLoopCallback</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"[&#123;&#125;] [&#123;&#125;] Sending message cnx &#123;&#125;, sequenceId &#123;&#125;"</span><span class="token punctuation">,</span> producer<span class="token punctuation">.</span>topic<span class="token punctuation">,</span> producer<span class="token punctuation">.</span>producerName<span class="token punctuation">,</span> cnx<span class="token punctuation">,</span>                sequenceId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        cnx<span class="token punctuation">.</span><span class="token function">ctx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> cnx<span class="token punctuation">.</span><span class="token function">ctx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        op<span class="token punctuation">.</span><span class="token function">updateSentTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中cmd是一个<B>ByteBufPair</B>对象,message是存储在对象中的;</p><p>通过Netty的writeAndFlush方法将消息刷新到channel中最后请求到Broker服务;</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><ul><li>时序图</li></ul><h2 id="注意事项"><a class="header-anchor" href="#注意事项"></a>注意事项</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># docker启动Pulsar Standalone模式</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-p</span> <span class="token number">6650</span>:6650 <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">--mount</span> <span class="token assign-left variable">source</span><span class="token operator">=</span>pulsardata,target<span class="token operator">=</span>/pulsar/data <span class="token parameter variable">--mount</span> <span class="token assign-left variable">source</span><span class="token operator">=</span>pulsarconf,target<span class="token operator">=</span>/pulsar/conf apachepulsar/pulsar:4.0.5 bin/pulsar standalone<span class="token comment"># docker容器内创建tenant</span>bin/pulsar-admin tenants create my-tenant<span class="token comment"># docker容器内创建namespace</span>bin/pulsar-admin namespaces create my-tenant/my-ns<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Pulsar发送消息分析&lt;/h1&gt;
&lt;p&gt;Pulsar提供的多种发送消息的模式,分别是:send(msg)-同步消息,sendAsync(msg)-异步消息;&lt;/p&gt;
&lt;h2 id=&quot;简单示例&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简单示例&quot;&gt;</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="pulsar" scheme="https://agmtopy.gitee.io/tags/pulsar/"/>
    
  </entry>
  
  <entry>
    <title>Java的隐藏利器:鲜为人知却极具价值的工具与库</title>
    <link href="https://agmtopy.gitee.io/2025/06/22/1.%E6%9D%82%E8%AE%B0/Java%E7%9A%84%E9%9A%90%E8%97%8F%E5%88%A9%E5%99%A8-%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E5%8D%B4%E6%9E%81%E5%85%B7%E4%BB%B7%E5%80%BC%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%BA%93/"/>
    <id>https://agmtopy.gitee.io/2025/06/22/1.%E6%9D%82%E8%AE%B0/Java%E7%9A%84%E9%9A%90%E8%97%8F%E5%88%A9%E5%99%A8-%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E5%8D%B4%E6%9E%81%E5%85%B7%E4%BB%B7%E5%80%BC%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%BA%93/</id>
    <published>2025-06-22T07:38:30.000Z</published>
    <updated>2025-06-24T21:53:11.816Z</updated>
    
    <content type="html"><![CDATA[<h1>Java的隐藏利器:鲜为人知却极具价值的工具与库</h1><p>源自:<a href="https://www.youtube.com/watch?v=bOEPqLyazAk,%E4%BB%A5%E4%B8%8B%E6%98%AF%E8%A7%86%E9%A2%91%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%89%A9%E5%B1%95,github%E5%9C%B0%E5%9D%80:https://github.com/johanjanssen/JavaHiddenGems">https://www.youtube.com/watch?v=bOEPqLyazAk,以下是视频内容的总结和扩展,github地址:https://github.com/johanjanssen/JavaHiddenGems</a></p><p>分为五个部分:架构、测试、实现、安全、构建</p><h2 id="架构"><a class="header-anchor" href="#架构"></a>架构</h2><h3 id="Arun"><a class="header-anchor" href="#Arun"></a>Arun</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java的隐藏利器:鲜为人知却极具价值的工具与库&lt;/h1&gt;
&lt;p&gt;源自:&lt;a href=&quot;https://www.youtube.com/watch?v=bOEPqLyazAk,%E4%BB%A5%E4%B8%8B%E6%98%AF%E8%A7%86%E9%A2%91%E</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计的实践</title>
    <link href="https://agmtopy.gitee.io/2025/06/10/24.%E6%9E%B6%E6%9E%84/2.1DDD%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2025/06/10/24.%E6%9E%B6%E6%9E%84/2.1DDD%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-06-10T14:36:09.000Z</published>
    <updated>2025-06-22T07:38:07.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>领域驱动设计断断续续看过几本书,但是都没有系统性的学习完成过,因此这篇文章从三个阶段来完成的记录一下,分别是<B>基础概念</B>、<B>核心知识</B>、<B>高级扩展</B>;</p><h2 id="基础概念"><a class="header-anchor" href="#基础概念"></a>基础概念</h2><h3 id="领域驱动设计的开发流程"><a class="header-anchor" href="#领域驱动设计的开发流程"></a>领域驱动设计的开发流程</h3><p><img src="" alt="领域驱动设计的开发流程"></p><p>模型的建立：获取行为需求 -&gt; 领域建模。<br>模型的实现：架构设计 -&gt; 数据库设计 -&gt; 代码实现。<br>DDD 的基本开发过程：获取行为需求 -&gt; 领域建模 -&gt; 架构设计 -&gt; 数据库设计 -&gt; 代码实现</p><h3 id="获取行为需求"><a class="header-anchor" href="#获取行为需求"></a>获取行为需求</h3><p>获取行为需求指的是，我们首先要分析系统具有哪些功能，这些功能由什么人操作，会产生什么效果。这个过程传统上叫做“捕获行为需求”<br>常用的获取行为需求的方式有两种，第一种是用例(use case),第二种是事件风暴</p><p>2.1 事件风暴<br>!()[]<br>事件风暴在实践过程中会遇到来回返工的情况，出现这两种情况一般是两个原因,第一个原因会议偏离主题、第二个原因会议无结论记录,因此在事件风暴这个环节,可以落地的方法是由一个人负责,完成梳理之后进行评审的方式;</p><p>事件风暴过程中需要注意的点:</p><ol><li>对于领域事件的命名，采用完成时+被动语态，例如添加完成订单,在事件风暴中的动作是’订单已添加’、签订好合同,在事件风暴中的动作是’合同已签订’;</li><li>在DDD的命名中,如果有约定俗成的业务术语,优先使用业务术语;</li><li>不要把技术事件当作领域事件,例如事务提交、缓存已命中等;</li><li>查询功能不算领域事件;</li></ol><p>可以使用https://boardmix.cn/来做事件风暴</p><p>2.2 识别命令</p><blockquote><p>命令(command)，就是引发领域事件的操作，我们可以通过分析领域事件得到。除了识别出命令本身以外，我们通常还要识别出谁执行的命令，以及为了执行命令我们要查询出什么数据;</p></blockquote><p>!(命令图列)[]</p><p>2.3. 识别领域名词</p><blockquote><p>领域名词，是从领域事件、命令、执行者、查询数据里找到的名词性概念。例如，对于签订合同这个命令而言，受到影响的名词性概念是“合同”；</p></blockquote><ul><li>注意实现</li></ul><ol><li>在事件风暴里只列出主要的、足以用于表达和交流领域知识的步骤</li><li>事件风暴的粒度原则上宜粗不宜细,有一个大体的轮廓即可</li></ol><p>小结:事件风暴就是先确定要做什么事情(<B>领域事件</B>),然后由于什么动作出发(<B>命令</B>),然后找到动作由谁(<B>执行者</B>)进行触发，最后早到出发这个动作需要查询什么数据(<B>查询数据</B>)的过程:</p><h3 id="领域建模"><a class="header-anchor" href="#领域建模"></a>领域建模</h3><p>目的:</p><ul><li>将业务知识可视化，准确、深刻地反映为领域知识，并且在业务和技术人员之间达成一致；</li><li>指导系统的设计和编码，也就是说，领域模型应该能够比较容易地转化成数据库模式和代码实现;</li></ul><p>!(模型之间的联系)[]</p><p>领域对象表示的是领域事件的作用端，也就是<B>领域名词</B>，例如提交订单这个领域事件对应的领域对象就是订单;</p><p>领域对象由三部分组成:</p><ol><li>领域对象</li><li>领域对象之间的关系</li><li>领域对象的关键属性</li></ol><ul><li>领域对象又可以划分为:实体、值对象<br>实体对应到代码中就是类对象,实体与实体之间的关系就是类图,类有关键属性;</li></ul><p>建立完成领域模型后,需要完善<B>业务规则</B>、<B>建立词汇表</B></p><ul><li>模型驱动设计</li></ul><ol><li>领域模型要和业务需求保持一致</li><li>系统实现要和领域模型保持一致</li></ol><p>领域模型是堆业务进行模拟和提炼,形成浓缩的知识</p><ul><li>统一语言</li></ul><blockquote><p>统一语言包含了两个层面的含义：一是业务和技术人员之间的语言是统一的，二是开发团队内部各角色之间的语言是统一的。最终结果就是每一行代码都能对应到统一语言，从而与业务保持一致</p></blockquote><h3 id="架构设计"><a class="header-anchor" href="#架构设计"></a>架构设计</h3><h4 id="分层架构"><a class="header-anchor" href="#分层架构"></a>分层架构</h4><p>分层架构的核心思想就是将代码分成若干层,每一层负责不同的关注点;将不稳定的部分依赖与稳定的部分,常用的分层架构有六边形架构,外层依赖内层，但是内层不能依赖外层;<br>实践上就是采用分模块和分package的方式进行分层</p><h3 id="数据库设计"><a class="header-anchor" href="#数据库设计"></a>数据库设计</h3><p>在传统的软件开发过程中,对于数据库的设计是采用的’主观理解法’俗称拍脑袋法进行设计的，在了解到需求后,通过思考需求得到数据库模型,在根据数据库模型进行实现,这种方式设计的数据库模型很难精确的反映业务领域模型;<br>采用DDD的方式通过模块到实体,在到数据库模型的方式进行设计的方法，得到的数据库模型更贴近业务领域模型;</p><h3 id="代码实现"><a class="header-anchor" href="#代码实现"></a>代码实现</h3><p>在对象的定义上有两种模式:面向过程的方式和面向对象的方式，面向过程的方式就是常说的贫血模型,面向对象的方式就是充血模型或者说是富领域模式;在实践过程中并不是面向过程模式就要比面向对象模式低级,在实际研发过程中两者的关系如下所示:</p><p><img src="" alt="面向过程与面向对象之间的关系"></p><blockquote><p>面向对象和面向过程之间有一个广阔的&quot;灰色地带&quot;,这里面的变化非常多,难以穷尽,这两个极端都不是我们要追求的,我们需要做的是找到其中的一个平衡点;</p></blockquote><p>原则:</p><ol><li>依赖层问题</li><li>依赖倒置原则</li></ol><h4 id="提供领域对象的封装性"><a class="header-anchor" href="#提供领域对象的封装性"></a>提供领域对象的封装性</h4><ol><li>限制getter和setter的数量</li><li>用有业务含义的接口替代简单的setter和getter</li></ol><h4 id="编程风格"><a class="header-anchor" href="#编程风格"></a>编程风格</h4><ol><li>领域对象不能访问数据库</li><li>领域服务只能读数据库,领域服务需要读数据库。而写库的功能通常可以由应用服务来做，从而减轻领域层的负担</li><li>应用服务可以读写数据库</li><li>用ID表示对象之间的关联</li><li>领域对象有自己的领域服务</li></ol><h4 id="小结"><a class="header-anchor" href="#小结"></a>小结</h4><p>捕获行为需求和事件风暴的关系如下图所示,通过事件风暴的形式捕获到系统的行为需求,从而形成<B>统一语言</B>和<B>模型驱动设计</B></p><p><img src="" alt="事件风暴的关系"></p><p>执行者查询读数据，然后发出命令。命令触发领域事件。<br>可以从命令、领域事件、执行者、读数据中识别出领域名词。</p><p><img src="" alt="模型的建立"></p><p>这张图是领域驱动设计的精华,最核心的是<B>领域模型</B>,领域模型上面衍生出<B>领域对象</B>,下面衍生出<B>业务规则</B>;</p><h2 id="业务规则"><a class="header-anchor" href="#业务规则"></a>业务规则</h2><h3 id="聚合"><a class="header-anchor" href="#聚合"></a>聚合</h3><p>聚合指的是实体与实体之间的一种关系,这种关系有两种特点:第一具有整体和部分的关系,第二具有不变规则,而且这种不变规则的并发的时候可能被破坏;<br>这种关系中心的实体被称为<B>聚合根</B>,聚合根需要有一个全局唯一标识;\</p><p>聚合的作用是为一组具有整体部分关系的对象维护不变规则;</p><blockquote><p>减号(-)表示这是一个私有(private)属性、加号(+)表示公有(public)权限、井号(#)表示保护(protected)权限、波浪号(~)表示包级私有(package private)权限</p></blockquote><p><img src="" alt="领域模型"></p><p><img src="" alt="实现模型"></p><p>实现对象关联的方法分为两种,一种是<B>对象关联</B>、一种是<B>ID关联</B>,使用对象关联切换的成本较高,比较倾向与使用ID进行关联;<br>1<br>对<B>聚合对象</B>进行持久化的时候,是针对整个聚合下的多个对象进行的持久化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Repository</span><span class="token punctuation">.</span>java<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token class-name">Emp</span> emp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 持久化聚合对象</span>    empRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>emp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 插入skill对象</span>    emp<span class="token punctuation">.</span><span class="token function">getSkills</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>skill <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        skill<span class="token punctuation">.</span><span class="token function">setEmpId</span><span class="token punctuation">(</span>emp<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置关联的ID</span>        skillRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>skill<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//插入work对象</span>    emp<span class="token punctuation">.</span><span class="token function">getWorks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>work <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        work<span class="token punctuation">.</span><span class="token function">setEmpId</span><span class="token punctuation">(</span>emp<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置关联的ID</span>        workRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Repository表示的是对整个聚合进行持久化操作,而DAO表示的是对单个对象进行持久化操作,因此在DDD中Repository是对聚合的操作,而DAO是对单个对象的操作;</p><p>对于不变规则的实现,有两个需要注意的点:</p><ol><li>如果规则的验证不需要访问数据库,那么首先应该考虑在领域对象里实现,而不是在领域服务里实现;</li><li>对于聚合根的内部对象,对于它们的验证必须是从整个聚合层面才能进行验证的,无法单独进行验证;</li></ol><p>聚合在达到一定规模之后也要进行拆分,避免一个大的聚合导致的性能问题;</p><h4 id="用事务保证固定规则"><a class="header-anchor" href="#用事务保证固定规则"></a>用事务保证固定规则</h4><p>由于数据库事务无法完成避免并发修改聚合根的问题,会存在数据库事务的粒度与业务需求不匹配、丢失更新的问题,因此需要使用乐观锁的方式来保证聚合根的并发修改问题;</p><p>乐观锁的实现方式:</p><ol><li>在聚合根中添加版本号字段</li><li>在更新聚合根时,使用版本号进行校验</li><li>如果版本号不匹配,则说明有其他事务已经修改了聚合根,需要重新加载聚合根并进行处理</li></ol><p>悲观锁的实现方式:</p><ol><li>在聚合根中添加锁字段</li><li>在更新聚合根时,使用锁字段进行校验</li><li>如果锁字段被其他事务占用,则等待或抛出异常<br>类似于独占锁的方式,悲观锁会导致性能问题,因此在DDD中不推荐使用悲观锁的方式;</li></ol><p>没有关联对象的聚合根,被称为单实体聚合,现在我们面向对象的项目对于PO的定义就是单实体聚合;</p><h3 id="泛化"><a class="header-anchor" href="#泛化"></a>泛化</h3><p>泛化是指在领域模型中,将具有相同属性和行为的对象抽象为一个父类,从而减少代码的重复和复杂度;<br>泛化的实现方式是通过继承的方式,将相同的属性和行为;</p><blockquote><p>直接“借用”系统中已经存在的机制，在短期内虽然达到了目的，但长期来看会导致概念混乱，这种做法是很多开发团队常见的错误。而错误的根源，就在于我们没有掌握一种优雅的方法，来处理不同概念的共性和个性;</p></blockquote><p>可以泛化,不代表必须进行泛化,有三个原则:<br>第一:如果只有特征值不相同,那么用特征值为对象进行分类即可,不必要进行泛化;<br>第二:如果特性种类不同,那么很可能需要进行泛化<br>第三:如果在<B>业务规则</B>、<B>操作接口</B>、<B>操作实现</B>上有共性和个性的化,优先考虑在实现上</p><h3 id="限界上下文"><a class="header-anchor" href="#限界上下文"></a>限界上下文</h3><blockquote><p>限界上下文确实和划分模块、划分子系统一样，是一种分而治之的手段，可以起到分离关注点的作用。但限界上下文增加了一个要点，就是，它的目的还在于维护概念一致性。这里的概念一致性,不在是全局一致性,而是局部一致性;</p></blockquote><p>限界上下文的划分是和组织结构相关的,由于全局一致性已经超过了团队的认知负载了,所有限界上下文不在追求全局一致性;</p><h2 id="如何践行领域驱动设计"><a class="header-anchor" href="#如何践行领域驱动设计"></a>如何践行领域驱动设计</h2><p>实施DDD的项目要满足以下几个关键因素:有价值\有痛点\有意愿\有时间;</p><ul><li><p>有价值，是指站在企业的角度，这个系统对达成企业的战略目标有较大的意义；或者从业务角度，这个系统能够为公司带来比较大的收益。包括 DDD 在内的任何技术改进过程，都需要一定的成本。只有应用到价值较大系统，才能带来足够的回报</p></li><li><p>有痛点，指的是公司管理层或者开发团队确实遇到了难以解决的困难，需求寻求方法学的帮助。如果目前的开发方法挺顺利的，没有感受到明显的问题，只是“为了引入而引入 DDD”，那么往往会动力不足;</p></li><li><p>有意愿，指的是开发团队确实愿意学习新技能。其中，项目经理、开发组长、技术骨干等角色往往起着决定性的作用;</p></li><li><p>有时间，也很重要。引入任何新技术，总会有些成本。包括学习成本、试错成本等等。关键是看产出是否大于成本;</p></li></ul><p>实施DDD的场景有三种实际场景:</p><ol><li>新的项目</li><li>改造现有项目</li><li>改进现有的研发流程</li></ol><h3 id="新的项目"><a class="header-anchor" href="#新的项目"></a>新的项目</h3><blockquote><p>领导希望保证质量，降低风险，觉得需要方法学的支持，因此要引入 DDD</p></blockquote><p>在新的项目中引入DDD要避免的是<B>瀑布型思维</B>,避免在一开始就想要把模型建立的完美;</p><h3 id="改造现有项目"><a class="header-anchor" href="#改造现有项目"></a>改造现有项目</h3><p>改造现有项目主要分为四个步骤:反推领域模型 -&gt; 建立目标领域模型  -&gt; 设计演进路线  -&gt; 迭代实施,在这个过程中,一定不要陷入第一个步骤和第二个步骤中,在这两个步骤中只会有模型产出,没有实际落地的代码,也看不到任何实际的效果,会导致人们失去耐心,最终DDD无疾而终;</p><p>建议的做法是，首先选择系统中一个相对独立的小模块，然后按照前面的 4 步，尽快落地到代码并上线，建立最小闭环。通过这个过程，初步掌握 DDD 落地技能并取得实际效果。<br>同时，这么做也能培养人才，积累经验，建立必要的开发流程。完成之后，再选择下一个切片，逐步扩大范围，并深化 DDD 的技能。</p><h3 id="改进现有的研发流程"><a class="header-anchor" href="#改进现有的研发流程"></a>改进现有的研发流程</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;领域驱动设计断断续续看过几本书,但是都没有系统性的学习完成过,因此这篇文章从三个阶段来完成的记录一下,分别是&lt;B&gt;基础概念&lt;/B&gt;、&lt;B&gt;核心知识&lt;/B&gt;</summary>
      
    
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="领域驱动设计" scheme="https://agmtopy.gitee.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java性能权威指南一Java性能调优工具箱</title>
    <link href="https://agmtopy.gitee.io/2025/05/26/12.JVM/31.java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2025/05/26/12.JVM/31.java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E4%B8%80)/</id>
    <published>2025-05-26T14:47:22.000Z</published>
    <updated>2025-07-08T16:25:18.944Z</updated>
    
    <content type="html"><![CDATA[<h1>java性能权威指南一Java性能调优工具箱</h1><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>说来惭愧这本书是HeapDump社区,大概是23年的礼品吧,也是目前最后一本收到的技术书籍,以下是对这本书的学习笔记;</p><p>说到Java性能优化,有两个绕不开的前置条件:</p><ol><li><p>关于对’不要过早优化’论点的误区<br>在这个一点上,个人理解是不要过早投入精力进行极致优化,例如0.99s的响应时间,投入大量精力优化到0.49s,投入和产出不成正比;<br>'过早优化’这个词语是高德纳最早提出来的,但是完整的原话是&quot;我们不应该把大量的时间耗费在哪些小的性能改进上,过早优化是所有噩梦的根源&quot;,这不是我们编写复杂、混乱、晦涩代码的借口；</p></li><li><p>性能测试的方法<br>性能测试有几个原则:</p></li></ol><ul><li>测试真实应用</li><li>理解批处理流逝时间、吞吐量和响应时间<br>这个指的是Java应用通常都会使用JIT-即时编译技术，因此需要运行一段时间后才能测试出真实的性能水平</li><li>同统计方法论应对性能变化<br>就算是计算机科学这一严谨的学科,在测试过程中也会出现毛刺现象,因此我们评估应用的性能指标一定是要基于统计学来进行分析;</li></ul><p>简单介绍过前置条件后,下面进入主菜<B>Java性能调优工具箱</B>一节;</p><h2 id="性能调优工具"><a class="header-anchor" href="#性能调优工具"></a>性能调优工具</h2><h3 id="操作系统的工具和分析"><a class="header-anchor" href="#操作系统的工具和分析"></a>操作系统的工具和分析</h3><ul><li>CPU使用率<br>性能调优的目的是<B>提高单位时间内CPU的使用率<B><br>常用的命令是有:</li></ul><ol><li>vmstat [选项] [延迟时间] [次数]</li></ol><ul><li>磁盘使用率<br>目前来说磁盘读写相比CPU还是太慢太慢了,I/O阻塞是导致大部分程序性能无法提高的原因;<br>常用的命令有:</li></ul><ol><li>isstat -xm 5<br>输出CPU使用情况、磁盘I/O统计信息，关键指标:<B>%util-磁盘使用率</B>、<B>w_await-磁盘写入时间(毫秒)</B>、<B>%iowait-等待I/O的时间占比</B>、<B>wMB/s-磁盘每秒写入大小</B></li></ol><ul><li>网络使用率<br>网络使用率类似磁盘使用率，常用的命令有:</li></ul><ol><li>netstat:netstat -a 显示所有活动的网络连接、netstat -l 显示所有正在监听的端口,新版本的Linux中使用命令<B>ss</B>进行替代;</li><li>nicstat 5:<B>%Util - 网络端口使用率</B>、<B>rKB/s 读取速度 </B>、<B>wKB/s  写入速度</B></li></ol><h3 id="JAVA监控工具"><a class="header-anchor" href="#JAVA监控工具"></a>JAVA监控工具</h3><h4 id="JDK自带工具"><a class="header-anchor" href="#JDK自带工具"></a>JDK自带工具</h4><ul><li><p>jcmd<br>用于打印VM的信息,</p></li><li><p>jconsole<br>最早的JVM图形化性能监控工具</p></li><li><p>jhat<br>读取memory dump文件</p></li><li><p>jinfo<br>查看JVM的系统属性</p></li><li><p>jstack<br>转储Java进程的堆栈信息</p></li><li><p>jstat<br>提供GC和类装载活动的信息</p></li><li><p>jvisualvm<br>监控和分析JVM性能的工具</p></li></ul><p>重点的命令有:</p><ol><li><p>内存转储 (Heap Dump)<br>jmap -dump:format=b,file=heapdump.hprof <pid><br>jcmd <pid> GC.heap_dump <PATH>/heapdump.hprof</p></li><li><p>线程转储 (Thread Dump)<br>jstack <pid> &gt; threaddump.txt<br>jcmd <pid> Thread.print &gt; threaddump.txt</p></li></ol><h3 id="性能分析工具"><a class="header-anchor" href="#性能分析工具"></a>性能分析工具</h3><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://bbs.huaweicloud.com/blogs/395995">为什么说过早优化是万恶之源</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;java性能权威指南一Java性能调优工具箱&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;说来惭愧这本书是HeapDump社区,大概是23年的礼品吧,也是目前最后一本收到的技术书籍</summary>
      
    
    
    
    <category term="性能" scheme="https://agmtopy.gitee.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>系统的稳定性建设</title>
    <link href="https://agmtopy.gitee.io/2025/05/13/1.%E6%9D%82%E8%AE%B0/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/"/>
    <id>https://agmtopy.gitee.io/2025/05/13/1.%E6%9D%82%E8%AE%B0/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/</id>
    <published>2025-05-13T14:55:55.000Z</published>
    <updated>2025-05-26T00:14:47.074Z</updated>
    
    <content type="html"><![CDATA[<h1>系统的稳定性建设</h1><p>系统的稳定性建设在工作中虽然已经做了很多相关的工作,但是没有形成系统性的思考,因此通过这篇文章记录一下相关的方法论;</p><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>软件系统由于自身的特点,具备横向扩展的复制能力和交付后持续迭代的特点,使得软件系统需要在不断的迭代中努力去维持系统的稳定性,不然就会导致将大量的研发资源投入到灭火中,而不是在业务的创新上,不是技术是深入上;<br>软件系统的稳定性建设就是<B>保证系统在不断迭代中,能够保持稳定态,并且在发生故障时能够快速恢复到正常状态的能力</B>;</p><h2 id="如何衡量系统的稳定性"><a class="header-anchor" href="#如何衡量系统的稳定性"></a>如何衡量系统的稳定性?</h2><p>在对传统系统进行稳定性判断时常用的指标是通过服务的可用时长占比,例如Uptime:999.99%,即一年中有5.26分钟的不可用时间,但是在金融系统中,由于业务的特点单纯的可用时长占比已经不能完全反映系统的稳定性了,因此需要引入数据的正确性来衡量系统的稳定性;</p><p><B>业务指标偏离度</B>用于表示将实际业务数据与预期值或历史值进行比较，衡量业务指标的偏离程度。如果系统不稳定，导致数据获取或处理错误，那么业务指标偏离度可能会出现异常波动。对于金融类的系统,通常的做法是按照交易维度来进行统计的,<B>错误的数据笔数/总的交易笔数/天或月或季</B>,这样就能够很好的反映出系统的稳定性;</p><h2 id="影响系统稳定性的因素有哪些"><a class="header-anchor" href="#影响系统稳定性的因素有哪些"></a>影响系统稳定性的因素有哪些?</h2><ul><li>现状<br>在现在的系统中,出现系统不稳定性的原因主要有一下几个方面:硬件系统导致的服务不可用、业务配置错误、代码BUG、外围服务导致等;</li></ul><ol><li>硬件系统导致的不可用场景:云服务厂商提供的MySQL不稳定、网络原因等</li><li>业务配置错误:产品参数开关配置错误</li><li>代码BUG:NPE、计算金额错误</li><li>外围服务导致:上游服务不按约定传参导致、下游服务不可用影响业务的正常开展</li></ol><p>通过上面场景的分析,可以总结为下面这个图:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE.png?raw=true" alt="系统稳定性建设"></p><p>影响系统的稳定性主要可以分为两个大类:<B>自然因素</B>、<B>人为因素</B>;<br>自然因素是不能避免的原因,只能从发现、解决的环节来尽可能的降低影响;<br>人为因素是可以通过<B>流程</B>、<B>规范</B>、<B>工具</B>来避免的,我们在提高系统的稳定性上也是着重优化人为因素这一点;</p><h3 id="自然因素"><a class="header-anchor" href="#自然因素"></a>自然因素</h3><ol><li>硬件原因<br>硬件原因导致的服务不可用可以分为:</li></ol><ul><li>服务器硬件不可用:断电、磁盘损坏、路由器不可用等等</li><li>网络故障:网络超时、丢包、中断等</li></ul><ol start="2"><li>三方服务原因<br>这里的三方服务指的是,非同一公司内部提供的服务导致不可用,通常可以分为:</li></ol><ul><li>云服务厂商提供的服务不可用,例如存储服务、MySQL服务等</li><li>开源框架的BUG</li></ul><p>自然原因导致的系统稳定性下降,可以从两个方面进行思考:</p><ol><li>通过冗余硬件的方式来降低风险,例如RAID技术和UPS等硬件设备;</li><li>通过事后监控的形式,尽早的发现问题,从而解决问题,控制影响范围;</li></ol><h3 id="人为因素"><a class="header-anchor" href="#人为因素"></a>人为因素</h3><p>人为可以控制的因素可以划分为几个大的环节:需求评审阶段 -&gt; 研发阶段 -&gt; 测试阶段 -&gt; 上线阶段 -&gt; 故障处理</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E9%9C%80%E6%B1%82%E4%BA%A4%E4%BB%98%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?raw=true" alt="需求交付生命周期"></p><p>下面从这个几个环节分析是什么原因导致稳定性降低</p><h4 id="需求评审环节"><a class="header-anchor" href="#需求评审环节"></a>需求评审环节</h4><p>需求评审环节指的不是对一个需求或者一个功能集(模块)的片面思考,更多是是需要从行业-公司-业务条线上的思考,没有一成不变的业务,需要运营、产品、研发一起想清楚、想透彻,然后提出合理的业务诉求,以及有预见性的业务建设;<br>在这个阶段有三个可以值得思考和把控的点:</p><ol><li><p>团队的定位<br>先抓住团队的立身之本,分析这个行业或者公司在的核心业务是什么?这个团队能为这个核心业务贡献什么?<br>例如电商系统的核心部门是广告业务、金融系统的核心部门是风险或者资金部门,核心业务拥有最大的资源倾斜;<br>但是核心业务在不同的时期是会发生变化的,好的职业路径肯定是不断在在核心业务条线上游走,但是很难做到;</p></li><li><p>没有长远的需求规划能力<br>在实际工作中,遇到很多产品经理只是需求方的一个传话筒,这一类产品往往对行业没有一个整体的意识,只能做到被业务方牵着鼻子走,设计的方案往往也是短视的,导致的结果就是设计的产品方案是定制化的,没有横向的复制扩展能力,以及纵向业务扩展能力;</p></li></ol><blockquote><p><B>横向的复制能力</B>指的解决的是行业内通用的痛点,通过一次方案能适用多个使用方的能力;<br><B>纵向的扩展能力</B>指的是能对抽象出业务能力,对未来业务的变化有预见性的设计;</p></blockquote><p><B>业务理解</B>是对系统稳定性影响最大的一个因素,软件系统是现实需求的直观反馈,业务架构决定了技术架构;<br>如果产研团队对业务理解的不深刻不透彻,只能着眼于未来一年甚至几个月的短期需求和利益,想到哪里就做到哪里,那么技术层面上就无法做好提前的布局和设计,变更、堆砌、重复就会接踵而来;<br>万丈高楼平地起,业务需求的理解才是软件系统的地基,地基不稳定,后续在通过各种手段方法措施来进行治理都只能治标不治本;</p><ol start="3"><li>业务需求的把控<br>从业务需求层面考虑稳定型,主要从两个方面做起:一是<B>业务需求的过滤</B>,过滤出真正有价值的需求,二是<B>需求模型的简化</B>;<br>对于需求价值的判断可以采用需求价值判断决策漏斗来进行分析:</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E9%9C%80%E6%B1%82%E4%BB%B7%E5%80%BC%E8%BF%87%E6%BB%A4%E6%BC%8F%E6%96%97%E5%9B%BE.drawio.png?raw=true" alt="需求价值判断决策漏斗"></p><p>对于业务价值的判断,尤其是做创新型业务时,产品或者业务的想法很多,这能体现创新的源动力,但是作为实现这些想法的技术人员,要能从纷繁复杂的需求中找到最核心的需求,必须要<B>对需求方的原始需求进行合理性的质疑</B>,砍掉没有核心价值的伪需求,来精简业务模型,将有限的研发资源投入真正有业务价值的地方;</p><p>业务模型的简化会带来业务复杂度的简化,从而提高系统稳定性;</p><blockquote><p>小结:<B>对业务理解的认知,是建立全局稳定性思考的前提条件,对需求的去伪存真化繁为简决定了一个系统的复杂度,做稳定性建设必须要考虑这一环节</B></p></blockquote><h4 id="设计阶段"><a class="header-anchor" href="#设计阶段"></a>设计阶段</h4><p>研发阶段、测试阶段、上线阶段、故障处理阶段,这几个阶段都是需要投入研发资源去进行关注的,下面依次来分析一下会导致稳定性下降的原因;</p><p>在设计阶段中主要的产出物是<B>技术方案</B>,表示研发阶段的开始,在这个环节中需要把控好<B>技术设计方案</B>的质量,从而尽量在早期进行调整;</p><p>在进行详细方案评审前,一定一定要让整个团队清楚,评审的目的是<B>团队帮助你来检查方案,而不是挑战你的方案,不是来找茬的</B>,有谦虚、平和的心态才能有开发、友善的建议;</p><ul><li><p>业务上<br>在实际工作中,处理业务需求的技术方案设计遇到两类人,一类是只关心这个需求是作什么,如何才能把这个需求实现,另外一类是了解这个需求是做什么,并且知道为什么要做这个需求,并且在这个需求上进行扩展;<br>第一类人,做100个需求和做10个需求的效果是一样的,没有主动思考的能力,这一类人的技术方案需要在设计评审时引导他进行思考,但是引导还是需要分人分场合进行的,工作态度严肃坚定的人和自由散漫的人提出一个相同的意见,最后得到的反馈也是不一样的;<br>第二类人,能够做到主动思考,但是在主动思考过程中需要注意的是不要陷入过度设计中去,工程化实际上是围绕这效率\质量这两个点来进行的,适当才是当前最好的设计,这部分过渡设计可能更多的出现在技术上;</p></li><li><p>技术上<br>一个不好的技术方案,经常会出现问题的几个地方:</p></li></ul><table><thead><tr><th>序号</th><th>场景</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>限流</td><td>限流是服务提供者基于自身考虑提供的保护自身的能力,常见的算法有计数器算法、滑动窗口算法、令牌桶算法等，实现的框架有Resilience4j、Sentinel</td></tr><tr><td>2</td><td>熔断降级</td><td>熔断是防止我们的系统被下游系统拖垮，实现的框架有Resilience4j、Sentinel</td></tr><tr><td>3</td><td>超时机制</td><td>超时时间的设置需要遵循漏斗原则</td></tr><tr><td>4</td><td>重试机制</td><td>RPC框架的默认重试机制、避免出现重试风暴</td></tr><tr><td>5</td><td>兼容性考虑</td><td>新逻辑-兼容-老数据、老逻辑-兼容-新数据</td></tr><tr><td>6</td><td>隔离</td><td>数据隔离、系统隔离、读写分离、线程池隔离等</td></tr></tbody></table><blockquote><p>小结: 在设计阶段需要重点关注详细设计方案的技术合理性和业务合理性,两个方面;</p></blockquote><h4 id="研发阶段"><a class="header-anchor" href="#研发阶段"></a>研发阶段</h4><p>这个阶段产出的是代码,对于代码codeReview是最后一个流程,在这个动作中，可以有三个需要关注的：</p><ol><li>技术经理统一代码风格</li><li>结对编程，这里的结对编程不是说一个人写，一个人在旁边看，而是一个人负责写，另外一个owner负责codeReview</li><li>单元测试的覆盖度，单元测试一定是必要的！在提测前发现问题，影响越小；</li></ol><blockquote><p>在这个阶段中，遇到最多的问题是写代码的同学对边界值、API不熟悉、代码混乱等，没有降低整体复杂度的意识;</p></blockquote><h4 id="测试阶段"><a class="header-anchor" href="#测试阶段"></a>测试阶段</h4><p>在测试阶段，容易忽略的是正常场景的回归；测试需要做到全流程全场景的覆盖，通过人工手动的去完成，是一个低效不稳定的方法；<br><B>测试的原则是尽可能的用机器完成自动化测试和全场景的覆盖，将宝贵的人力资源投入到必须用人力进行测试的环节</B></p><h4 id="上线阶段"><a class="header-anchor" href="#上线阶段"></a>上线阶段</h4><p>在上线需要关注的是两点：代码和配置</p><ol><li>代码<br>如果代码没上去，一切都是白搭，检查上线的内容</li><li>配置<br>对应的业务配置也需要调整</li></ol><h4 id="故障处理阶段"><a class="header-anchor" href="#故障处理阶段"></a>故障处理阶段</h4><p>故障处理阶段需要注意处理问题的先后顺序，原则上是按照下面这个流程进行处理</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png?raw=true" alt="故障处理流程.png"></p><p>第一点需要注意的是和业务方的沟通以及在问题发现时及时团队内同步；<br>第二点需要注意的是一定要正确定位到问题在进行修改，避免产生连锁问题;</p><h2 id="应对措施"><a class="header-anchor" href="#应对措施"></a>应对措施</h2><p>上述阐述了影响系统稳定性的几个原因，针对这些原因可以从以下几个方面来进行应对;</p><h3 id="制度-规范"><a class="header-anchor" href="#制度-规范"></a>制度/规范</h3><p>制度或者规范要能去落地才是好的制度,必须是要符合人的本性的;按研发流程划分主要分下图:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E5%88%B6%E5%BA%A6%E8%A7%84%E8%8C%83.png?raw=true" alt="制度规范"><br>在这几个环节过程中都会产生问题,但是问题的影响范围从大到小，解决问题消耗的资源从小到大；举一个例子，在需求评审阶段如果对于需求的理解出现偏差会导致返工,由于返工压缩工期又会增加系统的不稳定性;</p><h3 id="工具"><a class="header-anchor" href="#工具"></a>工具</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E5%B7%A5%E5%85%B7%20%20.png?raw=true" alt="工具"></p><p>工具可以为我们降低稳定性建设的资源投入,提高效率,主要分为<B>研发工具</B>和<B>故障排查工具</B></p><h3 id="预案"><a class="header-anchor" href="#预案"></a>预案</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E9%A2%84%E6%A1%88.png?raw=true" alt="预案"></p><p>出现问题是无法避免的,但是解决问题的方式方法是有一定的流程的,通常出现的问题是线上出现问题,在没有保存现场时,直接重启,导致无法找到故障原因、第二种是处理问题的顺序错误,应该先降低影响,在探寻原因;</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>一个简单的总结就是:</p><ol><li>做好需求的分析和设计</li><li>做好技术方案的评审</li><li>codereview以及单元测试</li><li>测试场景的覆盖</li><li>故障应对预案</li></ol><p>其实最后还应该有一个复盘阶段,但是个人在实际工作中感觉复盘是一项意义比较小的工作,有些坑还是要亲自跌倒了才能长记性;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E9%98%BF%E9%87%8C%E6%B5%85%E8%B0%88%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E5%B1%82%E9%9D%A2%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BF%9D%E9%9A%9C/">阿里浅谈系统实现层面稳定性保障</a><br><a href="https://developer.jdcloud.com/article/3894">万字长文浅谈系统稳定性建设</a><br><a href="https://www.infoq.cn/article/z4ssmnks3w4ebbustyo1">稳定性全系列（一）：如何做好系统稳定性建设</a><br><a href="https://cloud.tencent.com/developer/article/1758295">换个角度聊系统稳定性建设</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;系统的稳定性建设&lt;/h1&gt;
&lt;p&gt;系统的稳定性建设在工作中虽然已经做了很多相关的工作,但是没有形成系统性的思考,因此通过这篇文章记录一下相关的方法论;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="业务监控" scheme="https://agmtopy.gitee.io/tags/%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>MAT使用指南</title>
    <link href="https://agmtopy.gitee.io/2025/05/05/12.JVM/21.MAT%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://agmtopy.gitee.io/2025/05/05/12.JVM/21.MAT%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2025-05-05T13:04:46.000Z</published>
    <updated>2025-05-06T13:27:12.325Z</updated>
    
    <content type="html"><![CDATA[<h1>MAT使用指南</h1><p>前言:将MAT常用的使用方法记录下来以备不时之需,后续补充也在这上面进行</p><h2 id="MAT使用过程中常见问题"><a class="header-anchor" href="#MAT使用过程中常见问题"></a>MAT使用过程中常见问题</h2><ol><li><p>JDK版本不匹配<br>目前MAT版本为1.16.0,需要JDK17以上版版本,如果要使用JDK8作为运行时环境需要下载1.7.0版本<br><a href="https://github.com/eclipse-mat/mat/releases/tag/R_1.7.0">R_1.7.0</a></p></li><li><p>运行目标版本不一致<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98.png?raw=true" alt="MAT_启动问题"><br>如果MAT的运行版本和目标版本不一致,会导致无法打开dump文件,需要在MAT的安装目录下找到<code>MemoryAnalyzer.ini</code>文件,修改如下:</p> <pre class="line-numbers language-none"><code class="language-none">-vm&#123;#你的jdk路径#&#125;\jdk-21.0.2\bin\javaw.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是必须将<code>-vm</code>配置放到<code>-vmargs</code>之前,否则会导致MAT无法启动</p></li><li><p>运行时内存不足<br>如果在使用MAT的过程中出现了<code>java.lang.OutOfMemoryError: Java heap space</code>的错误,可以在<code>MemoryAnalyzer.ini</code>中添加如下配置:</p><pre class="line-numbers language-none"><code class="language-none">-Xms512m-Xmx2048m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中<code>-Xms</code>表示初始内存大小,<code>-Xmx</code>表示最大内存大小,可以根据自己的机器配置进行调整,<B>注意MAT的内存大小一般设置为hprf文件的两倍</B></p></li><li><p>调整内存单位<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%BD%8D1.png?raw=true" alt="调整内存"><br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%BD%8D2.png?raw=true" alt="调整内存2"></p></li></ol><h2 id="MAT常用功能"><a class="header-anchor" href="#MAT常用功能"></a>MAT常用功能</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_%E4%B8%BB%E7%95%8C%E9%9D%A2.png?raw=true" alt="MAT主界面"></p><h3 id="Histogram"><a class="header-anchor" href="#Histogram"></a>Histogram</h3><p>直方图:用于分析对象的数量和大小<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_Histogram.png?raw=true" alt="MAT_Histogram"><br>从上图中可以看到Object的数量和大小,shallow Heap表示对象本身占用的内存,retained Heap表示对象引用的内存,可以通过右键点击show object by class进行查看;<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_Histogram_income.png?raw=true" alt="MAT_Histogram_incomeing"></p><h3 id="dominator-tree"><a class="header-anchor" href="#dominator-tree"></a>dominator tree</h3><p>支配树:用于分析对象的引用关系和占用大小<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_dominator_tree.png?raw=true" alt="dominator tree"><br>dominator tree是MAT中最常用的功能,通过它可以很明显的分析出当前内存的占用情况,并且可以按照class,package,ClassLoad等进行分类;</p><ul><li><p>分组功能:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_dominator_tree1.png?raw=true" alt="dominator tree1"></p></li><li><p>GC Root引用功能:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_dominator_tree2.png?raw=true" alt="dominator tree2"></p></li><li><p>调用链功能:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_dominator_tree3.png?raw=true" alt="dominator tree3"></p></li></ul><h3 id="Leak-Suspects-by-Snapshot-Comparison"><a class="header-anchor" href="#Leak-Suspects-by-Snapshot-Comparison"></a>Leak Suspects by Snapshot Comparison</h3><p>疑似内存泄漏视图:通过这个视图可以快速分析内存泄漏问题<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_Leak%20Suspects%20by%20Snapshot%20Comparison.png?raw=true" alt="Leak Suspects"></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://github.com/eclipse-mat/mat">MAT项目地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MAT使用指南&lt;/h1&gt;
&lt;p&gt;前言:将MAT常用的使用方法记录下来以备不时之需,后续补充也在这上面进行&lt;/p&gt;
&lt;h2 id=&quot;MAT使用过程中常见问题&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MAT使用过程中常见问题&quot;&gt;&lt;/a&gt;MAT使用过程</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Prompt工程实战</title>
    <link href="https://agmtopy.gitee.io/2025/03/22/25.AIGC/2.Prompt%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    <id>https://agmtopy.gitee.io/2025/03/22/25.AIGC/2.Prompt%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98/</id>
    <published>2025-03-22T06:29:45.000Z</published>
    <updated>2025-03-22T06:34:23.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prompt工程实战"><a class="header-anchor" href="#Prompt工程实战"></a>Prompt工程实战</h2><h3 id="什么是Prompt"><a class="header-anchor" href="#什么是Prompt"></a>什么是Prompt</h3><p>Prompt指的是在AI模型中输入的一段文本，用于指导模型的输出,Prompt</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prompt工程实战&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Prompt工程实战&quot;&gt;&lt;/a&gt;Prompt工程实战&lt;/h2&gt;
&lt;h3 id=&quot;什么是Prompt&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是Pr</summary>
      
    
    
    
    <category term="AI" scheme="https://agmtopy.gitee.io/categories/AI/"/>
    
    
    <category term="Prompt" scheme="https://agmtopy.gitee.io/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>RPC通信原理</title>
    <link href="https://agmtopy.gitee.io/2025/03/17/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://agmtopy.gitee.io/2025/03/17/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</id>
    <published>2025-03-17T12:51:01.000Z</published>
    <updated>2025-03-29T11:38:28.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《架构思考》-RPC通信原理"><a class="header-anchor" href="#《架构思考》-RPC通信原理"></a>《架构思考》-RPC通信原理</h2><h3 id="RPC调用流程"><a class="header-anchor" href="#RPC调用流程"></a>RPC调用流程</h3><ul><li>服务端、</li></ul><ol><li>网络模块</li><li>协议解码</li><li>反序列化</li><li>服务调用</li></ol><ul><li>客户端</li></ul><ol><li>调用接口方法</li><li>代理实现</li><li>序列化</li><li>协议编码</li><li>网络模块</li></ol><h3 id="Reactor模型"><a class="header-anchor" href="#Reactor模型"></a>Reactor模型</h3><p>Reactor模型</p><ul><li><p>Reactor单线程模型</p></li><li><p>Reactor多线程模型</p></li></ul><ol><li>MainReactor主线程<ul><li>单个线程,负责接收客户端连接</li></ul></li><li>SubReactor线程池</li></ol><ul><li>负责事件检测、I/O操作</li></ul><ol start="3"><li>worker线程池</li></ol><ul><li>负责业务处理</li></ul><p>优劣分析:MainReactor主线程与SubReactor线程池职责分工明确,MainReactor主线程只负责接收客户端连接,SubReactor线程池负责事件检测、I/O操作,worker线程池负责业务处理。<br>MainReactor主线程与SubReactor线程的数据交互简单,MainReactor主线程只需要把新连接传给SubReactor线程池即可,SubReactor线程池无需返回数据;<br>多个SubReactor线程能够应对更高的并发请求;<br>缺点:编程复杂度较高</p><p>小结:Reactor多线程模型也被称呼为1+M+N模型,1代表MainReactor主线程,M代表SubReactor线程池,N代表worker线程池。广泛应用于Ngix、Netty等高性能网络框架中。</p><h3 id="Netty框架"><a class="header-anchor" href="#Netty框架"></a>Netty框架</h3><ul><li>Netty模型</li></ul><ol><li>为什么要选择Netty,而不是选择NIO<ul><li>Netty api更加友好和强大</li><li>Netty自身线程安全</li><li>Netty拥有完整的高可用机制</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;《架构思考》-RPC通信原理&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#《架构思考》-RPC通信原理&quot;&gt;&lt;/a&gt;《架构思考》-RPC通信原理&lt;/h2&gt;
&lt;h3 id=&quot;RPC调用流程&quot;&gt;&lt;a class=&quot;header-anchor&quot; hr</summary>
      
    
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何深入理解ChatGPT等大语言模型-笔记</title>
    <link href="https://agmtopy.gitee.io/2025/03/07/25.AIGC/1.%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ChatGPT%E7%AD%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2025/03/07/25.AIGC/1.%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ChatGPT%E7%AD%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B-%E7%AC%94%E8%AE%B0/</id>
    <published>2025-03-07T15:49:06.000Z</published>
    <updated>2025-03-22T06:32:29.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何深入理解ChatGPT等大语言模型-笔记"><a class="header-anchor" href="#如何深入理解ChatGPT等大语言模型-笔记"></a>如何深入理解ChatGPT等大语言模型-笔记</h2><p>根据Andrej Kaparthy分享的<a href="https://www.youtube.com/watch?v=7xTGNNLPyMI">Deep Dive into LLMs like ChatGPT</a>视频，以下是我在学习过程中的一些笔记：</p><h3 id="预训练阶段"><a class="header-anchor" href="#预训练阶段"></a>预训练阶段</h3><ul><li>数据收集阶段</li></ul><ol><li>收集数据,通过爬虫技术收集大量文本数据</li><li>对数据进行清洗,去除无用信息</li><li>压缩数据,形成词表(token)</li></ol><ul><li>构建神经网络模型</li></ul><ol><li>根据词表预测下一个词的概率</li><li>对概率进行调整,使其更加正确,也就是<B>神经网络训练的过程</B><br>这里使用的是Transformer模型,这个不太懂 TODO,后面在了解</li></ol><ul><li>推理过程<br>推理过程简单来说就是根据步骤2生成的模型,在结合输入的文本,预测下一个词的概率;</li></ul><h4 id="基础模型"><a class="header-anchor" href="#基础模型"></a>基础模型</h4><ol><li>基础模型也具备上下文学习能力</li></ol><h3 id="监督式-微调阶段"><a class="header-anchor" href="#监督式-微调阶段"></a>监督式-微调阶段</h3><p>由于基础模型只能做到预测下一个词语的能力,不能理解文本的含义,所以需要对基础模型进行微调<br>微调的方式是通过对话的方式来进行调整,然后将调整后的数据重新训练基础模型,使其具备对话的能力</p><p>类似的文档数据集,可以参考(Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT)[<a href="https://huggingface.co/datasets/Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT">https://huggingface.co/datasets/Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT</a>]</p><p>微调阶段更重要的作用是修正基础模型的一些错误,使其更加准确,以及让模型知道自己的边界在哪里,从而解决<B>模型幻觉问题 </B></p><ul><li>模型需要分步思考<br>LLM模型在给出结果时,会依赖上一步输出的token,因此要避免一个步骤中就让模型给出最终的答案,而是分步思考,使用上一步的输出作为下一步的输入,这样可以减少模型幻觉问题或者让模型使用其他工具来实现;</li></ul><h3 id="强化学习阶段"><a class="header-anchor" href="#强化学习阶段"></a>强化学习阶段</h3><p><B>强化学习</B>指的是模型在给出答案后,会根据结果来增加能输出正确答题的路径的概率,减少错误答案的路径的概率,在不断的迭代中,模型会更加准确;<br>对于有明确答案的问题,可以使用LLM评判模型给出的答案是否正确,从而进行强化学习;<br>对于没有明确答案的问题,通常使用另外一个神经网络模型来模拟人类的评判标准,来进行评分,从而进行强化学习;<br>RLHF会有对抗问题,因为模型会想办法欺骗评判标准;</p><p>PS:这个分享教程的格式非常好,首先是分享的知识只划分为三个段落,每个段落完成后都会进行回溯,最后进行整体回溯;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fineweb-v1">FineWeb: decanting the web for the finest text data at scale</a><br><a href="https://tiktokenizer.vercel.app/?model=cl100k_base">Tiktokenizer</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何深入理解ChatGPT等大语言模型-笔记&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#如何深入理解ChatGPT等大语言模型-笔记&quot;&gt;&lt;/a&gt;如何深入理解ChatGPT等大语言模型-笔记&lt;/h2&gt;
&lt;p&gt;根据Andrej Kaparthy</summary>
      
    
    
    
    <category term="AI" scheme="https://agmtopy.gitee.io/categories/AI/"/>
    
    
    <category term="AI" scheme="https://agmtopy.gitee.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>第一章-前言</title>
    <link href="https://agmtopy.gitee.io/2024/12/12/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E8%A8%80/"/>
    <id>https://agmtopy.gitee.io/2024/12/12/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E8%A8%80/</id>
    <published>2024-12-12T13:08:02.000Z</published>
    <updated>2025-03-17T12:50:27.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《架构思考》-前言"><a class="header-anchor" href="#《架构思考》-前言"></a>《架构思考》-前言</h2><h3 id="互联网架构演变历史"><a class="header-anchor" href="#互联网架构演变历史"></a>互联网架构演变历史</h3><h4 id="1-业务架构"><a class="header-anchor" href="#1-业务架构"></a>1. 业务架构</h4><p>1.1 单体架构<br>在互联网早期发展中,主要以单体架构为主,按照业务-&gt;应用层-&gt;数据层进行简单划分;<br>每一个业务系统就是一个单独的业务团队,数据和人员(组织关系)都是独立的,造成数据隔离和组织单体化的问题;</p><p>1.2 中台战略<br>由阿里提出来的,理念是<B>共享</B>,共享业务、系统、组织架构上的一种落地方式和实施办法;<br>关键字:共享、节约成本、协助;<br>中台战略主要分为数据中台和业务中台两层能力,如图所示:</p><p>#TODO</p><p>1.3 去中台战略</p><ol><li>中台的复用率不高,提炼和维护中台所花费的代价抵不上中台复用带来的价值</li></ol><h4 id="2-数据架构"><a class="header-anchor" href="#2-数据架构"></a>2. 数据架构</h4><ul><li>数据库架构</li></ul><ol><li><p>单体数据库架构<br>web项目通过JDBC直连单体数据库</p></li><li><p>主从读写<br>数据库采用读写分离架构,主库负责写操作,从库负责读操作;<br>涉及到的中间件:sharding-jdbc,mycat</p></li><li><p>分库分表<br>分库分表有两种方式:一种是横向切分,一种是纵向切分:</p></li></ol><ul><li><p>横向拆分指的是按照记录进行拆分</p></li><li><p>纵向拆分指的是按照字段进行拆分</p></li><li><p>高速缓存<br>引入redis来解决热数据的问题;<br>缓存带来的问题:</p></li></ul><ol><li>缓存击穿(单一key失效)</li><li>缓存穿透(无效key访问)</li><li>缓存雪崩(大量key失效)</li><li>缓存一致性</li></ol><ul><li>数据多样化</li></ul><ol><li>分布式文件系统:HDFS,FastDFS</li><li>nosql:mongodb,redis</li><li>搜索引擎:Elasticsearch</li></ol><h4 id="3-应用架构"><a class="header-anchor" href="#3-应用架构"></a>3. 应用架构</h4><ol><li><p>单机调优<br>上古时代使用tomcat或者jboos进行部署时,对单机进行调优,比如JVM参数优化、数据库连接池优化等;</p></li><li><p>动静分离<br>前端静态资源独立部署到前置服务器上</p></li><li><p>SOA架构<br>SOA架构需要引入ESB(企业服务总线)来进行整体调度</p></li><li><p>微服务架构<br>微服务架构是SOA架构的一种改进,微服务架构是一套系统和理念;</p></li></ol><h4 id="4-部署架构"><a class="header-anchor" href="#4-部署架构"></a>4. 部署架构</h4><ol><li><p>单机部署<br>小型项目直接部署到单机上</p></li><li><p>集群部署<br>集群部署主要是为了解决单机瓶颈问题,比如单机CPU、内存、IO瓶颈;</p></li><li><p>多层代理<br>多层代理使用负载均衡器来解决单机瓶颈问题;</p></li><li><p>异地访问<br>异地访问主要是为了解决跨地域访问延迟问题;</p></li><li><p>云平台<br>云平台主要是为了解决自建机房的成本问题,通常使用docker、k8s等技术;</p></li></ol><h4 id="5-架构思想"><a class="header-anchor" href="#5-架构思想"></a>5. 架构思想</h4><ol><li>知行合一,做之前,先思考意义</li><li>原生由于定制,约定大于配置</li><li>什么都要,最后什么都要不了</li><li>控制技术欲,不要瞎折腾</li><li>留下扩展,但是不要想到100年以后</li><li>没有最好的,只有最合适的</li><li>够用就好,用的越花,风险越大</li><li>简约最美</li></ol><h3 id="容器化技术概览"><a class="header-anchor" href="#容器化技术概览"></a>容器化技术概览</h3><p>应用部署方式的演变:从硬件虚拟化(操作系统虚拟化))到容器虚拟化(容器虚拟化的演变;</p><h4 id="什么是容器化"><a class="header-anchor" href="#什么是容器化"></a>什么是容器化</h4><blockquote><p>容器化是将应用程序或服务及其依赖或者配置,一起打包为容器映像的一种软件构建及部署技术;</p></blockquote><p><img src="" alt="容器化架构"></p><ul><li>什么是docker</li></ul><blockquote><p>docker是go语言研发的容器引擎,基于容器化技术和沙箱机制的应用部署技术;<br>可适用于自动化测试、打包、持续集成、发布等场景,以下是Docker的优点:</p></blockquote><ol><li>更高效的系统资源利用率</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>更轻松的迁移</li></ol><p>当然docker也有缺点:</p><ol><li>隔离性不如虚拟机</li><li>性能高于虚拟机,但是低于物理机</li></ol><p>docker的应用场景:<br>1.微服务部署场景<br>2. DevOps场景</p><p>额外需要注意的是,对docker文件的修改只会体现在当前层,对其他层的修改会采用标记删除-复制修改的方式进行;</p><h2 id="Zookeeper"><a class="header-anchor" href="#Zookeeper"></a>Zookeeper</h2><h3 id="Zookeeper基础及高级应用"><a class="header-anchor" href="#Zookeeper基础及高级应用"></a>Zookeeper基础及高级应用</h3><ul><li><p>Zookeeper数据模型<br>Zookeeper的数据模型是一个树形目录结构,类似于文件系统的目录结构,通过k-v的方式来进行存储,key是由’/'分割的路径;<br>每个Znode节点可以存储的数据大小为1MB,选择1Mb的原因是基于zookeeper作为分布式协调服务的高性能和稳定性考量,其设计初衷就是用于协调服务,而非存储大量数据;</p></li><li><p>Zookeeper节点类型</p></li></ul><ol><li>持久化节点(默认类型)</li><li>持久化顺序节点</li><li>临时节点</li><li>临时顺序节点<br>另外还有容器节点和超时节点等</li></ol><h4 id="Zookeeper应用场景"><a class="header-anchor" href="#Zookeeper应用场景"></a>Zookeeper应用场景</h4><ul><li>分布式锁</li></ul><blockquote><p>分布式锁指的是在分布式环境下,跨进程\跨主机\跨网络的共享资源,实现互斥访问,保证一致性;在Zookeeper中,锁就是一个数据节点;</p></blockquote><p>普通实现:通过注册<B>临时节点</B>,各个客户端抢占创建临时节点的方式,来获取锁,其他未抢占到该节点的客户端通过监听该节点的变化来重新获取锁;<br>这种方式存在的问题是: 羊群效应,指的是持有锁的客户端释放锁之后,其他所有客户端由于是通过watch机制监听该节点,导致所有客户端都会收到通知,然后重新发起竞争锁的请求,从而造成大量无效竞争;<br>解决方案是:通过临时顺序节点,每个客户端在创建锁的时候,都会创建一个临时顺序节点,然后通过监听前一个节点的变化来获取锁;</p><ul><li>分布式锁-读写锁</li></ul><blockquote><p>通过Zk实现分布式读写锁,是通过将临时顺序节点分为<B>读锁节点</B>和<B>写锁节点</B>来进行实现;</p></blockquote><ol><li>读请求时,通过判断当前读节点,如果没有比自己更小的节点或者比自己小的节点都是读节点,那么获取读锁成功,如果比自己小的节点中有写锁节点,那么获取读锁失败;</li><li>写请求时,通过判断当前写节点,如果没有比自己更小的节点,那么获取读锁成功,如果自己不是最小的节点,那么获取读锁失败;</li><li>读锁或者写锁完成操作后,都要进行释放;</li></ol><ul><li>配置中心</li></ul><blockquote><p>使用zookeeper作为配置中心,主要是通过客户端来监听配置节点的变化来实现;</p></blockquote><ul><li>注册中心</li></ul><blockquote><p>使用zookeeper作为注册中心,是通过客户端来注册服务节点,调用端监听服务节点的变化来实现;</p></blockquote><ul><li>Curator客户端的实现</li></ul><ol><li>InterProcessMutex:分布式可重入排他锁</li><li>InterProcessSemaphoreV2:分布式信号量</li></ol><h4 id="Zookeeper选举策略"><a class="header-anchor" href="#Zookeeper选举策略"></a>Zookeeper选举策略</h4><ul><li>ZAB协议</li></ul><p>Zookeeper的选举策略是基于ZAB协议来进行实现的,ZAB协议是一种对<B>Paxos算法</B>的简化实现,是专门未Zookeeper设计的支持崩溃恢复的原子广播协议;<br>基于该协议zk实现了一种主备模式(即Leader和Follower模式)的系统架构来保证集群中的各个节点的数据一致性;<br>在ZAB协议下,节点分为两个角色:<B>Leader</B>和<B>Follower</B>,第三个角色是Observer,Observer不参与投票;<br>Leader: 唯一，负责写操作和协调,一个zk集群中同一时刻只会有一个Leader,Leader发起并维护与各个follower和Observer的心跳,Leader通过心跳来维护集群中各个节点的状态,同时将写操作广播到各个节点<br>Follower: 多数，负责读操作并参与选举,同时Follower会响应Leader的心跳,并且接受Leader的写操作广播;Follower也可以响应客户端的写操作,然后将写操作转发给Leader,来进行完成;<br>Observer: 可选，专注于读操作，不参与选举,Observer的设计是为了提供读能力,因此被设计为数据是满足最终一致性的,因此可能会有读取数据延迟的问题,解决这个问题的方法是:1.强制Sync,2.客户端优先连接到Leader或者follower,3.对于强一致性的业务场景不使用Observer;</p><ul><li>ZAB协议的两种模式</li></ul><ol><li>崩溃恢复模式:一旦Leader服务器进入崩溃或者网络原因导致与集群中的过半follower失去连接,那么就会进入崩溃恢复模式;zk集群会进入选举阶段,通过投票的方式来选出新的Leader;</li><li>消息广播模式:Leader选出之后,就会进入消息广播模式;在该模式下,Leader会进行消息广播,需要注意的是<B>满足过半节点即可</B>,这是和Paxos算法的区别;</li></ol><ul><li>zk的选举过程<br>Zookeeper的选举过程分为两类,第一类是<B>服务器启动时的Leader选举流程</B>、<B>异常恢复场景Leader的选举过程</B><br>首先介绍几个概念:</li></ul><ol><li>zxid:zxid是一个64位的数字,高32位是epoch(leader纪元),低32位是当前leader纪元内事务ID,节点初始化时为0|0;</li><li>serverid:也被称为<B>myId</B>,代表服务器的ID,是一个32位的数字,初始化是通过myid文件进行初始化的;</li><li>Quorum:集群中过半的节点数量;</li></ol><p>leader选举流程大致可以分为以下几个步骤:</p><ol><li>集群启动时,每个节点都会初始化自己的zxid和serverid;</li><li>集群启动时,每个节点都会发起投票,投的都是自己,并且将投票信息广播出去</li><li>每个节点通过对比自己的(zxid,serverid)和接收到的投票信息,来确定自己的投票结果,并且将投票信息广播出去;</li><li>当某个节点收到的投票信息数量达到过半时,该节点就会成为Leader;</li><li>Leader选举完成后,Leader会进行消息广播;</li></ol><h2 id="Apollo配置中心"><a class="header-anchor" href="#Apollo配置中心"></a>Apollo配置中心</h2><p>Apollo是分布式配置中心,主要用于管理分布式系统的配置信息;</p><p>@TODO</p><h2 id="Skywalking…"><a class="header-anchor" href="#Skywalking…"></a>Skywalking…</h2><h3 id="微服务系统监控的三要素"><a class="header-anchor" href="#微服务系统监控的三要素"></a>微服务系统监控的三要素</h3><p>度量单位:QPS,RT,CPU使用率,接口调用量,接口成功率<br>日志:业务日志,数据日志,异常日志<br>链路追踪:记录一个请求的完整路径</p><h3 id="分布式链路的组成"><a class="header-anchor" href="#分布式链路的组成"></a>分布式链路的组成</h3><ol><li><B>数据采集阶段</B></li><li><B>数据持久化阶段</B></li><li><B>数据展示阶段</B></li></ol><h3 id="opentraceing规范"><a class="header-anchor" href="#opentraceing规范"></a>opentraceing规范</h3><ul><li>trace</li></ul><blockquote><p>一个Trace代表一个事务、请求或者是流程在分布式系统中的执行过程;OpenTracing中的一个Trace由多个Span组成,一个Spen代表系统中具有开始时间<br>和执行时长的逻辑单元,Span一般会有一个名称,一个Trace中的Span是首尾相连接的;</p></blockquote><ul><li>Span</li></ul><blockquote><p>Span代表系统中具有开始时间和执行时长的逻辑单元,Span之间通过嵌套或者顺序排列建立逻辑因果关系;</p></blockquote><h3 id="配置"><a class="header-anchor" href="#配置"></a>配置</h3><ol><li>使用javaagent的方式,在启动时添加参数,设置ServiceName;</li></ol><h2 id="网络编程"><a class="header-anchor" href="#网络编程"></a>网络编程</h2><h3 id="网络IO模型"><a class="header-anchor" href="#网络IO模型"></a>网络IO模型</h3><ol><li>同步阻塞IO<br>同步阻塞IO:由于是依赖于操作系统的IO操作,因此会导致线程阻塞,并且由于线程数量的限制,无法创建大量IO线程;</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;《架构思考》-前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#《架构思考》-前言&quot;&gt;&lt;/a&gt;《架构思考》-前言&lt;/h2&gt;
&lt;h3 id=&quot;互联网架构演变历史&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#互联网架构演变历</summary>
      
    
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>深入分析JavaParser原理之基础用法(一)</title>
    <link href="https://agmtopy.gitee.io/2024/09/13/23.JavaParser%E5%88%86%E6%9E%90/1.%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90JavaParser%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>https://agmtopy.gitee.io/2024/09/13/23.JavaParser%E5%88%86%E6%9E%90/1.%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90JavaParser%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</id>
    <published>2024-09-13T13:00:29.000Z</published>
    <updated>2024-10-21T16:46:45.113Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分析JavaParser原理之基础用法(一)</h1><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>JavaParser是一个基于JavaCC的开源项目，它是一个解析器生成器和抽象语法树(AST)处理工具</p><h2 id="使用示例"><a class="header-anchor" href="#使用示例"></a>使用示例</h2><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分析JavaParser原理之基础用法(一)&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;JavaParser是一个基于JavaCC的开源项目，它是一个解析器生成器和抽象语法树</summary>
      
    
    
    
    <category term="JavaParser" scheme="https://agmtopy.gitee.io/categories/JavaParser/"/>
    
    
    <category term="JavaParser" scheme="https://agmtopy.gitee.io/tags/JavaParser/"/>
    
  </entry>
  
  <entry>
    <title>JDK21对比JDK8语法升级指南</title>
    <link href="https://agmtopy.gitee.io/2024/04/01/12.JVM/51.jdk21%E5%AF%B9%E6%AF%94jdk8%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/"/>
    <id>https://agmtopy.gitee.io/2024/04/01/12.JVM/51.jdk21%E5%AF%B9%E6%AF%94jdk8%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/</id>
    <published>2024-04-01T14:06:00.000Z</published>
    <updated>2024-05-23T15:37:17.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK21对比JDK8语法升级指南"><a class="header-anchor" href="#JDK21对比JDK8语法升级指南"></a>JDK21对比JDK8语法升级指南</h2><p>JDK8经过JDK11(LTS)、JDK17(LTS)、JDK21(LTS)等多个长期支持JDK版本,目前最新版本已经到了JDK22(non lts),下一个长期支持版本为JDK25,因此长时间内JDK21都会是一个生产版本,下面从三个三个方面了解JDK8升级到JDK21中语法层面的内容:<B>新语法特性</B>、<B>新API</B>、<B>并发</B>;</p><h3 id="新语法特性"><a class="header-anchor" href="#新语法特性"></a>新语法特性</h3><ol><li><p>Record<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/RecordKeyword1.java">RecordKeyword1.java</a><br><a href="(https://openjdk.org/jeps/432)">JEP 432: Record Patterns (Second Preview)</a></p></li><li><p>instanceof增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Instanceof2.java">Instanceof2.java</a><br><a href="https://openjdk.org/jeps/394">JEP 394: Pattern Matching for instanceof</a></p></li><li><p>Sealed Classes:密封类<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Permits3.java">Permits3.java</a><br><a href="https://openjdk.org/jeps/397">JEP 397: Sealed Classes (Second Preview)</a></p></li><li><p>TextBlock:文本块增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/TextBlock4.java">TextBlock4.java</a><br><a href="https://openjdk.org/jeps/378">JEP 378: Text Blocks</a></p></li><li><p>switch增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Switch6.java">Switch6.java</a><br><a href="https://openjdk.org/jeps/361">JEP 361: Switch Expressions</a></p></li><li><p>var:局部变量类型<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Var7.java">Var7.java</a><br><a href="https://openjdk.org/jeps/323">JEP 323: Local-Variable Syntax for Lambda Parameters</a></p></li><li><p>Interface Private Method<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/InterfacePrivate8.java">InterfacePrivate8</a><br><a href="https://openjdk.org/jeps/213">JEP 213: Milling Project Coin</a></p></li></ol><h3 id="新API"><a class="header-anchor" href="#新API"></a>新API</h3><ol><li><p>Collection:集合新增方法<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/SequencedCollection1.java">SequencedCollection1.java</a><br>[<a href="https://openjdk.org/jeps/431">https://openjdk.org/jeps/431</a>](JEP 431: Sequenced Collections)</p></li><li><p>BigDecimal.Two<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/BigDecimalTwo4.java">BigDecimalTwo4.java</a></p></li><li><p>HexFormat:16进制转换<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/HexFormat5.java">HexFormat5.java</a></p></li><li><p>Stream.toList<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StreamToList6.java">StreamToList6.java</a></p></li><li><p>Stream.MapMulti:flatMap<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StreamToList6.java">StreamToList6.java</a></p></li><li><p>Collectors.Teeing:集合合并<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/CollectorsTeeing8.java">CollectorsTeeing8.java</a></p></li><li><p>String增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StringIncrease9.java">StringIncrease9.java</a></p></li><li><p>Collectors.of:集合初始化<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/CollectionsFactoryMethods10.java">CollectionsFactoryMethods10.java</a></p></li><li><p>Flow API:实现响应式规范<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/MyPublisher11.java">MyPublisher11.java.java</a></p></li><li><p>Arrays.Mismatch:差集<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/ArraysMismatch12.java">ArraysMismatch12.java</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDK21对比JDK8语法升级指南&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JDK21对比JDK8语法升级指南&quot;&gt;&lt;/a&gt;JDK21对比JDK8语法升级指南&lt;/h2&gt;
&lt;p&gt;JDK8经过JDK11(LTS)、JDK17(LTS)、JDK2</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>1.高并发系统实战-如何解决缓存不同步</title>
    <link href="https://agmtopy.gitee.io/2024/02/27/21.%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/"/>
    <id>https://agmtopy.gitee.io/2024/02/27/21.%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/</id>
    <published>2024-02-27T13:35:37.000Z</published>
    <updated>2024-03-09T03:40:30.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高并发系统实战-如何解决缓存不同步"><a class="header-anchor" href="#高并发系统实战-如何解决缓存不同步"></a>高并发系统实战-如何解决缓存不同步</h2><p>使用缓存需要注意的地方:</p><ol><li>使用缓存需要考虑性价比</li><li>防止穿透缓存直接查询数据库场景</li><li>设置TTL</li></ol><p>缓存数据刷新场景:</p><ol><li><p>单条数据更新场景<br>常见的方法是通过’先更新数据库在删除缓存’的方式来进行出来,更严格的场景是通过延迟双删或者MQ的方式通知删除</p></li><li><p>避免大量临时缓存同时到期失效</p></li><li><p>对于高并发更新缓存的场景可以采用’singleflight(请求合并)'来进行优化</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高并发系统实战-如何解决缓存不同步&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#高并发系统实战-如何解决缓存不同步&quot;&gt;&lt;/a&gt;高并发系统实战-如何解决缓存不同步&lt;/h2&gt;
&lt;p&gt;使用缓存需要注意的地方:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用缓存需要</summary>
      
    
    
    
    <category term="极客时间" scheme="https://agmtopy.gitee.io/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
    
    <category term="高并发" scheme="https://agmtopy.gitee.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="缓存" scheme="https://agmtopy.gitee.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之美</title>
    <link href="https://agmtopy.gitee.io/2023/11/25/13.LeetCode/20.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E4%B8%80/"/>
    <id>https://agmtopy.gitee.io/2023/11/25/13.LeetCode/20.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E4%B8%80/</id>
    <published>2023-11-25T09:20:21.000Z</published>
    <updated>2023-11-27T15:00:12.072Z</updated>
    
    <content type="html"><![CDATA[<h1>数据结构与算法之美</h1><h2 id="链表"><a class="header-anchor" href="#链表"></a>链表</h2><p><img src="https://github.com/agmtopy/noteBook/blob/bcb7ec20e534a7a98747839531829e14b116a23b/png/J-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/S-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89.png?raw=true" alt="链表的定义"></p><p>链表的主要比较对象是数组,最大的差别在于内存空间是否连续不连续上,对于不连续的内存空间就需要<B>索引</B>或<B>下标</B>方式来标识;</p><p>回文串问题如何解决?</p><p>链表解决技巧:</p><ol><li>理解指针或引用的含义</li><li>警惕指针丢失和内存泄漏</li><li>哨兵概念,利用哨兵节点简化编程难度,用哨兵节点来屏蔽首尾节点的特殊处理逻辑</li><li>重点留意边界条件处理<br>如果链表为空时，代码是否能正常工作？<br>如果链表只包含一个结点时，代码是否能正常工作？<br>如果链表只包含两个结点时，代码是否能正常工作？<br>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li><li>画图举例操作</li></ol><p>练习题LeetCode对应编号：206，141，21，19，876</p><h2 id="栈"><a class="header-anchor" href="#栈"></a>栈</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;数据结构与算法之美&lt;/h1&gt;
&lt;h2 id=&quot;链表&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/agmtopy/noteBook/blob/bcb7ec2</summary>
      
    
    
    
    <category term="算法" scheme="https://agmtopy.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://agmtopy.gitee.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>深入理解分布式事务-原理与实践-分布式事务基础</title>
    <link href="https://agmtopy.gitee.io/2023/11/21/19.%E5%88%86%E5%B8%83%E5%BC%8F/1.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E4%B8%80/"/>
    <id>https://agmtopy.gitee.io/2023/11/21/19.%E5%88%86%E5%B8%83%E5%BC%8F/1.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E4%B8%80/</id>
    <published>2023-11-20T16:03:27.000Z</published>
    <updated>2025-07-31T18:02:13.267Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式事务基础</h1><h2 id="事务的基本概念"><a class="header-anchor" href="#事务的基本概念"></a>事务的基本概念</h2><h3 id="ACID"><a class="header-anchor" href="#ACID"></a>ACID</h3><ol><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ol><h3 id="事务的类型"><a class="header-anchor" href="#事务的类型"></a>事务的类型</h3><ul><li><p>扁平事务<br>事务操作中最常见、最简单的事务,无法单独提交整个事务中的部分事务,只能把整个事务全部提交或者回滚;</p></li><li><p>带有保存点的扁平事务<br>内部带有保存点的事务,可以将当前事务回滚到此位置;</p></li><li><p>链式事务<br>链式事务是在带有保存点的扁平事务的基础上,自动将当前事务的上下文隐式的传递给下一事务,也就是说一个事务的提交操作和下一个事务的开始操作合并在一起是具备原子性的;</p></li><li><p>嵌套事务<br>嵌套事务指的是有多个事务处于嵌套状态,共同完成一项任务的处理,整个任务具备原子性;嵌套事务最外层有一个顶层事务,只有当顶层事务完成后才会整体提交;</p></li><li><p>分布式事务基础<br>分布式事务指的是事务的参与者、事务所在的服务器、涉及的资源服务器以及事务管理器分别位于不同的分布式系统下的一个整体事务;</p></li></ul><h3 id="本地事务"><a class="header-anchor" href="#本地事务"></a>本地事务</h3><p>本地事务通常是由关系型数据库本身的事务特性来进行实现的,优缺点:</p><p>优点:</p><ol><li>严格支持ACID特性</li><li>事务可靠,关系型数据的事务是经过严格论证的</li><li>本地事务执行效率高</li><li>事务是由DBMS完成</li><li>不涉及网络通信</li></ol><p>缺点:</p><ol><li>不具备分布式事务的处理能力</li><li>一次事务处理过程只能连接一个支持事务的数据库,即不能用于多个事务性数据库;</li></ol><h3 id="MySql事务基础"><a class="header-anchor" href="#MySql事务基础"></a>MySql事务基础</h3><ul><li>并发带来的问题</li></ul><ol><li>更新丢失<br><B>丢失更新</B>本质上是<B>写操作冲突</B>,解决的方法是让每个事务按照一定的顺序进行写操作;</li><li>脏读<br><B>脏读</B>本质上是<B>读写操作冲突</B>,解决的方法是先写后读,写完之后才能读取;</li><li>不可重复读<br><B>不可重复读</B>本质上是<B>读写操作冲突</B>,解决的方法是先读后写,读完之后才能进行写入操作;</li><li>幻读<br><B>幻读</B>本质上是<B>读写操作冲突</B>,解决的方法是先读后写,读完之后才能进行写入操作;</li></ol><blockquote><p><B>不可重复读</B>和<B>幻读</B>的区别在于,不可重复读关注的是对字段的更新或删除操作,幻读的重点是在于插入操作;</p></blockquote><ul><li>MySQL事务隔离级别</li></ul><ol><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行化</li></ol><p>MySQL的默认事务隔离级别是<B>可重复读</B>,MySQL用MVCC机制保证的在克重复读级别下不会出现<B>脏读</B>&lt;B&gt;不可重复读</B>&lt;B&gt;幻读</B>,其中幻读是通过<B>间隙锁</B>来解决的;</p><ul><li>MySQL中锁的分类</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB.png?raw=true" alt="MySQL中锁的分类"></p><p>读锁和写锁是互斥的,读锁和读锁不互斥,写锁和写锁是互斥的;<br>避免死锁的几种方式:</p><ol><li>尽量让 数据表中的数据检索都通过索引的方式来完成,避免无效索引导致行锁升级为表锁;</li><li>合理设计索引,尽量缩小锁的范围;</li><li>尽量减少查询条件的范围,尽量避免间隙锁或缩小间隙锁的范围;</li><li>尽量控制事务的大小,减少一次事务锁定的资源数量,缩短锁定资源的时间;</li><li>如果一条SQL语句涉及事务加锁操作,则尽量将其放到最后,从而减少锁定资源的时间;</li></ol><ul><li>InnoDB的MVCC的原理</li></ul><p>通过在数据行上定义两个字段:分别是<B>创建行版本号</B>&lt;B&gt;删除行版本号</B>,这两个版本号只标识该行的创建和该行的删除动作的时序;</p><ol><li>查询操作</li></ol><blockquote><p>InnoDB存储引擎只会查询版本号小于或者等于当前查询事务版本号的数据行,这样做的目的是在于只能查询到当前事务开始时那一刻的数据,或者当前事务修改的数据行,并且会判断删除版本号是否大于当前事务ID;</p></blockquote><ol start="2"><li>插入操作</li></ol><blockquote><p>在插入数据时根据当前事务的版本号来维护数据行上的创建版本号,插入操作不维护删除版本号</p></blockquote><ol start="3"><li>更新操作</li></ol><blockquote><p>更新操作是在数据行上将上一条数据的删除版本号更新为当前更新操作的事务版本号,然后重新复制出一条新的数据行,其中创建版本号为当前更新事务的版本号;</p></blockquote><ol start="4"><li>删除操作</li></ol><blockquote><p>删除操作是更新最新的数据行上的DB_DELETED(删除行版本号)</p></blockquote><h2 id="MySQL事务的实现原理"><a class="header-anchor" href="#MySQL事务的实现原理"></a>MySQL事务的实现原理</h2><blockquote><p>MySQL的事务实现是由于锁\MVCC\Redo Log\Undo Log共同来完成的,其中事务的隔离性是通过锁和MVCC机制,原子性和持久性是通过Redo Log,一致性是通过Undo Log来实现的;</p></blockquote><h3 id="Redo-Log"><a class="header-anchor" href="#Redo-Log"></a>Redo Log</h3><p><B>Redo Log</B>向前,记录的是InnoDB执行的动作的日志,也被称为重做日志,用于故障恢复和保证事务的原子性和持久性;<br>Redo Log的日志记录格式是物理日志,记录的是磁盘上数据进行的修改操作;</p><p>其中对于Redo Log写入文件的刷盘时机有以下几种规则:</p><ol><li>由inboodb_flush_log_at_trx_commit配置决定:设置为0或者2时每秒去刷盘,区别在于是否需要通过Log Buffer,设置为1时是每次事务提交时进行刷盘</li><li>每秒刷新一次</li><li>Log Buffer内存使用超过一半时</li><li>当事务中存在checkpoint(检测点),checkpoint机制去刷新脏页</li></ol><h3 id="Undo-Log"><a class="header-anchor" href="#Undo-Log"></a>Undo Log</h3><p><B>Undo Log</B>是用于回滚事务和实现MVCC机制的,采用的是和操作相反的逻辑格式记录日志;<br>Undo Log的回滚段分 为insert undo log和update undo log;<br>insert undo log指的是事务对插入新记录产生的Undo log,只作用于事务回滚时需要,在事务提交后即可丢弃;<br>update undo log指的是事务对记录进行删除和更新操作时产生的Undo log日志,作用于事务回滚以及一致性读,只有当所有的事务id大于该版本时才能进行删除;</p><h3 id="Bin-Log"><a class="header-anchor" href="#Bin-Log"></a>Bin Log</h3><p>Bin log是MySQL用于主从复制和故障恢复的日志格式,其中记录格式分为<B>Row格式</B>&lt;B&gt;Statement格式</B>&lt;B&gt;Mixed模式</B>;</p><p>Row格式:保存的是对数据的修改<br>Statement格式:保存的是执行SQL<br>Mixed格式:默认是Statement,对于无法使用Statemnt格式的采用Row格式</p><p>MySQL事务在提交的时候会记录事务日志和二进制日志,是先记录二进制日志在写入事务日志;<br>两者配合完成了事务的一致性,采用的二阶段提交流程如下所示:</p><ol><li>Prepare阶段<br>a. BinLog Buffer<br>b. RedoLog Buffer -&gt; RedoLog file(prepare标识)</li><li>Commit 阶段<br>a. BinLog Buffer  -&gt; BinLog file<br>b. RedoLog file(prepare标识) -&gt; RedoLog file(commit标识)</li></ol><h3 id="MySQL事务流程"><a class="header-anchor" href="#MySQL事务流程"></a>MySQL事务流程</h3><ul><li>MySQL事务执行流程</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/MySQL%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png?raw=true" alt="MySQL事务执行流程"></p><p>在这个流程中,第4个步骤是记录Undo Log对应的Redo Log到内存缓冲区,因为Undo Log的操作也需要Redo Log进行记录</p><ul><li>MySQL事务恢复流程</li></ul><ol><li>在事务执行到第8步时,MySQL崩溃或者宕机,会优先使用Redo Log恢复数据,然后使用Undo Log回滚数据;</li><li>如果执行到第8步之后,MySQL崩溃或宕机,会使用Redo Log恢复数据;</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/MySQL%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B.png?raw=true" alt="MySQL事务恢复流程"></p><p>大体上可以划分为两个阶段:提交事务和回滚事务,其中提交事务是提交Redo Log已经标记为成功的事务,回滚事务是回滚Redo Log中未提交的事务,同时需要配合bin log完成写入;</p><h3 id="MySQL中的XA事务"><a class="header-anchor" href="#MySQL中的XA事务"></a>MySQL中的XA事务</h3><h2 id="Spring事务的实现原理"><a class="header-anchor" href="#Spring事务的实现原理"></a>Spring事务的实现原理</h2><h2 id="分布式事务的基本概念"><a class="header-anchor" href="#分布式事务的基本概念"></a>分布式事务的基本概念</h2><h2 id="分布式事务的理论基础"><a class="header-anchor" href="#分布式事务的理论基础"></a>分布式事务的理论基础</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式事务基础&lt;/h1&gt;
&lt;h2 id=&quot;事务的基本概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#事务的基本概念&quot;&gt;&lt;/a&gt;事务的基本概念&lt;/h2&gt;
&lt;h3 id=&quot;ACID&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#AC</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="读书笔记" scheme="https://agmtopy.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计_实现领域驱动设计-第二章</title>
    <link href="https://agmtopy.gitee.io/2023/10/28/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://agmtopy.gitee.io/2023/10/28/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-10-28T14:08:00.000Z</published>
    <updated>2023-11-25T09:19:12.834Z</updated>
    
    <content type="html"><![CDATA[<h1>如何理解领域、子域和限界上下文</h1><p>从三个问题开始:</p><ol><li>什么是领域?</li><li>什么是子域?</li><li>什么是限界上下文?</li></ol><h2 id="什么是领域"><a class="header-anchor" href="#什么是领域"></a>什么是领域?</h2><blockquote><p>从广义上来讲,<B>领域</B>是一个组织所做的事情以及其中包含的一切;</p></blockquote><p>这段话的解释应该是,领域是公司或组织所要提供的服务所对应的所有事情,这些事情就是领域;</p><p><B>领域</B>这个词的范围很大,承载太多的含义,领域既可以表示整个系统,也可以标识其中的某个核心域或者支撑子域;在DDD中一个领域被划分为多个<B>子域</B>,领域模型在<B>限界上下文</B>上下文中完成设计/开发;</p><p><img src="https://github.com/agmtopy/noteBook/blob/99706f9bc20ab65b10cc39b038f0b4248b599af3/png/s-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9B%BE2.1%E4%B8%80%E4%B8%AA%E5%90%AB%E6%9C%89%E5%AD%90%E5%9F%9F%E5%92%8C%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E9%A2%86%E5%9F%9F,%E6%A8%A1%E5%9E%8B.png?raw=true" alt=""></p><p>看一个含有子域和限界上下文的领域模型例子:</p><p>最外层中最大的实线表示的就是这个领域驱动模型中的<B>领域</B>,这个领域表示的是一个电子商务系统的领域是由于多个子域和限界上下文组成;<br>在内层中用虚线划分出来的就是<B>子域</B>,可以看到在<B>电子商务系统</B>的领域下有产品目录子域、订单子域、发票子域、物流子域;<br>在内层中还可以看到实线划分出来的<B>界限上下文</B>,界限上下文将不同的子域连接在了一起;</p><p>从上述的例子中<B>电子商务系统</B>就是一个领域,它表示的是电商公司的核心业务,这样我们可以得出领域即业务的结论;</p><h2 id="什么是子域"><a class="header-anchor" href="#什么是子域"></a>什么是子域;</h2><p>从上面的例子中可以看到子域就是更小的范围,子域并不是一定要做的很大,并且包含很多的功能;有些时候,子域可以简单到只包含一套算法,这套算法可能对于业务系统来说非常重要,但是并不包含在这套系统的核心域中;</p><p>子域又可以被划分成:<B>核心域</B>、<B>支撑域</B>、<B>通用域</B>三个部分;</p><p><img src="https://github.com/agmtopy/noteBook/blob/36f56f3815b4b3b5abcf5231aa48ae19410365d3/png/s-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9B%BE2.2%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E5%AD%90%E5%9F%9F%E5%92%8C%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png?raw=true" alt=""></p><p><B>核心域</B>是最高优先级、最资深的领域转换和最优秀的开发团队进行主导,在实施DDD的过程中,需要关注核心域;<br><B>支撑域</B>通常是用来支撑我们的业务的,虽然对于业务的某些方面重要,但是不是核心;<br><B>通用域</B>指的是可以被应用与整个业务系统,类似于基础框架,底层模型;</p><p>实施DDD的过程中应该尽量避免将关注点聚焦在<B>实体</B>、<B>值对象</B>之上,这样会导致缺少一种更广阔的视野,会导致不同的核心杂糅在一起,导致他们将两个模型创建成一个;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;如何理解领域、子域和限界上下文&lt;/h1&gt;
&lt;p&gt;从三个问题开始:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是领域?&lt;/li&gt;
&lt;li&gt;什么是子域?&lt;/li&gt;
&lt;li&gt;什么是限界上下文?&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;什么是领域&quot;&gt;&lt;a class=&quot;header-ancho</summary>
      
    
    
    
    <category term="领域驱动" scheme="https://agmtopy.gitee.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="领域驱动" scheme="https://agmtopy.gitee.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码分析(一)</title>
    <link href="https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/20.Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/20.Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/</id>
    <published>2023-06-27T15:14:13.000Z</published>
    <updated>2023-07-30T08:21:47.088Z</updated>
    
    <content type="html"><![CDATA[<h1>Netty源码分析(一)</h1><h2 id="简述"><a class="header-anchor" href="#简述"></a>简述</h2><p>从IO到NIO体现了java对于流操作的一个变迁,在到构建Netty,这一个系列文章主要讲述的就是Netty框架,第一篇文章从NIO出发;<br>主要分为:<br>Socket编程、IO模型、Netty简介、Netty示例,下面就开始今天的学习吧!</p><h2 id="Socket编程"><a class="header-anchor" href="#Socket编程"></a>Socket编程</h2><p>Socket最早是在4.3BSD UNIX中内置的’Berkeley Socket’演化而来,主要是用于实现进程间的通信;</p><h3 id="Socket通信模型"><a class="header-anchor" href="#Socket通信模型"></a>Socket通信模型</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.Socket%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B.png?raw=true" alt="Socket通信模型"></p><p>Socket通信模型如上图所示,Socket是作为应用层与传输层之间协议,对应用层来说只要按照Socket设计的协议进行调用就可以进行通信了;</p><p>常用的Socket类型有两种:“Stream Sockets”(串流式 Sockets)和&quot;Datagram Sockets&quot;(讯息式 Sockets),Stream Sockets底层使用的是TCP协议,Datagram Sockets底层使用的是UDP协议;</p><blockquote><p>CP 会在传输层对将上层送来的过大数据分割成多个 TCP 段（TCP segments），而 UDP 本身不会，UDP 是信息导向的（message oriented），若 UDP 信息过大时（整体数据包长度超过 MTU），则会由 host 或 router 在 IP 层对数据包进行分割，将一个 IP packet 分割成多个 IP fragments。IP fragmention 的缺点是，到达端的系统需要做 IP 数据包的重组，将多个 fragments 重组合并为原本的 IP 数据包，同时也会增加数据包遗失的可能性。如将一个 IP packet 分割成多个 IP fragments，只要其中一个 IP fragment 遗失了，到达端就会无法顺利重组 IP 数据包，因而造成数据包的遗失，若是高可靠度的应用，则上层协议需重送整个 packet 的数据。</p></blockquote><h3 id="简单示例"><a class="header-anchor" href="#简单示例"></a>简单示例</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/HttpServer01.kt">HttpServer01.kt</a></p><p>开启8880端口,然后返回字符串&quot;socket&quot;,通过这个程序可以看到影响程序响应的因素是在于对响应的一个处理速度,示例中的程序是采用new Thread的方式,但是在还有很多改进的空间:使用线程池;</p><p>这种I/O模型是标准的select/poll模型,有以下这些缺点:</p><ol><li>每次调用需要将数据从用户态拷贝到内核态</li><li>select需要遍历内核态传递进来的全部fd（file descriptor）是指向一个打开的文件或I/O设备的数字标识符</li><li>select支持的文件描述符只有1024个</li></ol><h2 id="NIO模型"><a class="header-anchor" href="#NIO模型"></a>NIO模型</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.IO%E6%A8%A1%E5%9E%8B.png?raw=true" alt="IO模型"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.IO%E6%A8%A1%E5%9E%8B.png?raw=true" alt="IO复用"></p><h2 id="Netty模型"><a class="header-anchor" href="#Netty模型"></a>Netty模型</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.Netty%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png?raw=true" alt="Netty整体流程"></p><p>下面根据这个整体流程先写一个简单示例;</p><h3 id="Netty基本组件"><a class="header-anchor" href="#Netty基本组件"></a>Netty基本组件</h3><h4 id="NioEventLoop组件"><a class="header-anchor" href="#NioEventLoop组件"></a>NioEventLoop组件</h4><p>NioEventLoop同时处理<B>客户端连接</B>、<B>读写客户端发送过来的数据</B></p><h4 id="Channel组件"><a class="header-anchor" href="#Channel组件"></a>Channel组件</h4><h4 id="ByteBuf"><a class="header-anchor" href="#ByteBuf"></a>ByteBuf</h4><h4 id="Pipeline"><a class="header-anchor" href="#Pipeline"></a>Pipeline</h4><p>使用逻辑链,来解析数据</p><h4 id="Channel-Handler"><a class="header-anchor" href="#Channel-Handler"></a>Channel Handler</h4><h3 id="执行过程"><a class="header-anchor" href="#执行过程"></a>执行过程</h3><h4 id="服务端执行流程"><a class="header-anchor" href="#服务端执行流程"></a>服务端执行流程</h4><ol><li><p>创建服务端Channel<br>bind():用户代码入口 -&gt;   initAndRegister():初始化并注册  -&gt;  newChannel():创建服务端Channel</p></li><li><p>初始化服务端Channel</p><p>NioServerSocketChannel.class初始化方法:<br>1. newSocket()通过JDK来创建原生Channel<br>2. NioServerSockerChannelConfig配置TCP参数<br>3. AbstractNioChannel<br>3.1 configureBlocking 设置阻塞/非阻塞模式<br>3.2 AbstractChannel创建id/unsafe/pipeline</p></li></ol><p>添加 ServerBootstrapAcceptor -&gt; ServerBootstrapAcceptor.init()</p><p>添加Handler,</p><ol start="3"><li>注册selector</li></ol><p>在创建和注册channel完成以后,会调用EventLoopGroup接口的实现类进行注册;</p><p>整体流程:</p><ol><li>bind()作为入口</li><li>AbstractBootstrap#initAndRegister作为实现方法</li><li>通过EventLoopGroup的子类,NioEventLoopGroup的父类MultithreadEventLoopGroup实现的<B>register()</B>实现</li></ol><p>register()执行的时候是通过MultithreadEventExecutorGroup#next()方法获取事件处理器,next()方法是通过<a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorChooserFactory.java#L34">DefaultEventExecutorChooserFactory#newChooser</a>来进行选择,选择EventExecutor[] executors数组中的元素时,对于偶数和奇数的处理方式不同;</p><p>register()方法<B>EventLoopGroup#register(Channel channel)</B>接口定义的将传入的channel注册到EvetLoop的方法;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    channel<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> promise<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java#L188">EmbeddedEventLoop</a></p><p>EventLoopGroup通过调用<B>channel.register</B>方法来进行处理;</p><ol start="4"><li>端口绑定<ol><li>AbstractBootstrap#doBind</li><li>AbstractBootstrap#doBind0</li><li>AbstractUnsafe#bind</li><li>NioSocketChannel#doBind</li><li>NioSocketChannel#doBind0</li><li>SocketUtils#bind</li><li>事件广播</li></ol></li></ol><p>'端口绑定’这个功能分为两个动作:1-操作端口绑定、2-绑定事件进行广播</p><p>上述1~6的步骤都是将Netty将设置的端口通过JDK底层方法进行绑定,在绑定完成后是通过后续<B>事件广播</B>功能将这一事件广播出去</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//端口绑定完成以后isActive()返回true</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasActive <span class="token operator">&amp;&amp;</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//广播事件 @TODO</span>            pipeline<span class="token punctuation">.</span><span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>pipeline.fireChannelActive()</B>方法会调用到<B>HeadContext#channelActive</B></p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><h2 id="NioEventLoop组件-v2"><a class="header-anchor" href="#NioEventLoop组件-v2"></a>NioEventLoop组件</h2><ol><li>默认情况下,Netty服务端会启动多少线程?什么时候启动?</li><li>Netty如何解决JDK空轮询问题?</li><li>Netty如何保证异步串行无锁化?</li></ol><h3 id="NioEventLoop创建过程"><a class="header-anchor" href="#NioEventLoop创建过程"></a>NioEventLoop创建过程</h3><h4 id="创建核心线程数"><a class="header-anchor" href="#创建核心线程数"></a>创建核心线程数</h4><p>在我们的示例代码中可以看到</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> bossGroup <span class="token operator">=</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> workerGroup <span class="token operator">=</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>NioEventLoopGroup有两种构造方法,一种传参,一种不传参数,进入构造方法可以看到:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置线程数量</span><span class="token keyword">public</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//不设置线程数量时</span><span class="token keyword">protected</span> <span class="token class-name">MultithreadEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">Executor</span> executor<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>nThreads <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token constant">DEFAULT_EVENT_LOOP_THREADS</span> <span class="token operator">:</span> nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_EVENT_LOOP_THREADS</span><span class="token punctuation">;</span><span class="token comment">//设置线程数量为配置参数值或默认当前核心数*2</span><span class="token keyword">static</span> <span class="token punctuation">&#123;</span>    <span class="token constant">DEFAULT_EVENT_LOOP_THREADS</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">SystemPropertyUtil</span><span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>            <span class="token string">"io.netty.eventLoopThreads"</span><span class="token punctuation">,</span> <span class="token class-name">NettyRuntime</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"-Dio.netty.eventLoopThreads: &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token constant">DEFAULT_EVENT_LOOP_THREADS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建线程执行器"><a class="header-anchor" href="#创建线程执行器"></a>创建线程执行器</h4><h3 id="NioEventLoop启动过程"><a class="header-anchor" href="#NioEventLoop启动过程"></a>NioEventLoop启动过程</h3><h3 id="NioEventLoop执行逻辑"><a class="header-anchor" href="#NioEventLoop执行逻辑"></a>NioEventLoop执行逻辑</h3><ol start="4"><li>业务逻辑:对数据包进行拆包 -&gt; 数据类型处理器</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.kancloud.cn/luoyoub/network-programming/2237006">Socket通信模型</a><br><a href="https://beej-zhcn.netdpi.net/whatissocket/liang_zhong_internet_sockets">Beej’s Guide to Network Programming简体中文</a><br><a href="https://www.cnblogs.com/ZhuChangwu/p/11237899.html">Netty中的策略模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Netty源码分析(一)&lt;/h1&gt;
&lt;h2 id=&quot;简述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;
&lt;p&gt;从IO到NIO体现了java对于流操作的一个变迁,在到构建Netty,这一个系列文章主要讲述的就是Netty框</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Netty" scheme="https://agmtopy.gitee.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty实战第一章</title>
    <link href="https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/25.Netty%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/25.Netty%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2023-06-27T15:14:13.000Z</published>
    <updated>2023-10-23T14:50:02.682Z</updated>
    
    <content type="html"><![CDATA[<h1>Netty实战第一章</h1><h2 id="简述"><a class="header-anchor" href="#简述"></a>简述</h2><p>在学习Netty源码的过程中,十分吃力看来还是需要先从<B>使用</B>在到<B>研究</B>过程,因此将《Netty实战》一书重新拾起,以下是相关笔记;</p><h2 id="Netty基础组件"><a class="header-anchor" href="#Netty基础组件"></a>Netty基础组件</h2><ol><li>Channel;</li><li>回调</li><li>Future</li><li>事件和ChannelHandler</li></ol><h3 id="Channel"><a class="header-anchor" href="#Channel"></a>Channel</h3><p>Channel是对Java NIO的一个抽象;</p><blockquote><p>代表一个到实体(例如硬件设备、文件、网络套接字)的开发连接,可以执行<B>读操作</B>和<B>写操作</B>,可以把Channel看作传入或传出数据的载体.因此它们可以被打开或关闭;</p></blockquote><h3 id="回调"><a class="header-anchor" href="#回调"></a>回调</h3><p>一个<B>回调</B>其实就是一个方法,一个指向已经被提供给另外一个方法的方法的引用,这使得后者方法可以在适当的时候来回调前者;</p><h3 id="Future"><a class="header-anchor" href="#Future"></a>Future</h3><p><B>Future</B>提供了另外一种在操作完成时通知应用程序的方式.这个对象可以看作是一个异步操作的结果的<B>占位符</B>;它将在未来的某个时刻完成,并提供对其结果的访问;在JDK中提供的已有的Future实现,需要手动检查对于操作是否完成或者需要柱塞,十分繁琐;因此在Netty提供了<B>ChannelFuture</B>实现,用于在执行异步操作的时候使用;</p><h3 id="事件和ChannelHandler"><a class="header-anchor" href="#事件和ChannelHandler"></a>事件和ChannelHandler</h3><p>Netty中使用不同的事件来通知我们状态的改变或者操作的状态,如下图所示的事件驱动</p><p>!(ChannelHandler链的入站和出站事件)[]</p><hr><ul><li><p>Future、回调和ChannelHandler<br>Netty的异步编程模型是建立在Future和回调的概念之上的,而将事件分派到ChannelHandler的方法则是建立在这个基础之上更高层的概念;</p></li><li><p>选择器、事件和EventLoop<br>Netty通过触发事件将Selector从应用程序中抽象出来,简化了原来需要手动编写的派发代码.在netty内部会为每一个Channel分配一个EventLoop用于处理所有事件,包括:</p></li></ul><ol><li>注册感兴趣的事件</li><li>将事件派发给ChannelHandler</li><li>安排进一步动作</li></ol><p>EventLoop本身就是一个线程驱动,其处理了一个Channel的所有I/O事件,并且在该EventLoop的整个生命周期内都不会发生改变;</p><h2 id="Netty的Hello-World"><a class="header-anchor" href="#Netty的Hello-World"></a>Netty的Hello World</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.Echo%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8.png?raw=true" alt="Echo客户端与服务端"></p><p>服务端是可以同时处理多个客户端连接的,客户端在建立一个连接之后,它会先服务端发送一个或者多个消息,反过来,服务器邮费将每个消息发回客户端,这就是典型的<B>请求⇌响应</B>模式;</p><h3 id="服务端代码"><a class="header-anchor" href="#服务端代码"></a>服务端代码</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoServerHandler.kt">EchoServerHandler</a></p><ul><li>EchoServerHandler实现了业务处理逻辑</li></ul><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoServer.kt">EchoServer</a></p><p>EchoServer创建引导过程:</p><ul><li>创建一个ServerBootstrap的实例来进行引导和绑定服务器</li><li>创建并分配一个<B>NioEventLoopGroup</B>实例以进行事件的处理,如接受新连接以及读写数据</li><li>指定服务器绑定的本地InetSocketAddress</li><li>使用一个EchoServerHandler实例初始化每一个新的Channel</li><li>调用ServerBootstrap.bind()方法以绑定服务器</li></ul><h3 id="客户端代码"><a class="header-anchor" href="#客户端代码"></a>客户端代码</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoClient.kt">EchoClient.kt</a><br><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoClientHandler.kt">EchoClientHandler.kt</a></p><p>EchoClientHandler业务逻辑:</p><ul><li>channelActive - 在到服务器的连接已经建立之后将被调用</li><li>channelRead - 当从服务器收到一条消息时被调用</li><li>exceptionCaught - 在处理过程中引发异常时将被调用</li></ul><p><B>channelRead</B>方法,每当接收到数据时,都会调用这个方法,需要注意的是,它在接受服务器发送的消息时可能会被<B>分段接收</B>;<br>举一个例子就是,当服务器发送5 Byte时,客户端不能保证这5 Byte会被一次性全部接收,可能是第一次接受到3 Byte,第二次接受到2 Byte;或者反之亦然;</p><p>TCP协议作为一个面向流的协议,它会保证数据流会按照服务端的发送顺序来进行接收;</p><p>EchoClient引导逻辑:</p><ul><li>与服务端引导逻辑类似</li><li>创建BootStrap,客户端这里是<B>BootStrap</B>,不是ServerBootStrap</li><li>指定EventLoopGroup处理客户端事件</li><li>选择NIO传输的Channel类型</li><li>设置服务端的地址</li><li>设置业务处理链</li></ul><h3 id="执行结果"><a class="header-anchor" href="#执行结果"></a>执行结果</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.Echo%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png?raw=true" alt="Echo客户端与服务器执行结果"></p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>通过Echo服务端与客户端的配合,我们初步了解到了创建一个Netty程序需要有两部分组成:<B>引导程序</B>、<B>业务处理</B>,接下来我们详细的了解一下Netty的组件和设计;</p><h2 id="Netty的组件和设计"><a class="header-anchor" href="#Netty的组件和设计"></a>Netty的组件和设计</h2><p>Netty的组件设计可以分为两个大类:<B>Netty网络抽象的代表</B>和<B>管理数据流和业务逻辑组件</B>;</p><p>Netty网络抽象的代表:</p><ul><li>Channel - 对Socket的抽象</li><li>EventLoop - 控制流、多线程处理、并发</li><li>ChannelFuture - 异步通知</li></ul><p>管理数据流和业务逻辑组件:</p><ul><li>ChannelHandler - 业务程序逻辑的容器</li><li>ChannelPipeline - 事件处理链</li></ul><h3 id="Channel接口"><a class="header-anchor" href="#Channel接口"></a>Channel接口</h3><p>Channel是对Socket的抽象接口,提供的API用于简化Socket类使用的复杂性,常见的实现类有:</p><ul><li>EmbeddedChannel</li><li>LocalServerChannel</li><li>NioDatagramChannel</li><li>NioSctpChannel</li><li>NioSocketChannel</li></ul><h3 id="EventLoop接口"><a class="header-anchor" href="#EventLoop接口"></a>EventLoop接口</h3><blockquote><p>EventLoop接口是Netty的核心抽象,用于处理连接的生命周期中所发生的事件;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.EventLoop%E6%8E%A5%E5%8F%A3%E7%B1%BB.png?raw=true" alt="EventLoop接口类"></p><h3 id="ChannelFuture"><a class="header-anchor" href="#ChannelFuture"></a>ChannelFuture</h3><p>在Netty中所有的I/O操作都是异步进行处理的,因为一个操作可能不会立即返回结果,所以Netty中定义了<B>一种用于在之后某个事件点确定其结果的方法</B>,这个结果就是<B>ChannelFuture</B>,其addListener方法注册了一个ChannelFutureListener,以便在某个操作完成时得到通知;</p><h3 id="ChannelPipeline"><a class="header-anchor" href="#ChannelPipeline"></a>ChannelPipeline</h3><p>ChannelPipeline为ChannelHandler链提供了容器,并定义了用于在该链上传播入站和出站事件流的API.当Channel被创建时,它被自动分配到它专属的ChannelPipenlines上;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.ChannelInboundHandler%E4%B8%8EChannelOutboundHandler.png?raw=true" alt="ChannelHandler的in/out实现接口"></p><p>ChannelHandler安装到ChannelPipeline中的过程如下所示:</p><ul><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中</li><li>当ChannelInitializer.initChannel()方法被调用时,ChannelInitializer将在ChannelPipline中安装一组自定义的ChannelHandler</li><li>ChannelInitializer将它自己从ChannelPipeline中移除</li></ul><p>源代码如下:</p><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/ChannelInitializer.java#L126">ChannelInitializer.java</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initMap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Guard against re-entrance.</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span>            <span class="token comment">// We do so to prevent multiple calls to initChannel(...).</span>            <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ctx<span class="token punctuation">.</span><span class="token function">isRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ctx<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/a12a0124efc418438a7179a42d4826f5db5676ba/src/main/kotlin/simple/echo/EchoClient.kt#L24">EchoClient</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>object <span class="token operator">:</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    override fun <span class="token function">initChannel</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> <span class="token class-name">SocketChannel</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ctx<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">EchoClientHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ChannelInitializer.initChannel()将一组自定义的ChannelHandler注册到ChannelPipeline链上;ChannelHandler是专门为支持广泛的用途而设计,可以将它看作为是处理往来ChannelPipeline事件的任何代码的通用容器;使得事件流经ChannelPipline是ChannelHandler的工作,它们是在应用程序的初始化或者引导阶段被安装的;</p><h3 id="ChannelHandler"><a class="header-anchor" href="#ChannelHandler"></a>ChannelHandler</h3><p>在Netty中以适配器的形式提供了大量默认的ChannelHandler实现类,用于简化应用程序处理逻辑的开发过程;常用的适配器类有:<B>ChannelHandlerAdapter</B>、<B>ChannelInboundHandlerAdapter</B>、<B>ChannelOutboundHandlerAdapter</B>、<B>ChannelDuplexHandler</B></p><ul><li>编码器和解码器</li></ul><blockquote><p>当你通过Netty发送或接收一个消息的时候,就将会发生一次数据转换,也就是说字节码会转换为另外一种格式,通常就是一个java对象;如果是出站消息,则会发生相反方向的转换:它将从它的当前格式被编码为字节;Netty为编码器和解码器提供了不同类型的抽象类;</p></blockquote><p>Netty提供的编码器和解码器适配器类都实现了<B>ChannelOutboundHandler接口</B>或者<B>ChannelInboundHandler接口</B></p><h3 id="引导程序"><a class="header-anchor" href="#引导程序"></a>引导程序</h3><p>从上面的例子中可以看到,我们在设置Netty的客户端或者服务端配置时,首先选择引导类<B>BootStrap</B>或者<B>ServerBootStrap</B>,下面是这两种引导类下一些区别;</p><table><thead><tr><th>类别</th><th>BootStrap</th><th>ServerBootStrap</th></tr></thead><tbody><tr><td>网络编程的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td>EventLoopGroup的数目</td><td>1</td><td>2</td></tr></tbody></table><p><img src="https://github.com/agmtopy/noteBook/blob/e1480b344e9bbe0242507dc79c7fdef266030bef/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E5%85%B7%E6%9C%89%E4%B8%A4%E4%B8%AAEventLoopGroup%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8.png?raw=true" alt="具有两个EventLoopGroup的服务器"></p><p>服务器设置两组不同的Channel,第一组只包含服务器自身的已绑定到某个本地端口的正在监听的套接字、第二组将包含所有已创建的用来处理传入的客户端连接的Channel;<br>与ServerChannel相关联的EventLoopGroup将分配一个负责为传入连接请求创建Channel的EventLoop;一旦连接被接受,第二个EventLoopGroup将会给它的Channel分配一个EventLoop;</p><h2 id="传输"><a class="header-anchor" href="#传输"></a>传输</h2><p>Netty中最为重要的知识,传输-可以使用<B>阻塞传输</B>、<B>异步传输</B>、Local等方式,在Netty中它为所有的传输实现都提供了通用的API;</p><h3 id="例子"><a class="header-anchor" href="#例子"></a>例子</h3><ol><li>JDK阻塞处理的例子</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/PlainOioServer.kt">PlainOioServer.java</a></p><p>在这段代码在每次接受连接时都会创建一个新的线程。这会导致大量的线程被创建和销毁，消耗大量的系统资源。为了避免这种情况，可以使用线程池来管理线程，重复使用现有的线程来处理新的连接、或者使用非柱塞的方式来进行,下面是一个非阻塞的例子;</p><ol start="2"><li>JDK非阻塞的例子</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/PlainNioServer.kt">PlainNioServer.java</a></p><p>从阻塞切换到非阻塞的代码十分复杂,下面看一下Netty是如何屏蔽这部分差异的</p><ol start="3"><li>使用Netty的阻塞网络处理</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/NettyOioServer.kt">NettyOioServer.java</a></p><ol start="4"><li>使用Netty的非阻塞网络处理</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/NettyNioServer.kt#L18C1-L18C1">NettyNioServer.java</a></p><p>可以看到Netty切换网络通道只需要调整<B>NioEventLoopGroup</B>、<B>NioServerSocketChannel</B>即可;</p><h3 id="传输API"><a class="header-anchor" href="#传输API"></a>传输API</h3><blockquote><p>传输API的核心是interface Channel,它被用于所有的I/O操作,Channel类的层次结构如下所示:</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/e1480b344e9bbe0242507dc79c7fdef266030bef/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.Channel%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png?raw=true" alt="Channel接口的层次结构"></p><p>每一个Channel都会被分配一个<B>ChannelPipeline</B>和<B>ChannelConfig</B>,ChannelConfig中包含了该Channel的所有配置设置,并且<B>支持热更新</B>;<br>由于Channel是独一无二的,所以为了保证顺序Channel实现了Comparable接口;</p><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/Channel.java#L77">Channel.java</a></p><p>ChannelPipeline是用于持有处理入站和出站以及业务处理事件的<B>ChannelHandler</B>实例,在代码中主要是add/remove/get等方法;<br>ChannelPipeline是典型的过滤器模式,数据经过不同的ChannelHandler进行处理;</p><p>在上一个步骤中引出了一个重要的类<B>ChannelHandler</B>,它实现了所有应用程序用于处理状态变化以及数据处理的逻辑,常用的类型有:</p><ol><li>数据格式转换,将数据同二进制格式转换为业务格式,反之亦然</li><li>提供异常的通知</li><li>提供Channel变为活动的或者非活动的通知</li><li>提供当Channel注册到EventLoop或者从EventLoop注销时的通知</li><li>提供有关用户自定义事件的通知</li></ol><p>channel重要的方法列表:</p><p><img src="https://github.com/agmtopy/noteBook/blob/f979c8e58879f1619e010dc459ca4e67871ece33/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.Channel%E7%9A%84%E6%96%B9%E6%B3%95.png?raw=true" alt="channel的方法"></p><p>channel是<B>线程安全</B>的,可以多个线程同时操作;</p><h3 id="内置的传输类型"><a class="header-anchor" href="#内置的传输类型"></a>内置的传输类型</h3><p>Netty内置了一些开箱即用的传输;这些传输包括jdk、linux等的特殊类型;</p><table><thead><tr><th>名称</th><th>包</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.nio</td><td>使用java.nio.channels包作为基础,基于选择器的方式</td></tr><tr><td>Epooll</td><td>io.netty.channel.epoll</td><td>由JNI驱动的epoll()和非阻塞I/O,这个传输支持只有在Linux上可用的多种特性.如SO_REUSEPORT,比NIO传输更快,并且是完全非阻塞的;</td></tr><tr><td>OIO</td><td>io.netty.channel.socket.oio</td><td>使用java.net包作为基础,使用的是阻塞流</td></tr><tr><td>Local</td><td>io.netty.channel.local</td><td>在JVM内部通过管道进行通信的本地传输形式</td></tr><tr><td>Embedded</td><td>io.netty.channel.embedded</td><td>测试channelHandler使用</td></tr></tbody></table><h4 id="NIO-非阻塞I-O"><a class="header-anchor" href="#NIO-非阻塞I-O"></a>NIO-非阻塞I/O</h4><p>NIO提供了一个所有I/O操作的全异步的实现,它是基于JDK1.4引入的NIO子系统中的选择器API来进行实现;</p><p>选择器背后的基本概念是充当一个<B>注册表</B>,在哪里你将可以请求在Channel的状态发生变化时得到通知,可能发生的状态变化有:</p><ul><li>新的Channel已被接受并且就绪</li><li>Channel连接已经完成</li><li>Channel有已经就绪的可供读取的数据</li><li>Channel可用于写数据</li></ul><p>选择器运行在一个检查状态变化并对其做出相应响应的线程上,在应用程序对状态的改变做出响应之后,选择器状态会被重置,然后继续重复这过程;</p><p><img src="https://github.com/agmtopy/noteBook/blob/4e4b9a4baccf9ccc5a16f77baa36b9117dc23f1e/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E9%80%89%E6%8B%A9%E5%B9%B6%E5%A4%84%E7%90%86%E7%8A%B6%E6%80%81%E7%9A%84%E5%8F%98%E5%8C%96%E8%BF%87%E7%A8%8B.png?raw=true" alt="选择并处理状态的变化"></p><p><img src="https://github.com/agmtopy/noteBook/blob/4e4b9a4baccf9ccc5a16f77baa36b9117dc23f1e/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.%E9%9B%B6%E6%8B%B7%E8%B4%9D.png?raw=true" alt="零拷贝"></p><p>零拷贝其实在Windows下有API进行支持;</p><h4 id="Epooll-用于Linux的本地非阻塞传输"><a class="header-anchor" href="#Epooll-用于Linux的本地非阻塞传输"></a>Epooll-用于Linux的本地非阻塞传输</h4><p>Netty为Linux提供了一组NIO API,其以一种和它本身的设计更加一致的方式使用epoll,实现类是<B>EpollEventLoopGroup</B></p><h4 id="OIO-旧的阻塞I-O"><a class="header-anchor" href="#OIO-旧的阻塞I-O"></a>OIO-旧的阻塞I/O</h4><blockquote><p>Netty的OIO传输实现代表了一种折中的办法;它可以通过常规的传输API使用,但是由于它是建立在java.net包的阻塞实现之上的,所以它不是异步的;Netty利用<B>SO_TIMEOUT</B>这个Socket标识,它指定了等待一个I/O操作完成的最大毫秒数.如果这个操作在指定时间间隔内没有完成,则将会抛出一个<B>SocketTimeout_Exception</B>,Netty将捕获这个异常并继续循环处理,在下次运行EventLoop时,它将再次尝试;</p></blockquote><p><img src="" alt="OIO的处理逻辑"></p><h4 id="用于JVM内部通信的Local传输"><a class="header-anchor" href="#用于JVM内部通信的Local传输"></a>用于JVM内部通信的Local传输</h4><blockquote><p>Netty提供了一个Local传输,用于在同一个JVM中运行的客户端和服务端程序之间的异步通信.在这个传输中,和服务器Channel相关联的SocketAddress并没有绑定物理网络地址;</p></blockquote><h4 id="Embedded-传输"><a class="header-anchor" href="#Embedded-传输"></a>Embedded 传输</h4><blockquote><p>Netty提供了一种额外的传输方式,使得你可以将一组ChannelHandler作为帮助器嵌入到其他的ChannelHandler内部;</p></blockquote><h2 id="ByteBuf"><a class="header-anchor" href="#ByteBuf"></a>ByteBuf</h2><p>网络数据的基本单位是字节,Java NIO提供了<B>ByteBuffer&lt;/B作为它的字节容器,但是这个类使用过于复杂;因此Netty在内部进行了分封装,通过API提供了两个类:<B>ByteBuf</B>和<B>ByteBufHolder</B>;</p><p>ByteBuf内部会维护两个不同的<B>索引</B>,一个用于读取,一个用于写入,当你从ByteBuf中读取数据时,它的readderIndex将会递增已经被读取过的字节数.同样的,当你写入ByteBuf时,它的writeIndex也会进行递增;</p><ol><li><p>堆缓冲区<br>最常用的ByteBuf模式就是将数据存储在JVM的堆空间中;</p></li><li><p>直接缓冲区<br><B>直接缓存区</B>是另外一种ByteBuf模式,我们期望用用于对象创建的内存分配永远都来自于堆中,但这并不是必须的,在JDK 1.4中引入的ButeBuffer类允许JVM实现通过本地调用来分配内存;这样可以避免每次在调用本地I/O操作之前将缓冲区的内容复制到一个中间缓冲区中;<br>“直接缓冲区的内存将驻留在常规的会被垃圾回收的堆内存之外”,直接缓冲区的主要缺点是<B>相对与基于堆内存的缓冲区,它们的分配和释放都比较昂贵</B></p></li><li><p>复合缓冲区<br><B>复合缓冲区</B>指的是,它为多个ByteBuf提供一个聚合视图,通过这个聚合视图可以根据需要进行添加和删除ByteBuf实例,用于补充JDK中的ByteBuffer中缺失的这个特性;<br>Netty中通过ByteBuf的子类 -&gt; CompositeByteBuf来实现这个功能,它提供了一个将多个缓冲区聚合成为单个合并缓冲区的虚拟实现;</p></li></ol><h2 id="字节级操作"><a class="header-anchor" href="#字节级操作"></a>字节级操作</h2><ol><li>随机访问索引</li><li>顺序访问索引</li><li>可丢弃字节</li><li>可读字节</li><li>可写字节</li><li>索引管理</li><li>查找操作</li><li>派生缓冲区</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Netty实战第一章&lt;/h1&gt;
&lt;h2 id=&quot;简述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;
&lt;p&gt;在学习Netty源码的过程中,十分吃力看来还是需要先从&lt;B&gt;使用&lt;/B&gt;在到&lt;B&gt;研究&lt;/B&gt;过程,因此将《Net</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Netty" scheme="https://agmtopy.gitee.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>G1GC的算法与实现之实现篇笔记</title>
    <link href="https://agmtopy.gitee.io/2023/05/06/20.%E7%AC%94%E8%AE%B0/41.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2023/05/06/20.%E7%AC%94%E8%AE%B0/41.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-05T21:32:23.000Z</published>
    <updated>2023-06-26T15:24:52.567Z</updated>
    
    <content type="html"><![CDATA[<h1>《深入Java虚拟机：JVM G1GC的算法与实现》-实现篇笔记</h1><p>在上一篇文章中我们记录了G1GC的算法包括<B>内存结构</B>、<B>标记位图</B>、<B>SATB本地队列</B>、<B>转移专用记忆集合</B>等关键组成部分,接下我们会对HotSpotVM的具体实现方法进行分析;</p><h2 id="HotSpot的代码结构"><a class="header-anchor" href="#HotSpot的代码结构"></a>HotSpot的代码结构</h2><p>HotSpot的源码位于src/hotspot下,如下所示</p><table><thead><tr><th>文件夹</th><th>说明</th></tr></thead><tbody><tr><td>cpu</td><td>依赖CPU的代码</td></tr><tr><td>os</td><td>依赖操作系统的代码</td></tr><tr><td>os_cpu</td><td>依赖操作系统和CPU的代码</td></tr><tr><td>share</td><td>通用代码</td></tr></tbody></table><p>在share下又划分为以下文件结构</p><table><thead><tr><th>文件夹</th><th>说明</th></tr></thead><tbody><tr><td>ci</td><td>C1编译器</td></tr><tr><td>classfile</td><td>Java类文件的定义</td></tr><tr><td>gc</td><td>GC部分</td></tr><tr><td>interpreter</td><td>Java解释器</td></tr><tr><td>oops</td><td>对象结构的定义</td></tr><tr><td>runtime</td><td>VM运行时所需库</td></tr></tbody></table><p>参考<a href="https://github.com/openjdk/jdk/tree/master/src/hotspot/share">openjdk</a></p><p>HotSpot内部的大部分代码都是继承与以下两个类中的一个:</p><ul><li>CheapObj类</li><li>AllStatic类</li></ul><p>下面对这两个类进行分析:</p><ul><li>CheapObj类</li></ul><blockquote><p>CheapObj类是一个由C的堆内存空间来管理的类,CheapObj类的子类实例都会被分配到C的堆内存上;</p></blockquote><ul><li>AllStatic类</li></ul><blockquote><p>AllStatic类是一个&quot;仅带有静态信息&quot;的特殊类,继承AllStatic的类不需要创建实例;</p></blockquote><p>由于HotSpotVM需要运行于各种操作系统之上.因此,开发者为HotSpotVM设计了一种巧妙的结构(接口),使得它能够通过统一的接口来处理各种操作系统的API;</p><ul><li>os.hpp</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">class os<span class="token operator">:</span> AllStatic <span class="token punctuation">&#123;</span>  friend class VMStructs<span class="token punctuation">;</span>  friend class JVMCIVMStructs<span class="token punctuation">;</span>  friend class MallocTracker<span class="token punctuation">;</span><span class="token comment">//省略</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>os类中定义的成员函数在HotSpotVM中都有对应的各种操作系统实现:</p><ol><li>os/posix/vm/os_posix.cpp</li><li>os/linux/vm/os_linux.cpp</li><li>os/windows/vm/os_windows.cpp</li><li>os/solaris/vm/os_solaris.cpp<br>在构建OpenJDK时,hotspot会从以上文件中,选择与当前系统对应的文件进行编译和链接;</li></ol><p>当VM调用os.hpp时,对于操作系统下的实现类就会执行具体方法;</p><ul><li>os_windows.cpp</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef _DEBUG#include &lt;crtdbg.h&gt;#endif#include &lt;windows.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;stat.h&gt;#include &lt;sys&#x2F;timeb.h&gt;#include &lt;objidl.h&gt;#include &lt;shlobj.h&gt;&#x2F;&#x2F;省略....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>os_windows.cpp</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef _DEBUG#include &lt;crtdbg.h&gt;#endif&#x2F;&#x2F; put OS-includes here# include &lt;sys&#x2F;types.h&gt;# include &lt;sys&#x2F;mman.h&gt;# include &lt;sys&#x2F;stat.h&gt;# include &lt;sys&#x2F;select.h&gt;# include &lt;pthread.h&gt;# include &lt;signal.h&gt;# include &lt;endian.h&gt;# include &lt;errno.h&gt;# include &lt;dlfcn.h&gt;&#x2F;&#x2F;省略....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在不同的实现下引入了不同的<B>.h</B>文件;</p><h2 id="堆结构"><a class="header-anchor" href="#堆结构"></a>堆结构</h2><p>堆结构大体上可以划分为两个部分:</p><ol><li>程序员选择的GC算法所使用的内存空间</li><li>常驻内存空间</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/VM%E5%A0%86%E5%88%92%E5%88%86.png?raw=true" alt="VM堆划分"></p><p>常驻内存空间通常是用于分配类型信息或方法信息等永久存在的对象,该空间几乎不会随着GC算法的变化而变化;</p><blockquote><p>在 JDK 8 及之后的版本中，永久代已经被移除，被一个称为元空间（Metaspace）的区域所取代。因此，可以说 JDK 8 及之后的版本中没有永久代这一概念。不过，元空间和永久代的作用类似，都是用于存放类信息等元数据的区域，只不过它们的实现方式和内存模型不同。 元空间和永久代最大的不同在于，元空间使用本地内存（native memory）存储元数据，而不是像永久代一样使用虚拟机内存（Java heap）来存储。这样的好处是可以避免永久代出现的内存溢出问题，因为元空间的大小可以根据需要动态调整，并且可以使用操作系统的内存分配器来管理内存。另外，元空间与永久代相比还有一些其他的不同点，例如元空间可以通过命令行参数来配置大小、元空间的垃圾回收机制与永久代不同等等。但是，从常驻内存空间的角度来说，可以认为元空间已经取代了永久代，成为了 Java 虚拟机中存放类信息等元数据的常驻内存区域。</p></blockquote><p>在JVM中是通过<B>Universe:initialize_heap</B>来实现创建堆内存的功能,如下所示,会根据<B>create_heap()</B>、<B>initialize()</B>方法选择不同的实现;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%88%9B%E5%BB%BA%E5%A0%86%E5%86%85%E5%AD%98%E9%80%89%E6%8B%A9%E6%89%A7%E8%A1%8C%E7%B1%BB.png?raw=true" alt="创建堆内存选择执行类"></p><p>下面详细看一下<B>G1CollectedHeap</B>,其中有三个重要的成员变量:</p><ol><li><B>_hrs</B>:通过数组维护所有的HeapRegion</li><li><B>_young_list</B>:新生代HeapRegion的链表</li><li><B>_free_region_list</B>:空闲HeapRegion的链表</li></ol><blockquote><p>管理各个区域是通过<B>HeapRegion</B>类来实现的,在G1CollectedHeap中为了快速找到每一个HeapRegion,因此用HeapRegionSeq（Heap Region Sequence）是用于表示堆区域（Heap Region）的序列或集合的地址,_hrs就是指向HeapRegionSeq的指针;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC%E5%A0%86%E7%BB%93%E6%9E%84.png?raw=true" alt="G1GC堆的结构"></p><h2 id="分配器"><a class="header-anchor" href="#分配器"></a>分配器</h2><h3 id="内存分配的流程"><a class="header-anchor" href="#内存分配的流程"></a>内存分配的流程</h3><p>Vm堆空间申请 -&gt; VM堆空间分配 -&gt; 对象的分配<br>下图展示这个过程</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%B5%81%E7%A8%8B.png?raw=true" alt="内存分配的流程"></p><p>需要注意的是在Linux上,用于实现内存申请和分配的是<B>mmap()</B>,在Linux中没有申请内存空间的概念,调用mmap()后就会分配内存空间,不过并不是立即分配物理空间,在这这中间还有一层虚拟内存;只有在分配到的内存空间被访问时才会实际发生物理内存分配;</p><h3 id="对象分配的流程"><a class="header-anchor" href="#对象分配的流程"></a>对象分配的流程</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.jpg?raw=true" alt="对象分配的流程"></p><h3 id="TLAB"><a class="header-anchor" href="#TLAB"></a>TLAB</h3><p>TLAB(Thread Local Allocation Buffer,线程本地分配缓冲区)是对象分配的要点之一;<br>VM是所有线程共享的内存空间,因此当需要在VM堆上分配对象时,必须锁定整个堆,以防止其他线程同时分配对象;<br>但是为了让不同线程工作于不同的CPU核心上时需要分配对象时不用等待VM堆上的锁释放,因此引入了TLAB的概念,解决思路就是让各个线程拥有自己的专用对象分配缓冲区,从而减少锁定次数;<br>当一个线程第一次分配对象时,它会从VM堆中得到一定大小的内存空间,然后作为它自己的缓冲区保存下来,当这个线程需要分配对象时,优先从这块专用区域进行分配;</p><h2 id="对象结构"><a class="header-anchor" href="#对象结构"></a>对象结构</h2><ul><li>oopDesc类</li></ul><blockquote><p>oopDesc类是所有GC目标对象的抽象基类,继承自oopDesc的类实例都是GC的目标对象;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/429872403e969e497aff2255a0064c748a8385e8/png/j-jvm/oopDesc%E7%B1%BB.png?raw=true" alt="oopDesc类"></p><blockquote><p>在第第56行代码中的_mark变量是对象头,_mark中不仅保存了标记-清除算法的标记,还保存了对象所需的其他各种信息;在oopDesc中有一个指向自己类的指针,在代码的<br>第57行_metadata.在大部分情况下,这个联合体中保存的是_klass变量的值,kass保存的是指向对象类的指针.</p></blockquote><ul><li>klass<br>klass继承于oopDesc,用来表示类型信息,Klass的实例是作为klassOop的一部分创建出来的;</li></ul><h2 id="HotSpot的线程管理"><a class="header-anchor" href="#HotSpot的线程管理"></a>HotSpot的线程管理</h2><p>在Windws和Linux中都有用于调用操作系统线程的库,在Windows上我们使用的是Windows Api调用线程,在Linux上我们使用的是POSIX线程标准的Pthreads库来调用线程;</p><p>在HotSpotVm内可以使用相同的方式调用不同操作系统得益于设计出来’线程抽象层’,最重要的就是<B>Thread</B>;</p><h3 id="Thread类"><a class="header-anchor" href="#Thread类"></a>Thread类</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/Thread%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png?raw=true" alt="Thread类的继承关系"></p><p>在Thread类中通过定义<B>虚函数run()</B>,子类进行实现,其中<B>JavaThread</B>表示的就是Java语言级别运行的线程,<B>NameThread类</B>是支持线程命名的,我们可以通过为对NameThread实例设置一个唯一名字;</p><h3 id="线程的什么周期"><a class="header-anchor" href="#线程的什么周期"></a>线程的什么周期</h3><ol><li>创建Thread类的实例</li><li>创建线程(调用os:create_thread)</li><li>开始线程处理(调用os:start_thread)</li><li>结束线程处理</li><li>释放Thread类实例</li></ol><p>一个windows下创建线程的例子:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadFunc(LPVOID);int main()&#123;    HANDLE hThread;    DWORD threadId;    hThread &#x3D; CreateThread(NULL, 0, ThreadFunc, 0, 0, &amp;threadId); &#x2F;&#x2F; 创建线程    printf(&quot;我是主线程， pid &#x3D; %d\n&quot;, GetCurrentThreadId());      &#x2F;&#x2F; 输出主线程pid    Sleep(2000);&#125;DWORD WINAPI ThreadFunc(LPVOID p)&#123;    printf(&quot;我是子线程， pid &#x3D; %d\n&quot;, GetCurrentThreadId()); &#x2F;&#x2F; 输出子线程pid    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程的互斥处理"><a class="header-anchor" href="#线程的互斥处理"></a>线程的互斥处理</h3><ul><li>什么是互斥处理?</li></ul><blockquote><p>如果线程共享内存空间,那么就会出现多个线程同时在一个地址上进行读写的情况.有些数据会被其他线程所改变,并且这样的改变是意料之外的;对于这样被修改的对象,被称为&quot;临界区&quot;.对于&quot;临界区&quot;的处理必须要按照原子操作;</p></blockquote><ul><li>如何实现互斥处理?</li></ul><ol><li><p>使用互斥量<br>互斥量可以是全局锁/标识/互斥原语等,个人理解互斥量主要是两个特点:全局可见和唯一持有</p></li><li><p>监视器<br>线程之间通过监视器来完成互斥和协助,在jvm中监视器是由Object中的monitor对象头来进行实现,</p></li></ol><blockquote><p><B>互斥方式可以避免线程使用共享数据时被其它线程干扰，而协作方式则帮助多个线程共同完成同一个目标</B></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《深入Java虚拟机：JVM G1GC的算法与实现》-实现篇笔记&lt;/h1&gt;
&lt;p&gt;在上一篇文章中我们记录了G1GC的算法包括&lt;B&gt;内存结构&lt;/B&gt;、&lt;B&gt;标记位图&lt;/B&gt;、&lt;B&gt;SATB本地队列&lt;/B&gt;、&lt;B&gt;转移专用记忆集合&lt;/B&gt;等关键组成部分,接下我们会对HotSp</summary>
      
    
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/categories/jvm/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
