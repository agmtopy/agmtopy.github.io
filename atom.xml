<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2022-12-24T03:30:58.433Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cola4.0的最佳工程实践</title>
    <link href="https://agmtopy.gitee.io/2022/12/24/1.%E6%9D%82%E8%AE%B0/Cola4-0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/12/24/1.%E6%9D%82%E8%AE%B0/Cola4-0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-24T03:30:46.000Z</published>
    <updated>2022-12-24T03:30:58.433Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Groowy脚本实现业务场景下动态性规则的实践</title>
    <link href="https://agmtopy.gitee.io/2022/12/16/1.%E6%9D%82%E8%AE%B0/Groowy%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8A%A8%E6%80%81%E6%80%A7%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/12/16/1.%E6%9D%82%E8%AE%B0/Groowy%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8A%A8%E6%80%81%E6%80%A7%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-16T13:39:20.000Z</published>
    <updated>2023-01-04T16:56:04.305Z</updated>
    
    <content type="html"><![CDATA[<h1>Groowy脚本实现业务场景下动态性规则的实践</h1><h2 id="前言："><a class="header-anchor" href="#前言："></a>前言：</h2><p>在复杂的业务中我们往往会采用分层的思想来降低每一层的复杂度，应用层还会采用一些设计模式来预留出对于未来的扩展；在面对<br>复杂和易变的业务场景下，作为开发者，我们更期望程序框架底座能够保持稳定，而对”<B>扩展</B>”更期望可以做到能快速响应业务需求的变化和做到隔离性；<br>由于程序语言的特性，有些语言不能做到实时热编译和部署，需要借助其他工具来实现这一个效果，在jvm平台上Groovy脚本语言就非常适合这种场景。<br>接下来以一个具体的业务需求来作为“引子”，来展开是这个需求实现过程中的一些思考和实践;</p><h2 id="需求背景"><a class="header-anchor" href="#需求背景"></a>需求背景</h2><p>原始需求简化后得出的核心目标就是对业务数据进行巡检,本身从功能上来讲比较简单;在系统设计出发的时候就明确了本次的功能目标:</p><ol><li>向上会抽象出<B>巡检功能</B>的核心领域,并且支持扩展</li><li>向下会设计出基础设施层来作为支撑</li></ol><p>向上这一部分工作开展的比较顺利,因为是基于现实诉求抽象公共特性/接口;但是向下这一部分设计在落地的时候遇到一些问题,有三个阶段分别是:</p><ol><li>采用手动编译java代码</li><li>采用开源框架编译加载java代码</li><li>使用Groovy动态脚本</li></ol><h3 id="设计评审"><a class="header-anchor" href="#设计评审"></a>设计评审</h3><p>在实现这个需求的时候,做技术方案设计评审的时候,我提供了两种实现基础设施层的技术方案:<br>第一种是通过easy-rules提供出一个一个散列开的业务校验规则执行器,这样做的优点是在于技术成本最低,且代码可读性好,但是没有动态编译执行的能力<br>第二种是通过引入动态语言实现,这样做的优点是程序具有动态编译执行的能力,缺点是在于技术成本略高,Groovy脚本语言需要一定的学习成本</p><p>最后的技术评审经过大家的沟通交流最后决定采用第一种方案来进行实现;</p><h3 id="方案实施"><a class="header-anchor" href="#方案实施"></a>方案实施</h3><p>在按照第一种方案进行实施的时候,遇到一个问题,代码的重复度太高;因为业务需求的本质就只是<B>对比</B>,因此最开始想采用反射来降低代码的重复度,将需要检查的字段放在Map进行处理;<br>在继续沿着这方面思考,就想到了既然是用Map来获取校验规则,那可不可以将校验规则写入配置中心或者数据库,再进行动态加载楠;<br>沿着这个思路开始查找java文件进行动态编译的框架<a href="https://github.com/jOOQ/jOOR">joor</a>,在进行快速验证的时候发现joor可以做到对java文件的动态编译,但是在JDK8上有部分编译错误无法实现业务的扩展性;<br>这个时候似乎只有一种选择了,就是采用<B>Groovy</B>来进行实现</p><h2 id="Groovy使用"><a class="header-anchor" href="#Groovy使用"></a>Groovy使用</h2><h3 id="整体执行流程"><a class="header-anchor" href="#整体执行流程"></a>整体执行流程</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/excalidraw/Untitled-2022-09-08-1533.png?raw=true" alt="整体执行流程"></p><p>在流程中抽象的比较方法是作为所有动态脚本的父类,默认采用了反射的反射来或者Object中指定的字段</p><h3 id="DynamicUtil的设计"><a class="header-anchor" href="#DynamicUtil的设计"></a>DynamicUtil的设计</h3><p>从四个问题开始入手:</p><ol><li>如何简化Groovy的学习成本,从而推广出去?</li><li>如何保证性能?</li><li>如何保证动态脚本的安全性?</li><li>如何保证动态脚本的代码质量(动态脚本的单元测试如何进行)?</li></ol><h4 id="对于如何简化Groovy的学习成本"><a class="header-anchor" href="#对于如何简化Groovy的学习成本"></a>对于如何简化Groovy的学习成本?</h4><p>项目初期可以采用<B>GroovyClassLoader</B>来执行<B>Java脚本</B></p><ul><li>DynamicUtil</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">GroovyClassLoader</span> groovyClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroovyClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> helloScript <span class="token operator">=</span> <span class="token string">"package com.agmtopy.source.groovy;\n"</span> <span class="token operator">+</span>                <span class="token string">"\n"</span> <span class="token operator">+</span>                <span class="token string">"class Hello &#123;\n"</span> <span class="token operator">+</span>                <span class="token string">"    public String method(String name) &#123;\n"</span> <span class="token operator">+</span>                <span class="token string">"        System.out.println(\"hello, \" + name);\n"</span> <span class="token operator">+</span>                <span class="token string">"        return name;\n"</span> <span class="token operator">+</span>                <span class="token string">"    &#125;\n"</span> <span class="token operator">+</span>                <span class="token string">"&#125;\n"</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span> helloClass <span class="token operator">=</span> groovyClassLoader<span class="token punctuation">.</span><span class="token function">parseClass</span><span class="token punctuation">(</span>helloScript<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">GroovyObject</span> object <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">GroovyObject</span><span class="token punctuation">)</span> helloClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> ret <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">invokeMethod</span><span class="token punctuation">(</span><span class="token string">"method"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 控制台输出"hello, world"</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印world</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Hello.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>agmtopy<span class="token punctuation">.</span>source<span class="token punctuation">.</span>groovy</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在上面这个例子中,我们执行的脚本就是java语法规则的脚本;这样如何简化Groovy脚本的问题就可以得到解决;<br>在整个执行框架稳定以后,还是需要推广Groovy脚本,java语法的脚本只是一个中间过渡方案!</p><h4 id="如何保证脚本的执行性能"><a class="header-anchor" href="#如何保证脚本的执行性能"></a>如何保证脚本的执行性能?</h4><p>这里的性能指的是两方面:<B>编译</B>和<B>执行</B>,我们先来看Groovy是如何编译脚本的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Class</span> <span class="token function">parseClass</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">GroovyCodeSource</span> codeSource<span class="token punctuation">,</span> <span class="token keyword">boolean</span> shouldCacheSource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CompilationFailedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取cacheKey:scriptTest+name 进行MD5</span>    <span class="token class-name">String</span> cacheKey <span class="token operator">=</span> <span class="token function">genSourceCacheKey</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//sourceCache是一个类似与Map类型的类</span>    <span class="token keyword">return</span> sourceCache<span class="token punctuation">.</span><span class="token function">getAndPut</span><span class="token punctuation">(</span>            cacheKey<span class="token punctuation">,</span>            key <span class="token operator">-></span> <span class="token function">doParseClass</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">,</span>            shouldCacheSource    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">Class</span> <span class="token function">doParseClass</span><span class="token punctuation">(</span><span class="token class-name">GroovyCodeSource</span> codeSource<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">validate</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span> answer<span class="token punctuation">;</span>  <span class="token comment">// Was neither already loaded nor compiling, so compile and add to cache.</span>    <span class="token class-name">CompilationUnit</span> unit <span class="token operator">=</span> <span class="token function">createCompilationUnit</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> codeSource<span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//省略...</span>        <span class="token comment">//创建ClassCollector,class类属性相关的收集对象</span>    <span class="token class-name">ClassCollector</span> collector <span class="token operator">=</span> <span class="token function">createCollector</span><span class="token punctuation">(</span>unit<span class="token punctuation">,</span> su<span class="token punctuation">)</span><span class="token punctuation">;</span>    unit<span class="token punctuation">.</span><span class="token function">setClassgenCallback</span><span class="token punctuation">(</span>collector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开始执行编译命令</span>    unit<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>goalPhase<span class="token punctuation">)</span><span class="token punctuation">;</span>    answer <span class="token operator">=</span> collector<span class="token punctuation">.</span>generatedClass<span class="token punctuation">;</span>    <span class="token class-name">String</span> mainClass <span class="token operator">=</span> su<span class="token punctuation">.</span><span class="token function">getAST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMainClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token operator">:</span> collector<span class="token punctuation">.</span><span class="token function">getLoadedClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token class-name">String</span> clazzName <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">definePackageInternal</span><span class="token punctuation">(</span>clazzName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置到classCache中</span>        <span class="token function">setClassCacheEntry</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置为answer</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazzName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mainClass<span class="token punctuation">)</span><span class="token punctuation">)</span> answer <span class="token operator">=</span> clazz<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> answer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中,执行流程如下</p><p>doParseClass() -&gt; createCollector() -&gt; unit.compile(goalPhase) -&gt; ClassCollector.call() -&gt; ClassCollector.createClass()</p><p>创建class对象的过程是在<B>ClassCollector.createClass</B>方法中,在这个方法中可以看到最后是调用的java.security.SecureClassLoader#defineClass()</p><ul><li>ClassCollector.createClass</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span> <span class="token function">createClass</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> code<span class="token punctuation">,</span> <span class="token class-name">ClassNode</span> classNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BytecodeProcessor</span> bytecodePostprocessor <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytecodePostprocessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fcode <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytecodePostprocessor<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fcode <span class="token operator">=</span> bytecodePostprocessor<span class="token punctuation">.</span><span class="token function">processBytecode</span><span class="token punctuation">(</span>classNode<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//GroovyClassLoader extends SecureClassLoader</span>    <span class="token class-name">GroovyClassLoader</span> cl <span class="token operator">=</span> <span class="token function">getDefiningClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//这里通过SecureClassLoader.defineClass 来进行加载</span>    <span class="token class-name">Class</span> theClass <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>classNode<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fcode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fcode<span class="token punctuation">.</span>length<span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">getAST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadedClasses<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>theClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//省略...</span>    <span class="token keyword">return</span> theClass<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里还有一个点是在创建<B>GroovyClassLoader</B>时,都是通过<B>new InnerLoader</B>的方式来创建</p><blockquote><p>return java.security.AccessController.doPrivileged((PrivilegedAction<InnerLoader>) () -&gt; new InnerLoader(GroovyClassLoader.this));</p></blockquote><p>这是因为Class对象是通过ClassLoader+class的方式来定位确定唯一一个类的,InnerLoader每次都会创建一个新的对象,这样可能会导致Metaspace内存溢出,虽然在Groovy3.0以后针对这个问题已经进行过优化了,但是还是强烈建议通过内存将脚本编译后的<B>GroovyObject</B>缓存下来,本身脚本的再次编译和加载都是一个较为消耗性能的动作;</p><p>我们下面继续对<B>执行性能</B>来进行分析,在网上大多数资料对于Groovy的脚本执行性能的分析,github中关于这方面的issue也比较少,并且大部分是针对与Groovy和Java进行对比的;<br>下面有几个关于Groovy脚本执行的建议:</p><ol><li>尽量使用静态类型,由于Groovy是动态语言,在将动态特性编译成为静态语言时是比较消耗性能的</li><li>oracle官方对于Groovy的5条性能建议</li></ol><h4 id="如何保证动态脚本的安全性"><a class="header-anchor" href="#如何保证动态脚本的安全性"></a>如何保证动态脚本的安全性?</h4><p>如何保证动态脚本的安全性?其实也是分为两个方面考虑的:</p><ol><li>执行安全性</li></ol><blockquote><p>执行安全性指的是在执行脚本时是否会影响到我的宿主进程?如何规避这种风险?</p></blockquote><ol start="2"><li>脚本本身的安全性</li></ol><blockquote><p>脚本本身的安全性指的是脚本语义是否正确/正常以及可信</p></blockquote><p>下面对着两方面进行分析和设计:</p><p><B>脚本执行的安全性</B>方面最主要的考虑是错误的脚本是否会影响到主进程的执行?主要从下面几个方面考虑:</p><ol><li>内存<blockquote><p>内存主要还是考虑堆栈内存即可,一个是成员变量的空间分配,一个是while造成死循环使栈溢出等;可以在定义<B>GroovyClassLoader</B>时进行排除</p></blockquote></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">SecureASTCustomizer</span> secure <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecureASTCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建SecureASTCustomizer</span>secure<span class="token punctuation">.</span><span class="token function">setClosuresAllowed</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 禁止使用闭包</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tokensBlacklist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tokensBlacklist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Types</span><span class="token punctuation">.</span>*<span class="token operator">*</span>KEYWORD_WHILE<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加关键字黑名单 while和goto</span>tokensBlacklist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Types</span><span class="token punctuation">.</span>*<span class="token operator">*</span>KEYWORD_GOTO<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setTokensBlacklist</span><span class="token punctuation">(</span>tokensBlacklist<span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setIndirectImportCheckEnabled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置直接导入检查</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"com.alibaba.fastjson.JSONObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setImportsBlacklist</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>线程</li></ol><blockquote><p>对与线程方面的考虑主要是执行线程需要使用单独的线程池进行处理,这样做的目的是防止动态脚本的执行线程阻塞业务线程;第二个是动态脚本中应该禁止使用线程池来进行处理,这方面的考量主要是基于脚本业务代码尽量的要简单高效和可读性,引入线程池会增加脚本的复杂度和可维护性</p></blockquote><ol start="3"><li>数据库/资源的管理</li></ol><blockquote><p>对与数据库和其他资源的访问,我是持有拒绝的态度,主要观点还是和脚本中实现线程池类似,还有一点是脚本中进行数据变更和资源处理缺少了代码版本控制这一个环节;</p></blockquote><p><B>脚本本身的安全性</B>主要指的是脚本开发/提测/上线整个流程的安全和监控性,在这方面Vivo提供了一套内部使用的流程如下:</p><p><img src="https://static001.geekbang.org/infoq/ac/acf787602d9e4bf20abded0c80525565.png" alt="Groovy整体流程"></p><p>在这个过程中,除了code review部分需要开发者进行参与,其他部分都可以依托CI/CD工具实现自动化执行;<br>有了这样一个流程,其实是可以解决脚本本身的安全性的问题的;</p><h4 id="如何保证动态脚本的代码质量"><a class="header-anchor" href="#如何保证动态脚本的代码质量"></a>如何保证动态脚本的代码质量?</h4><p>动态脚本的代码质量如何进行保证,一方面是可以通过良好的code review机制来提高质量,另外一方面是需要建设好单元测试框架;<br>如何建立好动态脚本的单元测试?<br>首先是方便,在开发人员的角度一个工具只有在足够的简单方便的情况下才会乐意去进行使用,其次是流程规范.<br>目前执行的过程是在特定的测试包下,开发脚本,然后进行单元测试,在单元测试通过后在写入数据库中;<br>后续实践出更好的方案在进行更新</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>以上通过Groovy实现了动态特性的同时引入了一些尚未解决的问题:<br>执行性能/单元测试,后续在实践过程中也会对这些问题持续的进行更新.</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/en/cloud/paas/app-builder-cloud/visual-builder-groovy/best-practices-for-groovy-performance.html">oracle官方对于Groovy 性能的最佳实践</a><br><a href="https://www.huangchaoyu.com/2021/10/16/groovy%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%AE%B9%E6%98%93%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/">groovy静态编译容易引发的问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Groowy脚本实现业务场景下动态性规则的实践&lt;/h1&gt;
&lt;h2 id=&quot;前言：&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;
&lt;p&gt;在复杂的业务中我们往往会采用分层的思想来降低每一层的复杂度，应用层还会采用一些设计</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="guava" scheme="https://agmtopy.gitee.io/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>Class文件格式与加载</title>
    <link href="https://agmtopy.gitee.io/2022/12/03/12.JVM/9.Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8A%A0%E8%BD%BD/"/>
    <id>https://agmtopy.gitee.io/2022/12/03/12.JVM/9.Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-12-03T15:02:44.000Z</published>
    <updated>2022-12-04T10:14:51.378Z</updated>
    
    <content type="html"><![CDATA[<h1>Class文件格式与加载</h1><h2 id="类文件结构"><a class="header-anchor" href="#类文件结构"></a>类文件结构</h2><ul><li>类文件结构也就是Class文件的结构<ul><li>魔数:用于标识Class文件的版本</li><li>常量池:主要用于保存<strong>字面量(类似于字符串等)</strong> 和 <strong>符号引用(类和接口的全限定名\字段名称以及描述符\方法名称和描述符);</strong> 由于jvm在加载Class文件时才会进行<B>动态连接</B>,因此需要保存这些方法或接口的信息</li><li>访问标识:标识这个Class的类型(接口/类/public/abstract/final等)</li><li>类索引、父类索引与接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul></li></ul><h2 id="虚拟机类加载机制"><a class="header-anchor" href="#虚拟机类加载机制"></a>虚拟机类加载机制:</h2><ul><li>虚拟机把描述类的数据从Class文件加载到内存中,并对数据进行校验、转换解析、初始化的过程,最终形成可以被虚拟机之间使用的Java类型对象,就是虚拟机类的加载过程.</li></ul><h3 id="类加载的步骤"><a class="header-anchor" href="#类加载的步骤"></a>类加载的步骤</h3><ol><li>加载</li><li>连接:验证→准备→解析</li><li>初始化</li><li>使用</li><li>卸载</li></ol><p>在执行顺序上:加载→验证→准备→解析→初始化,这五个步骤的顺序是固定的;</p><h4 id="加载"><a class="header-anchor" href="#加载"></a>加载</h4><ol><li>通过类的全限定名来获取定义此类的二进制字节流</li><li>将二进制字节流转换为方法区运行时的数据结构</li><li>在内存中创建这个类的Class对象,作为方法区类结构的方法映射</li></ol><ul><li>对于HotSpot虚拟机而言,Class对象比较特殊,它虽然是对象,但是存放在方法区内,作为访问类结构的对象接口</li></ul><h4 id="验证"><a class="header-anchor" href="#验证"></a>验证</h4><ol><li>文件格式的验证:文件格式\运行版本等</li><li>元数据的验证:对字节码语义信息的分析,</li><li>字节码内容的验证:通过程序来校验方法块中的内容是否正确</li></ol><p>验证阶段贯穿[加载、准备、解析]，并不是严格的线性的顺序</p><h4 id="准备"><a class="header-anchor" href="#准备"></a>准备</h4><ol><li>为类变量分配内存并设置初始值的过程，对于类变量也仅仅是进行类型初始值的赋值(零值)</li><li>final修饰的类变量在这个阶段会直接进行赋实际值的过程，因为final修饰的值会被当作常量</li></ol><h4 id="解析"><a class="header-anchor" href="#解析"></a>解析</h4><ul><li>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程<ol><li>解析阶段会触发类的加载，当为找到Class对象时会根据类的全限定明进行加载</li><li>对字段会按照继承顺序从下先上进行查找，并校验访问权限</li><li>对类方法和接口方法的解析与字段类似</li></ol></li></ul><h4 id="初始化"><a class="header-anchor" href="#初始化"></a>初始化</h4><p>初始化就是在执行<B>clint()</B>的过程</p><p><B>clint()</B>是编译器自动收集类中所有的类变量赋值动作和静态语句块合并生成的</p><p>静态代码块可以对在它之后的类变量进行赋值，但是不能进行访问；因为类变量在<strong>准备阶段</strong>就完成的零值的赋值</p><p>虚拟机内部保证了在执行器之类的<B>clint()</B>方法之前先执行父类的<B>clint()</B>方法</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/ClassLoader_flow.jpg?raw=true" alt="Class文件整体加载结构"></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.geeksforgeeks.org/classloader-in-java/">java中的类加载器</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Class文件格式与加载&lt;/h1&gt;
&lt;h2 id=&quot;类文件结构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#类文件结构&quot;&gt;&lt;/a&gt;类文件结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类文件结构也就是Class文件的结构
&lt;ul&gt;
&lt;li&gt;魔数:用于标识Class</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>性能监控与故障处理工具</title>
    <link href="https://agmtopy.gitee.io/2022/12/01/1.%E6%9D%82%E8%AE%B0/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://agmtopy.gitee.io/2022/12/01/1.%E6%9D%82%E8%AE%B0/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2022-12-01T15:11:20.000Z</published>
    <updated>2022-12-03T14:59:38.223Z</updated>
    
    <content type="html"><![CDATA[<h1>性能监控与故障处理工具</h1><p>介绍处理jvm的相关问题办法以及相关工具的一个持续更新的集合</p><h2 id="📚-经验"><a class="header-anchor" href="#📚-经验"></a>📚 经验</h2><h3 id="CPU占用率高"><a class="header-anchor" href="#CPU占用率高"></a>CPU占用率高</h3><ul><li>通过jvm工具排查</li></ul><ol><li>通过<strong>top</strong>命令查询进程号</li><li>通过<strong>top -Hp <pid></strong> 查到线程号,转换成为<strong>16进制</strong></li><li>通过<strong>jstack <pid> |grep 16进制线程号 -A 10</strong> 找到CPU当前执行的方法堆栈</li></ol><ul><li>通过arthas排查</li></ul><ol><li>thread</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看线程状态(默认只显示10个线程)thread # 查看全部线程状态thread --all# 查看指定线程执行状态thread --pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="OOM问题"><a class="header-anchor" href="#OOM问题"></a>OOM问题</h3><ol><li>启动命令中设置</li></ol><blockquote><p><B>-XX:+HeapDumpOnOutOfMemoryError</B> 配合<B> -XX:HeapDumpPath</B><br>在OOM时生成dump文件</p></blockquote><ol start="2"><li>线上命令</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#生成堆转储快照dump文件命令  jmap -dump:format&#x3D;b,file&#x3D;heapdump.hprof pid# 生成堆栈信息文件命令  jstack -l pid &gt;&gt; stack.txt# Arthas命令  heapdump<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程问题"><a class="header-anchor" href="#线程问题"></a>线程问题</h3><ul><li>线程池提交任务不执行</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># arthas排查# 获取ClassLoad Hashsc -d com.agmtopy.source.executer.ExecutorServiceUtil# 获取对象ognl -x 1 &#39;@com.agmtopy.source.executer.ExecutorServiceUtil@threadPoolExecutor&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>线程死锁</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> # arthas排查Thread -b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="⚙-工具"><a class="header-anchor" href="#⚙-工具"></a>⚙ 工具</h2><p><B>Arthas</B>强烈推荐</p><h2 id="📒-常用命令"><a class="header-anchor" href="#📒-常用命令"></a>📒 常用命令</h2><h3 id="网络"><a class="header-anchor" href="#网络"></a>网络</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 采样tcp连接lsof -p 进程号 &gt; &#x2F;tmp&#x2F;进程号_lsof.txt# 查看指定端口netstat -tnlp | grep :8080ss -tunlp |grep :8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排查网络问题步骤:</p><ol><li>ping 目标地址</li><li>丢包<br>a. 链路中断<br>b. 抖动<br>c. 出口堵塞</li><li>能通<br>a. 检查dns和域名解析</li></ol><blockquote><p>/etc/resolv.conf 或者 dig 或者 nslookup :url</p></blockquote><p>b. 检查端口</p><blockquote><p>telnet -&gt; 如果全部端口不通检查<B>安全组策略</B>;部分端口不通检查<B>负载均衡白名单</B></p></blockquote><ol start="3"><li>不通<br>检查ip设置/网卡驱动/物理链路</li></ol><h3 id="内存"><a class="header-anchor" href="#内存"></a>内存</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 系统内存分布pmap -pid# 内存占用jmap -heap 进程号 &gt; &#x2F;tmp&#x2F;进程号_jmap_heap.txt# 保存进程堆栈jmap -dump:format&#x3D;b,file&#x3D;&#x2F;tmp&#x2F;进程号_jmap_dump.hprof 进程号# 内存对象占比jmap -histo 1 |more# GCjstat -gcutil 进程号 &gt; &#x2F;tmp&#x2F;进程号_jstat_gc.txtjstat -gcutil 1 1s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CPU"><a class="header-anchor" href="#CPU"></a>CPU</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看系统上下文切换vmstat -w 1# 查看进程上下文切换pidstat -p &#x2F;PID -wtu  5# 打印系统负载快照top -b -n 2 &gt; &#x2F;tmp&#x2F;top.txttop -H -n 1 -p pid &gt; &#x2F;tmp&#x2F;pid_top.txt# 进程列表ps -mp-o THREAD,tid,time | sort -k2r &gt; &#x2F;tmp&#x2F;进程号_threads.txt# 线程信息jstack -l 进程号 &gt; &#x2F;tmp&#x2F;进程号_jstack.txt# Arthasthread thread -tidthread -all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="I-O"><a class="header-anchor" href="#I-O"></a>I/O</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">strace -p pidiotop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;性能监控与故障处理工具&lt;/h1&gt;
&lt;p&gt;介绍处理jvm的相关问题办法以及相关工具的一个持续更新的集合&lt;/p&gt;
&lt;h2 id=&quot;📚-经验&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#📚-经验&quot;&gt;&lt;/a&gt;📚 经验&lt;/h2&gt;
&lt;h3 id=&quot;CPU占</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="工具" scheme="https://agmtopy.gitee.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jvm-垃圾回收器及算法基础</title>
    <link href="https://agmtopy.gitee.io/2022/12/01/12.JVM/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://agmtopy.gitee.io/2022/12/01/12.JVM/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-12-01T14:02:27.000Z</published>
    <updated>2022-12-01T15:11:09.972Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收器及算法基础</h1><h2 id="前提介绍"><a class="header-anchor" href="#前提介绍"></a>前提介绍</h2><p>垃圾回收器(GC)的理论研究在很早直接就开始了,大概是在60年代lisp语言就开始使用内存分配和垃圾回收机制来管理程序的内存了,近现代这一方向也是保持着极高的研究热度,从G1-&gt;ZGC</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/excalidraw/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80.png?raw=true" alt="大纲"></p><h2 id="算法基础"><a class="header-anchor" href="#算法基础"></a>算法基础</h2><p>对内存空间的回收首先需要解决一个问题那些是需要进行回收的对象,针对这个问题有两种处理方案:</p><ul><li><p>引用计数算法<br>引用计数是通过对对象被引用次数来标识是否有效,存在循环引用问题,可以通过可达性分析的步骤来解决</p></li><li><p>根标记算法,从<strong>GC Roots</strong>开始遍历整个内存对象是否可达的方式来标记需要回收的对象</p><p>首先<strong>GC Roots</strong>对象包括以下的几种:</p><ul><li>虚拟机栈中引用指向的对象(reference)</li><li>方法区中类静态属性引用的对象(静态属性对象,虽然不在栈帧中)</li><li>方法区常量引用的对象(例如常量池中的对象)</li><li>本地方法栈中引用的对象</li></ul></li></ul><h2 id="对象"><a class="header-anchor" href="#对象"></a>对象</h2><ul><li><p>对象的回收</p><p>对象的回收是一个非常严肃的动作,错误的回收将会是一场对用户的灾难,因此在JVM的实现中,对于GC线程的优先级设置的非常低,其次是在标记对象不可达后,还会声明会执行一次<strong>对象</strong>的**finalize()**方法,对于这个方法是否执行完成不做保证(防止死循环/wait time)</p><ul><li>finalize():用于GC回收前对象最后一次自救的方法,但是只会执行一次,防止内存溢出</li></ul></li><li><p>对象的分配</p><p>对象的分配与垃圾收集器的选择有关,对象是优先在Eden区进行分配,</p><p>进入老年代的几种场景:</p><ol><li>大对象直接进入老年代</li><li>长期存活的对象(16次GC)</li><li>动态对象年龄判断(一半相同年龄的对象直接进入老年代)</li></ol></li></ul><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><ul><li><p>标记类</p><p>标记-清除算法/标记-整理算法/复制算法</p><ul><li>标记整理算法是通过时间换空间形式的一种体现,通过整理回收后的内存碎片来达到可以继续分配的目的</li><li>复制算法是空间换时间的体现,通过预留一倍的空间来达到内存回收完成后没有内存碎片的问题</li></ul></li><li><p>分代类</p><p>分代算法主要是根据对象的存活周期,将对象划分为不同区域,在不同的区域上采取不同的算法来处理</p></li></ul><h2 id="HotSopt实现"><a class="header-anchor" href="#HotSopt实现"></a>HotSopt实现</h2><ul><li><p>枚举根节点</p><p>通过<strong>OopMap</strong>的的方式来快速查找GC Roots枚举</p></li><li><p>安全点</p><p>由于引用关系的变化会不断的影响GC Roots,因此HotSpot不是每条指令都会生成OopMap,而只在特定的位置才会产生OopMap,这种特殊的位置被称为<strong>Safe pint</strong>,有两种进入Safe point的方式:</p><ul><li>抢占式</li><li>主动中断式:主动中断的方式是通过设置<strong>中断标记</strong></li></ul></li><li><p>安全区域</p><p>安全区域被称为Safe Region,指的是一段不会改变引用关系的代码,在执行GC时是不会处理已进入Safe Region的线程,当这些线程在离开Sefe Region时也会检查GC是否完成</p></li></ul><h2 id="垃圾收集器"><a class="header-anchor" href="#垃圾收集器"></a>垃圾收集器</h2><ul><li><p>Parallel Scavenge收集器</p></li><li><p>Parallel  Old收集器</p><p>两种Parallel收集器分别是jdk8中默认是年轻代和老年代的垃圾收集器</p><ul><li><p>Parallel Scavenge收集器</p><p>用于<strong>新生代,<strong>关注</strong>吞吐量</strong>的多线程并行收集器</p><p>CMS是关注于停顿时间,尽可能的缩短用户线程的停顿时间,适合于有交互的web系统</p><p>Parallel是关注于吞吐量尽可能的在单位时间内多执行用户代码,缩小GC时间,适用于后台任务</p></li><li><p>Parallel Old收集器</p><p>是老年代的标记-整理算法的多线程垃圾收集器</p></li><li><p>CMS收集器(<strong>三标一清</strong>)</p><p>CMS收集器是以最短停顿时间为目标的垃圾收集器,是基于标记-清除算法演化而来,分为:</p><ol><li>初始标记阶段</li><li>并发标记阶段</li><li>重新标记阶段</li><li>并发清除阶段</li></ol><p>在初始标记和重新标记阶段会STW的方式来进行,因为初始化标记是查找**GC Roots,**重新标记是对并发标记阶段结果修正也需要STW;</p><p>整个CMS中最耗时的<strong>并发标记</strong>和<strong>并发清理阶段</strong>都可以和用户线程一起执行</p><p>CMS垃圾收集器的问题:</p><ol><li>参与线程过高,按照(coreSize+3)/4的方式分配</li><li>无法处理浮动垃圾,对于在重新标记后产生的垃圾只能在下一次GC时进行处理,占用空间,当老年代达到一个阈值后会出发full GC,当CMS在运行时产生内存不足会激活serial GC</li><li>内存碎片问题,通过full GC的方式解决</li></ol></li><li><p>G1收集器</p><ul><li>从jdk9开始G1就作为默认的垃圾处理器</li><li>在整体上G1是标记-整理算法,局部上是标记-复制算法</li></ul></li><li><p>Shenandoah/ZGC收集器</p><ul><li>亚毫秒级</li><li>无分区设计</li></ul></li></ul></li></ul><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.baeldung.com/jvm-zgc-garbage-collector">ZGC简介:可扩展的实验性低延迟 JVM 垃圾收集器</a><br><a href="https://xie.infoq.cn/article/586f901cf8f38dd2f63b54a44">ZGC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收器及算法基础&lt;/h1&gt;
&lt;h2 id=&quot;前提介绍&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提介绍&quot;&gt;&lt;/a&gt;前提介绍&lt;/h2&gt;
&lt;p&gt;垃圾回收器(GC)的理论研究在很早直接就开始了,大概是在60年代lisp语言就开始使用内存分配和垃圾回</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm-内存布局设计</title>
    <link href="https://agmtopy.gitee.io/2022/11/30/12.JVM/7.%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/"/>
    <id>https://agmtopy.gitee.io/2022/11/30/12.JVM/7.%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-11-30T14:13:23.000Z</published>
    <updated>2022-12-03T14:57:50.139Z</updated>
    
    <content type="html"><![CDATA[<h1>内存布局设计</h1><p>JVM的内存设计上是划分为两个大的区域的<B>启动时向操作系统分配的程序内存区域</B>、<B>直接对系统内存进行操作的区域</B>,后者不属于JVM管理,我们主要是分析前者</p><h2 id="大体结构"><a class="header-anchor" href="#大体结构"></a>大体结构</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/jvm%E6%80%BB%E8%A7%88.png?raw=true" alt="JVM架构图"></p><ol><li>程序计数器<ol><li><p>程序计数器是用来记录当前线程所执行的字节码的行号指示器,字节码解释器在工作时就是通过改变这个计数器的值来记录当前执行的指令.</p><p>它是JVM层次的指令执行记录与硬件层次的指令地址寄存器(IR)的区别在于程序计数器只是一段内存区域,通过软件实现的记录虚拟机字节码的执行地址,当执行Native方法时,该区域值为空</p></li><li><p>为什么要有程序计数器?</p><ol><li>在于jvm提交给CPU执行的指令不是一次性全部提交过去的,而是根据java的业务逻辑通过jvm编译在提交给CPU相应的指令,所以需要对IR进行抽象</li></ol></li></ol></li><li>Java虚拟机栈<ol><li>虚拟机栈描述的是Java方法执行时候的内存模型:线程在执行方法时都会创建相应独立的栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息;</li><li>虚拟机栈是由一个个栈帧组成的</li><li>局部变量表用于存储编译器可知的各种基本数据类型的值引用、对象引用、returnAddres类型(指向一个指令的类型,指的是方法返回的指令地址)</li></ol></li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E7%BA%BF%E7%A8%8B%E5%B8%A7%E6%A0%88.png?raw=true" alt="栈帧"></p><ol><li><p>本地方法栈</p><p>本地方法栈是用于表示对本地方法(native)执行的’c stack’</p></li><li><p>java堆</p><p>java堆是java进程管理的最大的一块内存区域,这个区域允许所有线程访问,作用是在这个区域分配对象实例空间;堆所分配的内存空间不需要是连续的(物理/逻辑上都是一样),在HotSpot中堆空间在默认情况下是申请的连续分配</p></li><li><p>方法区</p><p>方法区用于虚拟机加载类信息、常量池、静态变量、即时编译器编译后的代码数据等</p></li><li><p>常量池</p><p>常量池用于存放在编译期产生的各种字符串、符号引用以及允许运行期动态添加</p></li><li><p>直接内存</p></li></ol><p>直接内存指的是通过Native方法直接分配的堆外内存部分</p><h2 id="堆上内存分配过程"><a class="header-anchor" href="#堆上内存分配过程"></a>堆上内存分配过程</h2><p>堆上内存分配过程约等于对象的堆内存分配过程,堆上内存分配需要并发分配的问题,目前有两种处理方案:</p><ol><li>通过CAS机制加上失败重试来保证操作的原子性</li><li>通过本地线程分配缓冲(TLAB)的方式来保证,核心思想就是通过预先划分线程独占的内存空间来<strong>尽量避免从堆上直接分配内存从而避免频繁的锁竞争</strong></li></ol><h2 id="对象的内存布局"><a class="header-anchor" href="#对象的内存布局"></a>对象的内存布局</h2><p>对象的内存布局可以划分为三个区域:对象头(Header)、实例数据、对齐填充部分</p><ol><li><p>header</p><ol><li>Mark Word:通过标识来复用同一地址空间,列如对象哈希码/锁指针/偏向锁信息等</li><li>类型指针:用于标识对象的类元数据,其中数组类型要表示元素的类型以及元素的个数</li></ol></li><li><p>实例数据</p><ol><li>实例数据部分是用于存储业务数据的部分,在分配内存时会尽量遵守相同类型(宽度)的数据分配到一起</li></ol></li><li><p>对齐部分</p><ol><li>对齐部分不一定存在,由于jvm虚拟机分配内存是8个字节的整数倍,header部分设计是就遵守此规范,但是实例数据部分不一定能恰好遵循,因此需要进行数据填充来符合此规范</li></ol><h2 id="对象的访问定位"><a class="header-anchor" href="#对象的访问定位"></a>对象的访问定位</h2><p>在栈帧中通过<strong>reference</strong>来表示对象的指针,然后通过refernce查找对象的方式可以分为两种实现方案:</p><ol><li>直接通过指针来返回</li><li>通过句柄的方式来返回</li></ol><p>HotSpot是通过第二种方式来进行访问的,优点是**快,**缺点是在GC时需要修改栈帧中的reference数据</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.png?raw=true" alt="对象地址"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;内存布局设计&lt;/h1&gt;
&lt;p&gt;JVM的内存设计上是划分为两个大的区域的&lt;B&gt;启动时向操作系统分配的程序内存区域&lt;/B&gt;、&lt;B&gt;直接对系统内存进行操作的区域&lt;/B&gt;,后者不属于JVM管理,我们主要是分析前者&lt;/p&gt;
&lt;h2 id=&quot;大体结构&quot;&gt;&lt;a class=&quot;heade</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>多线程是否会影响执行效率</title>
    <link href="https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/"/>
    <id>https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/</id>
    <published>2022-11-15T14:50:30.000Z</published>
    <updated>2022-11-18T12:51:34.947Z</updated>
    
    <content type="html"><![CDATA[<h1>多线程是否会影响执行效率</h1><h2 id="前提"><a class="header-anchor" href="#前提"></a>前提</h2><p>今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的</p><blockquote><p>在同一机器/操作系统上,使用n个线程处理X个任务是不是和使用n*m个线程处理X个任务效率相同?</p></blockquote><p>这样的观点是基于<B>RR-时间片轮转</B>来进行推导的;我不太认同这种观点,直觉上认为参与处理的任务过多或过少都会影响执行效率;下面先进行这两种观点的推导然后在进行实际的验证</p><h2 id="时间片轮转"><a class="header-anchor" href="#时间片轮转"></a>时间片轮转</h2><p>假设前提:</p><ol><li>操作系统对进程的调度是采用的<B>时间片轮转</B>算法来进行处理的,时间片划分的大小为1s;</li><li>每个Task需要消耗单核CPU执行0.5s</li><li>不考虑线程上下文切换耗时</li></ol><p>根据以上的前提可以得出下面这个运行图例:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%201%20%E9%A1%B5.drawio.png?raw=true" alt="2Thread执行示例"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%202%20%E9%A1%B5.drawio.png?raw=true" alt="4Thread执行示例"></p><p>从上图中可以看到无论是2Thread来进行执行还是4Thread来进行执行对于任务的执行耗时其实都是没有任何影响的,因为这其实是1000个Task与2个执行core之间的关系;</p><p>这种说法正确的前提必须是满足<B>假设前提</B>中的3点</p><h2 id="线程过多过少都会影响执行效率"><a class="header-anchor" href="#线程过多过少都会影响执行效率"></a>线程过多过少都会影响执行效率</h2><p>这种观点主要是基于《Java并发编程实战》一书中的观点:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F.jpg?raw=true" alt="推算线程池大小"></p><p>N<sub>cpu</sub> ：指的是执行机器上的物理核心数,额外注意使用容器启动的核心数<br>U<sub>cpu</sub> ：指的期望的对CPU的使用率<br>W/C ：指的是等待时间与计算时间的比例,对于计算密集型与IO密集型这个值还有所区别</p><p>例子:</p><p>N<sub>Thread</sub> = 2 * 0.8 * (1 + 10/2) = 8</p><p>如果需要N<sub>Thread</sub>持续增长时需要<B>W/C</B>比例更大,这是不可能实现的,由于w/c是由于Task决定的;<br>以上是通过反证法的方式来解释提高N<sub>Thread</sub> 并不能增加并发执行效率的原因;</p><p>实际在运用过程中还需要注意<B>Amdahl定律</B>和线程引入造成的性能开销</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/amdahl%E5%AE%9A%E5%BE%8B.jpg?raw=true" alt="Amdahl定律"></p><p>Amdahl定律就是表达并发执行线程池数并不能提高效率,而是并发度提高才能提高执行效率</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%BC%95%E5%85%A5%E7%9A%84%E5%BC%80%E9%94%80.jpg?raw=true" alt="线程引入造成的性能开销"></p><p>频繁的线程切换会引起性能损耗</p><h2 id="实例分析"><a class="header-anchor" href="#实例分析"></a>实例分析</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecutorServiceUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> taskNum <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">LinkedBlockingQueue</span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span>taskNum <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">8192</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]正在执行... %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> st <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">extracted</span><span class="token punctuation">(</span>latch<span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> et <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]执行耗时[%s]ms %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> et <span class="token operator">-</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>            QUEUE<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">extracted</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> taskNum<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>latch<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> taskId<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>        <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">,</span> <span class="token keyword">int</span> taskId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> latch<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>taskId <span class="token operator">=</span> taskId<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> min<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">isPrime2</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPrime2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> sqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqrt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/jvmsource/blob/master/src/main/java/com/agmtopy/source/executer/ExecutorServiceUtil.java">ExecutorServiceUtil.java</a></p><p>这是一个循环求解0~10W之间的素数的程序,下面是分别在Windows/Linux上执行的结果</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux.jpg?raw=true" alt="Linux下的执行结果"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows.jpg?raw=true" alt="Windows下的执行结果"></p><p>操作系统的线程调度策略还是会影响性能的.Linux的线程调度要稍微比Windows的优秀一点点,下面使用<B>vmstat</B>和<B>pidstat</B>分析</p><ul><li>vmstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vmstat</span> -w <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vmstat.jpg?raw=true" alt="vmstat执行结果"></p><ul><li>pidstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pidstat -p /PID -wtu  <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pidstat.jpg?raw=true" alt="pidstat执行结果"></p><p>主要关心<B>cswch/s</B>和<B>nvcswch/s</B>、<B>in</B>和<B>cs</B>指标，表示的是<B>线程上下文切换</B>的一个频率,在线程不断的增加以后可以看到这几个指标在快速的向上增长<br>不管是从windows还是linux的一个执行结果来看，线程的增加都会导致程序的下降,但是这种下降并不是很明显，也许是得益于现代操作系统对线程切换的不断优化吧</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>一个线程池中核心线程数与最大线程数的数量是会受到多个方面因素共同影响的，例如<B>操作系统</B>、<B>物理核心逻辑线程</B> 以及任务类型(计算密集型/IO密集型)都有关系,因此在使用线程池时对于线程池的<B>6个</B>参数一定要有思考以后在进行创建相应的线程池;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/13834692/threads-configuration-based-on-no-of-cpu-cores/13958877#13958877">Threads configuration based on no. of CPU-cores</a><br><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a><br><a href="https://research.cs.wisc.edu/multifacet/amdahl/">Amdahl’s Law in the Multicore Era</a><br><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html">Linux vmstat命令实战详解</a><br><a href="https://timzhouyes.github.io/2020/04/29/Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/">Java常见的性能问题和排查</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;多线程是否会影响执行效率&lt;/h1&gt;
&lt;h2 id=&quot;前提&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;
&lt;p&gt;今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在同一机</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="多线程" scheme="https://agmtopy.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(三)</title>
    <link href="https://agmtopy.gitee.io/2022/11/14/20.%E7%AC%94%E8%AE%B0/22.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%89)/"/>
    <id>https://agmtopy.gitee.io/2022/11/14/20.%E7%AC%94%E8%AE%B0/22.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%89)/</id>
    <published>2022-11-14T15:50:10.000Z</published>
    <updated>2022-11-14T16:17:50.611Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(三)</h1><h2 id="Redis数据结构"><a class="header-anchor" href="#Redis数据结构"></a>Redis数据结构</h2><p>Redis的数据结构可以划分为下图所示:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.drawio.png?raw=true" alt="Redis的数据结构"></p><p>可以看到Redis底层采用的也是Map的方式来保存key以及value;</p><p>Redis主要的数据类型分为<B>String</B>、<B>list</B>、<B>set</B>、<B>map</B>、<B>sorted-set</B>等</p><p>下面会依次介绍这几种类型对象的底层实现原理</p><h2 id="String类型"><a class="header-anchor" href="#String类型"></a>String类型</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(三)&lt;/h1&gt;
&lt;h2 id=&quot;Redis数据结构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Redis数据结构&quot;&gt;&lt;/a&gt;Redis数据结构&lt;/h2&gt;
&lt;p&gt;Redis的数据结构可以划分为下图所示:&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TiDB数据库之简介</title>
    <link href="https://agmtopy.gitee.io/2022/11/05/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/41.TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <id>https://agmtopy.gitee.io/2022/11/05/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/41.TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%AE%80%E4%BB%8B/</id>
    <published>2022-11-05T07:30:55.000Z</published>
    <updated>2022-11-06T15:36:16.589Z</updated>
    
    <content type="html"><![CDATA[<h1>TiDB数据库之简介</h1><blockquote><p>TiDB 是 PingCAP 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processing, HTAP) 的融合型分布式数据库产品，具备水平扩容或者缩容、金融级高可用、实时 HTAP、云原生的分布式数据库、兼容 MySQL 5.7 协议和 MySQL 生态等重要特性。目标是为用户提供一站式 OLTP (Online Transactional Processing)、OLAP (Online Analytical Processing)、HTAP 解决方案。</p></blockquote><p>简单的说就是一款分布式数据库.</p><h2 id="五大特性"><a class="header-anchor" href="#五大特性"></a>五大特性</h2><ol><li><p>支持水平扩容或缩容<br>这一点在传统的RDBMS上不容易实现,传统的RDBMS通常是数据存储和计算没有进行分离的;</p></li><li><p>金融级高可用<br>采用<B> Multi-Raft 协议</B>来进行保证的</p></li><li><p>实时 HTAP<br>同时支持OLAP和OLTP处理</p></li><li><p>云原生的分布式数据库</p></li><li><p>兼容MySQL 5.7协议<br>支持MySQL协议这是一大优点</p></li></ol><h2 id="四大核心应用场景"><a class="header-anchor" href="#四大核心应用场景"></a>四大核心应用场景</h2><ol><li>对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高的金融行业属性的场景</li></ol><p>也就是适合需要高性能/高可用/高扩展性的场景</p><ol start="2"><li>对存储容量、可扩展性、并发要求较高的海量数据及高并发的 OLTP 场景</li></ol><blockquote><p>随着业务的高速发展，数据呈现爆炸性的增长，传统的单机数据库无法满足因数据爆炸性的增长对数据库的容量要求，可行方案是采用分库分表的中间件产品或者 NewSQL 数据库替代、采用高端的存储设备等，其中性价比最大的是 NewSQL 数据库，例如：TiDB。TiDB 采用计算、存储分离的架构，可对计算、存储分别进行扩容和缩容，计算最大支持 512 节点，每个节点最大支持 1000 并发，集群容量最大支持 PB 级别。</p></blockquote><ol start="3"><li><p>HTAP场景<br>一套数据库支持全部场景</p></li><li><p>OLAP场景<br>TiDB在实现上比ETL + Hadddoop简单和高效低本,并且可以直接用SQL实现分析统计功能</p></li></ol><h2 id="快速上手"><a class="header-anchor" href="#快速上手"></a>快速上手</h2><p>本次快速上手实验的环境主要是: WSL2+Ubunta</p><ol><li>下载安装脚本</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span class="token comment"># 下载完成后会展示安装脚本路径  'Shell profile:'后面的就是 $&#123;your_shell_profile&#125; 替换量</span><span class="token builtin class-name">source</span> <span class="token variable">$&#123;your_shell_profile&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_1.jpg?raw=true" alt="下载安装脚本"></p><ol start="2"><li>启动集群</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 默认TiDB、TiKV、PD 和 TiFlash 实例各一个</span>tiup playground<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_%E5%90%AF%E5%8A%A8.jpg?raw=true" alt="启动"></p><ol start="3"><li>TiDB的相关操作</li></ol><ul><li>连接TiDB</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用TiDB clinet</span>tiup client<span class="token comment"># 使用MySQL 协议</span>mysql --host <span class="token number">127.0</span>.0.1 --port <span class="token number">4000</span> -u root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_tidb%E5%8D%8F%E8%AE%AE%E7%99%BB%E9%99%86.jpg?raw=true" alt="TiDB clinet"></p><p>在使用MySQL客户端连接的时候,因为TiDB默认没有为root用户分配密码的,可以通过TiDB clint 登陆后使用<B>set password for root=‘123456’;</B>来修改密码</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_4_%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81.jpg?raw=true" alt="修改root 密码"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_5_%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.jpg?raw=true" alt="MySQL 协议连接成功"></p><ul><li>退出/清理</li></ul><ol><li><p>按下 Control+C 键停掉上述启用的 TiDB 服务。</p></li><li><p>等待服务退出操作完成后，执行以下命令：</p></li></ol><blockquote><p>tiup clean --all</p></blockquote><ul><li>管控平台/性能分析后台</li></ul><ol><li>dashboard</li></ol><p>可以看到TiDB的后台管理页面比较现代,支持各种功能包括<B>集群信息</B>、<B>慢SQL分析</B>、<B>日志查询</B>、<B>性能诊断</B>等</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_6_dashboard.jpg?raw=true" alt="dashboard"></p><h2 id="HTAP功能对比"><a class="header-anchor" href="#HTAP功能对比"></a>HTAP功能对比</h2><p>HTAOP功能就是在线分析功能,在传统的数据库使用过程中通常会伴随着这样的使用场景,下面用<B>TiFlash</B>和MySQL之间来对比</p><h3 id="准备数据"><a class="header-anchor" href="#准备数据"></a>准备数据</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用以下命令安装数据生成工具</span>tiup <span class="token function">install</span> bench<span class="token comment"># 使用以下命令生成数据</span>tiup bench tpch --sf<span class="token operator">=</span><span class="token number">1</span> prepare<span class="token operator">!</span><span class="token punctuation">[</span>准备数据<span class="token punctuation">]</span><span class="token punctuation">(</span>https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_1.jpg?raw<span class="token operator">=</span>true<span class="token punctuation">)</span><span class="token comment"># 运行以下 SQL 语句查看生成的数据量</span>SELECT CONCAT<span class="token punctuation">(</span>table_schema,<span class="token string">'.'</span>,table_name<span class="token punctuation">)</span> AS <span class="token string">'Table Name'</span>, table_rows AS <span class="token string">'Number of Rows'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">(</span>data_length/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS <span class="token string">'Data Size'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">(</span>index_length/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS <span class="token string">'Index Size'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">((</span>data_length+index_length<span class="token punctuation">)</span>/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS<span class="token string">'Total'</span>FROM information_schema.TABLES WHERE table_schema LIKE <span class="token string">'test'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_2_%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B1%95%E7%A4%BA.jpg?raw=true" alt="数据行数"></p><h3 id="执行SQL"><a class="header-anchor" href="#执行SQL"></a>执行SQL</h3><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT    l_orderkey,    SUM(        l_extendedprice * (1 - l_discount)    ) AS revenue,    o_orderdate,    o_shippriorityFROM    customer,    orders,    lineitemWHERE    c_mktsegment &#x3D; &#39;BUILDING&#39;AND c_custkey &#x3D; o_custkeyAND l_orderkey &#x3D; o_orderkeyAND o_orderdate &lt; DATE &#39;1996-01-01&#39;AND l_shipdate &gt; DATE &#39;1996-02-01&#39;GROUP BY    l_orderkey,    o_orderdate,    o_shippriorityORDER BY    revenue DESC,    o_orderdatelimit 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="同步列存数据"><a class="header-anchor" href="#同步列存数据"></a>同步列存数据</h3><p>TiFlash 部署完成后并不会自动同步 TiKV 数据，你可以在 MySQL 客户端向 TiDB 发送以下 DDL 命令指定需要同步到 TiFlash 的表。指定后，TiDB 将创建对应的 TiFlash 副本。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE test.customer SET TIFLASH REPLICA 1;ALTER TABLE test.orders SET TIFLASH REPLICA 1;ALTER TABLE test.lineitem SET TIFLASH REPLICA 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="分析对比性能差异"><a class="header-anchor" href="#分析对比性能差异"></a>分析对比性能差异</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_%E4%B8%8D%E4%BD%BF%E7%94%A8TiFlash.jpg?raw=true" alt="传统关系数据引擎"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_%E4%BD%BF%E7%94%A8TiFlash.jpg?raw=true" alt="TiFlash引擎"></p><p>可以看到TiFlash执行的耗时非常的少</p><h2 id="SQL-基本操作"><a class="header-anchor" href="#SQL-基本操作"></a>SQL 基本操作</h2><h2 id="SQL-基本操作-v2"><a class="header-anchor" href="#SQL-基本操作-v2"></a>SQL 基本操作</h2><p>TODO</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.pingcap.com/zh/tidb/dev/quick-start-with-tidb#%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4">TiDB官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;TiDB数据库之简介&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;TiDB 是 PingCAP 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processin</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="TiDB" scheme="https://agmtopy.gitee.io/tags/TiDB/"/>
    
  </entry>
  
  <entry>
    <title>git workflow的几种最佳实践方式</title>
    <link href="https://agmtopy.gitee.io/2022/10/29/1.%E6%9D%82%E8%AE%B0/git-workflow%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%B9%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2022/10/29/1.%E6%9D%82%E8%AE%B0/git-workflow%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%B9%E5%BC%8F/</id>
    <published>2022-10-29T02:54:10.000Z</published>
    <updated>2022-10-30T17:34:20.744Z</updated>
    
    <content type="html"><![CDATA[<h1>git workflow的几种最佳实践方式</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>现有的版本控制系统大多选择使用Git来进行管理/协作;不同的团队有会根据各自的情况选择不同的协助方式,常见的<B>git workflow</B>主要分为三种:</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow<br>常见的分支模式也可以大致划分为两种:</li><li>主干分支模式</li><li>特性分支模式</li></ul><p>下面就先介绍特性分支模式下的三种 Git WorkFlow特点与优劣;</p><h2 id="Git-flow"><a class="header-anchor" href="#Git-flow"></a>Git flow</h2><blockquote><p><B>Git flow</B>最早是由Vincent Driessen在2010年左右提出来的<B><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">《一个成功的 Git 分支模型》</a></B>一文中介绍他自己的分支管理模式;主要核心思想就是会存在两类分支:</p></blockquote><ul><li><p>长期分支:</p><ul><li><B>master</B></li><li><B>develop</B></li></ul></li><li><p>临时分支:</p><ul><li><B>hotfixs branch</B></li><li><B>release branch</B></li><li><B>feature branch</B></li></ul></li></ul><p>长期分支是一直存在的,临时分支只是会存在与一个迭代或一次hotfix的过程中,他们之间的关系如下所示:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/git_flow.png?raw=true" alt="git flow "></p><p>也可以看下面这个简化的git flow流程<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/git-flow%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png?raw=true" alt="git flow "></p><p>可以从上面两个图中看到开发者其实是站着<B>develop branch</B>一侧的,feature branch分支通常存在于本地,开发完成后执行<B>merge request(MR)</B>合并到<B>develop branch</B>(通常使用的是git merge --no–ff feature-branch的方式);同时发布分支(release branch)是从develop branch上切出来的,测试通过后mr到master中;</p><p>git flow中进行code review的判定点:</p><ul><li>尝试从私有分支合并代码到公有分支(develop, release/<em>, hotfix/</em>, master)中时</li></ul><p>例如从feature branch -&gt; develop branch,hotfixs branch -&gt; master/develop时是需要进行code review;<br>从develop -&gt; master时是不需要进行code review的;</p><h3 id="优点"><a class="header-anchor" href="#优点"></a>优点</h3><ul><li><p>严谨的合并流程<br>所有进入公共分支的代码都需要进行审核,确保代码问题;这样的合并流程适用于已有的成熟项目开发流程,可以尽量在前置协作过程中发现避免问题;</p></li><li><p>适用于开源项目(曾经)<br>各个贡献者都是在各自的repository(存储库)中工作,需要提出PR经过审核后才能提交代码到主库中</p></li></ul><h3 id="缺点"><a class="header-anchor" href="#缺点"></a>缺点</h3><ul><li><p>繁琐<br>在开发过程中,会持续维护两个长期分支<B>develop</B>和<B>master</B>,并且这两个分支的实际含义还有所重合(develop-拥有不稳定的全部代码的分支/master-拥有全部稳定代码的分支);</p></li><li><p>持续交付困难<br>所有的功能开发必须是在一个周期或多个周期内完成,造成master中的代码不是最新的,因此很难进行CD;也有基于git flow开进行CD的方案,但是有点舍本求末的感觉在里面了,CI/CD应该是在’每个人每天都致力于master上工作’的前提</p></li></ul><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>git flow的开发模式过于繁琐来保证较高的代码质量,需要去维护多个长期分支;繁琐也是相对于下面两种模式而言的;git flow的作者目前也是建议大家基于团队/项目来选择和更简单的GitHub flow;</p><h2 id="GitHub-flow"><a class="header-anchor" href="#GitHub-flow"></a>GitHub flow</h2><p>GitHub flow最早是由GitHub的技术经理scott chacon提出来的<a href="http://scottchacon.com/2011/08/31/github-flow.html">GitHub Flow</a>,是基于Github内部使用Git工作的一种流程;</p><blockquote><p>GitHub flow主要有以下几个特征:<br>- master branch中的代码是在任何时候都是可以进行部署的<br>- 功能分支名称需要用描述功能特性来进行命名的<br>- 即时将本地代码push/pull到服务器上<br>- 使用PR来进行协作(反馈/帮助/合并)<br>- 完成master合并后立即部署</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/github%20flow.jpg?raw=true" alt="github flow"></p><p>这是一个简易的GitHub flow的流程,可以看到所有去请求在进行审核之后都会被合并到Master分支中;<br>在实践中GitHub flow是一个一直向前的流程,对于master分支几乎不会进行回滚操作(通过新的提交抵消错误需要进行回滚的合并)</p><h3 id="优点-v2"><a class="header-anchor" href="#优点-v2"></a>优点</h3><ul><li><p>分支模型简单<br>这个分支模型简单是相对于Git flow来说的,只用维护一个长期分支<B>master</B>,利于后续的CI/CD</p></li><li><p>PR<br>这个是GitHub flow的一个创新,PR不止是合并代码而是一种协作方式,可以进行评论/审查/帮助,这个是跨地域进行大规模协作的基础,改变了以前通过邮件的方式;</p></li><li><p>可以最大限度减少未发布代码的数量<br>master branch 在合并代码后就会进入持续交付阶段,这样会最大限度的降低未发布代码的数量</p></li></ul><h3 id="缺点-v2"><a class="header-anchor" href="#缺点-v2"></a>缺点</h3><ul><li><p>无法应对版本的延迟发布<br>在实际开发工作中,持续交付不一定能实现,毕竟大多数技术开发还是以业务为导向的;</p></li><li><p>无法处理多版本交付<br>开发环境/测试环境/预发环境甚至生产多版本部署的场景</p></li></ul><h3 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h3><p>GitHub flow在简化Git flow的基础上支持开源软件的开发模式,但是自身也有一些问题.</p><h2 id="GitLab-flow"><a class="header-anchor" href="#GitLab-flow"></a>GitLab flow</h2><p>GitLab flow是由极狐公司提出在<B><a href="https://docs.gitlab.cn/jh/topics/gitlab_flow.html">GitLab Flow介绍</a></B>一文实践的分支管理方式;</p><p>GitLab flow的设计遵寻两个原则:</p><ul><li>单一主分支</li></ul><blockquote><p>单一主分支原则与GitHub Flow所保留的Master分支一致</p></blockquote><ul><li>上游优先</li></ul><blockquote><p>上游优先原则指的是只存在一个主分支master,它是所有其他分支的<B>上游</B>.只有上游分支采纳的代码变化,才能应用到其他分支。对于<B>持续发布</B>的项目，它建议在master分支以外，再建立不同的环境分支。比如,<B>开发环境</B>的分支是master,<B>预发环境</B>的分支是pre-* ,<B>生产环境</B>的分支是pro-*;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%201.png?raw=true" alt="上游优先流程"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%202.png?raw=true" alt="生产分支的切出"></p><p>从上述的流程中可以看到GitLab flow在分支上选择是多分支的管理方式,但是是一种基于<B>上游优先</B>策略下的多分支管理方式,并不是像Git flow那样同时维护多个长期分支,对于后续的发布分支流程,GitLab采用的也是从Master branch中切分支或者打tag的方式:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%203.jpg?raw=true" alt="GitLab 发布分支"></p><p>在GitLab的实践中,通常<B>Master branch</B>都是受保护的,这样大部分开发者不能对其进行直接修改;<br>其中在他们的实践中也认可践行(PR/MR)的协助方式,分支的命名也是采用的功能命名的方式,合并后立即删除,以便其他人重新开始这个功能的议题;issues是工作的开始,MR是工作的结束;</p><h3 id="优点-v3"><a class="header-anchor" href="#优点-v3"></a>优点</h3><ul><li><p>支持多版本部署<br>支持pre-* /pro-*的多分支部署方式</p></li><li><p>可以支持延迟发布<br>开发分支和发布分支可以并行</p></li></ul><h2 id="小结-v3"><a class="header-anchor" href="#小结-v3"></a>小结</h2><p>由于GitLab flow出现的时间比git flow/gitlab flow都要晚一些,因此吸收了这两种风格的特点(支持多分支/PR模式);<br>大多数开发模式都是让代码审查通过后直接进入Master branch,因为这样可以尽早的解决冲突;</p><p>以上三种代码分支的管理方式都是基于<B>功能开发</B>(先有需求驱动的开发模式),并不是GitLab flow就一定比Git flow要更好,只有更适合的,下面介绍三种简单的区分方式仅供参考:</p><ul><li>工作中会使用到多个版本 -&gt; Git flow</li></ul><blockquote><p>如果代码库在工作中有多个版本(即典型的软件产品,如操作系统、Office 软件包、自定义应用程序等);可以使用git-flow,主要原因是在开发下一个版本的同时,需要在生产中持续支持以前的版本,并且有一个较长的迭代周期;</p></blockquote><ul><li>工作中只会使用到一个版本 -&gt; GitHub flow</li></ul><blockquote><p>如果代码库始终只有一个生产版本（即网站、Web 服务等），可以使用 github flow。主要原因是您不需要为开发人员复杂的事情。一旦开发人员完成一项功能或完成错误修复，它就会立即升级为生产版本。</p></blockquote><ul><li>生产中的单一版本但非常复杂的软件 -&gt; Gitlab-flow</li></ul><blockquote><p>在商业大型软件或者是以提供服务的项目上，在生产中可能需要在您的分支和主分支之间来回部署,并且在不同版本都需要进行CI/CD。推荐就使用Gitlab-flow</p></blockquote><h2 id="基于主干的开发模式"><a class="header-anchor" href="#基于主干的开发模式"></a>基于主干的开发模式</h2><p>在基于主干的开发模式中,所有开发人员都在一个开放的分支上进行工作。一般是使用master分支.他们直接向Master提交代码并运行;开发人员会创建短暂的功能分支。一旦他们分支上的代码编译并通过所有测试，他们就会直接将其合并到master. 确保开发是真正连续的，并防止开发人员创建难以解决的合并冲突;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/%E5%9F%BA%E4%BA%8E%E4%B8%BB%E5%B9%B2%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png?raw=true" alt="基于主干开发流程"></p><p>可以看到<B>基于主干的开发流程</B>非常的简单,任何人都可以直接向Master branch 合并代码,能够做到快速交付/迭代;缺点是没有人来进行功能性code review,只能进行完整的源代码检查(这是一种灾难😰);</p><p>基于主干的开发模式适用于:<B>项目开始的早期</B>、<B>拥有的都是老手</B>(😖)或者是<B>基础架构强/持续集成工具集成度高/TDD和自动化测试覆盖完善场景</B>下;</p><p>其实还有其他的开发模式例如<B>集中式</B>、<B>Forking</B>等工作流程,有兴趣的可以了解一下;</p><h2 id="使用Git的几个约定"><a class="header-anchor" href="#使用Git的几个约定"></a>使用Git的几个约定</h2><p>在使用Git过程中,其实每个团队的风格不同,都有一些比较好的值得借鉴的地方,以下可能是我自己的一个使用习惯</p><ol><li><p><B>使用rebase -i整理需要提交的commit</B><br>每次大功能向master/develop等公开分支提交时,会首先将同一需求的多个commit压缩合并成为一个有具体含义的commit后在发起PR;这样做的原因是基于我认为提交的MR应该是一个完整的功能/补丁/操作的log,可以让之后进行阅读的人知道这一行代码是为那个需求/修复而写的,而不应该是一个需求中的一个小点添加的;第二点是便于回滚/Cherry-pick,一个commit的操作要比多个commit的操作更简单;</p></li><li><p><B>基于最新的共享分支进行MR</B><br>这一点是基于Code review来说的,基于过时的分支合并到共享分支中是会夹杂大量代码差异,不利于code review的进行;对于rebase的使用,坚持一个原则<B>私有分支操作使用rebase,共享分支操作使用merge</B></p></li><li><p><B>使用stash</B><br>暂存区配合分支切换可以较好的完成,工作区的分支切换/代码存储合并的动作</p></li></ol><h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2><ul><li><p>Code Review如何让每一个人参与其中?</p></li><li><p>CI耗时过程问题以及是否需要进行CI?</p></li></ul><blockquote><p>需要,非常需要;gradle cache;</p></blockquote><ul><li>代码文件冲突/合并的问题?</li></ul><blockquote><p>产生的原因是与长期分支脱节、需求划分的不合理、没有及时的协作解决冲突等等</p></blockquote><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.gitlab.cn/jh/topics/gitlab_flow.html">GitLab Flow 介绍</a><br><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a><br><a href="https://nvie.com/posts/a-successful-git-branching-model/">一个成功的Git分支模式</a><br><a href="http://dockone.io/article/2350">gitLab Flow的11条建议</a><br><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">atlassian Bitbucket</a><br><a href="https://about.gitlab.com/topics/version-control/what-is-git-workflow/">what-is-git-workflow</a><br><a href="https://www.toptal.com/software/trunk-based-development-git-flow">trunk based developmentgit flow</a><br><a href="https://medium.com/burdaforward/state-of-ci-cd-and-the-dreaded-git-flow-fce92d04fb07">State of CI/CD and the omnipresent git flow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;git workflow的几种最佳实践方式&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;现有的版本控制系统大多选择使用Git来进行管理/协作;不同的团队有会根据各自的情况选择不同的</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://agmtopy.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库系统原理</title>
    <link href="https://agmtopy.gitee.io/2022/09/27/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/31.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>https://agmtopy.gitee.io/2022/09/27/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/31.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2022-09-27T15:11:06.000Z</published>
    <updated>2022-11-05T07:31:16.606Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式数据库系统原理</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><blockquote><p>为什么需要分布式?</p></blockquote><ul><li><B>处理逻辑</B></li><li><B>功能</B></li><li><B>数据</B></li><li><B>控制</B></li></ul><p>对于这个的理解应该是:</p><ul><li>处理逻辑:对应应用实例或者算法之类的,单点无法满足某些需求(AP)</li><li>功能:对于功能的分布式划分主要是体现在微服务的拆分上,不同的功能拆分成为不同的服务</li><li>数据:对于数据的拆分主要是单点数据服务无法满足要求的情况下,进行拆库拆表</li><li>控制:<font color="#dddd00">这个暂时不能理解?控制是否为程序或者算法的同义楠?</font></li></ul><blockquote><p>什么是分布式数据库?<br>物理上分布不同地方,通过计算机网络逻辑上相互关联的数据库</p></blockquote><h3 id="主要的问题"><a class="header-anchor" href="#主要的问题"></a>主要的问题</h3><ul><li>数据如何选择分片?</li><li>分布式事务的实现?</li><li>性能问题?</li></ul><p>如下图:</p><p><img src="https://raw.githubusercontent.com/agmtopy/noteBook/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.jpg" alt="分布式数据问题之间的联系"></p><h3 id="集中式数据库模型与分布式数据库模型"><a class="header-anchor" href="#集中式数据库模型与分布式数据库模型"></a>集中式数据库模型与分布式数据库模型</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E9%9B%86%E4%B8%AD%E5%BC%8FDBMS%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.jpg?raw=true" alt="集中式DBMS分层架构"></p><p>可以看到集中式数据库就是一个标准的应用分层,以MySql为例</p><p>界面: 提供不同语音的MySql Drive<br>控制: 连接校验<br>编译: sql解析<br>执行: innodb存储引擎处理<br>数据访问:MySql内核处理<br>一致性: 各种Lock和log</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpg?raw=true" alt="分布式数据库结构"></p><p>可以看到分布式数据库系统需要从三个不同的方面进行考虑:<B>物理分布</B>&lt;B&gt;异构性</B>&lt;B&gt;自治性</B></p><ul><li>物理分布:指的是组成分布式系统的服务可以在物理上隔离,可以不需要在通一台硬件机器上运行</li><li>异构性:指的是各个服务允许使用各自的协议来提供服务,这一点在工业级的分布式数据库上应该没有实现,还是遵守相同协议来降低软件复杂度</li><li>自洽性:各个服务本身就可以单独对外提供服务,不用依赖其他系统,这一点常用的分布式系统较为不同</li></ul><h3 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h3><ul><li>DBMS</li></ul><blockquote><p>DBMS-关系数据库的概念是一组结构化的数据,它是出于我们对现实世界建模的映射,一个关系数据库是以表格形式表达数据的数据库.</p></blockquote><h2 id="分布式数据库设计"><a class="header-anchor" href="#分布式数据库设计"></a>分布式数据库设计</h2><p>有两种分布式数据库的设计方法:<B>自顶向下的方法</B>和<B>自底向上的方法</B>,这也是软件领域设计的两种通用设计方法,例如我们在设计系统的时候基于底层功能实现还是上层战略定位来进行的往往会得到不同的演进路线;</p><ul><li>自顶向下:指的是在设计的时候就考虑不同的实例去支持局部的全局概念模型</li><li>自底向上:指的是将多个数据库中的信息集成为一个紧密相连的多数据库系统,常用于<B>数据仓库/数据湖</B></li></ul><h3 id="分布设计的研究问题"><a class="header-anchor" href="#分布设计的研究问题"></a>分布设计的研究问题</h3><ul><li>如何得到正确的分片结果?<br>首先,数据分片有两种维度来进行,一种是垂直分片按照业务领域进行划分,一种是水平进行分片按照特定规则来进行划分;我们会重点研究采用水平模式的设计方案.</li></ul><p>专业的分布式数据库的数据划分好复杂,会去考虑数据的分片是按照某些条件来进行的,既要保证数据的分片又要保证数据的’亲和性’;一大段一大段的高阶函数~😳😳😳</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式数据库系统原理&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要分布式?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;B&gt;处理逻辑</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-内存管理篇</title>
    <link href="https://agmtopy.gitee.io/2022/09/24/20.%E7%AC%94%E8%AE%B0/12.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/09/24/20.%E7%AC%94%E8%AE%B0/12.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/</id>
    <published>2022-09-24T09:09:44.000Z</published>
    <updated>2022-09-25T14:22:14.661Z</updated>
    
    <content type="html"><![CDATA[<h1>现代操作系统原理与实现-内存管理篇</h1><p>一晃而过距离上一篇<B>硬件结构</B>已经过去了一个月有余了.最近一直在整理<B>Notion</B>上的笔记,把《深入理解Java虚拟机》的相关笔记也在notion上写和整理去了,对《现代操作系统原理与实现》的笔记也耽搁了许久;这本书应该是本年度最佳书籍了,会争取在今年把第一遍阅读的相关笔记完成,时间过的真的很快,跑题感慨了一下,下面继续有关内存部分的整理和理解吧!</p><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>在上一章中了解到物理内存是组成操作系统的重要部分,这一章节就是介绍操作系统是如何管理和使用内存的;</p><h3 id="内存管理"><a class="header-anchor" href="#内存管理"></a>内存管理</h3><p>内存管理主要是对物理内存的管理,在早期程序是直接分配在物理内存上运行的,那个时候操作系统都不存在,这样分配会产生几个问题例如程序直接操作物理内存无法做到隔离/分配内存空间的碎片化/无法处理超过物理容量限制的分配</p><p>针对这个些问题,提出了<B>虚拟内存</B>的概念,大概是在1956年的一位德国物理学家提出的,感觉这个时间过了好久了啊,但是在翻阅资料查这些的时候发现计算机的发明居然还没有80年,太不可思议了</p><p><img src="http://www.isolves.com/d/file/p/2020/03-17/bbd1470ef6879e2f6e4847b7444fde35.jpg" alt="虚拟内存技术发展时间线"></p><h4 id="虚拟内存"><a class="header-anchor" href="#虚拟内存"></a>虚拟内存</h4><blockquote><p>虚拟内存作为物理内存和应用程序之间的一个抽象层;应用程序不在直接运行在物理内存之上,而是运行在虚拟内存之上;应用程序在运行时只知道虚拟内存地址,cpu或者硬件负责将虚拟地址转换为物理地址,操作系统负责设置虚拟地址与物理地址之间的映射;每个应用程序只能看到属于自己的虚拟内存地址,并且看到的虚拟内存地址是同一的、连续的;</p></blockquote><ul><li>虚拟内存的结构<br>下面是一张有关CPU如何将虚拟地址转换为物理地址的图:</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/x-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/CPU%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio.png?raw=true" alt="CPU虚拟地址翻译示意图"></p><p>可以看到操作系统向CPU发生虚拟地址访问请求后,传给MMU在通过TLB转换后,将物理地址发送给操作总线,从而访问到物理内存地址;</p><p>现代操作系统都是通过分页的形式采用页表来实现的,<B>TLB</B>缓存了虚拟页号到物理页号之间的映射关系,TLB的设计非常简单就是做映射,但是却十分的高效,因为在内存数据的访问遵守<B>时空局部性原理</B></p><ul><li>虚拟内存中的换页</li></ul><p>在前面说到物理内存无法自动处理分配超过实际容量限制的场景.而虚拟内存可以做到,就是通过换页机制来实现的,具体流程如下:</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/143273007">操作系统之内存管理</a><br><a href="https://ewikizh.top/wiki/Virtual_memory#cite_note-10">虚拟内存</a><br><a href="https://www.isolves.com/it/rj/jy/2020-03-17/14226.html">虚拟内存技术的前世今生</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;现代操作系统原理与实现-内存管理篇&lt;/h1&gt;
&lt;p&gt;一晃而过距离上一篇&lt;B&gt;硬件结构&lt;/B&gt;已经过去了一个月有余了.最近一直在整理&lt;B&gt;Notion&lt;/B&gt;上的笔记,把《深入理解Java虚拟机》的相关笔记也在notion上写和整理去了,对《现代操作系统原理与实现》的笔记也</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-硬件结构篇</title>
    <link href="https://agmtopy.gitee.io/2022/08/14/20.%E7%AC%94%E8%AE%B0/11.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/08/14/20.%E7%AC%94%E8%AE%B0/11.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2022-08-14T06:39:04.000Z</published>
    <updated>2022-09-24T09:10:19.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>操作系统是建立在硬件结构基础上的软件实现,这一章节我们来介绍计算机的硬件结构.</p><h2 id="CPU与指令集架构"><a class="header-anchor" href="#CPU与指令集架构"></a>CPU与指令集架构</h2><blockquote><p>指令集架构是cpu与软件之间的桥梁,包括指令集\特权级\寄存器\执行模式\安全扩展\性能加速等等</p></blockquote><h3 id="指令集"><a class="header-anchor" href="#指令集"></a>指令集</h3><p>指令集包括<B>精简指令集(RISC)</B>和<B>复杂指令集(CISC)</B>两种.</p><ul><li><p>精简指令集<br>指的是没有寄存器的指令集,通过指令来模拟寄存器的操作,常见的安卓和苹果的A系/M系芯片都是使用的这种指令集</p></li><li><p>复杂指令集<br>指的是有寄存器的指令集,通过使用寄存器来执行指令,常见的Intel的X86芯片都是使用的这种指令集</p></li></ul><p>目前在生产中并没有严格隔离指令集,CISC也在集成RISC的相关指令</p><p>常用的指令类型分为4种:</p><ul><li>数据搬移指令(mov等)</li><li>寄存器计算指令(add/sub等)</li><li>内存读写指令(ldr-加载/str-读写等)</li><li>调整指令(b)</li><li>过程调用指令(bl/ret)</li><li>特权指令(mrs/msr)</li></ul><h2 id="特权级"><a class="header-anchor" href="#特权级"></a>特权级</h2><p>指的是指令运行的级别,分别是El0,El1,El2,El3</p><ul><li><p>El0<br>指的是最低特权级,应用程序通常运行在这一级别上,也可以称为<B>用户态</B></p></li><li><p>EL1<br>操作系统通常运行在这一级别上,也称为<B>内核态</B></p></li><li><p>El2<br>指的是次高特权级,操作系统通常运行在这一级别上,也称为<B>高级内核态</B>,通常虚拟机监控器需要运行在这一状态</p></li><li><p>El3<br>负责普通世界与安全世界的切换,安全世界是<B>AArch64</B>提出来的一个管理硬件交互的级别,EL3在级别上是最高的,因为可以直接操作硬件</p></li></ul><blockquote><p>EL0 &lt; EL1 &lt; EL3 &lt; EL3</p></blockquote><p>程序在运行过程中大量的发生EL0 &lt;=&gt; EL1转换,其实就是用户进程与内核进程在不断的进行切换的过程;这里需要注意一点的是<B>中断</B>是运行在EL1级别上的</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2.jpg?raw=true" alt="中断切换"></p><h2 id="寄存器"><a class="header-anchor" href="#寄存器"></a>寄存器</h2><p>寄存器是指令集中的一种数据结构,用于存储数据,比如寄存器中存储的是指令的地址,寄存器中存储的是指令的参数等等.它们是cpu的基本架构组成部分,参与指令的执行和计算过程.现代CPU往往会使用大量专用的寄存器来做专业的事情,比如帧指针寄存器,连接寄存器等</p><h2 id="物理内存与CPU缓存"><a class="header-anchor" href="#物理内存与CPU缓存"></a>物理内存与CPU缓存</h2><ul><li>物理缓存</li></ul><blockquote><p>CPU在执行的过程中,可以通过访存指令不断的向物理内存中读写数据;CPU使用物理内存的方式很简单:通过<B>总线</B>向物理内存发生一个读写请求,其中包括目标地址,物理内存在接收到请求后,会根据请求的类型进行读写操作,并返回相应的结果</p></blockquote><p>通过以上的描述可以得知CPU在进行执行时都是通过总线与内存进行交互\cpu从内存中取值后会放到私有的区域(CPU缓存)中,其实这样的设计也加大了应用人员开发出健壮/正确的并发代码难度,在编写并发相关代码时一定要仔细</p><ul><li>CPU缓存</li></ul><blockquote><p>CPU缓存是一个私有的区域,用于存储CPU执行过程中的数据;由若干个<B>缓存行</B>组成.每个缓存行包含:一个<B>有序位标识</B>标识数据是否有效和一个<B>标记地址</B>用于标记其对应的物理地址;</p></blockquote><blockquote><p>CPU以缓存行(常见的是64bit大小)为单位把物理内存读取到缓存中,也就是说如果只需要一个bit的数据,但是还是需要把该字节对应的缓存行数据全部读取到缓存中,写入反之亦然也是每次需要写出64bit大小的数据</p></blockquote><p>对于CPU缓存行最熟悉的一个作用是<B>禁止指令重排</B>,在java中我们知道valitate的一个作用是可见性,就是根据基于缓存行的<B>缓存一致性协议-MESI协议</B>来实现的</p><p>volatile的另外一个作用是可以解决编译器层面的可见性与重排序问题。而内存屏障则解决了硬件层面的可见性与重排序问题</p><h2 id="设备与中端"><a class="header-anchor" href="#设备与中端"></a>设备与中端</h2><p>常见的设备指的是输入与输出设备,常见的内存映射输入输出设备,常见的中断设备,比如硬盘,光驱,键盘,鼠标等</p><p><B>中断</B>机制是提供设备主动通知CPU的能力.设备通过向CPU发送中断来打断CPU的执行.</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>本章主要介绍<B>精简指令集</B>&lt;B&gt;特权级</B>&lt;B&gt;寄存器</B>&lt;B&gt;内存与缓存</B>等硬件基本结构<br>多核CPU缓存的设计遵守<B>缓存一致性协议</B>这个是valotail可见性的基础</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/MrLiuZF/p/15054855.html">CPU缓存</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;操作系统是建立在硬件结构基础上的软件实现,这一章节我们来介绍计算机的硬件结构.&lt;/p&gt;
&lt;h2 id=&quot;CPU与指令集架构&quot;&gt;&lt;a class=&quot;head</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(一)</title>
    <link href="https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%80)/</id>
    <published>2022-08-08T15:45:00.000Z</published>
    <updated>2022-11-14T15:51:04.370Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(一)</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>是《深入分布式缓存-从原理到实践》一书的一些记录</p><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><blockquote><p>cache这个词,据说来自于法语,本意是当CPU处理数据时先到cache中去寻找,如果数据在之前的操作与i就读取而被暂存其中,就不需要从主内存中去读取了.后来cache的范围有所扩展,泛指凡是位于速度相差比较大的两种硬件之间,用于协调两者数据传输差异的结构,都称为cache.</p></blockquote><p>凡是通过两种查询速度较大的方式来查询同一对象都称为cache</p><blockquote><p>缓存:存储在计算机上的一个原始数据复制集,以便用于访问   -wiki</p></blockquote><p>常见的一些缓存:</p><ul><li>CPU多级缓存</li><li>TLB(Translation lookaside buffer) -最新的虚拟内存-&gt;物理内存的转换</li></ul><p>缓存分类:</p><ul><li>按缓存位置划分<ul><li>客户端缓存</li><li>服务器端缓存</li><li>网络中的缓存</li></ul></li><li>按部署方式划分<ul><li>单体缓存</li><li>集群缓存</li><li>分布式缓存</li></ul></li></ul><h3 id="网络中的缓存"><a class="header-anchor" href="#网络中的缓存"></a>网络中的缓存</h3><ul><li>web代理缓存</li></ul><p>使用正向代理的方式将web服务器上的数据进行缓存,客户端请求后之间返回不需要重新先web服务器请求</p><ul><li>边缘缓存</li></ul><p>边缘缓存是通过反向代理的方式与用户处于同一网络,向用户提供静态内容的缓存,典型应用就是CDN缓存</p><h3 id="缓存算法"><a class="header-anchor" href="#缓存算法"></a>缓存算法</h3><p>LRU:最近最少使用算法<br>LFU:最少使用算法(会统计一段时间内每个缓存的访问次数)<br>SIZE:缓存大小算法(按照缓存的大小进行算法)</p><h2 id="分布式系统理论"><a class="header-anchor" href="#分布式系统理论"></a>分布式系统理论</h2><ul><li>并向与并发</li></ul><blockquote><p>并发指的是两个事情或多个事情在同一个时间段内间隔发生;并行指的是两个事情或多个事情在同一个时刻同时发生;</p></blockquote><ul><li>CAP</li></ul><blockquote><p>CAP理论提出一致性\可用性\分区容错性的取舍问题</p></blockquote><p>一致性©:指的是在同一时刻访问所有节点得到的数据相同<br>可用性(U):指的是在同一时刻访问所有节点得到的数据都可用<br>分区容错性§:指的是节点一定会发生故障,但是不会影响整个系统的正常运行</p><h3 id="分布式系统设计策略"><a class="header-anchor" href="#分布式系统设计策略"></a>分布式系统设计策略</h3><p>分布式系统设计策略指的是对于设计分布式系统常见的几个问题的处理策略:</p><ul><li>如何检测你还活着?</li><li>如何保障高可用?</li><li>容错机制的设计?</li><li>重试机制?</li><li>负载均衡?</li></ul><p>下面详细对每一个问题进行解答:</p><h4 id="如何检测你还活着"><a class="header-anchor" href="#如何检测你还活着"></a>如何检测你还活着?</h4><p>在分布式系统中如何检测当前节点是否存活?<br>在大多数分布式中间件中都是通过<B>心跳检测</B>的机制来检测当前节点是否存活的,例如在zk的client与server之间的心跳检测保持连接\redis哨兵架构中的哨兵与master/slave之间的心跳检测</p><p><B>φ-accrual 故障检测器</B>是通过滑动窗口的时间算法来统计结果</p><p><B>Gossip分发</B>(流言算法)通过消息的传递确定节点是否应该停止服务的算法</p><p>小结:<br>存活检测有两个方法:一个是从通信链路入手检测目标节点的网络是否异常\一种是通过检测当前状态是否符合预期状态来检测目标节点是否存活</p><h4 id="如何保障高可用"><a class="header-anchor" href="#如何保障高可用"></a>如何保障高可用?</h4><p>在分布式系统中保障高可用的核心就是数据备份,通过多个节点的备份来在任何节点故障的情况下提供服务<br>按照提供服务的节点时机可以分为<B>主备(Master/Slave)</B>&lt;B&gt;互备(Failover)</B>&lt;B&gt;集群(Cluster)</B>这三种方式</p><ul><li><p>主备(Master/Slave)模式<br>主备模式多用于要求严格提供C(一致性)\A(可用性)的场景中,MySQL的主备模式\Redis的哨兵模式</p></li><li><p>互备(Failover)模式<br>互备模式指的是各个节点提供的数据和服务是相同的,常见的RocketMQ的注册中心NameServer就是多个节点提供相同的服务</p></li><li><p>集群(Cluster)模式<br>集群模式指的是服务在多个节点运行,不同的节点运行不同的任务,比如Redis的集群模式;集群模式与主备模式/互备模式的区别在于集群模式是仅对服务进行高可用的设计,另外两种设计既有对服务和数据的双重含义</p></li></ul><h4 id="容错机制的设计"><a class="header-anchor" href="#容错机制的设计"></a>容错机制的设计</h4><p>容错机制指的是在系统设计中需要对一些异常场景的兼容,例如在Raft的一些实现中就会对CommitId进行CRC32的容错机制校验</p><h4 id="重试机制"><a class="header-anchor" href="#重试机制"></a>重试机制</h4><p>重试机制指的是系统调用失败后,由于无法确定是否网络异常,或者是否是系统调用的问题,可以重试一定次数,如果重试次数超过限制,则抛出异常;这种设计是基于网络异常和系统异常的区别的基础上来进行设计的,在一般认为中网络异常是频繁且持续的,因此可以重试机制下,重试一定次数<br>重试机制又会引出接口幂等的场景,因此在分布式系统设计中,接口一定要提供幂等</p><h4 id="负载均衡"><a class="header-anchor" href="#负载均衡"></a>负载均衡</h4><p>负载均衡类似于集群模式通过一个总的调度器来对任务进行分配,常用的负载均衡方案Nginx,LB</p><h3 id="分布式系统的几个通用问题"><a class="header-anchor" href="#分布式系统的几个通用问题"></a>分布式系统的几个通用问题</h3><ul><li>全局id的生成</li><li>hash取模分配</li><li>路由表</li><li>一致性hash算法</li><li>数据拆分</li><li>分布式锁的解决方案</li><li>分布式事务的解决方案</li></ul><h4 id="全局Id的生成方案"><a class="header-anchor" href="#全局Id的生成方案"></a>全局Id的生成方案</h4><p>分布式Id的产生是基于数据服务大都采用集群的模式提供服务,在这种模式下不同的节点如果产生的id不进行相互协调的话会造成id的冲突,因此需要一个全局的id生成方案来保证id的唯一性</p><p>有两种实现思路:</p><ul><li>基于节点执行不同规则的id生成</li><li>基于全局协调器的id生成</li></ul><p>下面分别来介绍一下这两种不同的方案</p><ul><li>基于节点执行不同规则的id生成</li></ul><p>是通过值得数据节点的id生成规则来实现的,例如对id设置初始值和步长,然后每个节点都会计算出自己的id,这样就可以保证id的唯一性</p><ul><li><p>基于全局协调器的id生成<br>基于全局协调器的id生成方案实现比较多,例如通过一张id表的方式来进行实现\通过分布式id生成器的号段模式来实现\通过分布式id生成器的雪花算法来实现</p></li><li><p>snowflake的id生成方案</p></li></ul><p>64bit = 41bit(时间戳) + 10bit(节点id) + 12bit(自增id)<br>时间戳精确到毫秒<br>12位自增id每个节点最多产生4096个id</p><h4 id="hash取模-路由表-一致性hash算法"><a class="header-anchor" href="#hash取模-路由表-一致性hash算法"></a>hash取模\路由表\一致性hash算法</h4><p>hash取模\路由表\一致性hash算法都是为了解决数据或服务的一个寻址过程,例如对于一个数据库来说,如果数据库有多个节点,那么对于某个数据来说,可以通过hash取模的方式来寻址到对应的节点,这样就可以保证数据的一致性</p><p>hash取模是指的是对数据进行hash取模,然后根据模的值来寻址到对应的节点,这样就可以保证数据的分片性</p><p>路由表是通过预设的路由表来寻址到对应的节点,这样就也可以保证数据的分片性;路由表还有一个优点是对于有序增加的场景下可以通过递增预设的路由表数据来寻址到对应的节点,还不影响之前的数据,但是这样有一个路由表单点问题,需要做好数据的备份和failover</p><h4 id="数据拆分"><a class="header-anchor" href="#数据拆分"></a>数据拆分</h4><p>数据的拆分主要指的是将数据分片到不同的节点上,这样就可以保证数据的一致性;前面已经介绍数据拆分的原理;<br>常用的数据拆分方案是mycat/shardingsphere等</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>这一章节主要给我们介绍<B>分布式系统设计策略</B>&lt;B&gt;分布式系统的几个通用问题</B>的解决方案</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(一)&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;是《深入分布式缓存-从原理到实践》一书的一些记录&lt;/p&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a clas</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(二)</title>
    <link href="https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/21.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%BA%8C)/"/>
    <id>https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/21.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%BA%8C)/</id>
    <published>2022-08-08T15:45:00.000Z</published>
    <updated>2022-11-14T15:51:02.990Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(二)</h1><h2 id="规划定义"><a class="header-anchor" href="#规划定义"></a>规划定义</h2><h3 id="JSR"><a class="header-anchor" href="#JSR"></a>JSR</h3><blockquote><p>JSR是java Specification Requests的缩写,是java定义的一种对java对象临时在内存中进行缓存的方法,包括对象的创建\访问\失效\一致性等</p></blockquote><h3 id="缓存常用方法"><a class="header-anchor" href="#缓存常用方法"></a>缓存常用方法</h3><table><thead><tr><th>接口</th><th>说明</th><th>Ehcache</th><th>Guava</th></tr></thead><tbody><tr><td>put()</td><td>添加缓存</td><td>✔</td><td>✔</td></tr><tr><td>putIfAbsent()</td><td>如果key不存在则添加缓存</td><td>✔</td><td>✔</td></tr><tr><td>replace()</td><td>如果key存在则替换缓存</td><td>✔</td><td>✔</td></tr><tr><td>get()</td><td>获取缓存</td><td>✔</td><td>✔</td></tr><tr><td>getAll()</td><td>获取所有缓存</td><td>✔</td><td>✔</td></tr><tr><td>getAllPresent(key)</td><td>存在key在进行加载</td><td>❌</td><td>✔</td></tr><tr><td>putAll(entries)</td><td>添加所有缓存</td><td>✔</td><td>✔</td></tr><tr><td>keySet()</td><td>获取所有key</td><td>❌</td><td>❌</td></tr><tr><td>remove()</td><td>移除缓存</td><td>✔</td><td>✔</td></tr><tr><td>clear()</td><td>清空缓存</td><td>✔</td><td>✔</td></tr></tbody></table><p>可以看到常见的缓存操作就三类:<B>添加</B>&lt;B&gt;获取</B>&lt;B&gt;移除</B></p><p>下面介绍两类缓存的实现方式:<B>本地缓存</B>和<B>分布式缓存</B></p><h2 id="本地缓存"><a class="header-anchor" href="#本地缓存"></a>本地缓存</h2><h3 id="Ehcache"><a class="header-anchor" href="#Ehcache"></a>Ehcache</h3><p>暂且将Ehcache划分到本地缓存中,因为在使用中大多数场景下还是将Ehcache作为本地缓存来进行使用</p><p>Ehcache2的核心淘汰策略逻辑如下:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ehcache_AbstractPolicy_selectedBasedOnPolicy.jpg?raw=true" alt="selectedBasedOnPolicy"></p><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/AbstractPolicy.java#L77">AbstractPolicy.selectedBasedOnPolicy</a></p><ul><li>compare</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Compares the desirableness for eviction of two elements * * @param element1 the element to compare against * @param element2 the element to compare * @return true if the second element is preferable for eviction to the first element * under ths policy */</span><span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<B>compare()</B>方法是核心的比较方法,下层有<B>LRUPolicy</B>&lt;B&gt;LFUPolicy</B>&lt;B&gt;FIFOPolicy</B>底层实现</p><ul><li>LruPolicy</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较最后访问时间</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getLastAccessTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getLastAccessTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/LruPolicy.java#L52">LruPolicy.compare</a></p><ul><li>LFU</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较访问次数</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getHitCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getHitCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/LfuPolicy.java#L52">LfuPolicy.compare</a></p><ul><li>FIFO</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较创建和更新时间</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getLatestOfCreationAndUpdateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getLatestOfCreationAndUpdateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/FifoPolicy.java#L52">FIFOPolicy.compare</a></p><h3 id="Guava-Cache"><a class="header-anchor" href="#Guava-Cache"></a>Guava Cache</h3><p>Guava Cache是Google对java集合的一种封装来实现缓存功能;</p><p>Guava Cache 提供缓存的失效时间和定时更新功能,下面介绍Guava Cache定时更新方法</p><ul><li>scheduleRefresh()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">V</span> <span class="token function">scheduleRefresh</span><span class="token punctuation">(</span>    <span class="token class-name">ReferenceEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> entry<span class="token punctuation">,</span>    <span class="token class-name">K</span> key<span class="token punctuation">,</span>    <span class="token keyword">int</span> hash<span class="token punctuation">,</span>    <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span>    <span class="token keyword">long</span> now<span class="token punctuation">,</span>    <span class="token class-name">CacheLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> loader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">refreshes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//map.refreshes()判断是否存在过期时间</span>      <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> entry<span class="token punctuation">.</span><span class="token function">getWriteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> map<span class="token punctuation">.</span>refreshNanos<span class="token punctuation">)</span><span class="token comment">//判断是否已经过期</span>      <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>entry<span class="token punctuation">.</span><span class="token function">getValueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断是否当前正在加载新值</span>    <span class="token class-name">V</span> newValue <span class="token operator">=</span> <span class="token function">refresh</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> loader<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新加载数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> newValue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>scheduleRefresh()方法是在get()方法中调用的<br><a href="https://github.com/google/guava/blob/c111c0150225739b3f5914d1739cd22fb692bce7/guava/src/com/google/common/cache/LocalCache.java#L2324">LocalCache.scheduleRefresh</a></p><h3 id="Caffine"><a class="header-anchor" href="#Caffine"></a>Caffine</h3><h2 id="二级缓存"><a class="header-anchor" href="#二级缓存"></a>二级缓存</h2><p>在使用集中式或者数据库热点配置数据时,我们往往将这些数据放到应用进程空间中中,这样可以提高缓存的命中率;可以用Echache/Guava作为二级缓存来进行使用<br>下面介绍两种常用的设计方案:</p><ul><li>定时轮询</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/reids%E6%95%B0%E6%8D%AE%E5%AE%9A%E6%97%B6%E8%BD%AE%E8%AF%A2%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88.drawio.png?raw=true" alt="定时轮询"></p><ul><li>消息通知</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/reids%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88.drawio.png?raw=true" alt="消息通知"></p><p>消息通知的方案可以保证准实时下的推送,但是会带来一定的开销,比如消息通知的推送频率是每秒一次,那么每秒钟的消息会被推送到缓存中,这样会带来一定的开销,通过这样的消耗来保证实时性;还需要注意一点的是应用的重启后一定要消费最新的消息或从redis中获取最新的数据</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://github.com/hazelcast/hazelcast">https://github.com/hazelcast/hazelcast</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(二)&lt;/h1&gt;
&lt;h2 id=&quot;规划定义&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#规划定义&quot;&gt;&lt;/a&gt;规划定义&lt;/h2&gt;
&lt;h3 id=&quot;JSR&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JS</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-操作系统结构篇</title>
    <link href="https://agmtopy.gitee.io/2022/08/04/20.%E7%AC%94%E8%AE%B0/10.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/08/04/20.%E7%AC%94%E8%AE%B0/10.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2022-08-04T01:00:34.000Z</published>
    <updated>2022-08-14T06:40:46.371Z</updated>
    
    <content type="html"><![CDATA[<h1>引言</h1><p>《现代操作系统原理与实现》是一本介绍操作系统相关的书籍,是以ARM平台进行演示的.目前在看过一遍之后,我觉得还是比较有意思的<B>操作系统结构</B>、<B>硬件结构</B>、<B>内存管理</B>、<B>进程与线程</B>、<B>进程间通信</B>、<B>同步原语</B>、<B>文件系统</B>这七个章节.<br>下面会依次对这些章节做相关介绍.</p><h2 id="操作系统结构"><a class="header-anchor" href="#操作系统结构"></a>操作系统结构</h2><p>为什么要优先介绍<B>操作系统结构</B>,是这个章节给我带来了极大的感悟：对于像操作系统这样庞大的系统,在良好的架构下可以很好的有序演进,这一点是很多业务系统所欠缺的.<br>下面将从两个方面进行介绍:<B>设计方法</B>、<B>实践</B></p><h2 id="设计方法"><a class="header-anchor" href="#设计方法"></a>设计方法</h2><p>对于操作系统的设计方法或者方法论(不太喜欢’方法论’这一表述词,因为有一种’定式’的味道,现实或代码中并没有什么是固定的)来说,主要是对复杂度进行管理的一种手段;<br>这里介绍了一种设计方法:<B>M.A.L.H</B>,即模块化(modularity)、抽象(abstraction)、分层(layering)、层级(hierarchy),我对于设计简直是认同的不能在认同了.</p><h3 id="模块化"><a class="header-anchor" href="#模块化"></a>模块化</h3><p>模块化是通过<B>‘分治法’</B>的思想,将一个复杂系统分解为一系列有明确含义/领域能相互进行交互的小模块.模块的划分一定要具有’高内聚’和’低耦合’的特性,不能过大也不能过于小.<br>现代操作系统都是模块化的,以linux内核为例,可以看到分为若干模块</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97.jpg?raw=true" alt="linux模块"></p><p>关于模块化还有一些学者的阐述:<br><img src="https://martinfowler.com/articles/microservice-trade-offs.html" alt="Microservice Trade-Offs"></p><h3 id="抽象"><a class="header-anchor" href="#抽象"></a>抽象</h3><p>抽象是在模块化的基础上,将<B>接口</B>与<B>内部实现</B>进行区分,从而使得策略与实现分离.<br>这也是程序设计中的一个重要的设计原则:<B>策略</B>与<B>机制</B>分离:<B>策略</B>表示的是&quot;要做什么&quot;,<B>机制</B>表示的是&quot;要如何做&quot;</p><p>在操作系统中有很多抽象的例子,比如<B>VFS</B>、<B>虚拟内存</B>等就对不同硬件的抽象.</p><p>良好的模块化与抽象可以很好的将一个大型系统分解为一系列能够比较好的进行交付的模块;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%8A%BD%E8%B1%A1.jpg?raw=true" alt="模块化与抽象"></p><h3 id="分层"><a class="header-anchor" href="#分层"></a>分层</h3><p>分层是通过将模块按照一定的规则进行层次划分,约束每一层内部模块之间的交付方式与跨层次模块之间的交互方式,从而使得整个系统的交付方式有序;通常的规则约束是:一个模块只能和同一层模块以及相邻的上下层模块进行交互,而不能跨模块进行交互.</p><p>分层是开始构建复杂系统架构的开始,通过确定层级后,先构建底层基础模块,然后在利用这些基础模提供的功能来构建应用服务.</p><p>在实际web项目中基本上都会根据controller/service/dao三层架构来进行划分,service层的扩展要稍微多一点,例如六边形架构、洋葱圈架构等.</p><h3 id="层次"><a class="header-anchor" href="#层次"></a>层次</h3><p>层次是模块化的另外一种表现方式,是系统对功能的抽象与组织;例如组织架构类似,在组织架构上经理岗位是负责某一部分业务的,那公司的这一部分业务就需要交给他这个岗位进行负责;这个岗位下又会在分解交给其他岗位完成一样;</p><p>层次会在完成模块化、抽象、分层后自然体现出来,它与分层概念很类似,我认为的区别在于分层关注的是交互/调用关系的维护和有序,层次是关注与功能的抽象和组织;</p><h3 id="一些碎碎念"><a class="header-anchor" href="#一些碎碎念"></a>一些碎碎念</h3><p>大多数程序员长期以来写的代码都是以实现当前需求为己任,对于代码之后的生命周期是不会去考虑的.这样的代码在过了几个月以后或者另外一位同事接手后不得不在一声声’问候’下继续做相同的事情.<br>我始终认为简单明了的代码是最好的代码,因为这样的可读性是最好的; 不用去追求’新’、‘奇’来体现技术能力,而是要去追求’正确性’、'可读性’来体现技术能力;<br>然而在实际开发中,我们往往缺少一种能够指导的方法,我认为<B>M.A.L.H</B>就是一种非常好的实现,M.A.L.H中隐含了一些程序设计的技巧或法则:单一职责原则、依赖倒置原则、接口隔离原则</p><p>个人理解总结下来:</p><p>是否<B>能够</B>模块化?<br>是否<B>需要</B>抽象?<br>是否<B>能够</B>分层?<br>是否<B>体现</B>层次?</p><p>这些表现是层层递进的一个过程.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;引言&lt;/h1&gt;
&lt;p&gt;《现代操作系统原理与实现》是一本介绍操作系统相关的书籍,是以ARM平台进行演示的.目前在看过一遍之后,我觉得还是比较有意思的&lt;B&gt;操作系统结构&lt;/B&gt;、&lt;B&gt;硬件结构&lt;/B&gt;、&lt;B&gt;内存管理&lt;/B&gt;、&lt;B&gt;进程与线程&lt;/B&gt;、&lt;B&gt;进程间通信&lt;/B&gt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>maven-shade-plugin使用中的小问题</title>
    <link href="https://agmtopy.gitee.io/2022/04/22/1.%E6%9D%82%E8%AE%B0/maven-shade-plugin%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://agmtopy.gitee.io/2022/04/22/1.%E6%9D%82%E8%AE%B0/maven-shade-plugin%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-22T15:17:08.000Z</published>
    <updated>2022-04-22T15:21:28.625Z</updated>
    
    <content type="html"><![CDATA[<h1>maven-shade-plugin使用中的小问题</h1><p>maven-shade-plugin打包导致META-INF/SERVICES中的文件丢失,导致jar在动态加载时无法启动.这个问题困扰了我一周,暂时先记录处理办法,后续完善解决步骤</p><p>主要是依据这篇文章来解决处理的<br><a href="https://cloud.tencent.com/developer/article/1622207">https://cloud.tencent.com/developer/article/1622207</a></p><ul><li>maven-shade-plugin模板</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-shade-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!-- put your configurations here --></span>                <span class="token comment">&lt;!--只包含该项目代码中用到的jar,在父项目中引入了，但在当前模块中没有用到就会被删掉--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>minimizeJar</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>minimizeJar</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!--重新定位类位置，就好像类是自己写的一样，修改别人jar包的package--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relocations</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relocation</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>com.alibaba.fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedPattern</span><span class="token punctuation">></span></span>com.gavinzh.learn.fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedPattern</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--这些类和包不会被改变--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>com.alibaba.fastjson.not.Exists<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>com.alibaba.fastjson.not.exists.*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relocation</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relocations</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                        <span class="token comment">&lt;!--创建一个你自己的标识符，位置在原有名称之后--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedArtifactAttached</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedArtifactAttached</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedClassifierName</span><span class="token punctuation">></span></span>gavinzh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedClassifierName</span><span class="token punctuation">></span></span>                        <span class="token comment">&lt;!--在打包过程中对文件做一些处理工作--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformers</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--在META-INF/MANIFEST.MF文件中添加key: value 可以设置Main方法--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span>                                    <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ManifestResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestEntries</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.gavinzh.learn.shade.Main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Build-Number</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Build-Number</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Built-By</span><span class="token punctuation">></span></span>your name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Built-By</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>X-Compile-Source-JDK</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>X-Compile-Source-JDK</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>X-Compile-Target-JDK</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>X-Compile-Target-JDK</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestEntries</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--阻止META-INF/LICENSE和META-INF/LICENSE.txt--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ApacheLicenseResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token comment">&lt;!--合并所有notice文件--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ApacheNoticeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addHeader</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addHeader</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--如果多个jar包在META-INF文件夹下含有相同的文件，那么需要将他们合并到一个文件里--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.handlers<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.schemas<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.factories<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring-form.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.tooling<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--如果多个jar包在META-INF文件夹下含有相同的xml文件，则需要聚合他们--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ComponentsXmlResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token comment">&lt;!--排除掉指定资源文件--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.DontIncludeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>.no_need<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--将项目下的文件file额外加到resource中--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.IncludeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/pom_test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>pom.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--整合spi服务中META-INF/services/文件夹的相关配置--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ServicesResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformers</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>shade<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;maven-shade-plugin使用中的小问题&lt;/h1&gt;
&lt;p&gt;maven-shade-plugin打包导致META-INF/SERVICES中的文件丢失,导致jar在动态加载时无法启动.这个问题困扰了我一周,暂时先记录处理办法,后续完善解决步骤&lt;/p&gt;
&lt;p&gt;主要是</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="markdown模板" scheme="https://agmtopy.gitee.io/tags/markdown%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源代码分析之启动原理分析</title>
    <link href="https://agmtopy.gitee.io/2022/04/12/22.springboot/1.SpringBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2022/04/12/22.springboot/1.SpringBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2022-04-12T12:46:39.000Z</published>
    <updated>2022-12-11T15:21:42.232Z</updated>
    
    <content type="html"><![CDATA[<h1>SpringBoot源代码分析之启动原理分析</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程思想-核心篇》的章节,在参考SpringBoot源代码分析而来,希望对你有所帮助</p><h2 id="准备工作"><a class="header-anchor" href="#准备工作"></a>准备工作</h2><p>参考项目为地址为:<a href="https://github.com/agmtopy/SpringBootExample">https://github.com/agmtopy/SpringBootExample</a></p><h2 id="启动类概览"><a class="header-anchor" href="#启动类概览"></a>启动类概览</h2><p>在项目中,启动类为<code>SpringDemoApplication</code>,这个类应该是一切的开始,下面我们就来根据这个<B>run</B>方法来进行分析</p><ul><li>SpringDemoApplication</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringDemoApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringDemoApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>执行链路</li></ul><p>可以看到执行链路为:</p><p>这里有一个小细节,在没有提前初始化SpringApplication()时是不能使用arthas进行插入代码,显示错误为图一</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/S-springboot%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/Arthas_SpringApplicationRun1.jpg?raw=true" alt="图1"></p><p>查看相关类信息也没有看到类加载</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/S-springboot%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/Arthas_SpringApplicationRun2.jpg?raw=true" alt="图2"></p><p>经过分析可以知道这时候<B>SpringApplication</B>类还没有加载</p><h3 id="构造方法"><a class="header-anchor" href="#构造方法"></a>构造方法</h3><ul><li>SpringApplication()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">      <span class="token comment">//1. 启动方法  </span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> primarySources<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span class="token comment">//2. 构造方法</span>   <span class="token keyword">public</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">ResourceLoader</span> resourceLoader<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//1. 初始化ResourceLoader</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">=</span> resourceLoader<span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">,</span> <span class="token string">"PrimarySources must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>primarySources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType <span class="token operator">=</span> <span class="token class-name">WebApplicationType</span><span class="token punctuation">.</span><span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>bootstrapRegistryInitializers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">BootstrapRegistryInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass <span class="token operator">=</span> <span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<B>SpringApplication</B>初始化的方法中可以看到几个关键的方法<B>3/4/5</B>,分别是获取到Spring工厂的实例后在将工厂实例进行传递;</p><p>下面就详细的探究一下这几个方法的作用</p><ul><li>getSpringFactoriesInstances()</li></ul><p>通过Springboot的源代码可以看到getSpringFactoriesInstances()最后调用到了Spring的<B>loadFactoryNames()</B>方法</p><ul><li>loadFactoryNames</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> factoryType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factories<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>factoryType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>主要是获取this.factories这个Map对象中的值,this.factories是<B>SpringFactoriesLoader</B>在进行初始化时产生的,回到SpringBoot中可以看到是通过forDefaultResourceLocation()方法</p><ul><li>forDefaultResourceLocation()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SpringFactoriesLoader</span> <span class="token function">forDefaultResourceLocation</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">forResourceLocation</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//实际调用这个方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SpringFactoriesLoader</span> <span class="token function">forResourceLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> resourceLocation<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>resourceLocation<span class="token punctuation">,</span> <span class="token string">"'resourceLocation' must not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ClassLoader</span> resourceClassLoader <span class="token operator">=</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> classLoader <span class="token operator">:</span><span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">></span></span> loaders <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>resourceClassLoader<span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentReferenceHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> loaders<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>resourceLocation<span class="token punctuation">,</span> key <span class="token operator">-></span><span class="token comment">// 首次初始化时使用的是loadFactoriesResource()方法来生成FactoryName</span><span class="token keyword">new</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> <span class="token function">loadFactoriesResource</span><span class="token punctuation">(</span>resourceClassLoader<span class="token punctuation">,</span> resourceLocation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 生成FactoryName</span><span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">loadFactoriesResource</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">,</span> <span class="token class-name">String</span> resourceLocation<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span>URL<span class="token punctuation">></span></span> urls <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>resourceLocation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">UrlResource</span> resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token class-name">PropertiesLoaderUtils</span><span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>properties<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> implementations <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">trim</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>implementations<span class="token operator">::</span><span class="token function">add</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>result<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">SpringFactoriesLoader</span><span class="token operator">::</span><span class="token function">toDistinctUnmodifiableList</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unable to load factories from location ["</span> <span class="token operator">+</span> resourceLocation <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 这一段方法的作用就是将传入的"META-INF/spring.factories"中的配置解析成为key-value形式的结果并返回</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>run()方法最后是执行<B>SpringApplication</B>的初始化方法:</p><h3 id="SpringApplication-run"><a class="header-anchor" href="#SpringApplication-run"></a>SpringApplication.run()</h3><ul><li>SpringApplication.run()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 运行Spring应用程序，创建并刷新新的容器 */</span><span class="token keyword">public</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//1. 执行需要在初始化开始时执行的钩子方法 -- 已经是过时的方法了在V3.0.0中间hook的实现挪到了SpringApplicationRunListener中,也就是在步骤5中进行执行</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">preRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 获取初始化时间</span><span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3.初始化BootStrapContext(引导上下文)</span><span class="token class-name">DefaultBootstrapContext</span> bootstrapContext <span class="token operator">=</span> <span class="token function">createBootstrapContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ConfigurableApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//4. 配置head头属性</span><span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 获取运行中的执行监听器</span><span class="token class-name">SpringApplicationRunListeners</span> listeners <span class="token operator">=</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6. 启动监听器</span>listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//7. 初始化应用程序参数</span><span class="token class-name">ApplicationArguments</span> applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8. 准备运行环境</span><span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span> bootstrapContext<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//9. 设置需要忽略的bean</span><span class="token function">configureIgnoreBeanInfo</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10. 打印Banner信息</span><span class="token class-name">Banner</span> printedBanner <span class="token operator">=</span> <span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//11. 创建ApplicationContext</span>context <span class="token operator">=</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//12. 设置应用程序启动器(用于收集启动过程中的一些信息)</span>context<span class="token punctuation">.</span><span class="token function">setApplicationStartup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//13. 准备启动ApplicationContext</span><span class="token function">prepareContext</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//14. 判断是否需要重新刷新容器</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//15. 后置刷新容器方法</span><span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//16. 记录时间</span><span class="token class-name">Duration</span> timeTakenToStartup <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofNanos</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>timeTakenToStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//17. 设置监听时间</span>listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> timeTakenToStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//18. 执行Runner方法</span><span class="token function">callRunners</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Duration</span> timeTakenToReady <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofNanos</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>listeners<span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> timeTakenToReady<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//19. 执行后置Hook后置方法</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">postRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> context<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到run方法的执行过程分为几个阶段:</p><ul><li><p><B>前置准备阶段</B></p><ul><li>执行前置钩子方法(步骤一)</li><li>初始化引导上下文(步骤二\步骤三\步骤四)</li><li>设置启动监听器 (步骤五\步骤六)</li></ul></li><li><p><B>启动容器阶段</B></p><ul><li>初始化应用参数(步骤七\八\九\十)</li><li>创建容器(步骤十一\十二\十三)</li></ul></li><li><p><B>刷新容器阶段</B></p><ul><li>刷新容器(步骤十四)</li><li>创建容器(步骤十五)</li></ul></li><li><p><B>执行后置方法阶段</B></p><ul><li>执行Runner(步骤十八)</li><li>执行hook(步骤十九)</li></ul></li></ul><h2 id="前置准备阶段"><a class="header-anchor" href="#前置准备阶段"></a>前置准备阶段</h2><p><B>前置准备阶段</B>主要是设置一些容器上下文和钩子函数,下面详细分析一下这几个功能的实现</p><h3 id="执行前置钩子方法"><a class="header-anchor" href="#执行前置钩子方法"></a>执行前置钩子方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置钩子方法</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">preRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个方法是在针对于AOT的启动过程中提供的钩子方法,最早应用于<B>v3.0.0-M4</B>版本中,<a href="https://github.com/spring-projects/spring-boot/commit/9cd17f8a14eab8007c372c045a6b9295a3a56126?diff=unified">commit</a>,但是在2022.09调整过一次代码结构,将hook重写为基于<B>SpringApplicationRunListener</B>来进行实现了</p><p>下面来继续分析<B>SpringApplicationHooks</B>的执行流程</p><ul><li>org.springframework.boot.SpringApplication#getRunListeners</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1. 注册到Listeners中private SpringApplicationRunListeners getRunListeners(String[] args) &#123;ArgumentResolver argumentResolver &#x3D; ArgumentResolver.of(SpringApplication.class, this);argumentResolver &#x3D; argumentResolver.and(String[].class, args);List&lt;SpringApplicationRunListener&gt; listeners &#x3D; getSpringFactoriesInstances(SpringApplicationRunListener.class,argumentResolver);&#x2F;&#x2F;获取applicationHook对象SpringApplicationHook hook &#x3D; applicationHook.get();SpringApplicationRunListener hookListener &#x3D; (hook !&#x3D; null) ? hook.getRunListener(this) : null;if (hookListener !&#x3D; null) &#123;listeners &#x3D; new ArrayList&lt;&gt;(listeners);&#x2F;&#x2F;将applicationHookListener添加到listeners.add(hookListener);&#125;return new SpringApplicationRunListeners(logger, listeners, this.applicationStartup);&#125;&#x2F;&#x2F;2. 将Hook设置到applicationHook中public static &lt;T&gt; T withHook(SpringApplicationHook hook, ThrowingSupplier&lt;T&gt; action) &#123;applicationHook.set(hook);try &#123;return action.get();&#125;finally &#123;applicationHook.set(null);&#125;&#125;&#x2F;&#x2F;3. applicationHookprivate static final ThreadLocal&lt;SpringApplicationHook&gt; applicationHook &#x3D; new ThreadLocal&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<B>applicationHook</B>是放在一个ThreadLocal中的变量,由创建application对象输入;</p><p><B>SpringApplicationHook</B>只有一个方法,就是设置<B>Listener</B></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SpringApplicationHook</span> <span class="token punctuation">&#123;</span><span class="token class-name">SpringApplicationRunListener</span> <span class="token function">getRunListener</span><span class="token punctuation">(</span><span class="token class-name">SpringApplication</span> springApplication<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="设置主类"><a class="header-anchor" href="#设置主类"></a>设置主类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="准备运行环境"><a class="header-anchor" href="#准备运行环境"></a>准备运行环境</h3><ul><li>prepareEnvironment</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">ConfigurableEnvironment</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span><span class="token class-name">SpringApplicationRunListeners</span> listeners<span class="token punctuation">,</span><span class="token class-name">DefaultBootstrapContext</span> bootstrapContext<span class="token punctuation">,</span> <span class="token class-name">ApplicationArguments</span> applicationArguments<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//1.初始化创建Environment对象</span><span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token function">getOrCreateEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 配置Environment对象</span><span class="token function">configureEnvironment</span><span class="token punctuation">(</span>environment<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">.</span><span class="token function">getSourceArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3. 先检查配置属性源</span><span class="token class-name">ConfigurationPropertySources</span><span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4.执行environmentPrepared方法(扩展点1)</span>listeners<span class="token punctuation">.</span><span class="token function">environmentPrepared</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 移除掉默认属性</span><span class="token class-name">DefaultPropertiesPropertySource</span><span class="token punctuation">.</span><span class="token function">moveToEnd</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token operator">!</span>environment<span class="token punctuation">.</span><span class="token function">containsProperty</span><span class="token punctuation">(</span><span class="token string">"spring.main.environment-prefix"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Environment prefix cannot be set via properties."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6. 绑定"spring.main"为this</span><span class="token function">bindToSpringApplication</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isCustomEnvironment<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//7. 转换Environment</span><span class="token class-name">EnvironmentConverter</span> environmentConverter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnvironmentConverter</span><span class="token punctuation">(</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>environment <span class="token operator">=</span> environmentConverter<span class="token punctuation">.</span><span class="token function">convertEnvironmentIfNecessary</span><span class="token punctuation">(</span>environment<span class="token punctuation">,</span> <span class="token function">deduceEnvironmentClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">ConfigurationPropertySources</span><span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> environment<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>prepareEnvironment</B>的大概方法就是执行</p><ol><li>初始化配置Environment对象</li><li>执行的SpringApplicationRunListeners.environmentPrepared方法(扩展点1)</li><li>绑定相关属性</li></ol><p>这里面最重要的当属<B>listeners.environmentPrepared</B></p><ul><li>org.springframework.boot.SpringApplicationRunListeners#environmentPrepared</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">environmentPrepared</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableBootstrapContext</span> bootstrapContext<span class="token punctuation">,</span> <span class="token class-name">ConfigurableEnvironment</span> environment<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">doWithListeners</span><span class="token punctuation">(</span><span class="token string">"spring.boot.application.environment-prepared"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span> <span class="token operator">-></span> listener<span class="token punctuation">.</span><span class="token function">environmentPrepared</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> environment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到会回调注册为<B>配置文件</B>中配置的类的相关方法</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Run Listeners</span>org.springframework.boot.SpringApplicationRunListener=\org.springframework.boot.context.event.EventPublishingRunListener<span class="token punctuation">,</span>\org.springframework.boot.context.event.SpringApplicationRunListenerTest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在<B>SpringApplicationRunListeners</B>里面执行方法也比较有意思,就是直接执行方法listener的具体方法</p><h3 id="初始化ApplicationContext"><a class="header-anchor" href="#初始化ApplicationContext"></a>初始化ApplicationContext</h3><ul><li>createApplicationContext()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContextFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//ServletWebServerApplicationContextFactory.java</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">WebApplicationType</span> webApplicationType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>webApplicationType <span class="token operator">!=</span> <span class="token class-name">WebApplicationType</span><span class="token punctuation">.</span>SERVLET<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断是否需要激活AOT</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">AotDetector</span><span class="token punctuation">.</span><span class="token function">useGeneratedArtifacts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigServletWebServerApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//返回ServletContext</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServletWebServerApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化ApplicationContex方法就是根据应用类型,方法对应的ApplicationContex</p><h3 id="预处理容器"><a class="header-anchor" href="#预处理容器"></a>预处理容器</h3><ul><li>prepareContext()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">postProcessApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanNameGenerator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>context<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span>CONFIGURATION_BEAN_NAME_GENERATOR<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanNameGenerator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token keyword">instanceof</span> <span class="token class-name">GenericApplicationContext</span> genericApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置ResourceLoader</span>genericApplicationContext<span class="token punctuation">.</span><span class="token function">setResourceLoader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token keyword">instanceof</span> <span class="token class-name">DefaultResourceLoader</span> defaultResourceLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置ClassLoader</span>defaultResourceLoader<span class="token punctuation">.</span><span class="token function">setClassLoader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>addConversionService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>context<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setConversionService</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConversionService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>prepareContext用来设置<B>setResourceLoader</B>&gt;、<B>setClassLoader</B><br>这里有一个没搞懂的</p><blockquote><p>context instanceof DefaultResourceLoader defaultResourceLoader<br>context会是DefaultResourceLoader的实现类嘛？这里没有搞懂</p></blockquote><ul><li>applyInitializers()</li></ul><p>执行初始化方法,这是第二个扩展点</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">applyInitializers</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//遍历全部初始化容器&lt;ApplicationContextInitializer></span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span> initializer <span class="token operator">:</span> <span class="token function">getInitializers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> requiredType <span class="token operator">=</span> <span class="token class-name">GenericTypeResolver</span><span class="token punctuation">.</span><span class="token function">resolveTypeArgument</span><span class="token punctuation">(</span>initializer<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">isInstanceOf</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token string">"Unable to call initializer."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行初始化方法</span>initializer<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//setInitializers</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> initializers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>initializers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>initializers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//在SpringApplication()的构造方法中完成设置</span><span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Application Context Initializers</span>org.springframework.context.ApplicationContextInitializer=\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer<span class="token punctuation">,</span>\org.springframework.boot.context.ContextIdApplicationContextInitializer<span class="token punctuation">,</span>\org.springframework.boot.context.config.DelegatingApplicationContextInitializer<span class="token punctuation">,</span>\org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer<span class="token punctuation">,</span>\org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看一下<B>ContextIdApplicationContextInitializer</B>是做什么的?</p><ul><li>ContextIdApplicationContextInitializer</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getApplicationId</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableEnvironment</span> environment<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> name <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"spring.application.name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">?</span> name <span class="token operator">:</span> <span class="token string">"application"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ContextId</span> contextId <span class="token operator">=</span> <span class="token function">getContextId</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>applicationContext<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>contextId<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>applicationContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token class-name">ContextId</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> contextId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个类主要是想context中设置contextId的动作,也可以把它看做是设置context的一种扩展点</p><ul><li>设置BeanFactory</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取Bean Factory</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">"springApplicationArguments"</span><span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>printedBanner <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">"springBootBanner"</span><span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">AbstractAutowireCapableBeanFactory</span> autowireCapableBeanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置BeanFactory是否允许循环依赖</span>autowireCapableBeanFactory<span class="token punctuation">.</span><span class="token function">setAllowCircularReferences</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">DefaultListableBeanFactory</span> listableBeanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置是否允许BeanDefinition重写</span>listableBeanFactory<span class="token punctuation">.</span><span class="token function">setAllowBeanDefinitionOverriding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowBeanDefinitionOverriding<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对BeanFactory设置关键属性<B>是否可以重载BeanDefinition</B>和<B>是否允许循环依赖</B></p><ul><li>addBeanFactoryPostProcessor</li></ul><p>向容器中添加<B>BeanFactoryPostProcessor</B>,</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//是否延迟加载</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazyInitialization<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置BeanFactoryPostProcessor</span>context<span class="token punctuation">.</span><span class="token function">addBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LazyInitializationBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//add PropertySourceOrderingBeanFactoryPostProcessor</span>context<span class="token punctuation">.</span><span class="token function">addBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PropertySourceOrderingBeanFactoryPostProcessor</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后还有listeners.contextLoaded</span>listeners<span class="token punctuation">.</span><span class="token function">contextLoaded</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="刷新容器"><a class="header-anchor" href="#刷新容器"></a>刷新容器</h2><p>在SpringBoot中刷新容器反而比较简单,只需要调用Spring的refresh()方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">afterRefresh</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">,</span> <span class="token class-name">ApplicationArguments</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//listeners.started</span>listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> timeTakenToStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在SpringContext refresh完成后还有一个afterRefresh方法,但是这个方法是空的,不会进行处理;</p><p>然后在往下就是一个listeners.started的调用</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>1.创建计时器并开始<br>​2.创建启动器上下文并执行监听器BootstrapRegistryInitializer的initialize方法<br>​3.创建上下文ConfigurableApplicationContext变量并设置环境一些属性<br>​4.获取SpringApplicationRunListener监听器并执行其starting方法<br>​5.将命令行参数封装到ApplicationArguments里面来<br>​6.初始化应用上下文环境<br>​7.处理忽略Bean的信息<br>​8.打印Banner信息<br>​9.根据当前应用类型来创建context上下文<br>​10.设置记录器<br>​11.为刷新上下前做准备<br>​12.刷新上下文，最重要的功能在这的<br>​13.刷新后的扩展方法，其实里面什么都没有<br>​14.计时器结束<br>​15.记录log<br>​16.SpringApplicationRunListener监听器回调started<br>​17.SpringApplicationRunListener监听器回调running</p><p>注意这个过程中的扩展点:</p><ol><li>listeners</li><li>ApplicationContextInitializer</li></ol><p>和对BeanFactory属性的设置;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;SpringBoot源代码分析之启动原理分析&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://agmtopy.gitee.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://agmtopy.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux的定时测量分析</title>
    <link href="https://agmtopy.gitee.io/2022/04/02/21.linux/linux%E7%9A%84%E5%AE%9A%E6%97%B6%E6%B5%8B%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2022/04/02/21.linux/linux%E7%9A%84%E5%AE%9A%E6%97%B6%E6%B5%8B%E9%87%8F%E5%88%86%E6%9E%90/</id>
    <published>2022-04-02T05:28:22.000Z</published>
    <updated>2022-04-02T10:16:07.537Z</updated>
    
    <content type="html"><![CDATA[<h1>linux的定时测量分析</h1><p>定时测量之前的文章学习中的初步印象,是由特殊的电路系统上报给操作系统的一种信号量。下面是《深入理解Linux内核》一书中的阐述和思考。</p><h2 id="定时测量"><a class="header-anchor" href="#定时测量"></a>定时测量</h2><p>操作系统中需要处理的<B>定时测量</B>主要是两种：</p><ul><li>测量当前的日期和时间</li><li>维持定时器，以便测量出某一时间间隔</li></ul><p>定时测量是通过一种基于固定的频率振荡设备和计数器设备来实现的，下面介绍一下这几个硬件设备。</p><h3 id="时钟和定时器电路"><a class="header-anchor" href="#时钟和定时器电路"></a>时钟和定时器电路</h3><ul><li>实时时钟-RTC<br>实时时钟(Renl Time Clock RTC)是一个独立于CPU和其他芯片的设备，即使当计算设备被切断电源时，它还是还能正常工作。</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/RTC.jpg?raw=true" alt="RTC产品图"></p><p>在现代的计算机结构中，RTC设备通常被集成到南桥中</p><ul><li>时间戳计数器-TSC</li></ul><p>时间戳计数器是用来接收外部传递的振荡器的时钟信号。在x86架构下是通过一条名叫<B>CLK</B>的输入总线和一个名叫<B>时间戳计时器寄存器</B>来实现的。</p><ul><li><p>可编程间隔定时器-PIT<br>PIT与RTC类似，也是一个独立于CPU和其他芯片的设备，但是它的工作方式与RTC不同。PIT是通过按照固定的频率发送一个特殊的中断信号来实现的。</p></li><li><p>CPU本地定时器</p></li></ul><p>CPU本地定时器的工作原理与PIT类似都是发送一个特殊的中断信号，但是不同点在于，CPU本地定时器是据语系统总线的时钟信号量的值来实现的。</p><ul><li>高精度事件定时器-HPET</li></ul><p>高精度事件定时器是由MS与Intel共同研发的一种新型定时器,目前应该是支持最广泛的定时器,内部主要包括8个32位或64位的独立计数器，在windows下通过设备管理器插看到</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/HPET.jpg?raw=true" alt="HPET"></p><p>在参考资料2中可以看到时钟频率对游戏帧率的影响，游戏帧率越高，时钟频率越低，这样的话，游戏的性能就会越好。这里的原理类似于显示屏幕的物理帧率对游戏性能的影响一样,可以看一下B站Up主的一个视频<a href="https://www.bilibili.com/video/BV19L411N7xw?spm_id_from=333.999.0.0">游戏帧数竟然可以影响永劫的攻击速度？！</a></p><ul><li>ACPI定时器</li></ul><p>ACPI电源管理定时器几乎存在所有的ACPI主板上，它是一个简单的计数器，每次时钟节拍到来时，寄存器就加1.</p><p>以上是一些定时器的简单介绍，主要有<B>RTC</B>、<B>HPET</B></p><h2 id="Linux计时体系结构"><a class="header-anchor" href="#Linux计时体系结构"></a>Linux计时体系结构</h2><p>linux启动后必须执行的与时间相关的操作是以下几个：</p><ul><li>更新系统启动以后经过的时间</li><li>更新当前日期和时间</li><li>确定当前进程在每一个CPU上运行的时间</li><li>更新资源使用统计数量<br>-检查每一个软件定时器的时间间隔是否达到</li></ul><p>在多处理器系统中，每一个CPU都有一个时钟，它的频率可以被设置，默认的频率是1GHz，也就是说，每秒钟的时钟节拍数是1000000。普通活动(例如:软定时器)都是由全局定时器产生的中断触发的；CPU的活动则是由本地的APIC产生的中断触发的。</p><p>(PS:APIC与ACPI的区别，ACIP是本地CPU定时器，而APIC是全局电源方面的定时器，优先级较高)</p><p>内核会提供两个最基本的计时函数:一个保持对当前时间的记录，一个计算当前秒内流逝的纳秒数</p><ul><li>计时体系的数据结构</li></ul><p>这里主要介绍一个<B>jiffies变量</B>,这个变量是用于记录系统启动后产生的节拍数，但是在X86架构下这个变量使用的是一个32位置的有符号值,因此大约只需要50天左右就会置为0，这被称为时钟回绕问题，linux提供了time_after和time_before函数来解决这个问题。解决问题的思路是通过先将32位的数据转化为64位的long类型来比较，这样做的原理是，当32位的数据转化为64位的long类型后，其符号位会被置为0，从一个有符号数变成了无符号数，在对差值与0进行比较，就可以解决时钟回绕问题。</p><p>关于这个<B>jiffies变量</B>还有一个指的注意的地方是，它在初始化时，并不是赋的0，而是负3W多的一个数字,这样做的目的是尽早的发现时钟回绕问题是否被正确的处理，这里面实际体现了一种不可靠思想，想尽量的让问题尽早的暴露出来，指的学习!</p><p>jiffies变量为什么选择的是32位而不是64位,这里主要是因为在32位系统中对64位数值的访问需要使用两个32位数值来处理，这样操作两次比直接操作32位的数值要慢一些</p><h2 id="定时测量的应用"><a class="header-anchor" href="#定时测量的应用"></a>定时测量的应用</h2><ul><li>更新日期和时间</li><li>更新系统统计数据，例如CPU统计数、系统负载等</li><li>监管内核代码，例如每次时钟中断时判断当前系统正在做什么</li><li>检查非屏蔽中断监视器,监控系统内核的运行情况</li><li>软定时器与延迟函数</li></ul><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>Linux的定时测量是通过不同的硬件来实现的，有记录当前时间的RTC、有记录系统启动时间的TSC、有记录CPU的时钟周期的APIC、有记录全局时间的电源定时器ACPI、记录高精度时间的HPET等。操作系统通过这些定时器来实现记录系统运行状态、记录当前时间、记录流逝时间等功能。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="http://manpages.ubuntu.com/manpages/xenial/man4/rtc.4.html">ubuntu RTC驱动说明书</a><br><a href="https://silicophilic.com/disabling-hpet-settings/">如何通过禁用 HPET 设置来提高游戏性能</a><br><a href="https://blogs.gnome.org/raywang/2007/11/19/acpi%E5%92%8Capic%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB/">ACPI和APIC有什么关系</a><br><a href="https://www.modb.pro/db/217433">jiffies如何避免时钟回绕问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;linux的定时测量分析&lt;/h1&gt;
&lt;p&gt;定时测量之前的文章学习中的初步印象,是由特殊的电路系统上报给操作系统的一种信号量。下面是《深入理解Linux内核》一书中的阐述和思考。&lt;/p&gt;
&lt;h2 id=&quot;定时测量&quot;&gt;&lt;a class=&quot;header-anchor&quot; href</summary>
      
    
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="https://agmtopy.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>银行会计-笔记</title>
    <link href="https://agmtopy.gitee.io/2022/03/27/1.%E6%9D%82%E8%AE%B0/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1-%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2022/03/27/1.%E6%9D%82%E8%AE%B0/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1-%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-27T07:10:10.000Z</published>
    <updated>2022-05-05T13:29:58.697Z</updated>
    
    <content type="html"><![CDATA[<h1>《银行会计》笔记</h1><p>《银行会计》一书是席总带给我看的，一直以来在对这方面的知识都比较匮乏，以下是我在阅读这本书是做的一些笔记,希望能对你有帮助,开心😋😋😋</p><h2 id="第二章-银行会计的基本核算方法"><a class="header-anchor" href="#第二章-银行会计的基本核算方法"></a>第二章:银行会计的基本核算方法</h2><h3 id="会计科目"><a class="header-anchor" href="#会计科目"></a>会计科目</h3><blockquote><p>会计科目指的是对会计对象的具体内容按照不同的性质和经济管理的要求进行分类，分类后的种种科目就是会计科目</p></blockquote><p>会计科目就是根据一些法规和自身的场景/要求，将经营过程/活动分解成的科目，通过这些科目就可以按照一定的维度，统计出经营结果，从而进行会计分析</p><h3 id="会计科目的分类"><a class="header-anchor" href="#会计科目的分类"></a>会计科目的分类</h3><blockquote><p>1.按照资产负载表进行分类</br>2. 按照会计科目所反映的经营活动进行分类(这里可以理解为按照会计科目来进行分类，因为会计科目的编码是要符号一定的经济活动的</p></blockquote><ul><li><p>按照资产负载表进行分类<br>按照这种方式主要是通过资产负载表来进行分类，这种方式的好处就是可以按照资产负载表的结构来进行分类，这种方式的缺点就是不能按照经营活动的结构来进行分类，因为经营活动的结构是不确定的，这里引申出一个概念<B>资产负载表</B></p><ul><li>资产负载表<blockquote><p>资产负债表是反应企业在<B>某一特点时间</B>的<B>财务状况</B>的报表,是企业经营活动的<B>静态</B>展示;由两个方面组成<B>资产</B>、<B>负债与股东权益</B>两个大的方面组成<br>会计科目按照资产负载表的关系进行分类就可以划分为<B>表内科目</B>、<B>表外科目</B></p></blockquote></li></ul><p>这里又引申出来两个概念<B>表内科目</B>、<B>表外科目</B></p><ul><li><p>表内科目</p><blockquote><p>表内科目指的是反映银行资金发生增减变化的会计科目，其余额会在资产负债表上体现，用于表示复式记账法的会计核算过程</p></blockquote></li><li><p>表外科目</p><blockquote><p>表外科目指的是核算业务中已发生，但是尚未涉及资金增减的事项的科目，其余额不会在负债资产表上体现，用于单式记账法的会计核算过程<br>表外科目主要用于指代不列入资产负债表内和损益表内的会计科目，主要用于金融行业内使用的一类特殊科目，这里的<B>表</B>指的是资产负债表。</p></blockquote></li></ul></li><li><p>按照经营活动进行分类</p><ul><li>资产类科目</li><li>负债类科目</li><li>资产负债共同类科目</li><li>所有者权益类科目</li><li>损益类科目<br>以下是一个银行会计科目表列子</li></ul></li><li><p>银行会计科目表</p></li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1%E7%A7%91%E7%9B%AE%E8%A1%A8.jpg?raw=true" alt=""><br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1%E7%A7%91%E7%9B%AE%E8%A1%A81.jpg?raw=true" alt="银行会计科目表"></p><p>可以看到会计科目表分为5大分类，分别对应不同的经营活动</p><h3 id="科目代号"><a class="header-anchor" href="#科目代号"></a>科目代号</h3><p>从上面的银行会计科目表中可以看到，不同的科目都有一个特定的编号，分别由两个部分组成<B>一级科目</B>、<B>二级科目</B></p><ul><li><p>一级科目<br>一级科目的编排规则是：第一位数字代表科目的资金性质，即：1-代表资产类科目；2-代表负债类科目；3-代表所有者权益类科目；4-代表资产负债类科目；5-代表损益类科目；6~9代表表外科目及补充资料；第二位数字代表业务性质；剩下两位表示顺序；</p></li><li><p>二级科目<br>二级科目是一般是由6位组成，前四位是一级科目，后两位表示顺序</p></li></ul><h3 id="记账方法"><a class="header-anchor" href="#记账方法"></a>记账方法</h3><p>记账方法指的是在核算过程中，按照那样的规则进行处理；我们需要知道的就是表内用<B>复式记账法</B>、表外用<B>单式记账法</B></p><ul><li>单式记账法<br>单式记账法指的是对每一次经营活动只会在一个科目中进行登记，即：一个科目只会记录一次，不会出现多次记账的情况，这样的记账方式优点是简单,缺点是不能反映完整的经营活动</li><li>复式记账法<br>复式记账法指的是对于每笔经营活动都需要在多个科目中进行登记，即：一个科目可以记录多次，这样的记账方式优点是可以反映完整的经营活动，缺点是记账方式复杂，不能简单地反映经营活动</li></ul><p>简单的理解就是，单式记账法只能记录一次经营活动的结果，而不是过程，复式记账法记录的是一个经营活动的过程，通过在两个以上的账户中同时描述同一笔经营活动的过程，可以反映完整的经营活动</p><p>根据复式记账法原理演化出来的<B>借贷记账法</B>是国际通用的记账法，主要包括记账主体、记账符号、记账规则、试算平衡四个方面</p><ul><li>借贷记账法</li></ul><blockquote><p>借贷记账法是根据复式记账法原理,以<B>‘借’</B>、<B>‘贷’</B>作为记账符号，以<B>有借必有贷，借贷必相等</B>作为记账规则，用以记录和反映经济业务发生而导致的会计要素增减编号过程及其结果的一种复试记账法<br>可以从上面的表述中得知，借贷记账法的的目标是描述经济活动的<B>过程</B>和<B>结果</B>这两方面。</p></blockquote><ul><li>记账主体</li></ul><blockquote><p>记账主体指的是借贷记账法进行记账时，记录的是一条条<B>会计科目</B>，这些会计科目就是借贷记账法的记账主体。</p></blockquote><ul><li>记账符号</li></ul><blockquote><p>记账符号指的是<B>借</B>、<B>贷</B>，这两个符号，表示的是科目的方向，在前面的会计科目中可以得知会计科目实际上是没有方向概念的，只是描述经济活动的过程，因此需要有方向概念，这个方向概念就是记账符号。</p></blockquote><ul><li><p>记账规则<br><B>有借必有贷,借贷必相等</B>，这个规则是根据’资产 = 负载 + 所有者权益’的会计恒等式作为理论基础发展而来，通俗的表述就是：<B>即一笔经济业务的发生，必然会在一个账户的借方和贷方登记相同的金额，以达到会计分录是借贷平衡的结果</B>。</p></li><li><p>试算平衡<br>试算平衡指的是在记账过程中如果每笔经济活动记账时都满足’记账规则’时，那么在核对<B>发生额</B>和<B>余额</B>时也应该是相等的。银行每天按照总账维度核对借方和贷方的发生额和总额。</p></li></ul><p><img src="" alt="试算平衡表"></p><p>以上是借贷记账法的组成元素，分别是记账主体、记账符号、记账规则、试算平衡四个方面。复式记账法可以较好的描述表内的资产增减过程，但是对于表外资产就不太适用，因此表外资产采用的是单式记账法，即采用收入和支出作为记账符号，业务事项发生时计入<B>收入</B>、业务事项注销或冲正时计入<B>付出</B>；余额表示尚未结算的业务事项；</p><h3 id="账务组织"><a class="header-anchor" href="#账务组织"></a>账务组织</h3><p>账务组织指的是根据会计凭证对经济业务活动进行核算，分为<B>账务明细</B>、<B>综合核算</B>两个大的方面组成，都会根据<B>账簿</B>来进行记录，账簿分为<B>明显账</B>、<B>日记账</B>、<B>总账</B>、<B>登记簿</B>四种类型</p><ul><li><p>明细账<br>明细账指的是会计账簿中反映相关业务情况的账簿</p></li><li><p>总账<br>总账指的是银行会计账簿中综合核算和监督各项经济业务的分类账簿，它是综合核算和明显核算相互核对以及统驭明显分户账的主要工具</p></li><li><p>日记账<br>日记账主要是核算现金收入和现金付出的日记账，是现金收入和现金付出的详细记录</p></li><li><p>登记簿<br>登记簿主要是用于记录表外科目的增减变化的账簿</p></li></ul><h2 id="第四章-贷款业务的核算"><a class="header-anchor" href="#第四章-贷款业务的核算"></a>第四章:贷款业务的核算</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《银行会计》笔记&lt;/h1&gt;
&lt;p&gt;《银行会计》一书是席总带给我看的，一直以来在对这方面的知识都比较匮乏，以下是我在阅读这本书是做的一些笔记,希望能对你有帮助,开心😋😋😋&lt;/p&gt;
&lt;h2 id=&quot;第二章-银行会计的基本核算方法&quot;&gt;&lt;a class=&quot;header-an</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://agmtopy.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
