<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2023-04-25T15:42:14.188Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记</title>
    <link href="https://agmtopy.gitee.io/2023/04/05/20.%E7%AC%94%E8%AE%B0/40.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2023/04/05/20.%E7%AC%94%E8%AE%B0/40.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-05T08:55:33.000Z</published>
    <updated>2023-04-25T15:42:14.188Z</updated>
    
    <content type="html"><![CDATA[<h1>《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记</h1><p>这一篇文章主要是用于记录《深入Java虚拟机：JVM G1GC的算法与实现》一书中<B>算法篇</B>部分的笔记,主要分为引子、并发标记、转移、软实时性、分代G1GC模式;</p><h2 id="G1-GC是什么"><a class="header-anchor" href="#G1-GC是什么"></a>G1 GC是什么?</h2><p>在G1GC之前JVM中存在的垃圾收集器主要是<B>Parallel Scavenge</B>和<B>Parallel Old</B>,在jdk9将G1设置为默认处理器后,截至现在的jdk 20都是默认的垃圾收集器,目前G1GC就是JDK平台跨最多版本的默认垃圾收集器;</p><p>G1GC设计的出发点与之前的GC收集器有明显的不同,之前的不管是串行的Serial还是并发Paraller都是基于<B>吞吐量</B>和<B>缩短最大暂停时间</B>来进行设计的;<br>目前JVM的生态或者说面向的应用还是偏向于Web处理方面的,这一类应用的特点短、快,因此需要具有<B>软实时性</B>和<B>高吞吐量</B>的垃圾收集器;</p><blockquote><p>软实时性指的是处理时间可以超出最后期限,但是超出最后期限的频率很重要.只有超出的频率在用户能够容忍的范围之内,才能称之为&quot;软实时性&quot;<br>举一个栗子: 公司都允许每个考勤周期内迟到2或者3次,公司可以容忍这种情况发生,但是超过规定的次数之后就不能忍受了,这种行为就叫&quot;软实时性&quot;;与之相反的&quot;硬实时性&quot;,例如&quot;职务侵占&quot;公司就一次都不能忍受;</p></blockquote><p>咱们已经了解了为什么需要重头开始设计一个GC算法了,下面就看一下具体的内存结构和算法实现.</p><h3 id="G1GC的内存结构"><a class="header-anchor" href="#G1GC的内存结构"></a>G1GC的内存结构</h3><ul><li>内存布局</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png?raw=true" alt="G1GC内存布局"></p><p>首先G1GC的内存布局最大的特点是抛弃了内存中对于老年代和年轻代的内存范围划分,而是采用区域(region),默认大小为1MB的形式进行划分.<br>对于region内存的大小用户可以随意设置,但是在内部会将用户设置的值向上调整为2的指数幂(2^n),1000kb-&gt;1024kb;</p><ul><li>对象引用</li></ul><p>这里的对象引用指的不是对象与对象之间的引用,而是在GC查找对象时持有的引用关系,一个典型的栗子就是老年代中引用年轻代存储关系的<B>记忆集</B>;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png?raw=true" alt="G1GC 跨代引用布局"></p><ul><li>Card Table</li></ul><blockquote><p>Card Tables and Concurrent Phases  If a garbage collector does not collect the entire heap (an incremental collection), the garbage collector needs to know where there are pointers from the uncollected part of the heap into the part of the heap that is being collected. This is typically for a generational garbage collector in which the uncollected part of the heap is usually the old generation, and the collected part of the heap is the young generation. The data structure for keeping this information (old generation pointers to young generation objects), is a remembered set. A card table is a particular type of remembered set. Java HotSpot VM uses an array of bytes as a card table. Each byte is referred to as a card. A card corresponds to a range of addresses in the heap. Dirtying a card means changing the value of the byte to a dirty value; a dirty value might contain a new pointer from the old generation to the young generation in the address range covered by the card. 如果垃圾收集器不收集整个堆而是进行增量收集，则垃圾收集器需要知道从堆的未收集部分到正在收集的堆部分的指针在哪里。 这通常适用于分代垃圾收集器，其中堆的未收集部分通常是老年代，堆中已收集的部分是新生代。 保存此信息的数据结构（指向年轻代对象的老年代指针）是一个记忆集(RS)。 Card Table是一种特殊类型的记忆集。 Java HotSpot VM 使用字节数组作为卡片表。 每个字节称为一张卡片。 一张卡片对应堆中的一个地址范围。 弄脏一张卡片意味着将字节的值更改为脏值； 一个脏值可能包含一个新的指针，在卡覆盖的地址范围内从老一代到年轻一代。</p></blockquote><p>Card Table是用于简化年轻代收集,类似与一个被老年代持有年轻代对象的索引,在年轻代进行垃圾收集时按图索骥就可以把这些被跨代引用的对象找出来,之后会详细的讲述一下执行过程;</p><h3 id="执行过程"><a class="header-anchor" href="#执行过程"></a>执行过程</h3><p>G1GC底层算法是<B>标记-压缩</B>算法,这样的话它的执行步骤可以划分为两个部分:</p><ol><li>并发标记阶段<br>并发标记阶段主要是在尽量不暂停mutator线程(即访问和修改Manage Object的线程,如所有Java Thread及其Attach到JVM的thread)的情况下标记出存活的对象,而且在标记过程中会记录下每个区域(region)内存活的对象数量;</li><li>转移压缩阶段<br>转移压缩阶段主要是将待回收区域内的存活对象复杂到其他空闲区域中,然后将空闲出来的区域标记为空闲状态,类似于GC算法,但是是以单位进行的;</li></ol><p>需要注意的是<B>并发标记</B>和<B>转移压缩</B>在处理顺序上是没有先后顺序的,并发标记的结果对于转移压缩阶段也不是必须的.</p><hr><p>上面简单的描述了一下G1GC的执行过程,下面我们来详细的看一下<B>并发标记阶段</B>做的事情</p><h2 id="并发标记阶段"><a class="header-anchor" href="#并发标记阶段"></a>并发标记阶段</h2><h3 id="标记位图"><a class="header-anchor" href="#标记位图"></a>标记位图</h3><p>首先解释&quot;并发标记&quot;是在标记什么?</p><blockquote><p>并发标记是在标记所有的存活对象和可以回收的对象,并发标记并不是直接在对象内存上添加标记,而是在<B>标记位图</B>上</p></blockquote><p>标记位图如图所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/74172d16f52935f2a49645d6f14132e0b6d966f5/png/j-jvm/%E6%A0%87%E8%AE%B0%E4%BD%8D%E5%9B%BE.png?raw=true" alt="标记位图"></p><p>标记位图是对<B>region</B>中分配的对象进行一个类似于索引标记的数据结构,每个bit位对应一个对象,默认最小的对象为8字节,0代表活动对象;</p><p>每个region都有两个<B>标记位图</B>分别是nextBitMap和prevBitMap用于保存本次的位图和上一次的位图;</p><p>由于在并发标记阶段Mutator线程可以继续分配对象或者yuang GC,会破坏已经进行过标记的内存区域,因此需要用4个标记位来确定,分别是<B>bottom</B>、<B>TOP</B>、<B>prevTAMS</B>、<B>nextTAMS</B></p><p>bottom-TOP范围表示的开始标记前的某个区域的底部和顶部<br>TAMS(Top-at-Mark-Start,标记开始时的top)，prevTAMS和nextTAMS即上/下一次的标记的top</p><p>nextTAMS-TOP范围表示就就是标记过程中新产生的对象所占用的区域</p><h3 id="执行步骤"><a class="header-anchor" href="#执行步骤"></a>执行步骤</h3><p>并发标记过程包括以下5个步骤:</p><ol><li>初始标记阶段</li><li>并发标记阶段</li><li>最终标记阶段</li><li>存活对象计数阶段</li><li>收尾阶段</li></ol><h4 id="初始标记阶段"><a class="header-anchor" href="#初始标记阶段"></a>初始标记阶段</h4><ol><li>创建标记位图<blockquote><p>在初始化阶段,GC线程会首先创建Next MarkBitmap</p></blockquote></li><li>对GC Root可达对象进行扫描和标记,为了防止GC Root对象变化,<B>Mutator是暂停执行的</B>,这里需要注意的是初始标记阶段有且只会对GC Root的可达对象进行标记</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png?raw=true" alt="初始标记阶段结果"></p><h4 id="并发标记阶段-v2"><a class="header-anchor" href="#并发标记阶段-v2"></a>并发标记阶段</h4><blockquote><p>并发标记阶段,GC线程会继续扫描在初始化阶段被标记过的对象,分析它们的引用关系,完成大部分存活对象的标记</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png?raw=true" alt="并发标记阶段结果"></p><p>在并发标记阶段GC线程和Mutator线程是并发执行的,那么是如何解决<B>标记遗漏</B>问题的楠?</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5_%E6%A0%87%E8%AE%B0%E9%81%97%E6%BC%8F.png?raw=true" alt="标记遗漏"></p><p>首先说一下<B>标记遗漏</B>产生的原因,从上图中可以看到我们的GC线程已经标记到第二层对象,这个时候Mutator线程将Obj1-Obj3直接的引用关系去除,并且GCRoot-Obj3产生新的引用关系,由于Obj1标记完成后已经没有下属的任何引用那么就不会在标记Obj3,就发生了标记遗漏,可以看到发生标记遗漏的两个条件:</p><ul><li>新产生一条或多条从黑色对象(已标记对象)到白色对象(未标记对象)的新引用;</li><li>删除灰色对象(正在标记对象)到白色对象的引用关系;</li></ul><p>那么解决标记遗漏的问题就在于对这两个关系的破坏或者记录:</p><blockquote><p>在CMS中采用的是增量更新(Incremental Update)方案,破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次;</p></blockquote><blockquote><p>在G1GC中采用的是原始快照(Snapshot At The Beginning,SATB)方案,破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次;</p></blockquote><p>这里重新扫描的是灰色对象,然后是在快照中扫描,快照指的是GC在开始时对象之间的引用关系,这里会产生一个问题,将本来已经可以进行回收的对象标记为活动的,系统设计上应该是要保证没有漏掉的对象,防止不能回收掉这些内存.</p><p>G1GC采用的是<B>写屏障</B>技术来记录对象之间引用关系的变化,对于新分配的对象直接认为这部分对象是已经标记完成;</p><h4 id="最终标记阶段"><a class="header-anchor" href="#最终标记阶段"></a>最终标记阶段</h4><p>最终标记阶段是对<B>SATB本地队列</B>进行扫描,因为在并发标记介绍以后本地的SATB队列容量可能不满,不会刷新到全局SATB队列中,因此需要全局暂停来处理这些&quot;残留的SATB本地队列&quot;;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%85%A8%E5%B1%80SATB%E7%BB%93%E6%9E%84.png?raw=true" alt="全局SATB与局部SATB之间的关系"></p><p>最终标记处理的就是上图中mutator1线程和mutator2线程对于的局部SATB队列;</p><h4 id="存活对象计数阶段"><a class="header-anchor" href="#存活对象计数阶段"></a>存活对象计数阶段</h4><p>通过上面三个标记步骤(初始、并发、最终)将本次GC需要进行内存收集的对象标记出来了,这个时候就需要扫描各个区域的<B>next标记位图</B>,统计各个区域内存活对象的字节数目;<br>这个计数步骤可以和mutator是并发执行的,但是不能和转移线程(Remembered set)线程并行执行,因为如果并行执行会破坏region内的计数正确性;</p><h4 id="收尾阶段"><a class="header-anchor" href="#收尾阶段"></a>收尾阶段</h4><p>在上面两个步骤(标记、计数)中我们已经得到GC所需的最重要的两个信息:</p><ol><li>标记完成后存活对象和死亡对象之间的区分(标记位图)</li><li>存活对象的内存占用(内存占用字节数量)</li></ol><p>有上面俩组数据之后,才能进行</p><ul><li>转移压缩</li></ul><p>转移压缩过程中涉及到一个比较重要的概念<B>转移效率</B>,指的是&quot;死亡对象的字节数 % 转移所需时间&quot;,换句话说,转移效率指的是<B>转移1个字节所需时间</B>;</p><p>这里的转移指的是是对于存活对象转移的耗时,因为在一个需要对象回收比较多的region区域内,只需要将少量的存活对象转移出去,这块region就可以进行回收了;</p><p>通过<B>历史转移效率</B>的数据,就可以尝试预测下次内存需要进行回收的时间;</p><h4 id="小结"><a class="header-anchor" href="#小结"></a>小结</h4><p>在标记阶段主要是通过两种数据结构<B>标记位图</B>、<B>SATB</B>来实现对region的标识和计数,流程上分为:</p><ol><li>初始标记阶段 -&gt; GCRoot出发</li><li>并发标记阶段 -&gt; 上一步中散发的引用的对象</li><li>最终标记阶段 -&gt; 标记局部SATB中的对象</li><li>计数/收尾阶段 -&gt; 计数统计和转移</li></ol><p>对局部SATB的操作使用的是前置写屏障技术来实现的;</p><p>下面详细用一节来介绍一下转移的具体过程;</p><h2 id="GC的转移功能"><a class="header-anchor" href="#GC的转移功能"></a>GC的转移功能</h2><h3 id="转移的先决条件"><a class="header-anchor" href="#转移的先决条件"></a>转移的先决条件</h3><p>首先说一下为什么需要转移,由于内存特性会出现碎片化,因此需要对内存进行整理,才能继续分配对象,整理这个步骤具体的操作就是通过转移来实现的;</p><p>转移功能是通过具体的<B>转移专用记忆集合</B>来快速索引对象的,记录的是区域与区域之间的对象间的引用关系;通过使用转移专用记忆集合,在转移时即使不扫描所有区域内的对象,也可以查询到待转移对象<br>所在区域被其他区域引用的情况,从而简化单个区域回收的转移处理步骤;</p><blockquote><p>G1GC是通过卡表(card table)来进行实现转移专用记忆集合的元素的;</p></blockquote><p>在上图&quot;G1GC 跨代引用布局&quot;图列中的<B>Remembered Set</B>就是<B>转移专用记忆集合</B>,记录的元素就是card table的元素地址,如下所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E8%BD%AC%E7%A7%BB%E4%B8%93%E7%94%A8%E8%AE%B0%E5%BF%86%E9%9B%86%E5%90%88%E7%9A%84%E6%9E%84%E9%80%A0.png?raw=true" alt="转移专用记忆集合"></p><blockquote><p>每个区域都有一个<B>转移专业记忆集合</B>,它是通过hash列表实现的,key为引用本区域的其他区域地址,value为一个数组,元素是引用区域对应的<B>卡表</B>中的元素;<br>通过RS和Card Table这样的数据结构,在进行跨代引用对象的转移时可以快速的根据数据来进行查找;</p></blockquote><p>RS的写入是由专用的<B>转移专用记忆集合维护线程</B>来进行维护的,可以和mutator线程并发执行;</p><h3 id="转移的执行步骤"><a class="header-anchor" href="#转移的执行步骤"></a>转移的执行步骤</h3><p>转移的执行步骤可以分为以下三个:</p><ol><li><p>选择回收集合<br>指的是根据上述标记阶段得到的信息来选择被转移的区域.被选中的区域被称为<B>回收集合</B>;</p></li><li><p>根转移<br>指的是将回收集合中的由GC Root对象直接引用的对象和被其他区域引用的对象转移到其他空间中;</p></li><li><p>转移<br>指的是以2步骤中转移的对象作为起点扫描其子孙对象,然后将这些对象转移到其他空间中;</p></li></ol><h4 id="选择回收集合"><a class="header-anchor" href="#选择回收集合"></a>选择回收集合</h4><p>这个步骤是G1GC算法的核心部分,在选择需要进行回收的集合时,是按照两个原则来进行选择:</p><ul><li><B>转移效率高</B>的区域优先</li><li>整体区域转移预测的暂停时间需要在用户的容忍范围之内</li></ul><p>在标记的最后一个步骤<B>收尾阶段</B>中我们介绍了什么是<B>转移效率</B>的概念,简单的理解就是存活的对象越少,这个region的转移效率就越高;<br>然后根据转移效率对所有region进行排序,就可以得到一个region数组;<br>每一个region都有一个预测的转移暂停时间,G1GC在选择本次的<B>回收集合</B>就是从region数据从上到下依次累积预测暂停时间,直到大于等于用户的容忍时间阀值,这个子集就是<br>本次需要进行回收的集合;</p><blockquote><p>G1GC中的G1是Garbage First的简称,翻译成中文指的是&quot;垃圾优先的垃圾回收&quot;算法,而<B>转移效率从高到低的顺序</B>就是垃圾优先的具体实现方法;</p></blockquote><h4 id="根转移步骤"><a class="header-anchor" href="#根转移步骤"></a>根转移步骤</h4><p><B>根转移</B>指的是将对象或者引用转移到其他区域,包括三类数据:</p><ol><li>由根直接引用的对象</li><li>并发标记处理中的对象</li><li>由其他区域对象直接引用的回收集合内的对象</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E7%A7%BB.png?raw=true" alt="对象转移"></p><p>对象转移分为三类:</p><ol><li>对于引用到回收集合内的对象,将该对象添加到<B>转移队列</B>中,然后进行回收;</li><li>对于引用到回收集合外的对象,将更新其他对象的转移专用记忆集合;</li><li>对于其他对象引用到回收对象时,更新回收对象的转移专用记忆集合;</li></ol><h4 id="转移"><a class="header-anchor" href="#转移"></a>转移</h4><blockquote><p>在完成根转移之后,哪些被转移队列引用的对象将会<B>依次进行转移</B>.直到转移队列都被清空,转移就全部完成了;至此,回收集合内所有存活的对象都被成功转移到存活区域了;</p></blockquote><h4 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h4><p>在<B>转移阶段</B>是整个G1GC最核心的思想实现,一个是&quot;垃圾优先的垃圾回收&quot;算法的实现,一个是&quot;根对象转移算法&quot;的实现;</p><h2 id="软实时性"><a class="header-anchor" href="#软实时性"></a>软实时性</h2><p>G1GC是如何实现软实时性的?</p><p>在G1GC中用户可以设置以下三个值:</p><ol><li><p>可用内存的上限<br>通过Xmn/xmx来指定堆空间最小/最大值,避免内存被过度占用,Xmn不建议使用,这个值会破坏我们对于暂停时间上限的配置</p></li><li><p>G1GC暂停时间上限<br>使用-XX:MaxGCPauseMillis=200 为所需的最大暂停时间设置目标值,默认值为 200 毫秒.这里有一个前提是在一个GC单位时间内的暂停时间上限;</p></li><li><p>GC单位时间<br>对于GC单位时间的配置,没有找到相关资料,但是肯定是有这个概念的;避免通过频繁的GC来达到暂停时间少的目的;</p></li></ol><p>G1GC是根据<B>预测转移时间</B>和<B>预测可信度</B>这两个计算结果来实现软实时性的;</p><blockquote><p>在G1GC内部有一个<B>调度队列</B>,其中的元素是暂停处理的开始时间和结束时间的组合.G1GC使用这个队列来高效的调度GC的暂停任务.调度队列中保存了最近一次<br>暂停处理的开始时间和介绍时间.调度队列中的元素有上限,如果添加元素时超过上限,队列头部最早添加的元素就会被删除;</p></blockquote><p>如下展示一下<B>GC暂停处理的调度过程</B></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E6%9A%82%E5%81%9C%E5%A4%84%E7%90%86%E7%9A%84%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png?raw=true" alt="GC暂停处理的调度过程"></p><p>图中<B>1</B>表示的是在当前时间开始预测下一次发生GC的暂停时间为X,第2步表示如果此时开始GC,在一个GC的单位时间之内会超过设定的GC暂停时间的上限,因此不进行暂停;<br>在第3步中,如果将暂停时间延迟,在GC的单位时间内不会超过设定的GC暂停时间上限;<br>需要注意的是<B>调度程序会保证在任意截取的GC单位时间内,总的GC暂停时间都不会超过用户设置的GC暂停时间上限</B>,当然在某些特殊情况下也会超出设置的暂停时间上限,这就是G1GC所保证的&quot;乱实时性&quot;,这些特殊情况包括但是不限于&quot;GC的预测时间不准确&quot;和&quot;堆内存空间不足&quot;等;</p><h2 id="分代G1GC模式"><a class="header-anchor" href="#分代G1GC模式"></a>分代G1GC模式</h2><p>在上述的<B>并发标记阶段</B>、<B>转移阶段</B>都是介绍的G1GC的进行GC时的算法和实现,在G1GC的实现中是引入了<B>分代</B>的概念的,下面来介绍一下G1GC的分代;</p><h3 id="为什么要进行分代"><a class="header-anchor" href="#为什么要进行分代"></a>为什么要进行分代?</h3><blockquote><p>分代:通过给对象引入&quot;年龄&quot;的做法来标记对象的重要程度,从而提升GC的效率;</p></blockquote><h3 id="GC模式划分"><a class="header-anchor" href="#GC模式划分"></a>GC模式划分</h3><ul><li>纯G1GC模式</li><li>分代G1GC模式</li></ul><p>两者之间的不同点:</p><p>内存划分的不同:</p><ul><li>区域是分代的</li><li>回收集合的选择是分代的</li></ul><blockquote><p>在分代G1GC模式中,区域会被划分成<B>新生代区域</B>和<B>老年代区域</B>两类;和其他分代算法类似,分代G1GC的对象也保存了自身在各次转移中存活下来的次数.新生代区域存放新生代对象,老年代区域存放老年代对象;</p></blockquote><p>在G1GC中新生代区域GC被称为<B>完全新生代GC</B>,老年代区域GC被称为部分新生代GC,他们之间的区别在于回收集合的选择,完全新生代GC是将<B>所有的新生代区域</B>选入回收集合,部分新生代GC是将<B>所有的新生代区域以及一部分老年代区域</B>选入回收集合中;</p><p>回收方式的不同:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E6%96%B0%E7%94%9F%E4%BB%A3GC%E7%9A%84%E8%BF%87%E7%A8%8B.jpg?raw=false" alt="新生代GC的过程"></p><p>从上图中可以看到部分新生代GC会将一部分老年代区域中的对象进行回收;</p><h3 id="新生代区域"><a class="header-anchor" href="#新生代区域"></a>新生代区域</h3><p>新生代区域会被划分成两类:</p><ul><li>创建区域</li><li>存活区域</li></ul><p>创建区域指的是用于存放刚刚生成一次都没有经历过转移的对象,存活区域用来保存至少转移过一次的对象;</p><p>在新生代区域中不会应用<B>转移转移写屏障</B>,因为新生代中的对象都是会被回收的,因此被引用方不会保存新生代的专用写屏障;</p><h2 id="算法篇的总结"><a class="header-anchor" href="#算法篇的总结"></a>算法篇的总结</h2><p><img src="" alt="mutator和GC的执行关系"></p><p>在大多数时候转移专用记忆集维护线程都是和mutator并发执行的,但是在GC的存活对象计数阶段记忆维护线程也是暂停的.888888</p><p>G1GC的优点:</p><ol><li>G1GC具备软实时性,可以由用户控制GC的暂停时间</li><li>能够充分发挥高配置机器的性能,做到并发执行</li><li>通过写屏障将处理粒度调整为更粗维度的卡片粒度,从而降低了写屏障发生的频率</li><li>通过对象的转移,实现了区域内没有内存碎片</li></ol><p>G1GC的缺点:</p><ol><li>适用与多核处理器的设备;</li><li>区域内不会出现碎片化,但是整个堆会按照区域出现碎片化;</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><ul><li>《深入Java虚拟机：JVM G1GC的算法与实现》中村成洋(作者) 吴炎昌,杨文轩 (译者)</li><li>《垃圾回收的算法与实现》中村成洋,相川光,竹内郁雄 (作者) 丁灵 (译者)<br><a href="https://wiki.openjdk.org/display/HotSpot/G1GC+Feedback">G1GC Feedback</a><br><a href="https://www.huminxi.com/2022/07/06/java%208%20vs%20java%2017%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">Java 8 vs Java 17 垃圾收集器</a><br><a href="https://www.bilibili.com/video/BV15B4y1972U/">G1GC最初的设计思路（上）</a><br><a href="https://developer.aliyun.com/article/1097566">JVM垃圾回收-记忆集和卡表</a><br><a href="https://zhuanlan.zhihu.com/p/444691935">图解 Remembered Set、Card Table、Write Barrier</a><br><a href="https://tech.meituan.com/2016/09/23/g1.html">Java Hotspot G1 GC的一些关键技术</a><br><a href="https://docs.oracle.com/en/java/javase/18/gctuning/garbage-first-g1-garbage-collector1.html#GUID-58968F63-9EAF-487E-A884-CF0831EA6D31">HotSpot Virtual Machine Garbage Collection Tuning Guide</a><br><a href="https://zhuanlan.zhihu.com/p/115501055">Java Memory：认识SafeRegion</a><br><a href="https://tschatzl.github.io/2022/08/04/concurrent-marking.html">Concurrent Marking in G1</a><br><a href="http://www.noobyard.com/article/p-smfxguqn-od.html">最清晰易懂的G1GC资料</a><br><a href="https://segmentfault.com/a/1190000039300766">SATB的一些理解</a><br><a href="https://www.zhihu.com/question/456166411">G1并发标记的原始快照（SATB）的过程是怎样的？</a><br><a href="https://www.jfokus.se/jfokus17/preso/Write-Barriers-in-Garbage-First-Garbage-Collector.pdf">Write Barriers in Garbage First Garbage Collector</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记&lt;/h1&gt;
&lt;p&gt;这一篇文章主要是用于记录《深入Java虚拟机：JVM G1GC的算法与实现》一书中&lt;B&gt;算法篇&lt;/B&gt;部分的笔记,主要分为引子、并发标记、转移、软实时性、分代G1GC模式;&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/categories/jvm/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java性能权威指南-性能测试的方法和工具</title>
    <link href="https://agmtopy.gitee.io/2023/03/24/20.%E7%AC%94%E8%AE%B0/30.Java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://agmtopy.gitee.io/2023/03/24/20.%E7%AC%94%E8%AE%B0/30.Java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2023-03-24T13:44:02.000Z</published>
    <updated>2023-04-05T08:53:03.580Z</updated>
    
    <content type="html"><![CDATA[<h1>Java性能权威指南-性能测试的方法和工具</h1><h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><p>记录在阅读《Java性能权威指南》过程中的一些笔记和感悟,主要会分为一下几个部分:性能测试方式方法、影响性能的原因、如何进行调优;下面第一部分就是对<B>性能测试方式方法</B>进行分析</p><h2 id="性能测试的四项原则"><a class="header-anchor" href="#性能测试的四项原则"></a>性能测试的四项原则</h2><p>当一个应用出现性能瓶颈或者性能方面的问题时，往往不能一眼发现问题的根源，会从多个方向去猜测原因,毫无头绪，因此对应用进行性能测试是了解当前阀值的一个好方法;</p><p>性能测试时有几项原则，可以更好的帮助我们进行分析</p><ol><li>测试真实的应用</li></ol><p>在真实的应用上进行性能测试,因为如果你的测试目标和真实的应用不是同一个时,很多影响性能的因素会导致判断错误;</p><ol start="2"><li>理解批处理流逝时间、吞吐量和响应时间</li></ol><ul><li>批处理流逝时间指的是<B>一个批处理作业从开始运行到结束的时间间隔</B></li><li>吞吐量指的是单位时间内完成的工作量,常见的指标有:TPS(事务数/1s)、RPS(请求数/1s)、OPS(操作数/1s)</li></ul><ol start="3"><li><p>用统计方法应对性能的变化<br>在小样本的数据下结果会存在较大的差异,因此要采用大量的数据集来消除这种差异;</p></li><li><p>尽早的开始测试<br>这一点对于性能测试来说个人不太认同,尽早的开始测试应该是对应用代码进行测试,来保证业务上的正确性;</p></li></ol><h2 id="性能测试的种类"><a class="header-anchor" href="#性能测试的种类"></a>性能测试的种类:</h2><ol><li>微基准测试</li></ol><blockquote><p>用来测量微小代码单元的性能<br>主要是用于测试代码片段的性能,有两个问题:测试代码复杂/对于性能准确性会因为偏差造成不准</p></blockquote><ol start="2"><li>宏基准测试</li></ol><blockquote><p>宏基准测试是以真实世界中的业务为测试目标来进行测试的一种方法，是用于评估系统的整体性能;</p></blockquote><ol start="3"><li>介基准测试</li></ol><blockquote><p>介基准测试是微基准测试和宏基准测试之间的测试方法,是用于评估组成真实业务规则中的一系列子方法;</p></blockquote><h2 id=""><a class="header-anchor" href="#"></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java性能权威指南-性能测试的方法和工具&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;记录在阅读《Java性能权威指南》过程中的一些笔记和感悟,主要会分为一下几个部分:性能测试方</summary>
      
    
    
    
    <category term="性能" scheme="https://agmtopy.gitee.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cola4.0的工程实践</title>
    <link href="https://agmtopy.gitee.io/2022/12/24/1.%E6%9D%82%E8%AE%B0/Cola4.0%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/12/24/1.%E6%9D%82%E8%AE%B0/Cola4.0%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-24T03:30:46.000Z</published>
    <updated>2023-01-28T03:14:34.853Z</updated>
    
    <content type="html"><![CDATA[<h1>Cola4.0的工程实践</h1><p>cola在今年迎来了4.0版本,在最新的版本中对<B>包结构</B>进行了调整以及将COLA项目整体划分为两个部分<B>COLA架构</B>和<B>COLA组件</B>;<br>下面先简单的介绍COLA的改变,再介绍CLOA4.0的工程实践</p><h2 id="COLA的改变"><a class="header-anchor" href="#COLA的改变"></a>COLA的改变</h2><p>COLA4.0的改变主要是聚焦与COLA架构和COLA组件两个部分:</p><ol><li>COLA架构：关注应用架构的定义和构建，提升应用质量。</li><li>COLA组件：提供应用开发所需要的可复用组件，提升研发效率。<br>作者Frank画了两张图很好的表现出来</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/COLA4.0%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png?raw=true" alt="COLA4.0分层模型"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/COLA%E6%9E%B6%E6%9E%84%E6%8A%BD%E8%B1%A1.png?raw=true" alt="COLA架构抽象"></p><h2 id="COLA-4-0d的实践"><a class="header-anchor" href="#COLA-4-0d的实践"></a>COLA 4.0d的实践</h2><h3 id="创建项目"><a class="header-anchor" href="#创建项目"></a>创建项目</h3><p>创建项目命令与之前的相同还是执行以下命令即可:</p><blockquote><p>mvn archetype:generate  -DgroupId=com.agmtopy.demo  -DartifactId=cola-demo  -Dversion=1.0.0-SNAPSHOT  -Dpackage=com.agmtopy.demo  -DarchetypeArtifactId=cola-framework-archetype-web  -DarchetypeGroupId=com.alibaba.cola  -DarchetypeVersion=4.3.1</p></blockquote><p>稍微注意修改 #groupId#/#artifactId#/#package#;<br>这个命令在PowerShell不能执行,参数传递错误,需要在CMD或者shell下执行</p><p>创建完成项目后可以看到项目目录如下:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_pom.jpg?raw=true" alt="cola项目结构_maven"></p><p>使用<B>gradle init</B>将maven转换成gradle项目</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_gradle.jpg?raw=true" alt="cola项目结构_gradle"></p><p>在maven项目转换成gradle项目时遇到几个问题:</p><ol><li>gradle ext定义常量在使用kotlin定义时,方式为<B>val</B></li><li>主build.gradle.kts引入BOM,子项目使用组件版本问题未解决,现在还是通过在子项目中直接引入的目标组件</li></ol><p>项目build成功后,通过<B>Application.main</B>启动即可访问</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola_helloworld.jpg?raw=true" alt="cola_helloworld"></p><h3 id="项目结构"><a class="header-anchor" href="#项目结构"></a>项目结构</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_gradle.jpg?raw=true" alt="cola项目结构_gradle"></p><p>通过<B>cola-framework-archetype-web</B>创建出来的项目结构如上所示,这个结构比较符合标准项目的定义;<br>在实际使用中结合目前团队现有方案我进行了部分调整,调整后的结构如下所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5.png?raw=true" alt="项目实践"></p><pre class="line-numbers language-none"><code class="language-none">├‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧integrationtest‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧┤├╌╌╌╌╌╌╌╌╌api&#x2F;app╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌batch╌╌╌╌╌╌╌╌╌╌╌╌╌┤                           ├╌╌╌╌╌╌╌╌╌╌joblay╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌business&#x2F;configure╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌domain╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌infrastructure&#x2F;common╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个结构中调整的地方如下:<br>新增:<B>integrationtest</B>作为通用测试的模块<br>新增:<B>configure</B>作为业务配置的模块,专门处理业务配置<br>改变:<B>adapter</B>模块扩充为<B>api/app/batch</B>三个模块,其中app和batch作为实例的启动入口<br>改变:<B>app</B>模块扩充为<B>joblay/business/configure</B>三个模块,作为业务处理<br>改变:<B>infrastructure</B>层新增加<B>common</B>模块,承载通用处理和工具类的职能<br>删除:删除<B>start</B>模块,将启动模块下沉到<B>app</B>和<B>batch</B>中</p><p>在这个模块设计中<B>joblay</B>存在的意义是用来实现批量业务领域内的功能;由于<B>app</B>和<B>batch</B>都只是承担start的功能;</p><p>项目地址为<B><a href="https://github.com/agmtopy/cola-demo">https://github.com/agmtopy/cola-demo</a></B></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/significantfrank/article/details/110934799?spm=1001.2014.3001.5502">COLA 4.0：应用架构的最佳实践</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Cola4.0的工程实践&lt;/h1&gt;
&lt;p&gt;cola在今年迎来了4.0版本,在最新的版本中对&lt;B&gt;包结构&lt;/B&gt;进行了调整以及将COLA项目整体划分为两个部分&lt;B&gt;COLA架构&lt;/B&gt;和&lt;B&gt;COLA组件&lt;/B&gt;;&lt;br&gt;
下面先简单的介绍COLA的改变,再介绍CLOA4.</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="cola" scheme="https://agmtopy.gitee.io/tags/cola/"/>
    
  </entry>
  
  <entry>
    <title>Groowy脚本实现业务场景下动态性规则的实践</title>
    <link href="https://agmtopy.gitee.io/2022/12/16/1.%E6%9D%82%E8%AE%B0/Groowy%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8A%A8%E6%80%81%E6%80%A7%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/12/16/1.%E6%9D%82%E8%AE%B0/Groowy%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8A%A8%E6%80%81%E6%80%A7%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-16T13:39:20.000Z</published>
    <updated>2023-01-04T16:56:04.305Z</updated>
    
    <content type="html"><![CDATA[<h1>Groowy脚本实现业务场景下动态性规则的实践</h1><h2 id="前言："><a class="header-anchor" href="#前言："></a>前言：</h2><p>在复杂的业务中我们往往会采用分层的思想来降低每一层的复杂度，应用层还会采用一些设计模式来预留出对于未来的扩展；在面对<br>复杂和易变的业务场景下，作为开发者，我们更期望程序框架底座能够保持稳定，而对”<B>扩展</B>”更期望可以做到能快速响应业务需求的变化和做到隔离性；<br>由于程序语言的特性，有些语言不能做到实时热编译和部署，需要借助其他工具来实现这一个效果，在jvm平台上Groovy脚本语言就非常适合这种场景。<br>接下来以一个具体的业务需求来作为“引子”，来展开是这个需求实现过程中的一些思考和实践;</p><h2 id="需求背景"><a class="header-anchor" href="#需求背景"></a>需求背景</h2><p>原始需求简化后得出的核心目标就是对业务数据进行巡检,本身从功能上来讲比较简单;在系统设计出发的时候就明确了本次的功能目标:</p><ol><li>向上会抽象出<B>巡检功能</B>的核心领域,并且支持扩展</li><li>向下会设计出基础设施层来作为支撑</li></ol><p>向上这一部分工作开展的比较顺利,因为是基于现实诉求抽象公共特性/接口;但是向下这一部分设计在落地的时候遇到一些问题,有三个阶段分别是:</p><ol><li>采用手动编译java代码</li><li>采用开源框架编译加载java代码</li><li>使用Groovy动态脚本</li></ol><h3 id="设计评审"><a class="header-anchor" href="#设计评审"></a>设计评审</h3><p>在实现这个需求的时候,做技术方案设计评审的时候,我提供了两种实现基础设施层的技术方案:<br>第一种是通过easy-rules提供出一个一个散列开的业务校验规则执行器,这样做的优点是在于技术成本最低,且代码可读性好,但是没有动态编译执行的能力<br>第二种是通过引入动态语言实现,这样做的优点是程序具有动态编译执行的能力,缺点是在于技术成本略高,Groovy脚本语言需要一定的学习成本</p><p>最后的技术评审经过大家的沟通交流最后决定采用第一种方案来进行实现;</p><h3 id="方案实施"><a class="header-anchor" href="#方案实施"></a>方案实施</h3><p>在按照第一种方案进行实施的时候,遇到一个问题,代码的重复度太高;因为业务需求的本质就只是<B>对比</B>,因此最开始想采用反射来降低代码的重复度,将需要检查的字段放在Map进行处理;<br>在继续沿着这方面思考,就想到了既然是用Map来获取校验规则,那可不可以将校验规则写入配置中心或者数据库,再进行动态加载楠;<br>沿着这个思路开始查找java文件进行动态编译的框架<a href="https://github.com/jOOQ/jOOR">joor</a>,在进行快速验证的时候发现joor可以做到对java文件的动态编译,但是在JDK8上有部分编译错误无法实现业务的扩展性;<br>这个时候似乎只有一种选择了,就是采用<B>Groovy</B>来进行实现</p><h2 id="Groovy使用"><a class="header-anchor" href="#Groovy使用"></a>Groovy使用</h2><h3 id="整体执行流程"><a class="header-anchor" href="#整体执行流程"></a>整体执行流程</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/excalidraw/Untitled-2022-09-08-1533.png?raw=true" alt="整体执行流程"></p><p>在流程中抽象的比较方法是作为所有动态脚本的父类,默认采用了反射的反射来或者Object中指定的字段</p><h3 id="DynamicUtil的设计"><a class="header-anchor" href="#DynamicUtil的设计"></a>DynamicUtil的设计</h3><p>从四个问题开始入手:</p><ol><li>如何简化Groovy的学习成本,从而推广出去?</li><li>如何保证性能?</li><li>如何保证动态脚本的安全性?</li><li>如何保证动态脚本的代码质量(动态脚本的单元测试如何进行)?</li></ol><h4 id="对于如何简化Groovy的学习成本"><a class="header-anchor" href="#对于如何简化Groovy的学习成本"></a>对于如何简化Groovy的学习成本?</h4><p>项目初期可以采用<B>GroovyClassLoader</B>来执行<B>Java脚本</B></p><ul><li>DynamicUtil</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">GroovyClassLoader</span> groovyClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroovyClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> helloScript <span class="token operator">=</span> <span class="token string">"package com.agmtopy.source.groovy;\n"</span> <span class="token operator">+</span>                <span class="token string">"\n"</span> <span class="token operator">+</span>                <span class="token string">"class Hello &#123;\n"</span> <span class="token operator">+</span>                <span class="token string">"    public String method(String name) &#123;\n"</span> <span class="token operator">+</span>                <span class="token string">"        System.out.println(\"hello, \" + name);\n"</span> <span class="token operator">+</span>                <span class="token string">"        return name;\n"</span> <span class="token operator">+</span>                <span class="token string">"    &#125;\n"</span> <span class="token operator">+</span>                <span class="token string">"&#125;\n"</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span> helloClass <span class="token operator">=</span> groovyClassLoader<span class="token punctuation">.</span><span class="token function">parseClass</span><span class="token punctuation">(</span>helloScript<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">GroovyObject</span> object <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">GroovyObject</span><span class="token punctuation">)</span> helloClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> ret <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">invokeMethod</span><span class="token punctuation">(</span><span class="token string">"method"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 控制台输出"hello, world"</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印world</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Hello.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>agmtopy<span class="token punctuation">.</span>source<span class="token punctuation">.</span>groovy</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在上面这个例子中,我们执行的脚本就是java语法规则的脚本;这样如何简化Groovy脚本的问题就可以得到解决;<br>在整个执行框架稳定以后,还是需要推广Groovy脚本,java语法的脚本只是一个中间过渡方案!</p><h4 id="如何保证脚本的执行性能"><a class="header-anchor" href="#如何保证脚本的执行性能"></a>如何保证脚本的执行性能?</h4><p>这里的性能指的是两方面:<B>编译</B>和<B>执行</B>,我们先来看Groovy是如何编译脚本的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Class</span> <span class="token function">parseClass</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">GroovyCodeSource</span> codeSource<span class="token punctuation">,</span> <span class="token keyword">boolean</span> shouldCacheSource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CompilationFailedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取cacheKey:scriptTest+name 进行MD5</span>    <span class="token class-name">String</span> cacheKey <span class="token operator">=</span> <span class="token function">genSourceCacheKey</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//sourceCache是一个类似与Map类型的类</span>    <span class="token keyword">return</span> sourceCache<span class="token punctuation">.</span><span class="token function">getAndPut</span><span class="token punctuation">(</span>            cacheKey<span class="token punctuation">,</span>            key <span class="token operator">-></span> <span class="token function">doParseClass</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">,</span>            shouldCacheSource    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">Class</span> <span class="token function">doParseClass</span><span class="token punctuation">(</span><span class="token class-name">GroovyCodeSource</span> codeSource<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">validate</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span> answer<span class="token punctuation">;</span>  <span class="token comment">// Was neither already loaded nor compiling, so compile and add to cache.</span>    <span class="token class-name">CompilationUnit</span> unit <span class="token operator">=</span> <span class="token function">createCompilationUnit</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> codeSource<span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//省略...</span>        <span class="token comment">//创建ClassCollector,class类属性相关的收集对象</span>    <span class="token class-name">ClassCollector</span> collector <span class="token operator">=</span> <span class="token function">createCollector</span><span class="token punctuation">(</span>unit<span class="token punctuation">,</span> su<span class="token punctuation">)</span><span class="token punctuation">;</span>    unit<span class="token punctuation">.</span><span class="token function">setClassgenCallback</span><span class="token punctuation">(</span>collector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开始执行编译命令</span>    unit<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>goalPhase<span class="token punctuation">)</span><span class="token punctuation">;</span>    answer <span class="token operator">=</span> collector<span class="token punctuation">.</span>generatedClass<span class="token punctuation">;</span>    <span class="token class-name">String</span> mainClass <span class="token operator">=</span> su<span class="token punctuation">.</span><span class="token function">getAST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMainClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token operator">:</span> collector<span class="token punctuation">.</span><span class="token function">getLoadedClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token class-name">String</span> clazzName <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">definePackageInternal</span><span class="token punctuation">(</span>clazzName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置到classCache中</span>        <span class="token function">setClassCacheEntry</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置为answer</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazzName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mainClass<span class="token punctuation">)</span><span class="token punctuation">)</span> answer <span class="token operator">=</span> clazz<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> answer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中,执行流程如下</p><p>doParseClass() -&gt; createCollector() -&gt; unit.compile(goalPhase) -&gt; ClassCollector.call() -&gt; ClassCollector.createClass()</p><p>创建class对象的过程是在<B>ClassCollector.createClass</B>方法中,在这个方法中可以看到最后是调用的java.security.SecureClassLoader#defineClass()</p><ul><li>ClassCollector.createClass</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span> <span class="token function">createClass</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> code<span class="token punctuation">,</span> <span class="token class-name">ClassNode</span> classNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BytecodeProcessor</span> bytecodePostprocessor <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytecodePostprocessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fcode <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytecodePostprocessor<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fcode <span class="token operator">=</span> bytecodePostprocessor<span class="token punctuation">.</span><span class="token function">processBytecode</span><span class="token punctuation">(</span>classNode<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//GroovyClassLoader extends SecureClassLoader</span>    <span class="token class-name">GroovyClassLoader</span> cl <span class="token operator">=</span> <span class="token function">getDefiningClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//这里通过SecureClassLoader.defineClass 来进行加载</span>    <span class="token class-name">Class</span> theClass <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>classNode<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fcode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fcode<span class="token punctuation">.</span>length<span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">getAST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadedClasses<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>theClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//省略...</span>    <span class="token keyword">return</span> theClass<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里还有一个点是在创建<B>GroovyClassLoader</B>时,都是通过<B>new InnerLoader</B>的方式来创建</p><blockquote><p>return java.security.AccessController.doPrivileged((PrivilegedAction<InnerLoader>) () -&gt; new InnerLoader(GroovyClassLoader.this));</p></blockquote><p>这是因为Class对象是通过ClassLoader+class的方式来定位确定唯一一个类的,InnerLoader每次都会创建一个新的对象,这样可能会导致Metaspace内存溢出,虽然在Groovy3.0以后针对这个问题已经进行过优化了,但是还是强烈建议通过内存将脚本编译后的<B>GroovyObject</B>缓存下来,本身脚本的再次编译和加载都是一个较为消耗性能的动作;</p><p>我们下面继续对<B>执行性能</B>来进行分析,在网上大多数资料对于Groovy的脚本执行性能的分析,github中关于这方面的issue也比较少,并且大部分是针对与Groovy和Java进行对比的;<br>下面有几个关于Groovy脚本执行的建议:</p><ol><li>尽量使用静态类型,由于Groovy是动态语言,在将动态特性编译成为静态语言时是比较消耗性能的</li><li>oracle官方对于Groovy的5条性能建议</li></ol><h4 id="如何保证动态脚本的安全性"><a class="header-anchor" href="#如何保证动态脚本的安全性"></a>如何保证动态脚本的安全性?</h4><p>如何保证动态脚本的安全性?其实也是分为两个方面考虑的:</p><ol><li>执行安全性</li></ol><blockquote><p>执行安全性指的是在执行脚本时是否会影响到我的宿主进程?如何规避这种风险?</p></blockquote><ol start="2"><li>脚本本身的安全性</li></ol><blockquote><p>脚本本身的安全性指的是脚本语义是否正确/正常以及可信</p></blockquote><p>下面对着两方面进行分析和设计:</p><p><B>脚本执行的安全性</B>方面最主要的考虑是错误的脚本是否会影响到主进程的执行?主要从下面几个方面考虑:</p><ol><li>内存<blockquote><p>内存主要还是考虑堆栈内存即可,一个是成员变量的空间分配,一个是while造成死循环使栈溢出等;可以在定义<B>GroovyClassLoader</B>时进行排除</p></blockquote></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">SecureASTCustomizer</span> secure <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecureASTCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建SecureASTCustomizer</span>secure<span class="token punctuation">.</span><span class="token function">setClosuresAllowed</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 禁止使用闭包</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tokensBlacklist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tokensBlacklist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Types</span><span class="token punctuation">.</span>*<span class="token operator">*</span>KEYWORD_WHILE<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加关键字黑名单 while和goto</span>tokensBlacklist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Types</span><span class="token punctuation">.</span>*<span class="token operator">*</span>KEYWORD_GOTO<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setTokensBlacklist</span><span class="token punctuation">(</span>tokensBlacklist<span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setIndirectImportCheckEnabled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置直接导入检查</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"com.alibaba.fastjson.JSONObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setImportsBlacklist</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>线程</li></ol><blockquote><p>对与线程方面的考虑主要是执行线程需要使用单独的线程池进行处理,这样做的目的是防止动态脚本的执行线程阻塞业务线程;第二个是动态脚本中应该禁止使用线程池来进行处理,这方面的考量主要是基于脚本业务代码尽量的要简单高效和可读性,引入线程池会增加脚本的复杂度和可维护性</p></blockquote><ol start="3"><li>数据库/资源的管理</li></ol><blockquote><p>对与数据库和其他资源的访问,我是持有拒绝的态度,主要观点还是和脚本中实现线程池类似,还有一点是脚本中进行数据变更和资源处理缺少了代码版本控制这一个环节;</p></blockquote><p><B>脚本本身的安全性</B>主要指的是脚本开发/提测/上线整个流程的安全和监控性,在这方面Vivo提供了一套内部使用的流程如下:</p><p><img src="https://static001.geekbang.org/infoq/ac/acf787602d9e4bf20abded0c80525565.png" alt="Groovy整体流程"></p><p>在这个过程中,除了code review部分需要开发者进行参与,其他部分都可以依托CI/CD工具实现自动化执行;<br>有了这样一个流程,其实是可以解决脚本本身的安全性的问题的;</p><h4 id="如何保证动态脚本的代码质量"><a class="header-anchor" href="#如何保证动态脚本的代码质量"></a>如何保证动态脚本的代码质量?</h4><p>动态脚本的代码质量如何进行保证,一方面是可以通过良好的code review机制来提高质量,另外一方面是需要建设好单元测试框架;<br>如何建立好动态脚本的单元测试?<br>首先是方便,在开发人员的角度一个工具只有在足够的简单方便的情况下才会乐意去进行使用,其次是流程规范.<br>目前执行的过程是在特定的测试包下,开发脚本,然后进行单元测试,在单元测试通过后在写入数据库中;<br>后续实践出更好的方案在进行更新</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>以上通过Groovy实现了动态特性的同时引入了一些尚未解决的问题:<br>执行性能/单元测试,后续在实践过程中也会对这些问题持续的进行更新.</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/en/cloud/paas/app-builder-cloud/visual-builder-groovy/best-practices-for-groovy-performance.html">oracle官方对于Groovy 性能的最佳实践</a><br><a href="https://www.huangchaoyu.com/2021/10/16/groovy%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%AE%B9%E6%98%93%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/">groovy静态编译容易引发的问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Groowy脚本实现业务场景下动态性规则的实践&lt;/h1&gt;
&lt;h2 id=&quot;前言：&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;
&lt;p&gt;在复杂的业务中我们往往会采用分层的思想来降低每一层的复杂度，应用层还会采用一些设计</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="guava" scheme="https://agmtopy.gitee.io/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>Class文件格式与加载</title>
    <link href="https://agmtopy.gitee.io/2022/12/03/12.JVM/9.Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8A%A0%E8%BD%BD/"/>
    <id>https://agmtopy.gitee.io/2022/12/03/12.JVM/9.Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-12-03T15:02:44.000Z</published>
    <updated>2022-12-04T10:14:51.378Z</updated>
    
    <content type="html"><![CDATA[<h1>Class文件格式与加载</h1><h2 id="类文件结构"><a class="header-anchor" href="#类文件结构"></a>类文件结构</h2><ul><li>类文件结构也就是Class文件的结构<ul><li>魔数:用于标识Class文件的版本</li><li>常量池:主要用于保存<strong>字面量(类似于字符串等)</strong> 和 <strong>符号引用(类和接口的全限定名\字段名称以及描述符\方法名称和描述符);</strong> 由于jvm在加载Class文件时才会进行<B>动态连接</B>,因此需要保存这些方法或接口的信息</li><li>访问标识:标识这个Class的类型(接口/类/public/abstract/final等)</li><li>类索引、父类索引与接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul></li></ul><h2 id="虚拟机类加载机制"><a class="header-anchor" href="#虚拟机类加载机制"></a>虚拟机类加载机制:</h2><ul><li>虚拟机把描述类的数据从Class文件加载到内存中,并对数据进行校验、转换解析、初始化的过程,最终形成可以被虚拟机之间使用的Java类型对象,就是虚拟机类的加载过程.</li></ul><h3 id="类加载的步骤"><a class="header-anchor" href="#类加载的步骤"></a>类加载的步骤</h3><ol><li>加载</li><li>连接:验证→准备→解析</li><li>初始化</li><li>使用</li><li>卸载</li></ol><p>在执行顺序上:加载→验证→准备→解析→初始化,这五个步骤的顺序是固定的;</p><h4 id="加载"><a class="header-anchor" href="#加载"></a>加载</h4><ol><li>通过类的全限定名来获取定义此类的二进制字节流</li><li>将二进制字节流转换为方法区运行时的数据结构</li><li>在内存中创建这个类的Class对象,作为方法区类结构的方法映射</li></ol><ul><li>对于HotSpot虚拟机而言,Class对象比较特殊,它虽然是对象,但是存放在方法区内,作为访问类结构的对象接口</li></ul><h4 id="验证"><a class="header-anchor" href="#验证"></a>验证</h4><ol><li>文件格式的验证:文件格式\运行版本等</li><li>元数据的验证:对字节码语义信息的分析,</li><li>字节码内容的验证:通过程序来校验方法块中的内容是否正确</li></ol><p>验证阶段贯穿[加载、准备、解析]，并不是严格的线性的顺序</p><h4 id="准备"><a class="header-anchor" href="#准备"></a>准备</h4><ol><li>为类变量分配内存并设置初始值的过程，对于类变量也仅仅是进行类型初始值的赋值(零值)</li><li>final修饰的类变量在这个阶段会直接进行赋实际值的过程，因为final修饰的值会被当作常量</li></ol><h4 id="解析"><a class="header-anchor" href="#解析"></a>解析</h4><ul><li>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程<ol><li>解析阶段会触发类的加载，当为找到Class对象时会根据类的全限定明进行加载</li><li>对字段会按照继承顺序从下先上进行查找，并校验访问权限</li><li>对类方法和接口方法的解析与字段类似</li></ol></li></ul><h4 id="初始化"><a class="header-anchor" href="#初始化"></a>初始化</h4><p>初始化就是在执行<B>clint()</B>的过程</p><p><B>clint()</B>是编译器自动收集类中所有的类变量赋值动作和静态语句块合并生成的</p><p>静态代码块可以对在它之后的类变量进行赋值，但是不能进行访问；因为类变量在<strong>准备阶段</strong>就完成的零值的赋值</p><p>虚拟机内部保证了在执行器之类的<B>clint()</B>方法之前先执行父类的<B>clint()</B>方法</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/ClassLoader_flow.jpg?raw=true" alt="Class文件整体加载结构"></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.geeksforgeeks.org/classloader-in-java/">java中的类加载器</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Class文件格式与加载&lt;/h1&gt;
&lt;h2 id=&quot;类文件结构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#类文件结构&quot;&gt;&lt;/a&gt;类文件结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类文件结构也就是Class文件的结构
&lt;ul&gt;
&lt;li&gt;魔数:用于标识Class</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>性能监控与故障处理工具</title>
    <link href="https://agmtopy.gitee.io/2022/12/01/1.%E6%9D%82%E8%AE%B0/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://agmtopy.gitee.io/2022/12/01/1.%E6%9D%82%E8%AE%B0/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2022-12-01T15:11:20.000Z</published>
    <updated>2022-12-03T14:59:38.223Z</updated>
    
    <content type="html"><![CDATA[<h1>性能监控与故障处理工具</h1><p>介绍处理jvm的相关问题办法以及相关工具的一个持续更新的集合</p><h2 id="📚-经验"><a class="header-anchor" href="#📚-经验"></a>📚 经验</h2><h3 id="CPU占用率高"><a class="header-anchor" href="#CPU占用率高"></a>CPU占用率高</h3><ul><li>通过jvm工具排查</li></ul><ol><li>通过<strong>top</strong>命令查询进程号</li><li>通过<strong>top -Hp <pid></strong> 查到线程号,转换成为<strong>16进制</strong></li><li>通过<strong>jstack <pid> |grep 16进制线程号 -A 10</strong> 找到CPU当前执行的方法堆栈</li></ol><ul><li>通过arthas排查</li></ul><ol><li>thread</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看线程状态(默认只显示10个线程)</span>thread <span class="token comment"># 查看全部线程状态</span>thread --all<span class="token comment"># 查看指定线程执行状态</span>thread --pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="OOM问题"><a class="header-anchor" href="#OOM问题"></a>OOM问题</h3><ol><li>启动命令中设置</li></ol><blockquote><p><B>-XX:+HeapDumpOnOutOfMemoryError</B> 配合<B> -XX:HeapDumpPath</B><br>在OOM时生成dump文件</p></blockquote><ol start="2"><li>线上命令</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#生成堆转储快照dump文件命令</span>  jmap -dump:format<span class="token operator">=</span>b,file<span class="token operator">=</span>heapdump.hprof pid<span class="token comment"># 生成堆栈信息文件命令</span>  jstack -l pid <span class="token operator">>></span> stack.txt<span class="token comment"># Arthas命令</span>  heapdump<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程问题"><a class="header-anchor" href="#线程问题"></a>线程问题</h3><ul><li>线程池提交任务不执行</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># arthas排查</span><span class="token comment"># 获取ClassLoad Hash</span>sc -d com.agmtopy.source.executer.ExecutorServiceUtil<span class="token comment"># 获取对象</span>ognl -x <span class="token number">1</span> <span class="token string">'@com.agmtopy.source.executer.ExecutorServiceUtil@threadPoolExecutor'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>线程死锁</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> <span class="token comment"># arthas排查</span>Thread -b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="⚙-工具"><a class="header-anchor" href="#⚙-工具"></a>⚙ 工具</h2><p><B>Arthas</B>强烈推荐</p><h2 id="📒-常用命令"><a class="header-anchor" href="#📒-常用命令"></a>📒 常用命令</h2><h3 id="网络"><a class="header-anchor" href="#网络"></a>网络</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 采样tcp连接</span><span class="token function">lsof</span> -p 进程号 <span class="token operator">></span> /tmp/进程号_lsof.txt<span class="token comment"># 查看指定端口</span><span class="token function">netstat</span> -tnlp <span class="token operator">|</span> <span class="token function">grep</span> :8080ss -tunlp <span class="token operator">|</span><span class="token function">grep</span> :8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排查网络问题步骤:</p><ol><li>ping 目标地址</li><li>丢包<br>a. 链路中断<br>b. 抖动<br>c. 出口堵塞</li><li>能通<br>a. 检查dns和域名解析</li></ol><blockquote><p>/etc/resolv.conf 或者 dig 或者 nslookup :url</p></blockquote><p>b. 检查端口</p><blockquote><p>telnet -&gt; 如果全部端口不通检查<B>安全组策略</B>;部分端口不通检查<B>负载均衡白名单</B></p></blockquote><ol start="3"><li>不通<br>检查ip设置/网卡驱动/物理链路</li></ol><h3 id="内存"><a class="header-anchor" href="#内存"></a>内存</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 系统内存分布</span>pmap -pid<span class="token comment"># 内存占用</span>jmap -heap 进程号 <span class="token operator">></span> /tmp/进程号_jmap_heap.txt<span class="token comment"># 保存进程堆栈</span>jmap -dump:format<span class="token operator">=</span>b,file<span class="token operator">=</span>/tmp/进程号_jmap_dump.hprof 进程号<span class="token comment"># 内存对象占比</span>jmap -histo <span class="token number">1</span> <span class="token operator">|</span><span class="token function">more</span><span class="token comment"># GC</span>jstat -gcutil 进程号 <span class="token operator">></span> /tmp/进程号_jstat_gc.txtjstat -gcutil <span class="token number">1</span> 1s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CPU"><a class="header-anchor" href="#CPU"></a>CPU</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统上下文切换</span><span class="token function">vmstat</span> -w <span class="token number">1</span><span class="token comment"># 查看进程上下文切换</span>pidstat -p /PID -wtu  <span class="token number">5</span><span class="token comment"># 打印系统负载快照</span><span class="token function">top</span> -b -n <span class="token number">2</span> <span class="token operator">></span> /tmp/top.txt<span class="token function">top</span> -H -n <span class="token number">1</span> -p pid <span class="token operator">></span> /tmp/pid_top.txt<span class="token comment"># 进程列表</span><span class="token function">ps</span> -mp-o THREAD,tid,time <span class="token operator">|</span> <span class="token function">sort</span> -k2r <span class="token operator">></span> /tmp/进程号_threads.txt<span class="token comment"># 线程信息</span>jstack -l 进程号 <span class="token operator">></span> /tmp/进程号_jstack.txt<span class="token comment"># Arthas</span>thread thread -tidthread -all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="I-O"><a class="header-anchor" href="#I-O"></a>I/O</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">strace</span> -p pidiotop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;性能监控与故障处理工具&lt;/h1&gt;
&lt;p&gt;介绍处理jvm的相关问题办法以及相关工具的一个持续更新的集合&lt;/p&gt;
&lt;h2 id=&quot;📚-经验&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#📚-经验&quot;&gt;&lt;/a&gt;📚 经验&lt;/h2&gt;
&lt;h3 id=&quot;CPU占</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="工具" scheme="https://agmtopy.gitee.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jvm-垃圾回收器及算法基础</title>
    <link href="https://agmtopy.gitee.io/2022/12/01/12.JVM/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://agmtopy.gitee.io/2022/12/01/12.JVM/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-12-01T14:02:27.000Z</published>
    <updated>2022-12-03T14:59:41.787Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收器及算法基础</h1><h2 id="前提介绍"><a class="header-anchor" href="#前提介绍"></a>前提介绍</h2><p>垃圾回收器(GC)的理论研究在很早直接就开始了,大概是在60年代lisp语言就开始使用内存分配和垃圾回收机制来管理程序的内存了,近现代这一方向也是保持着极高的研究热度,从G1-&gt;ZGC</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/excalidraw/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80.png?raw=true" alt="大纲"></p><h2 id="算法基础"><a class="header-anchor" href="#算法基础"></a>算法基础</h2><p>对内存空间的回收首先需要解决一个问题那些是需要进行回收的对象,针对这个问题有两种处理方案:</p><ul><li><p>引用计数算法<br>引用计数是通过对对象被引用次数来标识是否有效,存在循环引用问题,可以通过可达性分析的步骤来解决</p></li><li><p>根标记算法,从<strong>GC Roots</strong>开始遍历整个内存对象是否可达的方式来标记需要回收的对象</p><p>首先<strong>GC Roots</strong>对象包括以下的几种:</p><ul><li>虚拟机栈中引用指向的对象(reference)</li><li>方法区中类静态属性引用的对象(静态属性对象,虽然不在栈帧中)</li><li>方法区常量引用的对象(例如常量池中的对象)</li><li>本地方法栈中引用的对象</li></ul></li></ul><h2 id="对象"><a class="header-anchor" href="#对象"></a>对象</h2><ul><li><p>对象的回收</p><p>对象的回收是一个非常严肃的动作,错误的回收将会是一场对用户的灾难,因此在JVM的实现中,对于GC线程的优先级设置的非常低,其次是在标记对象不可达后,还会声明会执行一次<strong>对象</strong>的**finalize()**方法,对于这个方法是否执行完成不做保证(防止死循环/wait time)</p><ul><li>finalize():用于GC回收前对象最后一次自救的方法,但是只会执行一次,防止内存溢出</li></ul></li><li><p>对象的分配</p><p>对象的分配与垃圾收集器的选择有关,对象是优先在Eden区进行分配,</p><p>进入老年代的几种场景:</p><ol><li>大对象直接进入老年代</li><li>长期存活的对象(16次GC)</li><li>动态对象年龄判断(一半相同年龄的对象直接进入老年代)</li></ol></li></ul><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><ul><li><p>标记类</p><p>标记-清除算法/标记-整理算法/复制算法</p><ul><li>标记整理算法是通过时间换空间形式的一种体现,通过整理回收后的内存碎片来达到可以继续分配的目的</li><li>复制算法是空间换时间的体现,通过预留一倍的空间来达到内存回收完成后没有内存碎片的问题</li></ul></li><li><p>分代类</p><p>分代算法主要是根据对象的存活周期,将对象划分为不同区域,在不同的区域上采取不同的算法来处理</p></li></ul><h2 id="HotSopt实现"><a class="header-anchor" href="#HotSopt实现"></a>HotSopt实现</h2><ul><li><p>枚举根节点</p><p>通过<strong>OopMap</strong>的的方式来快速查找GC Roots枚举</p></li><li><p>安全点</p><p>由于引用关系的变化会不断的影响GC Roots,因此HotSpot不是每条指令都会生成OopMap,而只在特定的位置才会产生OopMap,这种特殊的位置被称为<strong>Safe pint</strong>,有两种进入Safe point的方式:</p><ul><li>抢占式</li><li>主动中断式:主动中断的方式是通过设置<strong>中断标记</strong></li></ul></li><li><p>安全区域</p><p>安全区域被称为Safe Region,指的是一段不会改变引用关系的代码,在执行GC时是不会处理已进入Safe Region的线程,当这些线程在离开Sefe Region时也会检查GC是否完成</p></li></ul><h2 id="垃圾收集器"><a class="header-anchor" href="#垃圾收集器"></a>垃圾收集器</h2><ul><li><p>Parallel Scavenge收集器</p></li><li><p>Parallel  Old收集器</p><p>两种Parallel收集器分别是jdk8中默认是年轻代和老年代的垃圾收集器</p><ul><li><p>Parallel Scavenge收集器</p><p>用于<strong>新生代,<strong>关注</strong>吞吐量</strong>的多线程并行收集器</p><p>CMS是关注于停顿时间,尽可能的缩短用户线程的停顿时间,适合于有交互的web系统</p><p>Parallel是关注于吞吐量尽可能的在单位时间内多执行用户代码,缩小GC时间,适用于后台任务</p></li><li><p>Parallel Old收集器</p><p>是老年代的标记-整理算法的多线程垃圾收集器</p></li><li><p>CMS收集器(<strong>三标一清</strong>)</p><p>CMS收集器是以最短停顿时间为目标的垃圾收集器,是基于标记-清除算法演化而来,分为:</p><ol><li>初始标记阶段</li><li>并发标记阶段</li><li>重新标记阶段</li><li>并发清除阶段</li></ol><p>在初始标记和重新标记阶段会STW的方式来进行,因为初始化标记是查找**GC Roots,**重新标记是对并发标记阶段结果修正也需要STW;</p><p>整个CMS中最耗时的<strong>并发标记</strong>和<strong>并发清理阶段</strong>都可以和用户线程一起执行</p><p>CMS垃圾收集器的问题:</p><ol><li>参与线程过高,按照(coreSize+3)/4的方式分配</li><li>无法处理浮动垃圾,对于在重新标记后产生的垃圾只能在下一次GC时进行处理,占用空间,当老年代达到一个阈值后会出发full GC,当CMS在运行时产生内存不足会激活serial GC</li><li>内存碎片问题,通过full GC的方式解决</li></ol></li><li><p>G1收集器</p><ul><li>从jdk9开始G1就作为默认的垃圾处理器</li><li>在整体上G1是标记-整理算法,局部上是标记-复制算法</li></ul></li><li><p>Shenandoah/ZGC收集器</p><ul><li>亚毫秒级</li><li>无分区设计</li></ul></li></ul></li></ul><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.baeldung.com/jvm-zgc-garbage-collector">ZGC简介:可扩展的实验性低延迟 JVM 垃圾收集器</a><br><a href="https://xie.infoq.cn/article/586f901cf8f38dd2f63b54a44">ZGC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收器及算法基础&lt;/h1&gt;
&lt;h2 id=&quot;前提介绍&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提介绍&quot;&gt;&lt;/a&gt;前提介绍&lt;/h2&gt;
&lt;p&gt;垃圾回收器(GC)的理论研究在很早直接就开始了,大概是在60年代lisp语言就开始使用内存分配和垃圾回</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm-内存布局设计</title>
    <link href="https://agmtopy.gitee.io/2022/11/30/12.JVM/7.%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/"/>
    <id>https://agmtopy.gitee.io/2022/11/30/12.JVM/7.%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-11-30T14:13:23.000Z</published>
    <updated>2022-12-03T14:57:50.139Z</updated>
    
    <content type="html"><![CDATA[<h1>内存布局设计</h1><p>JVM的内存设计上是划分为两个大的区域的<B>启动时向操作系统分配的程序内存区域</B>、<B>直接对系统内存进行操作的区域</B>,后者不属于JVM管理,我们主要是分析前者</p><h2 id="大体结构"><a class="header-anchor" href="#大体结构"></a>大体结构</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/jvm%E6%80%BB%E8%A7%88.png?raw=true" alt="JVM架构图"></p><ol><li>程序计数器<ol><li><p>程序计数器是用来记录当前线程所执行的字节码的行号指示器,字节码解释器在工作时就是通过改变这个计数器的值来记录当前执行的指令.</p><p>它是JVM层次的指令执行记录与硬件层次的指令地址寄存器(IR)的区别在于程序计数器只是一段内存区域,通过软件实现的记录虚拟机字节码的执行地址,当执行Native方法时,该区域值为空</p></li><li><p>为什么要有程序计数器?</p><ol><li>在于jvm提交给CPU执行的指令不是一次性全部提交过去的,而是根据java的业务逻辑通过jvm编译在提交给CPU相应的指令,所以需要对IR进行抽象</li></ol></li></ol></li><li>Java虚拟机栈<ol><li>虚拟机栈描述的是Java方法执行时候的内存模型:线程在执行方法时都会创建相应独立的栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息;</li><li>虚拟机栈是由一个个栈帧组成的</li><li>局部变量表用于存储编译器可知的各种基本数据类型的值引用、对象引用、returnAddres类型(指向一个指令的类型,指的是方法返回的指令地址)</li></ol></li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E7%BA%BF%E7%A8%8B%E5%B8%A7%E6%A0%88.png?raw=true" alt="栈帧"></p><ol><li><p>本地方法栈</p><p>本地方法栈是用于表示对本地方法(native)执行的’c stack’</p></li><li><p>java堆</p><p>java堆是java进程管理的最大的一块内存区域,这个区域允许所有线程访问,作用是在这个区域分配对象实例空间;堆所分配的内存空间不需要是连续的(物理/逻辑上都是一样),在HotSpot中堆空间在默认情况下是申请的连续分配</p></li><li><p>方法区</p><p>方法区用于虚拟机加载类信息、常量池、静态变量、即时编译器编译后的代码数据等</p></li><li><p>常量池</p><p>常量池用于存放在编译期产生的各种字符串、符号引用以及允许运行期动态添加</p></li><li><p>直接内存</p></li></ol><p>直接内存指的是通过Native方法直接分配的堆外内存部分</p><h2 id="堆上内存分配过程"><a class="header-anchor" href="#堆上内存分配过程"></a>堆上内存分配过程</h2><p>堆上内存分配过程约等于对象的堆内存分配过程,堆上内存分配需要并发分配的问题,目前有两种处理方案:</p><ol><li>通过CAS机制加上失败重试来保证操作的原子性</li><li>通过本地线程分配缓冲(TLAB)的方式来保证,核心思想就是通过预先划分线程独占的内存空间来<strong>尽量避免从堆上直接分配内存从而避免频繁的锁竞争</strong></li></ol><h2 id="对象的内存布局"><a class="header-anchor" href="#对象的内存布局"></a>对象的内存布局</h2><p>对象的内存布局可以划分为三个区域:对象头(Header)、实例数据、对齐填充部分</p><ol><li><p>header</p><ol><li>Mark Word:通过标识来复用同一地址空间,列如对象哈希码/锁指针/偏向锁信息等</li><li>类型指针:用于标识对象的类元数据,其中数组类型要表示元素的类型以及元素的个数</li></ol></li><li><p>实例数据</p><ol><li>实例数据部分是用于存储业务数据的部分,在分配内存时会尽量遵守相同类型(宽度)的数据分配到一起</li></ol></li><li><p>对齐部分</p><ol><li>对齐部分不一定存在,由于jvm虚拟机分配内存是8个字节的整数倍,header部分设计是就遵守此规范,但是实例数据部分不一定能恰好遵循,因此需要进行数据填充来符合此规范</li></ol><h2 id="对象的访问定位"><a class="header-anchor" href="#对象的访问定位"></a>对象的访问定位</h2><p>在栈帧中通过<strong>reference</strong>来表示对象的指针,然后通过refernce查找对象的方式可以分为两种实现方案:</p><ol><li>直接通过指针来返回</li><li>通过句柄的方式来返回</li></ol><p>HotSpot是通过第二种方式来进行访问的,优点是**快,**缺点是在GC时需要修改栈帧中的reference数据</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.png?raw=true" alt="对象地址"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;内存布局设计&lt;/h1&gt;
&lt;p&gt;JVM的内存设计上是划分为两个大的区域的&lt;B&gt;启动时向操作系统分配的程序内存区域&lt;/B&gt;、&lt;B&gt;直接对系统内存进行操作的区域&lt;/B&gt;,后者不属于JVM管理,我们主要是分析前者&lt;/p&gt;
&lt;h2 id=&quot;大体结构&quot;&gt;&lt;a class=&quot;heade</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>多线程是否会影响执行效率</title>
    <link href="https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/"/>
    <id>https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/</id>
    <published>2022-11-15T14:50:30.000Z</published>
    <updated>2022-11-18T12:51:34.947Z</updated>
    
    <content type="html"><![CDATA[<h1>多线程是否会影响执行效率</h1><h2 id="前提"><a class="header-anchor" href="#前提"></a>前提</h2><p>今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的</p><blockquote><p>在同一机器/操作系统上,使用n个线程处理X个任务是不是和使用n*m个线程处理X个任务效率相同?</p></blockquote><p>这样的观点是基于<B>RR-时间片轮转</B>来进行推导的;我不太认同这种观点,直觉上认为参与处理的任务过多或过少都会影响执行效率;下面先进行这两种观点的推导然后在进行实际的验证</p><h2 id="时间片轮转"><a class="header-anchor" href="#时间片轮转"></a>时间片轮转</h2><p>假设前提:</p><ol><li>操作系统对进程的调度是采用的<B>时间片轮转</B>算法来进行处理的,时间片划分的大小为1s;</li><li>每个Task需要消耗单核CPU执行0.5s</li><li>不考虑线程上下文切换耗时</li></ol><p>根据以上的前提可以得出下面这个运行图例:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%201%20%E9%A1%B5.drawio.png?raw=true" alt="2Thread执行示例"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%202%20%E9%A1%B5.drawio.png?raw=true" alt="4Thread执行示例"></p><p>从上图中可以看到无论是2Thread来进行执行还是4Thread来进行执行对于任务的执行耗时其实都是没有任何影响的,因为这其实是1000个Task与2个执行core之间的关系;</p><p>这种说法正确的前提必须是满足<B>假设前提</B>中的3点</p><h2 id="线程过多过少都会影响执行效率"><a class="header-anchor" href="#线程过多过少都会影响执行效率"></a>线程过多过少都会影响执行效率</h2><p>这种观点主要是基于《Java并发编程实战》一书中的观点:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F.jpg?raw=true" alt="推算线程池大小"></p><p>N<sub>cpu</sub> ：指的是执行机器上的物理核心数,额外注意使用容器启动的核心数<br>U<sub>cpu</sub> ：指的期望的对CPU的使用率<br>W/C ：指的是等待时间与计算时间的比例,对于计算密集型与IO密集型这个值还有所区别</p><p>例子:</p><p>N<sub>Thread</sub> = 2 * 0.8 * (1 + 10/2) = 8</p><p>如果需要N<sub>Thread</sub>持续增长时需要<B>W/C</B>比例更大,这是不可能实现的,由于w/c是由于Task决定的;<br>以上是通过反证法的方式来解释提高N<sub>Thread</sub> 并不能增加并发执行效率的原因;</p><p>实际在运用过程中还需要注意<B>Amdahl定律</B>和线程引入造成的性能开销</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/amdahl%E5%AE%9A%E5%BE%8B.jpg?raw=true" alt="Amdahl定律"></p><p>Amdahl定律就是表达并发执行线程池数并不能提高效率,而是并发度提高才能提高执行效率</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%BC%95%E5%85%A5%E7%9A%84%E5%BC%80%E9%94%80.jpg?raw=true" alt="线程引入造成的性能开销"></p><p>频繁的线程切换会引起性能损耗</p><h2 id="实例分析"><a class="header-anchor" href="#实例分析"></a>实例分析</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecutorServiceUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> taskNum <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">LinkedBlockingQueue</span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span>taskNum <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">8192</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]正在执行... %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> st <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">extracted</span><span class="token punctuation">(</span>latch<span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> et <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]执行耗时[%s]ms %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> et <span class="token operator">-</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>            QUEUE<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">extracted</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> taskNum<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>latch<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> taskId<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>        <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">,</span> <span class="token keyword">int</span> taskId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> latch<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>taskId <span class="token operator">=</span> taskId<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> min<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">isPrime2</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPrime2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> sqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqrt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/jvmsource/blob/master/src/main/java/com/agmtopy/source/executer/ExecutorServiceUtil.java">ExecutorServiceUtil.java</a></p><p>这是一个循环求解0~10W之间的素数的程序,下面是分别在Windows/Linux上执行的结果</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux.jpg?raw=true" alt="Linux下的执行结果"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows.jpg?raw=true" alt="Windows下的执行结果"></p><p>操作系统的线程调度策略还是会影响性能的.Linux的线程调度要稍微比Windows的优秀一点点,下面使用<B>vmstat</B>和<B>pidstat</B>分析</p><ul><li>vmstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vmstat</span> -w <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vmstat.jpg?raw=true" alt="vmstat执行结果"></p><ul><li>pidstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pidstat -p /PID -wtu  <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pidstat.jpg?raw=true" alt="pidstat执行结果"></p><p>主要关心<B>cswch/s</B>和<B>nvcswch/s</B>、<B>in</B>和<B>cs</B>指标，表示的是<B>线程上下文切换</B>的一个频率,在线程不断的增加以后可以看到这几个指标在快速的向上增长<br>不管是从windows还是linux的一个执行结果来看，线程的增加都会导致程序的下降,但是这种下降并不是很明显，也许是得益于现代操作系统对线程切换的不断优化吧</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>一个线程池中核心线程数与最大线程数的数量是会受到多个方面因素共同影响的，例如<B>操作系统</B>、<B>物理核心逻辑线程</B> 以及任务类型(计算密集型/IO密集型)都有关系,因此在使用线程池时对于线程池的<B>6个</B>参数一定要有思考以后在进行创建相应的线程池;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/13834692/threads-configuration-based-on-no-of-cpu-cores/13958877#13958877">Threads configuration based on no. of CPU-cores</a><br><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a><br><a href="https://research.cs.wisc.edu/multifacet/amdahl/">Amdahl’s Law in the Multicore Era</a><br><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html">Linux vmstat命令实战详解</a><br><a href="https://timzhouyes.github.io/2020/04/29/Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/">Java常见的性能问题和排查</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;多线程是否会影响执行效率&lt;/h1&gt;
&lt;h2 id=&quot;前提&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;
&lt;p&gt;今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在同一机</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="多线程" scheme="https://agmtopy.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(三)</title>
    <link href="https://agmtopy.gitee.io/2022/11/14/20.%E7%AC%94%E8%AE%B0/22.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%89)/"/>
    <id>https://agmtopy.gitee.io/2022/11/14/20.%E7%AC%94%E8%AE%B0/22.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%89)/</id>
    <published>2022-11-14T15:50:10.000Z</published>
    <updated>2022-11-14T16:17:50.611Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(三)</h1><h2 id="Redis数据结构"><a class="header-anchor" href="#Redis数据结构"></a>Redis数据结构</h2><p>Redis的数据结构可以划分为下图所示:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.drawio.png?raw=true" alt="Redis的数据结构"></p><p>可以看到Redis底层采用的也是Map的方式来保存key以及value;</p><p>Redis主要的数据类型分为<B>String</B>、<B>list</B>、<B>set</B>、<B>map</B>、<B>sorted-set</B>等</p><p>下面会依次介绍这几种类型对象的底层实现原理</p><h2 id="String类型"><a class="header-anchor" href="#String类型"></a>String类型</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(三)&lt;/h1&gt;
&lt;h2 id=&quot;Redis数据结构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Redis数据结构&quot;&gt;&lt;/a&gt;Redis数据结构&lt;/h2&gt;
&lt;p&gt;Redis的数据结构可以划分为下图所示:&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TiDB数据库之简介</title>
    <link href="https://agmtopy.gitee.io/2022/11/05/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/41.TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <id>https://agmtopy.gitee.io/2022/11/05/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/41.TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%AE%80%E4%BB%8B/</id>
    <published>2022-11-05T07:30:55.000Z</published>
    <updated>2022-11-06T15:36:16.589Z</updated>
    
    <content type="html"><![CDATA[<h1>TiDB数据库之简介</h1><blockquote><p>TiDB 是 PingCAP 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processing, HTAP) 的融合型分布式数据库产品，具备水平扩容或者缩容、金融级高可用、实时 HTAP、云原生的分布式数据库、兼容 MySQL 5.7 协议和 MySQL 生态等重要特性。目标是为用户提供一站式 OLTP (Online Transactional Processing)、OLAP (Online Analytical Processing)、HTAP 解决方案。</p></blockquote><p>简单的说就是一款分布式数据库.</p><h2 id="五大特性"><a class="header-anchor" href="#五大特性"></a>五大特性</h2><ol><li><p>支持水平扩容或缩容<br>这一点在传统的RDBMS上不容易实现,传统的RDBMS通常是数据存储和计算没有进行分离的;</p></li><li><p>金融级高可用<br>采用<B> Multi-Raft 协议</B>来进行保证的</p></li><li><p>实时 HTAP<br>同时支持OLAP和OLTP处理</p></li><li><p>云原生的分布式数据库</p></li><li><p>兼容MySQL 5.7协议<br>支持MySQL协议这是一大优点</p></li></ol><h2 id="四大核心应用场景"><a class="header-anchor" href="#四大核心应用场景"></a>四大核心应用场景</h2><ol><li>对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高的金融行业属性的场景</li></ol><p>也就是适合需要高性能/高可用/高扩展性的场景</p><ol start="2"><li>对存储容量、可扩展性、并发要求较高的海量数据及高并发的 OLTP 场景</li></ol><blockquote><p>随着业务的高速发展，数据呈现爆炸性的增长，传统的单机数据库无法满足因数据爆炸性的增长对数据库的容量要求，可行方案是采用分库分表的中间件产品或者 NewSQL 数据库替代、采用高端的存储设备等，其中性价比最大的是 NewSQL 数据库，例如：TiDB。TiDB 采用计算、存储分离的架构，可对计算、存储分别进行扩容和缩容，计算最大支持 512 节点，每个节点最大支持 1000 并发，集群容量最大支持 PB 级别。</p></blockquote><ol start="3"><li><p>HTAP场景<br>一套数据库支持全部场景</p></li><li><p>OLAP场景<br>TiDB在实现上比ETL + Hadddoop简单和高效低本,并且可以直接用SQL实现分析统计功能</p></li></ol><h2 id="快速上手"><a class="header-anchor" href="#快速上手"></a>快速上手</h2><p>本次快速上手实验的环境主要是: WSL2+Ubunta</p><ol><li>下载安装脚本</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span class="token comment"># 下载完成后会展示安装脚本路径  'Shell profile:'后面的就是 $&#123;your_shell_profile&#125; 替换量</span><span class="token builtin class-name">source</span> <span class="token variable">$&#123;your_shell_profile&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_1.jpg?raw=true" alt="下载安装脚本"></p><ol start="2"><li>启动集群</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 默认TiDB、TiKV、PD 和 TiFlash 实例各一个</span>tiup playground<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_%E5%90%AF%E5%8A%A8.jpg?raw=true" alt="启动"></p><ol start="3"><li>TiDB的相关操作</li></ol><ul><li>连接TiDB</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用TiDB clinet</span>tiup client<span class="token comment"># 使用MySQL 协议</span>mysql --host <span class="token number">127.0</span>.0.1 --port <span class="token number">4000</span> -u root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_tidb%E5%8D%8F%E8%AE%AE%E7%99%BB%E9%99%86.jpg?raw=true" alt="TiDB clinet"></p><p>在使用MySQL客户端连接的时候,因为TiDB默认没有为root用户分配密码的,可以通过TiDB clint 登陆后使用<B>set password for root=‘123456’;</B>来修改密码</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_4_%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81.jpg?raw=true" alt="修改root 密码"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_5_%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.jpg?raw=true" alt="MySQL 协议连接成功"></p><ul><li>退出/清理</li></ul><ol><li><p>按下 Control+C 键停掉上述启用的 TiDB 服务。</p></li><li><p>等待服务退出操作完成后，执行以下命令：</p></li></ol><blockquote><p>tiup clean --all</p></blockquote><ul><li>管控平台/性能分析后台</li></ul><ol><li>dashboard</li></ol><p>可以看到TiDB的后台管理页面比较现代,支持各种功能包括<B>集群信息</B>、<B>慢SQL分析</B>、<B>日志查询</B>、<B>性能诊断</B>等</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_6_dashboard.jpg?raw=true" alt="dashboard"></p><h2 id="HTAP功能对比"><a class="header-anchor" href="#HTAP功能对比"></a>HTAP功能对比</h2><p>HTAOP功能就是在线分析功能,在传统的数据库使用过程中通常会伴随着这样的使用场景,下面用<B>TiFlash</B>和MySQL之间来对比</p><h3 id="准备数据"><a class="header-anchor" href="#准备数据"></a>准备数据</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用以下命令安装数据生成工具</span>tiup <span class="token function">install</span> bench<span class="token comment"># 使用以下命令生成数据</span>tiup bench tpch --sf<span class="token operator">=</span><span class="token number">1</span> prepare<span class="token operator">!</span><span class="token punctuation">[</span>准备数据<span class="token punctuation">]</span><span class="token punctuation">(</span>https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_1.jpg?raw<span class="token operator">=</span>true<span class="token punctuation">)</span><span class="token comment"># 运行以下 SQL 语句查看生成的数据量</span>SELECT CONCAT<span class="token punctuation">(</span>table_schema,<span class="token string">'.'</span>,table_name<span class="token punctuation">)</span> AS <span class="token string">'Table Name'</span>, table_rows AS <span class="token string">'Number of Rows'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">(</span>data_length/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS <span class="token string">'Data Size'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">(</span>index_length/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS <span class="token string">'Index Size'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">((</span>data_length+index_length<span class="token punctuation">)</span>/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS<span class="token string">'Total'</span>FROM information_schema.TABLES WHERE table_schema LIKE <span class="token string">'test'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_2_%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B1%95%E7%A4%BA.jpg?raw=true" alt="数据行数"></p><h3 id="执行SQL"><a class="header-anchor" href="#执行SQL"></a>执行SQL</h3><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT    l_orderkey,    SUM(        l_extendedprice * (1 - l_discount)    ) AS revenue,    o_orderdate,    o_shippriorityFROM    customer,    orders,    lineitemWHERE    c_mktsegment &#x3D; &#39;BUILDING&#39;AND c_custkey &#x3D; o_custkeyAND l_orderkey &#x3D; o_orderkeyAND o_orderdate &lt; DATE &#39;1996-01-01&#39;AND l_shipdate &gt; DATE &#39;1996-02-01&#39;GROUP BY    l_orderkey,    o_orderdate,    o_shippriorityORDER BY    revenue DESC,    o_orderdatelimit 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="同步列存数据"><a class="header-anchor" href="#同步列存数据"></a>同步列存数据</h3><p>TiFlash 部署完成后并不会自动同步 TiKV 数据，你可以在 MySQL 客户端向 TiDB 发送以下 DDL 命令指定需要同步到 TiFlash 的表。指定后，TiDB 将创建对应的 TiFlash 副本。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE test.customer SET TIFLASH REPLICA 1;ALTER TABLE test.orders SET TIFLASH REPLICA 1;ALTER TABLE test.lineitem SET TIFLASH REPLICA 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="分析对比性能差异"><a class="header-anchor" href="#分析对比性能差异"></a>分析对比性能差异</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_%E4%B8%8D%E4%BD%BF%E7%94%A8TiFlash.jpg?raw=true" alt="传统关系数据引擎"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_%E4%BD%BF%E7%94%A8TiFlash.jpg?raw=true" alt="TiFlash引擎"></p><p>可以看到TiFlash执行的耗时非常的少</p><h2 id="SQL-基本操作"><a class="header-anchor" href="#SQL-基本操作"></a>SQL 基本操作</h2><h2 id="SQL-基本操作-v2"><a class="header-anchor" href="#SQL-基本操作-v2"></a>SQL 基本操作</h2><p>TODO</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.pingcap.com/zh/tidb/dev/quick-start-with-tidb#%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4">TiDB官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;TiDB数据库之简介&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;TiDB 是 PingCAP 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processin</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="TiDB" scheme="https://agmtopy.gitee.io/tags/TiDB/"/>
    
  </entry>
  
  <entry>
    <title>git workflow的几种最佳实践方式</title>
    <link href="https://agmtopy.gitee.io/2022/10/29/1.%E6%9D%82%E8%AE%B0/git-workflow%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%B9%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2022/10/29/1.%E6%9D%82%E8%AE%B0/git-workflow%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%B9%E5%BC%8F/</id>
    <published>2022-10-29T02:54:10.000Z</published>
    <updated>2022-10-30T17:34:20.744Z</updated>
    
    <content type="html"><![CDATA[<h1>git workflow的几种最佳实践方式</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>现有的版本控制系统大多选择使用Git来进行管理/协作;不同的团队有会根据各自的情况选择不同的协助方式,常见的<B>git workflow</B>主要分为三种:</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow<br>常见的分支模式也可以大致划分为两种:</li><li>主干分支模式</li><li>特性分支模式</li></ul><p>下面就先介绍特性分支模式下的三种 Git WorkFlow特点与优劣;</p><h2 id="Git-flow"><a class="header-anchor" href="#Git-flow"></a>Git flow</h2><blockquote><p><B>Git flow</B>最早是由Vincent Driessen在2010年左右提出来的<B><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">《一个成功的 Git 分支模型》</a></B>一文中介绍他自己的分支管理模式;主要核心思想就是会存在两类分支:</p></blockquote><ul><li><p>长期分支:</p><ul><li><B>master</B></li><li><B>develop</B></li></ul></li><li><p>临时分支:</p><ul><li><B>hotfixs branch</B></li><li><B>release branch</B></li><li><B>feature branch</B></li></ul></li></ul><p>长期分支是一直存在的,临时分支只是会存在与一个迭代或一次hotfix的过程中,他们之间的关系如下所示:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/git_flow.png?raw=true" alt="git flow "></p><p>也可以看下面这个简化的git flow流程<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/git-flow%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png?raw=true" alt="git flow "></p><p>可以从上面两个图中看到开发者其实是站着<B>develop branch</B>一侧的,feature branch分支通常存在于本地,开发完成后执行<B>merge request(MR)</B>合并到<B>develop branch</B>(通常使用的是git merge --no–ff feature-branch的方式);同时发布分支(release branch)是从develop branch上切出来的,测试通过后mr到master中;</p><p>git flow中进行code review的判定点:</p><ul><li>尝试从私有分支合并代码到公有分支(develop, release/<em>, hotfix/</em>, master)中时</li></ul><p>例如从feature branch -&gt; develop branch,hotfixs branch -&gt; master/develop时是需要进行code review;<br>从develop -&gt; master时是不需要进行code review的;</p><h3 id="优点"><a class="header-anchor" href="#优点"></a>优点</h3><ul><li><p>严谨的合并流程<br>所有进入公共分支的代码都需要进行审核,确保代码问题;这样的合并流程适用于已有的成熟项目开发流程,可以尽量在前置协作过程中发现避免问题;</p></li><li><p>适用于开源项目(曾经)<br>各个贡献者都是在各自的repository(存储库)中工作,需要提出PR经过审核后才能提交代码到主库中</p></li></ul><h3 id="缺点"><a class="header-anchor" href="#缺点"></a>缺点</h3><ul><li><p>繁琐<br>在开发过程中,会持续维护两个长期分支<B>develop</B>和<B>master</B>,并且这两个分支的实际含义还有所重合(develop-拥有不稳定的全部代码的分支/master-拥有全部稳定代码的分支);</p></li><li><p>持续交付困难<br>所有的功能开发必须是在一个周期或多个周期内完成,造成master中的代码不是最新的,因此很难进行CD;也有基于git flow开进行CD的方案,但是有点舍本求末的感觉在里面了,CI/CD应该是在’每个人每天都致力于master上工作’的前提</p></li></ul><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>git flow的开发模式过于繁琐来保证较高的代码质量,需要去维护多个长期分支;繁琐也是相对于下面两种模式而言的;git flow的作者目前也是建议大家基于团队/项目来选择和更简单的GitHub flow;</p><h2 id="GitHub-flow"><a class="header-anchor" href="#GitHub-flow"></a>GitHub flow</h2><p>GitHub flow最早是由GitHub的技术经理scott chacon提出来的<a href="http://scottchacon.com/2011/08/31/github-flow.html">GitHub Flow</a>,是基于Github内部使用Git工作的一种流程;</p><blockquote><p>GitHub flow主要有以下几个特征:<br>- master branch中的代码是在任何时候都是可以进行部署的<br>- 功能分支名称需要用描述功能特性来进行命名的<br>- 即时将本地代码push/pull到服务器上<br>- 使用PR来进行协作(反馈/帮助/合并)<br>- 完成master合并后立即部署</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/github%20flow.jpg?raw=true" alt="github flow"></p><p>这是一个简易的GitHub flow的流程,可以看到所有去请求在进行审核之后都会被合并到Master分支中;<br>在实践中GitHub flow是一个一直向前的流程,对于master分支几乎不会进行回滚操作(通过新的提交抵消错误需要进行回滚的合并)</p><h3 id="优点-v2"><a class="header-anchor" href="#优点-v2"></a>优点</h3><ul><li><p>分支模型简单<br>这个分支模型简单是相对于Git flow来说的,只用维护一个长期分支<B>master</B>,利于后续的CI/CD</p></li><li><p>PR<br>这个是GitHub flow的一个创新,PR不止是合并代码而是一种协作方式,可以进行评论/审查/帮助,这个是跨地域进行大规模协作的基础,改变了以前通过邮件的方式;</p></li><li><p>可以最大限度减少未发布代码的数量<br>master branch 在合并代码后就会进入持续交付阶段,这样会最大限度的降低未发布代码的数量</p></li></ul><h3 id="缺点-v2"><a class="header-anchor" href="#缺点-v2"></a>缺点</h3><ul><li><p>无法应对版本的延迟发布<br>在实际开发工作中,持续交付不一定能实现,毕竟大多数技术开发还是以业务为导向的;</p></li><li><p>无法处理多版本交付<br>开发环境/测试环境/预发环境甚至生产多版本部署的场景</p></li></ul><h3 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h3><p>GitHub flow在简化Git flow的基础上支持开源软件的开发模式,但是自身也有一些问题.</p><h2 id="GitLab-flow"><a class="header-anchor" href="#GitLab-flow"></a>GitLab flow</h2><p>GitLab flow是由极狐公司提出在<B><a href="https://docs.gitlab.cn/jh/topics/gitlab_flow.html">GitLab Flow介绍</a></B>一文实践的分支管理方式;</p><p>GitLab flow的设计遵寻两个原则:</p><ul><li>单一主分支</li></ul><blockquote><p>单一主分支原则与GitHub Flow所保留的Master分支一致</p></blockquote><ul><li>上游优先</li></ul><blockquote><p>上游优先原则指的是只存在一个主分支master,它是所有其他分支的<B>上游</B>.只有上游分支采纳的代码变化,才能应用到其他分支。对于<B>持续发布</B>的项目，它建议在master分支以外，再建立不同的环境分支。比如,<B>开发环境</B>的分支是master,<B>预发环境</B>的分支是pre-* ,<B>生产环境</B>的分支是pro-*;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%201.png?raw=true" alt="上游优先流程"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%202.png?raw=true" alt="生产分支的切出"></p><p>从上述的流程中可以看到GitLab flow在分支上选择是多分支的管理方式,但是是一种基于<B>上游优先</B>策略下的多分支管理方式,并不是像Git flow那样同时维护多个长期分支,对于后续的发布分支流程,GitLab采用的也是从Master branch中切分支或者打tag的方式:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%203.jpg?raw=true" alt="GitLab 发布分支"></p><p>在GitLab的实践中,通常<B>Master branch</B>都是受保护的,这样大部分开发者不能对其进行直接修改;<br>其中在他们的实践中也认可践行(PR/MR)的协助方式,分支的命名也是采用的功能命名的方式,合并后立即删除,以便其他人重新开始这个功能的议题;issues是工作的开始,MR是工作的结束;</p><h3 id="优点-v3"><a class="header-anchor" href="#优点-v3"></a>优点</h3><ul><li><p>支持多版本部署<br>支持pre-* /pro-*的多分支部署方式</p></li><li><p>可以支持延迟发布<br>开发分支和发布分支可以并行</p></li></ul><h2 id="小结-v3"><a class="header-anchor" href="#小结-v3"></a>小结</h2><p>由于GitLab flow出现的时间比git flow/gitlab flow都要晚一些,因此吸收了这两种风格的特点(支持多分支/PR模式);<br>大多数开发模式都是让代码审查通过后直接进入Master branch,因为这样可以尽早的解决冲突;</p><p>以上三种代码分支的管理方式都是基于<B>功能开发</B>(先有需求驱动的开发模式),并不是GitLab flow就一定比Git flow要更好,只有更适合的,下面介绍三种简单的区分方式仅供参考:</p><ul><li>工作中会使用到多个版本 -&gt; Git flow</li></ul><blockquote><p>如果代码库在工作中有多个版本(即典型的软件产品,如操作系统、Office 软件包、自定义应用程序等);可以使用git-flow,主要原因是在开发下一个版本的同时,需要在生产中持续支持以前的版本,并且有一个较长的迭代周期;</p></blockquote><ul><li>工作中只会使用到一个版本 -&gt; GitHub flow</li></ul><blockquote><p>如果代码库始终只有一个生产版本（即网站、Web 服务等），可以使用 github flow。主要原因是您不需要为开发人员复杂的事情。一旦开发人员完成一项功能或完成错误修复，它就会立即升级为生产版本。</p></blockquote><ul><li>生产中的单一版本但非常复杂的软件 -&gt; Gitlab-flow</li></ul><blockquote><p>在商业大型软件或者是以提供服务的项目上，在生产中可能需要在您的分支和主分支之间来回部署,并且在不同版本都需要进行CI/CD。推荐就使用Gitlab-flow</p></blockquote><h2 id="基于主干的开发模式"><a class="header-anchor" href="#基于主干的开发模式"></a>基于主干的开发模式</h2><p>在基于主干的开发模式中,所有开发人员都在一个开放的分支上进行工作。一般是使用master分支.他们直接向Master提交代码并运行;开发人员会创建短暂的功能分支。一旦他们分支上的代码编译并通过所有测试，他们就会直接将其合并到master. 确保开发是真正连续的，并防止开发人员创建难以解决的合并冲突;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/%E5%9F%BA%E4%BA%8E%E4%B8%BB%E5%B9%B2%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png?raw=true" alt="基于主干开发流程"></p><p>可以看到<B>基于主干的开发流程</B>非常的简单,任何人都可以直接向Master branch 合并代码,能够做到快速交付/迭代;缺点是没有人来进行功能性code review,只能进行完整的源代码检查(这是一种灾难😰);</p><p>基于主干的开发模式适用于:<B>项目开始的早期</B>、<B>拥有的都是老手</B>(😖)或者是<B>基础架构强/持续集成工具集成度高/TDD和自动化测试覆盖完善场景</B>下;</p><p>其实还有其他的开发模式例如<B>集中式</B>、<B>Forking</B>等工作流程,有兴趣的可以了解一下;</p><h2 id="使用Git的几个约定"><a class="header-anchor" href="#使用Git的几个约定"></a>使用Git的几个约定</h2><p>在使用Git过程中,其实每个团队的风格不同,都有一些比较好的值得借鉴的地方,以下可能是我自己的一个使用习惯</p><ol><li><p><B>使用rebase -i整理需要提交的commit</B><br>每次大功能向master/develop等公开分支提交时,会首先将同一需求的多个commit压缩合并成为一个有具体含义的commit后在发起PR;这样做的原因是基于我认为提交的MR应该是一个完整的功能/补丁/操作的log,可以让之后进行阅读的人知道这一行代码是为那个需求/修复而写的,而不应该是一个需求中的一个小点添加的;第二点是便于回滚/Cherry-pick,一个commit的操作要比多个commit的操作更简单;</p></li><li><p><B>基于最新的共享分支进行MR</B><br>这一点是基于Code review来说的,基于过时的分支合并到共享分支中是会夹杂大量代码差异,不利于code review的进行;对于rebase的使用,坚持一个原则<B>私有分支操作使用rebase,共享分支操作使用merge</B></p></li><li><p><B>使用stash</B><br>暂存区配合分支切换可以较好的完成,工作区的分支切换/代码存储合并的动作</p></li></ol><h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2><ul><li><p>Code Review如何让每一个人参与其中?</p></li><li><p>CI耗时过程问题以及是否需要进行CI?</p></li></ul><blockquote><p>需要,非常需要;gradle cache;</p></blockquote><ul><li>代码文件冲突/合并的问题?</li></ul><blockquote><p>产生的原因是与长期分支脱节、需求划分的不合理、没有及时的协作解决冲突等等</p></blockquote><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.gitlab.cn/jh/topics/gitlab_flow.html">GitLab Flow 介绍</a><br><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a><br><a href="https://nvie.com/posts/a-successful-git-branching-model/">一个成功的Git分支模式</a><br><a href="http://dockone.io/article/2350">gitLab Flow的11条建议</a><br><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">atlassian Bitbucket</a><br><a href="https://about.gitlab.com/topics/version-control/what-is-git-workflow/">what-is-git-workflow</a><br><a href="https://www.toptal.com/software/trunk-based-development-git-flow">trunk based developmentgit flow</a><br><a href="https://medium.com/burdaforward/state-of-ci-cd-and-the-dreaded-git-flow-fce92d04fb07">State of CI/CD and the omnipresent git flow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;git workflow的几种最佳实践方式&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;现有的版本控制系统大多选择使用Git来进行管理/协作;不同的团队有会根据各自的情况选择不同的</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://agmtopy.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库系统原理</title>
    <link href="https://agmtopy.gitee.io/2022/09/27/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/31.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>https://agmtopy.gitee.io/2022/09/27/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/31.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2022-09-27T15:11:06.000Z</published>
    <updated>2022-11-05T07:31:16.606Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式数据库系统原理</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><blockquote><p>为什么需要分布式?</p></blockquote><ul><li><B>处理逻辑</B></li><li><B>功能</B></li><li><B>数据</B></li><li><B>控制</B></li></ul><p>对于这个的理解应该是:</p><ul><li>处理逻辑:对应应用实例或者算法之类的,单点无法满足某些需求(AP)</li><li>功能:对于功能的分布式划分主要是体现在微服务的拆分上,不同的功能拆分成为不同的服务</li><li>数据:对于数据的拆分主要是单点数据服务无法满足要求的情况下,进行拆库拆表</li><li>控制:<font color="#dddd00">这个暂时不能理解?控制是否为程序或者算法的同义楠?</font></li></ul><blockquote><p>什么是分布式数据库?<br>物理上分布不同地方,通过计算机网络逻辑上相互关联的数据库</p></blockquote><h3 id="主要的问题"><a class="header-anchor" href="#主要的问题"></a>主要的问题</h3><ul><li>数据如何选择分片?</li><li>分布式事务的实现?</li><li>性能问题?</li></ul><p>如下图:</p><p><img src="https://raw.githubusercontent.com/agmtopy/noteBook/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.jpg" alt="分布式数据问题之间的联系"></p><h3 id="集中式数据库模型与分布式数据库模型"><a class="header-anchor" href="#集中式数据库模型与分布式数据库模型"></a>集中式数据库模型与分布式数据库模型</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E9%9B%86%E4%B8%AD%E5%BC%8FDBMS%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.jpg?raw=true" alt="集中式DBMS分层架构"></p><p>可以看到集中式数据库就是一个标准的应用分层,以MySql为例</p><p>界面: 提供不同语音的MySql Drive<br>控制: 连接校验<br>编译: sql解析<br>执行: innodb存储引擎处理<br>数据访问:MySql内核处理<br>一致性: 各种Lock和log</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpg?raw=true" alt="分布式数据库结构"></p><p>可以看到分布式数据库系统需要从三个不同的方面进行考虑:<B>物理分布</B>&lt;B&gt;异构性</B>&lt;B&gt;自治性</B></p><ul><li>物理分布:指的是组成分布式系统的服务可以在物理上隔离,可以不需要在通一台硬件机器上运行</li><li>异构性:指的是各个服务允许使用各自的协议来提供服务,这一点在工业级的分布式数据库上应该没有实现,还是遵守相同协议来降低软件复杂度</li><li>自洽性:各个服务本身就可以单独对外提供服务,不用依赖其他系统,这一点常用的分布式系统较为不同</li></ul><h3 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h3><ul><li>DBMS</li></ul><blockquote><p>DBMS-关系数据库的概念是一组结构化的数据,它是出于我们对现实世界建模的映射,一个关系数据库是以表格形式表达数据的数据库.</p></blockquote><h2 id="分布式数据库设计"><a class="header-anchor" href="#分布式数据库设计"></a>分布式数据库设计</h2><p>有两种分布式数据库的设计方法:<B>自顶向下的方法</B>和<B>自底向上的方法</B>,这也是软件领域设计的两种通用设计方法,例如我们在设计系统的时候基于底层功能实现还是上层战略定位来进行的往往会得到不同的演进路线;</p><ul><li>自顶向下:指的是在设计的时候就考虑不同的实例去支持局部的全局概念模型</li><li>自底向上:指的是将多个数据库中的信息集成为一个紧密相连的多数据库系统,常用于<B>数据仓库/数据湖</B></li></ul><h3 id="分布设计的研究问题"><a class="header-anchor" href="#分布设计的研究问题"></a>分布设计的研究问题</h3><ul><li>如何得到正确的分片结果?<br>首先,数据分片有两种维度来进行,一种是垂直分片按照业务领域进行划分,一种是水平进行分片按照特定规则来进行划分;我们会重点研究采用水平模式的设计方案.</li></ul><p>专业的分布式数据库的数据划分好复杂,会去考虑数据的分片是按照某些条件来进行的,既要保证数据的分片又要保证数据的’亲和性’;一大段一大段的高阶函数~😳😳😳</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式数据库系统原理&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要分布式?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;B&gt;处理逻辑</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-内存管理篇</title>
    <link href="https://agmtopy.gitee.io/2022/09/24/20.%E7%AC%94%E8%AE%B0/12.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/09/24/20.%E7%AC%94%E8%AE%B0/12.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/</id>
    <published>2022-09-24T09:09:44.000Z</published>
    <updated>2022-09-25T14:22:14.661Z</updated>
    
    <content type="html"><![CDATA[<h1>现代操作系统原理与实现-内存管理篇</h1><p>一晃而过距离上一篇<B>硬件结构</B>已经过去了一个月有余了.最近一直在整理<B>Notion</B>上的笔记,把《深入理解Java虚拟机》的相关笔记也在notion上写和整理去了,对《现代操作系统原理与实现》的笔记也耽搁了许久;这本书应该是本年度最佳书籍了,会争取在今年把第一遍阅读的相关笔记完成,时间过的真的很快,跑题感慨了一下,下面继续有关内存部分的整理和理解吧!</p><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>在上一章中了解到物理内存是组成操作系统的重要部分,这一章节就是介绍操作系统是如何管理和使用内存的;</p><h3 id="内存管理"><a class="header-anchor" href="#内存管理"></a>内存管理</h3><p>内存管理主要是对物理内存的管理,在早期程序是直接分配在物理内存上运行的,那个时候操作系统都不存在,这样分配会产生几个问题例如程序直接操作物理内存无法做到隔离/分配内存空间的碎片化/无法处理超过物理容量限制的分配</p><p>针对这个些问题,提出了<B>虚拟内存</B>的概念,大概是在1956年的一位德国物理学家提出的,感觉这个时间过了好久了啊,但是在翻阅资料查这些的时候发现计算机的发明居然还没有80年,太不可思议了</p><p><img src="http://www.isolves.com/d/file/p/2020/03-17/bbd1470ef6879e2f6e4847b7444fde35.jpg" alt="虚拟内存技术发展时间线"></p><h4 id="虚拟内存"><a class="header-anchor" href="#虚拟内存"></a>虚拟内存</h4><blockquote><p>虚拟内存作为物理内存和应用程序之间的一个抽象层;应用程序不在直接运行在物理内存之上,而是运行在虚拟内存之上;应用程序在运行时只知道虚拟内存地址,cpu或者硬件负责将虚拟地址转换为物理地址,操作系统负责设置虚拟地址与物理地址之间的映射;每个应用程序只能看到属于自己的虚拟内存地址,并且看到的虚拟内存地址是同一的、连续的;</p></blockquote><ul><li>虚拟内存的结构<br>下面是一张有关CPU如何将虚拟地址转换为物理地址的图:</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/x-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/CPU%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio.png?raw=true" alt="CPU虚拟地址翻译示意图"></p><p>可以看到操作系统向CPU发生虚拟地址访问请求后,传给MMU在通过TLB转换后,将物理地址发送给操作总线,从而访问到物理内存地址;</p><p>现代操作系统都是通过分页的形式采用页表来实现的,<B>TLB</B>缓存了虚拟页号到物理页号之间的映射关系,TLB的设计非常简单就是做映射,但是却十分的高效,因为在内存数据的访问遵守<B>时空局部性原理</B></p><ul><li>虚拟内存中的换页</li></ul><p>在前面说到物理内存无法自动处理分配超过实际容量限制的场景.而虚拟内存可以做到,就是通过换页机制来实现的,具体流程如下:</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/143273007">操作系统之内存管理</a><br><a href="https://ewikizh.top/wiki/Virtual_memory#cite_note-10">虚拟内存</a><br><a href="https://www.isolves.com/it/rj/jy/2020-03-17/14226.html">虚拟内存技术的前世今生</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;现代操作系统原理与实现-内存管理篇&lt;/h1&gt;
&lt;p&gt;一晃而过距离上一篇&lt;B&gt;硬件结构&lt;/B&gt;已经过去了一个月有余了.最近一直在整理&lt;B&gt;Notion&lt;/B&gt;上的笔记,把《深入理解Java虚拟机》的相关笔记也在notion上写和整理去了,对《现代操作系统原理与实现》的笔记也</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-硬件结构篇</title>
    <link href="https://agmtopy.gitee.io/2022/08/14/20.%E7%AC%94%E8%AE%B0/11.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/08/14/20.%E7%AC%94%E8%AE%B0/11.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2022-08-14T06:39:04.000Z</published>
    <updated>2022-09-24T09:10:19.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>操作系统是建立在硬件结构基础上的软件实现,这一章节我们来介绍计算机的硬件结构.</p><h2 id="CPU与指令集架构"><a class="header-anchor" href="#CPU与指令集架构"></a>CPU与指令集架构</h2><blockquote><p>指令集架构是cpu与软件之间的桥梁,包括指令集\特权级\寄存器\执行模式\安全扩展\性能加速等等</p></blockquote><h3 id="指令集"><a class="header-anchor" href="#指令集"></a>指令集</h3><p>指令集包括<B>精简指令集(RISC)</B>和<B>复杂指令集(CISC)</B>两种.</p><ul><li><p>精简指令集<br>指的是没有寄存器的指令集,通过指令来模拟寄存器的操作,常见的安卓和苹果的A系/M系芯片都是使用的这种指令集</p></li><li><p>复杂指令集<br>指的是有寄存器的指令集,通过使用寄存器来执行指令,常见的Intel的X86芯片都是使用的这种指令集</p></li></ul><p>目前在生产中并没有严格隔离指令集,CISC也在集成RISC的相关指令</p><p>常用的指令类型分为4种:</p><ul><li>数据搬移指令(mov等)</li><li>寄存器计算指令(add/sub等)</li><li>内存读写指令(ldr-加载/str-读写等)</li><li>调整指令(b)</li><li>过程调用指令(bl/ret)</li><li>特权指令(mrs/msr)</li></ul><h2 id="特权级"><a class="header-anchor" href="#特权级"></a>特权级</h2><p>指的是指令运行的级别,分别是El0,El1,El2,El3</p><ul><li><p>El0<br>指的是最低特权级,应用程序通常运行在这一级别上,也可以称为<B>用户态</B></p></li><li><p>EL1<br>操作系统通常运行在这一级别上,也称为<B>内核态</B></p></li><li><p>El2<br>指的是次高特权级,操作系统通常运行在这一级别上,也称为<B>高级内核态</B>,通常虚拟机监控器需要运行在这一状态</p></li><li><p>El3<br>负责普通世界与安全世界的切换,安全世界是<B>AArch64</B>提出来的一个管理硬件交互的级别,EL3在级别上是最高的,因为可以直接操作硬件</p></li></ul><blockquote><p>EL0 &lt; EL1 &lt; EL3 &lt; EL3</p></blockquote><p>程序在运行过程中大量的发生EL0 &lt;=&gt; EL1转换,其实就是用户进程与内核进程在不断的进行切换的过程;这里需要注意一点的是<B>中断</B>是运行在EL1级别上的</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2.jpg?raw=true" alt="中断切换"></p><h2 id="寄存器"><a class="header-anchor" href="#寄存器"></a>寄存器</h2><p>寄存器是指令集中的一种数据结构,用于存储数据,比如寄存器中存储的是指令的地址,寄存器中存储的是指令的参数等等.它们是cpu的基本架构组成部分,参与指令的执行和计算过程.现代CPU往往会使用大量专用的寄存器来做专业的事情,比如帧指针寄存器,连接寄存器等</p><h2 id="物理内存与CPU缓存"><a class="header-anchor" href="#物理内存与CPU缓存"></a>物理内存与CPU缓存</h2><ul><li>物理缓存</li></ul><blockquote><p>CPU在执行的过程中,可以通过访存指令不断的向物理内存中读写数据;CPU使用物理内存的方式很简单:通过<B>总线</B>向物理内存发生一个读写请求,其中包括目标地址,物理内存在接收到请求后,会根据请求的类型进行读写操作,并返回相应的结果</p></blockquote><p>通过以上的描述可以得知CPU在进行执行时都是通过总线与内存进行交互\cpu从内存中取值后会放到私有的区域(CPU缓存)中,其实这样的设计也加大了应用人员开发出健壮/正确的并发代码难度,在编写并发相关代码时一定要仔细</p><ul><li>CPU缓存</li></ul><blockquote><p>CPU缓存是一个私有的区域,用于存储CPU执行过程中的数据;由若干个<B>缓存行</B>组成.每个缓存行包含:一个<B>有序位标识</B>标识数据是否有效和一个<B>标记地址</B>用于标记其对应的物理地址;</p></blockquote><blockquote><p>CPU以缓存行(常见的是64bit大小)为单位把物理内存读取到缓存中,也就是说如果只需要一个bit的数据,但是还是需要把该字节对应的缓存行数据全部读取到缓存中,写入反之亦然也是每次需要写出64bit大小的数据</p></blockquote><p>对于CPU缓存行最熟悉的一个作用是<B>禁止指令重排</B>,在java中我们知道valitate的一个作用是可见性,就是根据基于缓存行的<B>缓存一致性协议-MESI协议</B>来实现的</p><p>volatile的另外一个作用是可以解决编译器层面的可见性与重排序问题。而内存屏障则解决了硬件层面的可见性与重排序问题</p><h2 id="设备与中端"><a class="header-anchor" href="#设备与中端"></a>设备与中端</h2><p>常见的设备指的是输入与输出设备,常见的内存映射输入输出设备,常见的中断设备,比如硬盘,光驱,键盘,鼠标等</p><p><B>中断</B>机制是提供设备主动通知CPU的能力.设备通过向CPU发送中断来打断CPU的执行.</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>本章主要介绍<B>精简指令集</B>&lt;B&gt;特权级</B>&lt;B&gt;寄存器</B>&lt;B&gt;内存与缓存</B>等硬件基本结构<br>多核CPU缓存的设计遵守<B>缓存一致性协议</B>这个是valotail可见性的基础</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/MrLiuZF/p/15054855.html">CPU缓存</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;操作系统是建立在硬件结构基础上的软件实现,这一章节我们来介绍计算机的硬件结构.&lt;/p&gt;
&lt;h2 id=&quot;CPU与指令集架构&quot;&gt;&lt;a class=&quot;head</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(一)</title>
    <link href="https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%80)/</id>
    <published>2022-08-08T15:45:00.000Z</published>
    <updated>2022-11-14T15:51:04.370Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(一)</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>是《深入分布式缓存-从原理到实践》一书的一些记录</p><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><blockquote><p>cache这个词,据说来自于法语,本意是当CPU处理数据时先到cache中去寻找,如果数据在之前的操作与i就读取而被暂存其中,就不需要从主内存中去读取了.后来cache的范围有所扩展,泛指凡是位于速度相差比较大的两种硬件之间,用于协调两者数据传输差异的结构,都称为cache.</p></blockquote><p>凡是通过两种查询速度较大的方式来查询同一对象都称为cache</p><blockquote><p>缓存:存储在计算机上的一个原始数据复制集,以便用于访问   -wiki</p></blockquote><p>常见的一些缓存:</p><ul><li>CPU多级缓存</li><li>TLB(Translation lookaside buffer) -最新的虚拟内存-&gt;物理内存的转换</li></ul><p>缓存分类:</p><ul><li>按缓存位置划分<ul><li>客户端缓存</li><li>服务器端缓存</li><li>网络中的缓存</li></ul></li><li>按部署方式划分<ul><li>单体缓存</li><li>集群缓存</li><li>分布式缓存</li></ul></li></ul><h3 id="网络中的缓存"><a class="header-anchor" href="#网络中的缓存"></a>网络中的缓存</h3><ul><li>web代理缓存</li></ul><p>使用正向代理的方式将web服务器上的数据进行缓存,客户端请求后之间返回不需要重新先web服务器请求</p><ul><li>边缘缓存</li></ul><p>边缘缓存是通过反向代理的方式与用户处于同一网络,向用户提供静态内容的缓存,典型应用就是CDN缓存</p><h3 id="缓存算法"><a class="header-anchor" href="#缓存算法"></a>缓存算法</h3><p>LRU:最近最少使用算法<br>LFU:最少使用算法(会统计一段时间内每个缓存的访问次数)<br>SIZE:缓存大小算法(按照缓存的大小进行算法)</p><h2 id="分布式系统理论"><a class="header-anchor" href="#分布式系统理论"></a>分布式系统理论</h2><ul><li>并向与并发</li></ul><blockquote><p>并发指的是两个事情或多个事情在同一个时间段内间隔发生;并行指的是两个事情或多个事情在同一个时刻同时发生;</p></blockquote><ul><li>CAP</li></ul><blockquote><p>CAP理论提出一致性\可用性\分区容错性的取舍问题</p></blockquote><p>一致性©:指的是在同一时刻访问所有节点得到的数据相同<br>可用性(U):指的是在同一时刻访问所有节点得到的数据都可用<br>分区容错性§:指的是节点一定会发生故障,但是不会影响整个系统的正常运行</p><h3 id="分布式系统设计策略"><a class="header-anchor" href="#分布式系统设计策略"></a>分布式系统设计策略</h3><p>分布式系统设计策略指的是对于设计分布式系统常见的几个问题的处理策略:</p><ul><li>如何检测你还活着?</li><li>如何保障高可用?</li><li>容错机制的设计?</li><li>重试机制?</li><li>负载均衡?</li></ul><p>下面详细对每一个问题进行解答:</p><h4 id="如何检测你还活着"><a class="header-anchor" href="#如何检测你还活着"></a>如何检测你还活着?</h4><p>在分布式系统中如何检测当前节点是否存活?<br>在大多数分布式中间件中都是通过<B>心跳检测</B>的机制来检测当前节点是否存活的,例如在zk的client与server之间的心跳检测保持连接\redis哨兵架构中的哨兵与master/slave之间的心跳检测</p><p><B>φ-accrual 故障检测器</B>是通过滑动窗口的时间算法来统计结果</p><p><B>Gossip分发</B>(流言算法)通过消息的传递确定节点是否应该停止服务的算法</p><p>小结:<br>存活检测有两个方法:一个是从通信链路入手检测目标节点的网络是否异常\一种是通过检测当前状态是否符合预期状态来检测目标节点是否存活</p><h4 id="如何保障高可用"><a class="header-anchor" href="#如何保障高可用"></a>如何保障高可用?</h4><p>在分布式系统中保障高可用的核心就是数据备份,通过多个节点的备份来在任何节点故障的情况下提供服务<br>按照提供服务的节点时机可以分为<B>主备(Master/Slave)</B>&lt;B&gt;互备(Failover)</B>&lt;B&gt;集群(Cluster)</B>这三种方式</p><ul><li><p>主备(Master/Slave)模式<br>主备模式多用于要求严格提供C(一致性)\A(可用性)的场景中,MySQL的主备模式\Redis的哨兵模式</p></li><li><p>互备(Failover)模式<br>互备模式指的是各个节点提供的数据和服务是相同的,常见的RocketMQ的注册中心NameServer就是多个节点提供相同的服务</p></li><li><p>集群(Cluster)模式<br>集群模式指的是服务在多个节点运行,不同的节点运行不同的任务,比如Redis的集群模式;集群模式与主备模式/互备模式的区别在于集群模式是仅对服务进行高可用的设计,另外两种设计既有对服务和数据的双重含义</p></li></ul><h4 id="容错机制的设计"><a class="header-anchor" href="#容错机制的设计"></a>容错机制的设计</h4><p>容错机制指的是在系统设计中需要对一些异常场景的兼容,例如在Raft的一些实现中就会对CommitId进行CRC32的容错机制校验</p><h4 id="重试机制"><a class="header-anchor" href="#重试机制"></a>重试机制</h4><p>重试机制指的是系统调用失败后,由于无法确定是否网络异常,或者是否是系统调用的问题,可以重试一定次数,如果重试次数超过限制,则抛出异常;这种设计是基于网络异常和系统异常的区别的基础上来进行设计的,在一般认为中网络异常是频繁且持续的,因此可以重试机制下,重试一定次数<br>重试机制又会引出接口幂等的场景,因此在分布式系统设计中,接口一定要提供幂等</p><h4 id="负载均衡"><a class="header-anchor" href="#负载均衡"></a>负载均衡</h4><p>负载均衡类似于集群模式通过一个总的调度器来对任务进行分配,常用的负载均衡方案Nginx,LB</p><h3 id="分布式系统的几个通用问题"><a class="header-anchor" href="#分布式系统的几个通用问题"></a>分布式系统的几个通用问题</h3><ul><li>全局id的生成</li><li>hash取模分配</li><li>路由表</li><li>一致性hash算法</li><li>数据拆分</li><li>分布式锁的解决方案</li><li>分布式事务的解决方案</li></ul><h4 id="全局Id的生成方案"><a class="header-anchor" href="#全局Id的生成方案"></a>全局Id的生成方案</h4><p>分布式Id的产生是基于数据服务大都采用集群的模式提供服务,在这种模式下不同的节点如果产生的id不进行相互协调的话会造成id的冲突,因此需要一个全局的id生成方案来保证id的唯一性</p><p>有两种实现思路:</p><ul><li>基于节点执行不同规则的id生成</li><li>基于全局协调器的id生成</li></ul><p>下面分别来介绍一下这两种不同的方案</p><ul><li>基于节点执行不同规则的id生成</li></ul><p>是通过值得数据节点的id生成规则来实现的,例如对id设置初始值和步长,然后每个节点都会计算出自己的id,这样就可以保证id的唯一性</p><ul><li><p>基于全局协调器的id生成<br>基于全局协调器的id生成方案实现比较多,例如通过一张id表的方式来进行实现\通过分布式id生成器的号段模式来实现\通过分布式id生成器的雪花算法来实现</p></li><li><p>snowflake的id生成方案</p></li></ul><p>64bit = 41bit(时间戳) + 10bit(节点id) + 12bit(自增id)<br>时间戳精确到毫秒<br>12位自增id每个节点最多产生4096个id</p><h4 id="hash取模-路由表-一致性hash算法"><a class="header-anchor" href="#hash取模-路由表-一致性hash算法"></a>hash取模\路由表\一致性hash算法</h4><p>hash取模\路由表\一致性hash算法都是为了解决数据或服务的一个寻址过程,例如对于一个数据库来说,如果数据库有多个节点,那么对于某个数据来说,可以通过hash取模的方式来寻址到对应的节点,这样就可以保证数据的一致性</p><p>hash取模是指的是对数据进行hash取模,然后根据模的值来寻址到对应的节点,这样就可以保证数据的分片性</p><p>路由表是通过预设的路由表来寻址到对应的节点,这样就也可以保证数据的分片性;路由表还有一个优点是对于有序增加的场景下可以通过递增预设的路由表数据来寻址到对应的节点,还不影响之前的数据,但是这样有一个路由表单点问题,需要做好数据的备份和failover</p><h4 id="数据拆分"><a class="header-anchor" href="#数据拆分"></a>数据拆分</h4><p>数据的拆分主要指的是将数据分片到不同的节点上,这样就可以保证数据的一致性;前面已经介绍数据拆分的原理;<br>常用的数据拆分方案是mycat/shardingsphere等</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>这一章节主要给我们介绍<B>分布式系统设计策略</B>&lt;B&gt;分布式系统的几个通用问题</B>的解决方案</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(一)&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;是《深入分布式缓存-从原理到实践》一书的一些记录&lt;/p&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a clas</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(二)</title>
    <link href="https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/21.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%BA%8C)/"/>
    <id>https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/21.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%BA%8C)/</id>
    <published>2022-08-08T15:45:00.000Z</published>
    <updated>2022-11-14T15:51:02.990Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(二)</h1><h2 id="规划定义"><a class="header-anchor" href="#规划定义"></a>规划定义</h2><h3 id="JSR"><a class="header-anchor" href="#JSR"></a>JSR</h3><blockquote><p>JSR是java Specification Requests的缩写,是java定义的一种对java对象临时在内存中进行缓存的方法,包括对象的创建\访问\失效\一致性等</p></blockquote><h3 id="缓存常用方法"><a class="header-anchor" href="#缓存常用方法"></a>缓存常用方法</h3><table><thead><tr><th>接口</th><th>说明</th><th>Ehcache</th><th>Guava</th></tr></thead><tbody><tr><td>put()</td><td>添加缓存</td><td>✔</td><td>✔</td></tr><tr><td>putIfAbsent()</td><td>如果key不存在则添加缓存</td><td>✔</td><td>✔</td></tr><tr><td>replace()</td><td>如果key存在则替换缓存</td><td>✔</td><td>✔</td></tr><tr><td>get()</td><td>获取缓存</td><td>✔</td><td>✔</td></tr><tr><td>getAll()</td><td>获取所有缓存</td><td>✔</td><td>✔</td></tr><tr><td>getAllPresent(key)</td><td>存在key在进行加载</td><td>❌</td><td>✔</td></tr><tr><td>putAll(entries)</td><td>添加所有缓存</td><td>✔</td><td>✔</td></tr><tr><td>keySet()</td><td>获取所有key</td><td>❌</td><td>❌</td></tr><tr><td>remove()</td><td>移除缓存</td><td>✔</td><td>✔</td></tr><tr><td>clear()</td><td>清空缓存</td><td>✔</td><td>✔</td></tr></tbody></table><p>可以看到常见的缓存操作就三类:<B>添加</B>&lt;B&gt;获取</B>&lt;B&gt;移除</B></p><p>下面介绍两类缓存的实现方式:<B>本地缓存</B>和<B>分布式缓存</B></p><h2 id="本地缓存"><a class="header-anchor" href="#本地缓存"></a>本地缓存</h2><h3 id="Ehcache"><a class="header-anchor" href="#Ehcache"></a>Ehcache</h3><p>暂且将Ehcache划分到本地缓存中,因为在使用中大多数场景下还是将Ehcache作为本地缓存来进行使用</p><p>Ehcache2的核心淘汰策略逻辑如下:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ehcache_AbstractPolicy_selectedBasedOnPolicy.jpg?raw=true" alt="selectedBasedOnPolicy"></p><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/AbstractPolicy.java#L77">AbstractPolicy.selectedBasedOnPolicy</a></p><ul><li>compare</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Compares the desirableness for eviction of two elements * * @param element1 the element to compare against * @param element2 the element to compare * @return true if the second element is preferable for eviction to the first element * under ths policy */</span><span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<B>compare()</B>方法是核心的比较方法,下层有<B>LRUPolicy</B>&lt;B&gt;LFUPolicy</B>&lt;B&gt;FIFOPolicy</B>底层实现</p><ul><li>LruPolicy</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较最后访问时间</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getLastAccessTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getLastAccessTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/LruPolicy.java#L52">LruPolicy.compare</a></p><ul><li>LFU</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较访问次数</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getHitCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getHitCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/LfuPolicy.java#L52">LfuPolicy.compare</a></p><ul><li>FIFO</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较创建和更新时间</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getLatestOfCreationAndUpdateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getLatestOfCreationAndUpdateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/FifoPolicy.java#L52">FIFOPolicy.compare</a></p><h3 id="Guava-Cache"><a class="header-anchor" href="#Guava-Cache"></a>Guava Cache</h3><p>Guava Cache是Google对java集合的一种封装来实现缓存功能;</p><p>Guava Cache 提供缓存的失效时间和定时更新功能,下面介绍Guava Cache定时更新方法</p><ul><li>scheduleRefresh()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">V</span> <span class="token function">scheduleRefresh</span><span class="token punctuation">(</span>    <span class="token class-name">ReferenceEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> entry<span class="token punctuation">,</span>    <span class="token class-name">K</span> key<span class="token punctuation">,</span>    <span class="token keyword">int</span> hash<span class="token punctuation">,</span>    <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span>    <span class="token keyword">long</span> now<span class="token punctuation">,</span>    <span class="token class-name">CacheLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> loader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">refreshes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//map.refreshes()判断是否存在过期时间</span>      <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> entry<span class="token punctuation">.</span><span class="token function">getWriteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> map<span class="token punctuation">.</span>refreshNanos<span class="token punctuation">)</span><span class="token comment">//判断是否已经过期</span>      <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>entry<span class="token punctuation">.</span><span class="token function">getValueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断是否当前正在加载新值</span>    <span class="token class-name">V</span> newValue <span class="token operator">=</span> <span class="token function">refresh</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> loader<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新加载数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> newValue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>scheduleRefresh()方法是在get()方法中调用的<br><a href="https://github.com/google/guava/blob/c111c0150225739b3f5914d1739cd22fb692bce7/guava/src/com/google/common/cache/LocalCache.java#L2324">LocalCache.scheduleRefresh</a></p><h3 id="Caffine"><a class="header-anchor" href="#Caffine"></a>Caffine</h3><h2 id="二级缓存"><a class="header-anchor" href="#二级缓存"></a>二级缓存</h2><p>在使用集中式或者数据库热点配置数据时,我们往往将这些数据放到应用进程空间中中,这样可以提高缓存的命中率;可以用Echache/Guava作为二级缓存来进行使用<br>下面介绍两种常用的设计方案:</p><ul><li>定时轮询</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/reids%E6%95%B0%E6%8D%AE%E5%AE%9A%E6%97%B6%E8%BD%AE%E8%AF%A2%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88.drawio.png?raw=true" alt="定时轮询"></p><ul><li>消息通知</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/reids%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88.drawio.png?raw=true" alt="消息通知"></p><p>消息通知的方案可以保证准实时下的推送,但是会带来一定的开销,比如消息通知的推送频率是每秒一次,那么每秒钟的消息会被推送到缓存中,这样会带来一定的开销,通过这样的消耗来保证实时性;还需要注意一点的是应用的重启后一定要消费最新的消息或从redis中获取最新的数据</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://github.com/hazelcast/hazelcast">https://github.com/hazelcast/hazelcast</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(二)&lt;/h1&gt;
&lt;h2 id=&quot;规划定义&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#规划定义&quot;&gt;&lt;/a&gt;规划定义&lt;/h2&gt;
&lt;h3 id=&quot;JSR&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JS</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-操作系统结构篇</title>
    <link href="https://agmtopy.gitee.io/2022/08/04/20.%E7%AC%94%E8%AE%B0/10.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/08/04/20.%E7%AC%94%E8%AE%B0/10.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2022-08-04T01:00:34.000Z</published>
    <updated>2022-08-14T06:40:46.371Z</updated>
    
    <content type="html"><![CDATA[<h1>引言</h1><p>《现代操作系统原理与实现》是一本介绍操作系统相关的书籍,是以ARM平台进行演示的.目前在看过一遍之后,我觉得还是比较有意思的<B>操作系统结构</B>、<B>硬件结构</B>、<B>内存管理</B>、<B>进程与线程</B>、<B>进程间通信</B>、<B>同步原语</B>、<B>文件系统</B>这七个章节.<br>下面会依次对这些章节做相关介绍.</p><h2 id="操作系统结构"><a class="header-anchor" href="#操作系统结构"></a>操作系统结构</h2><p>为什么要优先介绍<B>操作系统结构</B>,是这个章节给我带来了极大的感悟：对于像操作系统这样庞大的系统,在良好的架构下可以很好的有序演进,这一点是很多业务系统所欠缺的.<br>下面将从两个方面进行介绍:<B>设计方法</B>、<B>实践</B></p><h2 id="设计方法"><a class="header-anchor" href="#设计方法"></a>设计方法</h2><p>对于操作系统的设计方法或者方法论(不太喜欢’方法论’这一表述词,因为有一种’定式’的味道,现实或代码中并没有什么是固定的)来说,主要是对复杂度进行管理的一种手段;<br>这里介绍了一种设计方法:<B>M.A.L.H</B>,即模块化(modularity)、抽象(abstraction)、分层(layering)、层级(hierarchy),我对于设计简直是认同的不能在认同了.</p><h3 id="模块化"><a class="header-anchor" href="#模块化"></a>模块化</h3><p>模块化是通过<B>‘分治法’</B>的思想,将一个复杂系统分解为一系列有明确含义/领域能相互进行交互的小模块.模块的划分一定要具有’高内聚’和’低耦合’的特性,不能过大也不能过于小.<br>现代操作系统都是模块化的,以linux内核为例,可以看到分为若干模块</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97.jpg?raw=true" alt="linux模块"></p><p>关于模块化还有一些学者的阐述:<br><img src="https://martinfowler.com/articles/microservice-trade-offs.html" alt="Microservice Trade-Offs"></p><h3 id="抽象"><a class="header-anchor" href="#抽象"></a>抽象</h3><p>抽象是在模块化的基础上,将<B>接口</B>与<B>内部实现</B>进行区分,从而使得策略与实现分离.<br>这也是程序设计中的一个重要的设计原则:<B>策略</B>与<B>机制</B>分离:<B>策略</B>表示的是&quot;要做什么&quot;,<B>机制</B>表示的是&quot;要如何做&quot;</p><p>在操作系统中有很多抽象的例子,比如<B>VFS</B>、<B>虚拟内存</B>等就对不同硬件的抽象.</p><p>良好的模块化与抽象可以很好的将一个大型系统分解为一系列能够比较好的进行交付的模块;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%8A%BD%E8%B1%A1.jpg?raw=true" alt="模块化与抽象"></p><h3 id="分层"><a class="header-anchor" href="#分层"></a>分层</h3><p>分层是通过将模块按照一定的规则进行层次划分,约束每一层内部模块之间的交付方式与跨层次模块之间的交互方式,从而使得整个系统的交付方式有序;通常的规则约束是:一个模块只能和同一层模块以及相邻的上下层模块进行交互,而不能跨模块进行交互.</p><p>分层是开始构建复杂系统架构的开始,通过确定层级后,先构建底层基础模块,然后在利用这些基础模提供的功能来构建应用服务.</p><p>在实际web项目中基本上都会根据controller/service/dao三层架构来进行划分,service层的扩展要稍微多一点,例如六边形架构、洋葱圈架构等.</p><h3 id="层次"><a class="header-anchor" href="#层次"></a>层次</h3><p>层次是模块化的另外一种表现方式,是系统对功能的抽象与组织;例如组织架构类似,在组织架构上经理岗位是负责某一部分业务的,那公司的这一部分业务就需要交给他这个岗位进行负责;这个岗位下又会在分解交给其他岗位完成一样;</p><p>层次会在完成模块化、抽象、分层后自然体现出来,它与分层概念很类似,我认为的区别在于分层关注的是交互/调用关系的维护和有序,层次是关注与功能的抽象和组织;</p><h3 id="一些碎碎念"><a class="header-anchor" href="#一些碎碎念"></a>一些碎碎念</h3><p>大多数程序员长期以来写的代码都是以实现当前需求为己任,对于代码之后的生命周期是不会去考虑的.这样的代码在过了几个月以后或者另外一位同事接手后不得不在一声声’问候’下继续做相同的事情.<br>我始终认为简单明了的代码是最好的代码,因为这样的可读性是最好的; 不用去追求’新’、‘奇’来体现技术能力,而是要去追求’正确性’、'可读性’来体现技术能力;<br>然而在实际开发中,我们往往缺少一种能够指导的方法,我认为<B>M.A.L.H</B>就是一种非常好的实现,M.A.L.H中隐含了一些程序设计的技巧或法则:单一职责原则、依赖倒置原则、接口隔离原则</p><p>个人理解总结下来:</p><p>是否<B>能够</B>模块化?<br>是否<B>需要</B>抽象?<br>是否<B>能够</B>分层?<br>是否<B>体现</B>层次?</p><p>这些表现是层层递进的一个过程.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;引言&lt;/h1&gt;
&lt;p&gt;《现代操作系统原理与实现》是一本介绍操作系统相关的书籍,是以ARM平台进行演示的.目前在看过一遍之后,我觉得还是比较有意思的&lt;B&gt;操作系统结构&lt;/B&gt;、&lt;B&gt;硬件结构&lt;/B&gt;、&lt;B&gt;内存管理&lt;/B&gt;、&lt;B&gt;进程与线程&lt;/B&gt;、&lt;B&gt;进程间通信&lt;/B&gt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>maven-shade-plugin使用中的小问题</title>
    <link href="https://agmtopy.gitee.io/2022/04/22/1.%E6%9D%82%E8%AE%B0/maven-shade-plugin%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://agmtopy.gitee.io/2022/04/22/1.%E6%9D%82%E8%AE%B0/maven-shade-plugin%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-22T15:17:08.000Z</published>
    <updated>2022-04-22T15:21:28.625Z</updated>
    
    <content type="html"><![CDATA[<h1>maven-shade-plugin使用中的小问题</h1><p>maven-shade-plugin打包导致META-INF/SERVICES中的文件丢失,导致jar在动态加载时无法启动.这个问题困扰了我一周,暂时先记录处理办法,后续完善解决步骤</p><p>主要是依据这篇文章来解决处理的<br><a href="https://cloud.tencent.com/developer/article/1622207">https://cloud.tencent.com/developer/article/1622207</a></p><ul><li>maven-shade-plugin模板</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-shade-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!-- put your configurations here --></span>                <span class="token comment">&lt;!--只包含该项目代码中用到的jar,在父项目中引入了，但在当前模块中没有用到就会被删掉--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>minimizeJar</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>minimizeJar</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!--重新定位类位置，就好像类是自己写的一样，修改别人jar包的package--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relocations</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relocation</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>com.alibaba.fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedPattern</span><span class="token punctuation">></span></span>com.gavinzh.learn.fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedPattern</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--这些类和包不会被改变--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>com.alibaba.fastjson.not.Exists<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>com.alibaba.fastjson.not.exists.*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relocation</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relocations</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                        <span class="token comment">&lt;!--创建一个你自己的标识符，位置在原有名称之后--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedArtifactAttached</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedArtifactAttached</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedClassifierName</span><span class="token punctuation">></span></span>gavinzh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedClassifierName</span><span class="token punctuation">></span></span>                        <span class="token comment">&lt;!--在打包过程中对文件做一些处理工作--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformers</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--在META-INF/MANIFEST.MF文件中添加key: value 可以设置Main方法--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span>                                    <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ManifestResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestEntries</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.gavinzh.learn.shade.Main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Build-Number</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Build-Number</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Built-By</span><span class="token punctuation">></span></span>your name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Built-By</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>X-Compile-Source-JDK</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>X-Compile-Source-JDK</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>X-Compile-Target-JDK</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>X-Compile-Target-JDK</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestEntries</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--阻止META-INF/LICENSE和META-INF/LICENSE.txt--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ApacheLicenseResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token comment">&lt;!--合并所有notice文件--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ApacheNoticeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addHeader</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addHeader</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--如果多个jar包在META-INF文件夹下含有相同的文件，那么需要将他们合并到一个文件里--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.handlers<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.schemas<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.factories<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring-form.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.tooling<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--如果多个jar包在META-INF文件夹下含有相同的xml文件，则需要聚合他们--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ComponentsXmlResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token comment">&lt;!--排除掉指定资源文件--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.DontIncludeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>.no_need<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--将项目下的文件file额外加到resource中--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.IncludeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/pom_test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>pom.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--整合spi服务中META-INF/services/文件夹的相关配置--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ServicesResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformers</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>shade<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;maven-shade-plugin使用中的小问题&lt;/h1&gt;
&lt;p&gt;maven-shade-plugin打包导致META-INF/SERVICES中的文件丢失,导致jar在动态加载时无法启动.这个问题困扰了我一周,暂时先记录处理办法,后续完善解决步骤&lt;/p&gt;
&lt;p&gt;主要是</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="markdown模板" scheme="https://agmtopy.gitee.io/tags/markdown%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源代码分析之启动原理分析</title>
    <link href="https://agmtopy.gitee.io/2022/04/12/22.springboot/1.SpringBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2022/04/12/22.springboot/1.SpringBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2022-04-12T12:46:39.000Z</published>
    <updated>2022-12-12T15:07:55.215Z</updated>
    
    <content type="html"><![CDATA[<h1>SpringBoot源代码分析之启动原理分析</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程思想-核心篇》的章节,在参考SpringBoot源代码分析而来,希望对你有所帮助</p><h2 id="准备工作"><a class="header-anchor" href="#准备工作"></a>准备工作</h2><p>参考项目为地址为:<a href="https://github.com/agmtopy/SpringBootExample">https://github.com/agmtopy/SpringBootExample</a></p><h2 id="启动类概览"><a class="header-anchor" href="#启动类概览"></a>启动类概览</h2><p>在项目中,启动类为<code>SpringDemoApplication</code>,这个类应该是一切的开始,下面我们就来根据这个<B>run</B>方法来进行分析</p><ul><li>SpringDemoApplication</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringDemoApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringDemoApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>执行链路</li></ul><p>可以看到执行链路为:</p><p>这里有一个小细节,在没有提前初始化SpringApplication()时是不能使用arthas进行插入代码,显示错误为图一</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/S-springboot%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/Arthas_SpringApplicationRun1.jpg?raw=true" alt="图1"></p><p>查看相关类信息也没有看到类加载</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/S-springboot%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/Arthas_SpringApplicationRun2.jpg?raw=true" alt="图2"></p><p>经过分析可以知道这时候<B>SpringApplication</B>类还没有加载</p><h3 id="构造方法"><a class="header-anchor" href="#构造方法"></a>构造方法</h3><ul><li>SpringApplication()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">      <span class="token comment">//1. 启动方法  </span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> primarySources<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span class="token comment">//2. 构造方法</span>   <span class="token keyword">public</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">ResourceLoader</span> resourceLoader<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//1. 初始化ResourceLoader</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">=</span> resourceLoader<span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">,</span> <span class="token string">"PrimarySources must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>primarySources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType <span class="token operator">=</span> <span class="token class-name">WebApplicationType</span><span class="token punctuation">.</span><span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>bootstrapRegistryInitializers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">BootstrapRegistryInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass <span class="token operator">=</span> <span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<B>SpringApplication</B>初始化的方法中可以看到几个关键的方法<B>3/4/5</B>,分别是获取到Spring工厂的实例后在将工厂实例进行传递;</p><p>下面就详细的探究一下这几个方法的作用</p><ul><li>getSpringFactoriesInstances()</li></ul><p>通过Springboot的源代码可以看到getSpringFactoriesInstances()最后调用到了Spring的<B>loadFactoryNames()</B>方法</p><ul><li>loadFactoryNames</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> factoryType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>factories<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>factoryType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>主要是获取this.factories这个Map对象中的值,this.factories是<B>SpringFactoriesLoader</B>在进行初始化时产生的,回到SpringBoot中可以看到是通过forDefaultResourceLocation()方法</p><ul><li>forDefaultResourceLocation()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SpringFactoriesLoader</span> <span class="token function">forDefaultResourceLocation</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">forResourceLocation</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//实际调用这个方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SpringFactoriesLoader</span> <span class="token function">forResourceLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> resourceLocation<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>resourceLocation<span class="token punctuation">,</span> <span class="token string">"'resourceLocation' must not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ClassLoader</span> resourceClassLoader <span class="token operator">=</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> classLoader <span class="token operator">:</span><span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">></span></span> loaders <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>resourceClassLoader<span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentReferenceHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> loaders<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>resourceLocation<span class="token punctuation">,</span> key <span class="token operator">-></span><span class="token comment">// 首次初始化时使用的是loadFactoriesResource()方法来生成FactoryName</span><span class="token keyword">new</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> <span class="token function">loadFactoriesResource</span><span class="token punctuation">(</span>resourceClassLoader<span class="token punctuation">,</span> resourceLocation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 生成FactoryName</span><span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">loadFactoriesResource</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">,</span> <span class="token class-name">String</span> resourceLocation<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span>URL<span class="token punctuation">></span></span> urls <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>resourceLocation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">UrlResource</span> resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token class-name">PropertiesLoaderUtils</span><span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>properties<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> implementations <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">trim</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>implementations<span class="token operator">::</span><span class="token function">add</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>result<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">SpringFactoriesLoader</span><span class="token operator">::</span><span class="token function">toDistinctUnmodifiableList</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unable to load factories from location ["</span> <span class="token operator">+</span> resourceLocation <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 这一段方法的作用就是将传入的"META-INF/spring.factories"中的配置解析成为key-value形式的结果并返回</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>run()方法最后是执行<B>SpringApplication</B>的初始化方法:</p><h3 id="SpringApplication-run"><a class="header-anchor" href="#SpringApplication-run"></a>SpringApplication.run()</h3><ul><li>SpringApplication.run()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 运行Spring应用程序，创建并刷新新的容器 */</span><span class="token keyword">public</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//1. 执行需要在初始化开始时执行的钩子方法 -- 已经是过时的方法了在V3.0.0中间hook的实现挪到了SpringApplicationRunListener中,也就是在步骤5中进行执行</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">preRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 获取初始化时间</span><span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3.初始化BootStrapContext(引导上下文)</span><span class="token class-name">DefaultBootstrapContext</span> bootstrapContext <span class="token operator">=</span> <span class="token function">createBootstrapContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ConfigurableApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//4. 配置head头属性</span><span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 获取运行中的执行监听器</span><span class="token class-name">SpringApplicationRunListeners</span> listeners <span class="token operator">=</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6. 启动监听器</span>listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//7. 初始化应用程序参数</span><span class="token class-name">ApplicationArguments</span> applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8. 准备运行环境</span><span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span> bootstrapContext<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//9. 设置需要忽略的bean</span><span class="token function">configureIgnoreBeanInfo</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10. 打印Banner信息</span><span class="token class-name">Banner</span> printedBanner <span class="token operator">=</span> <span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//11. 创建ApplicationContext</span>context <span class="token operator">=</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//12. 设置应用程序启动器(用于收集启动过程中的一些信息)</span>context<span class="token punctuation">.</span><span class="token function">setApplicationStartup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//13. 准备启动ApplicationContext</span><span class="token function">prepareContext</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//14. 判断是否需要重新刷新容器</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//15. 后置刷新容器方法</span><span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//16. 记录时间</span><span class="token class-name">Duration</span> timeTakenToStartup <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofNanos</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>timeTakenToStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//17. 设置监听时间</span>listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> timeTakenToStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//18. 执行Runner方法</span><span class="token function">callRunners</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Duration</span> timeTakenToReady <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofNanos</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>listeners<span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> timeTakenToReady<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//19. 执行后置Hook后置方法</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">postRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> context<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到run方法的执行过程分为几个阶段:</p><ul><li><p><B>前置准备阶段</B></p><ul><li>执行前置钩子方法(步骤一)</li><li>初始化引导上下文(步骤二\步骤三\步骤四)</li><li>设置启动监听器 (步骤五\步骤六)</li></ul></li><li><p><B>启动容器阶段</B></p><ul><li>初始化应用参数(步骤七\八\九\十)</li><li>创建容器(步骤十一\十二\十三)</li></ul></li><li><p><B>刷新容器阶段</B></p><ul><li>刷新容器(步骤十四)</li><li>创建容器(步骤十五)</li></ul></li><li><p><B>执行后置方法阶段</B></p><ul><li>执行Runner(步骤十八)</li><li>执行hook(步骤十九)</li></ul></li></ul><h2 id="前置准备阶段"><a class="header-anchor" href="#前置准备阶段"></a>前置准备阶段</h2><p><B>前置准备阶段</B>主要是设置一些容器上下文和钩子函数,下面详细分析一下这几个功能的实现</p><h3 id="执行前置钩子方法"><a class="header-anchor" href="#执行前置钩子方法"></a>执行前置钩子方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置钩子方法</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">preRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个方法是在针对于AOT的启动过程中提供的钩子方法,最早应用于<B>v3.0.0-M4</B>版本中,<a href="https://github.com/spring-projects/spring-boot/commit/9cd17f8a14eab8007c372c045a6b9295a3a56126?diff=unified">commit</a>,但是在2022.09调整过一次代码结构,将hook重写为基于<B>SpringApplicationRunListener</B>来进行实现了</p><p>下面来继续分析<B>SpringApplicationHooks</B>的执行流程</p><ul><li>org.springframework.boot.SpringApplication#getRunListeners</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1. 注册到Listeners中private SpringApplicationRunListeners getRunListeners(String[] args) &#123;ArgumentResolver argumentResolver &#x3D; ArgumentResolver.of(SpringApplication.class, this);argumentResolver &#x3D; argumentResolver.and(String[].class, args);List&lt;SpringApplicationRunListener&gt; listeners &#x3D; getSpringFactoriesInstances(SpringApplicationRunListener.class,argumentResolver);&#x2F;&#x2F;获取applicationHook对象SpringApplicationHook hook &#x3D; applicationHook.get();SpringApplicationRunListener hookListener &#x3D; (hook !&#x3D; null) ? hook.getRunListener(this) : null;if (hookListener !&#x3D; null) &#123;listeners &#x3D; new ArrayList&lt;&gt;(listeners);&#x2F;&#x2F;将applicationHookListener添加到listeners.add(hookListener);&#125;return new SpringApplicationRunListeners(logger, listeners, this.applicationStartup);&#125;&#x2F;&#x2F;2. 将Hook设置到applicationHook中public static &lt;T&gt; T withHook(SpringApplicationHook hook, ThrowingSupplier&lt;T&gt; action) &#123;applicationHook.set(hook);try &#123;return action.get();&#125;finally &#123;applicationHook.set(null);&#125;&#125;&#x2F;&#x2F;3. applicationHookprivate static final ThreadLocal&lt;SpringApplicationHook&gt; applicationHook &#x3D; new ThreadLocal&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<B>applicationHook</B>是放在一个ThreadLocal中的变量,由创建application对象输入;</p><p><B>SpringApplicationHook</B>只有一个方法,就是设置<B>Listener</B></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SpringApplicationHook</span> <span class="token punctuation">&#123;</span><span class="token class-name">SpringApplicationRunListener</span> <span class="token function">getRunListener</span><span class="token punctuation">(</span><span class="token class-name">SpringApplication</span> springApplication<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="设置主类"><a class="header-anchor" href="#设置主类"></a>设置主类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="准备运行环境"><a class="header-anchor" href="#准备运行环境"></a>准备运行环境</h3><ul><li>prepareEnvironment</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">ConfigurableEnvironment</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span><span class="token class-name">SpringApplicationRunListeners</span> listeners<span class="token punctuation">,</span><span class="token class-name">DefaultBootstrapContext</span> bootstrapContext<span class="token punctuation">,</span> <span class="token class-name">ApplicationArguments</span> applicationArguments<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//1.初始化创建Environment对象</span><span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token function">getOrCreateEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 配置Environment对象</span><span class="token function">configureEnvironment</span><span class="token punctuation">(</span>environment<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">.</span><span class="token function">getSourceArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3. 先检查配置属性源</span><span class="token class-name">ConfigurationPropertySources</span><span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4.执行environmentPrepared方法(扩展点1)</span>listeners<span class="token punctuation">.</span><span class="token function">environmentPrepared</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 移除掉默认属性</span><span class="token class-name">DefaultPropertiesPropertySource</span><span class="token punctuation">.</span><span class="token function">moveToEnd</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token operator">!</span>environment<span class="token punctuation">.</span><span class="token function">containsProperty</span><span class="token punctuation">(</span><span class="token string">"spring.main.environment-prefix"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Environment prefix cannot be set via properties."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6. 绑定"spring.main"为this</span><span class="token function">bindToSpringApplication</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isCustomEnvironment<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//7. 转换Environment</span><span class="token class-name">EnvironmentConverter</span> environmentConverter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnvironmentConverter</span><span class="token punctuation">(</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>environment <span class="token operator">=</span> environmentConverter<span class="token punctuation">.</span><span class="token function">convertEnvironmentIfNecessary</span><span class="token punctuation">(</span>environment<span class="token punctuation">,</span> <span class="token function">deduceEnvironmentClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">ConfigurationPropertySources</span><span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> environment<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>prepareEnvironment</B>的大概方法就是执行</p><ol><li>初始化配置Environment对象</li><li>执行的SpringApplicationRunListeners.environmentPrepared方法(扩展点1)</li><li>绑定相关属性</li></ol><p>这里面最重要的当属<B>listeners.environmentPrepared</B></p><ul><li>org.springframework.boot.SpringApplicationRunListeners#environmentPrepared</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">environmentPrepared</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableBootstrapContext</span> bootstrapContext<span class="token punctuation">,</span> <span class="token class-name">ConfigurableEnvironment</span> environment<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">doWithListeners</span><span class="token punctuation">(</span><span class="token string">"spring.boot.application.environment-prepared"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span> <span class="token operator">-></span> listener<span class="token punctuation">.</span><span class="token function">environmentPrepared</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> environment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到会回调注册为<B>配置文件</B>中配置的类的相关方法</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Run Listeners</span>org.springframework.boot.SpringApplicationRunListener=\org.springframework.boot.context.event.EventPublishingRunListener<span class="token punctuation">,</span>\org.springframework.boot.context.event.SpringApplicationRunListenerTest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在<B>SpringApplicationRunListeners</B>里面执行方法也比较有意思,就是直接执行方法listener的具体方法</p><h3 id="初始化ApplicationContext"><a class="header-anchor" href="#初始化ApplicationContext"></a>初始化ApplicationContext</h3><ul><li>createApplicationContext()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContextFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//ServletWebServerApplicationContextFactory.java</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">WebApplicationType</span> webApplicationType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>webApplicationType <span class="token operator">!=</span> <span class="token class-name">WebApplicationType</span><span class="token punctuation">.</span>SERVLET<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断是否需要激活AOT</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">AotDetector</span><span class="token punctuation">.</span><span class="token function">useGeneratedArtifacts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigServletWebServerApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//返回ServletContext</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ServletWebServerApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化ApplicationContex方法就是根据应用类型,方法对应的ApplicationContex</p><h3 id="预处理容器"><a class="header-anchor" href="#预处理容器"></a>预处理容器</h3><ul><li>prepareContext()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">postProcessApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanNameGenerator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>context<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span>CONFIGURATION_BEAN_NAME_GENERATOR<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanNameGenerator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token keyword">instanceof</span> <span class="token class-name">GenericApplicationContext</span> genericApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置ResourceLoader</span>genericApplicationContext<span class="token punctuation">.</span><span class="token function">setResourceLoader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token keyword">instanceof</span> <span class="token class-name">DefaultResourceLoader</span> defaultResourceLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置ClassLoader</span>defaultResourceLoader<span class="token punctuation">.</span><span class="token function">setClassLoader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>addConversionService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>context<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setConversionService</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConversionService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>prepareContext用来设置<B>setResourceLoader</B>&gt;、<B>setClassLoader</B><br>这里有一个没搞懂的</p><blockquote><p>context instanceof DefaultResourceLoader defaultResourceLoader<br>context会是DefaultResourceLoader的实现类嘛？这里没有搞懂</p></blockquote><ul><li>applyInitializers()</li></ul><p>执行初始化方法,这是第二个扩展点</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">applyInitializers</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//遍历全部初始化容器&lt;ApplicationContextInitializer></span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span> initializer <span class="token operator">:</span> <span class="token function">getInitializers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> requiredType <span class="token operator">=</span> <span class="token class-name">GenericTypeResolver</span><span class="token punctuation">.</span><span class="token function">resolveTypeArgument</span><span class="token punctuation">(</span>initializer<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">isInstanceOf</span><span class="token punctuation">(</span>requiredType<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token string">"Unable to call initializer."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行初始化方法</span>initializer<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//setInitializers</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> initializers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>initializers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>initializers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//在SpringApplication()的构造方法中完成设置</span><span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Application Context Initializers</span>org.springframework.context.ApplicationContextInitializer=\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer<span class="token punctuation">,</span>\org.springframework.boot.context.ContextIdApplicationContextInitializer<span class="token punctuation">,</span>\org.springframework.boot.context.config.DelegatingApplicationContextInitializer<span class="token punctuation">,</span>\org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer<span class="token punctuation">,</span>\org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看一下<B>ContextIdApplicationContextInitializer</B>是做什么的?</p><ul><li>ContextIdApplicationContextInitializer</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getApplicationId</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableEnvironment</span> environment<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> name <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"spring.application.name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">?</span> name <span class="token operator">:</span> <span class="token string">"application"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">ContextId</span> contextId <span class="token operator">=</span> <span class="token function">getContextId</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>applicationContext<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>contextId<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>applicationContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token class-name">ContextId</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> contextId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个类主要是想context中设置contextId的动作,也可以把它看做是设置context的一种扩展点</p><ul><li>设置BeanFactory</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取Bean Factory</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">"springApplicationArguments"</span><span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>printedBanner <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">"springBootBanner"</span><span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">AbstractAutowireCapableBeanFactory</span> autowireCapableBeanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置BeanFactory是否允许循环依赖</span>autowireCapableBeanFactory<span class="token punctuation">.</span><span class="token function">setAllowCircularReferences</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">DefaultListableBeanFactory</span> listableBeanFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置是否允许BeanDefinition重写</span>listableBeanFactory<span class="token punctuation">.</span><span class="token function">setAllowBeanDefinitionOverriding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowBeanDefinitionOverriding<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对BeanFactory设置关键属性<B>是否可以重载BeanDefinition</B>和<B>是否允许循环依赖</B></p><ul><li>addBeanFactoryPostProcessor</li></ul><p>向容器中添加<B>BeanFactoryPostProcessor</B>,</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//是否延迟加载</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazyInitialization<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//设置BeanFactoryPostProcessor</span>context<span class="token punctuation">.</span><span class="token function">addBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LazyInitializationBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//add PropertySourceOrderingBeanFactoryPostProcessor</span>context<span class="token punctuation">.</span><span class="token function">addBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PropertySourceOrderingBeanFactoryPostProcessor</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后还有listeners.contextLoaded</span>listeners<span class="token punctuation">.</span><span class="token function">contextLoaded</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="刷新容器"><a class="header-anchor" href="#刷新容器"></a>刷新容器</h2><p>在SpringBoot中刷新容器反而比较简单,只需要调用Spring的refresh()方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">afterRefresh</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">,</span> <span class="token class-name">ApplicationArguments</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//listeners.started</span>listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> timeTakenToStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在SpringContext refresh完成后还有一个afterRefresh方法,但是这个方法是空的,不会进行处理;</p><p>然后在往下就是一个listeners.started的调用</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>1.创建计时器并开始<br>​2.创建启动器上下文并执行监听器BootstrapRegistryInitializer的initialize方法<br>​3.创建上下文ConfigurableApplicationContext变量并设置环境一些属性<br>​4.获取SpringApplicationRunListener监听器并执行其starting方法<br>​5.将命令行参数封装到ApplicationArguments里面来<br>​6.初始化应用上下文环境<br>​7.处理忽略Bean的信息<br>​8.打印Banner信息<br>​9.根据当前应用类型来创建context上下文<br>​10.设置记录器<br>​11.为刷新上下前做准备<br>​12.刷新上下文，最重要的功能在这的<br>​13.刷新后的扩展方法，其实里面什么都没有<br>​14.计时器结束<br>​15.记录log<br>​16.SpringApplicationRunListener监听器回调started<br>​17.SpringApplicationRunListener监听器回调running</p><p>注意这个过程中的扩展点:</p><ol><li>listeners</li><li>ApplicationContextInitializer</li></ol><p>和对BeanFactory属性的设置;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;SpringBoot源代码分析之启动原理分析&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://agmtopy.gitee.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://agmtopy.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
