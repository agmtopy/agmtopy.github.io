<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2021-06-16T16:01:48.085Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ中NameSrv的详细设计分析</title>
    <link href="https://agmtopy.gitee.io/2021/06/11/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/RocketMQ%E4%B8%ADNameSrv%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2021/06/11/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/RocketMQ%E4%B8%ADNameSrv%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/</id>
    <published>2021-06-11T14:57:56.000Z</published>
    <updated>2021-06-16T16:01:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ中NameSrv的详细设计分析"><a href="#RocketMQ中NameSrv的详细设计分析" class="headerlink" title="RocketMQ中NameSrv的详细设计分析"></a>RocketMQ中NameSrv的详细设计分析</h1><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>NameSrv是RoctetMQ项目下的一个模块，作为RockerMQ中的轻型注册中心,只负责与Topic有关的功能。<br>使用NameSrv来替代ZK等注册中心主要是有两个好处:</p><ol><li>减少整体复杂性<br>一个分布式系统强依赖另外一个分布式系统，增加了整个系统的复杂性(整体代码复杂性、运维的复杂性);<br>使用内置的轻量级注册中心,就可以消除原来与ZK等第三方注册中心的各种协议适配;<br>Namesrv中只需要开发与Topic有关的业务场景;<br>系统维护时也不用在考虑第三方系统的处理机制;</li><li>扩展能力<br>RocketMQ从设计初就考虑过在嵌入式设备上进行部署的能力,因此采用Namesrv的设计能最大限度的掌握系统</li></ol><p>目前Kafka在这方面做的更好，在V2.8之后不但去掉了ZK，并且采用broker集群中通过选举的方式选出leader节点来管理Topic、broker、consumer</p><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><ul><li><p>整体架构<br><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_architecture_3.png" alt="整体架构"><br>Namesrv集群是无状态的设计,每个组件(Broker、Producer、Consumer)都会向每一个Namesrv进行请求,因此Namesrv是选择了可用性</p></li><li><p>功能解析</p></li></ul><ol><li>Topic路由管理</li><li>Remoting远程服务</li><li>定时任务</li><li>KV管理模块</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Namesrv时序图"><a href="#Namesrv时序图" class="headerlink" title="Namesrv时序图"></a>Namesrv时序图</h3><p><a href="https://imgtu.com/i/2jkklQ"><img src="https://z3.ax1x.com/2021/06/16/2jkklQ.png" alt="Namesrv执行流程"></a></p><h3 id="NamesrvStartup"><a href="#NamesrvStartup" class="headerlink" title="NamesrvStartup"></a>NamesrvStartup</h3><h4 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h4><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 主函数入口 */</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">main0</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 具体执行逻辑:避免在main函数中添加过多的逻辑 */</span><span class="token keyword">fun</span> <span class="token function">main0</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> controller <span class="token operator">=</span> <span class="token function">createNamesrvController</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>        <span class="token function">start</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span>        <span class="token keyword">val</span> tip <span class="token operator">=</span>            <span class="token string">"The Name Server boot success. serializeType="</span> <span class="token operator">+</span> RemotingCommand<span class="token punctuation">.</span><span class="token function">getSerializeTypeConfigInThisServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        log<span class="token operator">!!</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>tip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span>tip<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 初始化NamesrvController */</span><span class="token keyword">fun</span> <span class="token function">createNamesrvController</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> NamesrvController <span class="token punctuation">&#123;</span>  <span class="token comment">//去除TLS和apache.commons的版本</span>  <span class="token keyword">return</span> <span class="token function">NamesrvController</span><span class="token punctuation">(</span><span class="token function">NamesrvConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">NettyServerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h4><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/**  * 启动NamesrvController  */</span><span class="token keyword">fun</span> <span class="token function">start</span><span class="token punctuation">(</span>controller<span class="token operator">:</span> NamesrvController<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>controller <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"NamesrvController is null"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//NamesrvController执行初始化,如果失败时退出进程</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>controller<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        controller<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    controller<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NamesrvStartup启动时候主要做了以下几个步骤：</p><ol><li>创建NamesrvController</li><li>处理TLS和加载Namesrv配置文件</li><li>启动NamesrvController</li><li>关闭NamesrvController</li></ol><ul><li>NamesrvController</li></ul><ol><li><p>总体逻辑</p></li><li><p>加载配置文件</p></li></ol><h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://rocketmq.apache.org/">rocketmq</a><br><a href="https://github.com/apache/rocketmq">rocketmq-github</a><br><a href="https://www.confluent.io/blog/kafka-without-zookeeper-a-sneak-peek/">Apache Kafka Made Simple: A First Glimpse of a Kafka Without ZooKeeper</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RocketMQ中NameSrv的详细设计分析&quot;&gt;&lt;a href=&quot;#RocketMQ中NameSrv的详细设计分析&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ中NameSrv的详细设计分析&quot;&gt;&lt;/a&gt;RocketMQ中NameSrv的</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RocketMQ" scheme="https://agmtopy.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>关于消息队列的一些历史</title>
    <link href="https://agmtopy.gitee.io/2021/05/08/1.%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%86%E5%8F%B2/"/>
    <id>https://agmtopy.gitee.io/2021/05/08/1.%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%86%E5%8F%B2/</id>
    <published>2021-05-08T14:03:28.000Z</published>
    <updated>2021-05-09T08:35:17.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于消息队列的一些历史"><a href="#关于消息队列的一些历史" class="headerlink" title="关于消息队列的一些历史"></a>关于消息队列的一些历史</h1><p>这是一篇关于消息队列的历史文章，有关消息队列的前世今生的一些信息。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>软件领域的消息队列最早是由Vivek Ranadive参考硬件中的系统总线提出来的,这老哥是一个印度裔,现在还是国王队的老板。<br>硬件领域中的系统总线主要分为数据总线、地址总线、控制总线这几个部分，用来连接不同的设备传输数据使用。<br><a href="https://imgtu.com/i/gJ4Q61"><img src="https://z3.ax1x.com/2021/05/09/gJ4Q61.png" alt="系统总线"></a><br>硬件上的系统总线着重在于通过线连接不同设备之间的交互，而消息队列是软件领域的连接不同系统之间交互的方式有应用层协议，现代的消息队列主要着重点是在于队列上。</p><h2 id="上古时期"><a href="#上古时期" class="headerlink" title="上古时期"></a>上古时期</h2><ul><li><p>1985<br>Vivek Ranadive根据系统总线设计出来的第一个消息系统叫The Information Bus(TIB)，TIB但是主要是在电信和金融领域进行使用。</p></li><li><p>1993<br>IBM MQ是由蓝色巨人IBM与1993年推出的消息队列产品，目前还保持更新现在迭代到了V9版本</p></li><li><p>1997<br>MS MQ是由微软推出的消息队列产品,不由感慨一句微软是真吊，为了.net硬是整了一个全家桶。</p></li></ul><p>这一时期由于各家的MQ产品都是为了旗下其他产品进行服务，为了形成壁垒，各家的MQ产品并未形成一个统一的规范，导致不同公司下的产品并不能使用其他公司的MQ。</p><h2 id="中古时期"><a href="#中古时期" class="headerlink" title="中古时期"></a>中古时期</h2><p>由于早期的MQ产品各自为政的场景下，这一时期主要统一了消息队列的协议，这些协议一直影响到了现在，主要诞生了以下几种协议以及接入规范：</p><ul><li><p> JMS<br>JMS是一套接入MQ中间件产品的接口规范，java为了黏合各家的消息队列试图通过类似于JDBC的方案在java端通过统一的协议，在根据不同产品的驱动去连接MQ。<br>各个厂商根据这套接口规范自行选择客户端进行实现，实现了这个接口规范的客户端可以在java应用程序内自由切换，类似于适配器模式</p></li><li><p>AMQP<br>AMQP是实现消息队列的一种协议，在协议层规定了消息队列应该有的逻辑规范。AMQP与具体的MQ(例如RabbitMQ、ActiveMQ)的关系类似与jvm规范和JVM实现(HotSpot)一样</p></li><li><p>MQTT<br>为嵌入式设备设计的一套消息队列协议</p></li><li><p>STOMP<br>Stomp协议，英文全名Streaming Text Orientated Message Protocol，中文名称为 ‘流文本定向消息协议’。是一种以纯文本为载体的协议（以文本为载体的意思是它的消息格式规范中没有类似XMPP协议那样的xml格式要求，你可以将它看作‘半结构化数据’）<br>双向消息通信协议还有很多，除了AMQP以外其他的大多都是即时消息协议。</p></li><li><p>ActiveMQ<br>在这一时期还有根据AMQP还诞生了ActiveMQ这一开源产品，ActiveMQ是第一个广泛使用到的开源MQ产品</p></li><li><p>RabbitMQ<br>RabbitMQ是2006年诞生的，现在和spring框架同属于vmware。由Erlang开发的。</p></li></ul><h2 id="现代时期"><a href="#现代时期" class="headerlink" title="现代时期"></a>现代时期</h2><p>由于ActiveMQ和RabbitMQ发展了多年，背负着沉重的历史包袱支持这非常全的MQ功能，在现代的MQ使用场景中这些消息队列不符合当下数据爆炸，小型机组成分布式系统的场景了。这时候出现了针对某个细分领域的消息队列框架Kafka、RocketMQ、Pulsar</p><ul><li><p>Kafka<br>Kafka是Linkedin为解决ActiveMQ性能问题而开发的分布式消息队列，目前已经成为大数据领域实际的消息传递组件</p></li><li><p>RocketMQ<br>RocketMQ是阿里开源的消息队列中间件，在设计上参考了kafka,通过java语言进行开发</p></li><li><p>Pulsar<br>Pulsar是雅虎开源的，天然支持多组成并且是计算和存储分离式的实现</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>消息队列的诞生是从金融场景出发，发展到现在最开始的那几种消息队列在功能上已经变得非常臃肿。现代的消息队列根据某一方面的着重点开始进行发展。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://tryrabbitmq.com/">http://tryrabbitmq.com/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于消息队列的一些历史&quot;&gt;&lt;a href=&quot;#关于消息队列的一些历史&quot; class=&quot;headerlink&quot; title=&quot;关于消息队列的一些历史&quot;&gt;&lt;/a&gt;关于消息队列的一些历史&lt;/h1&gt;&lt;p&gt;这是一篇关于消息队列的历史文章，有关消息队列的前世今生的一些信息。&lt;</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-可复用面向对象软件设计的基础-行为模式</title>
    <link href="https://agmtopy.gitee.io/2021/04/29/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2021/04/29/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-29T15:12:03.000Z</published>
    <updated>2021-05-08T13:59:04.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-可复用面向对象软件设计的基础-行为模式"><a href="#设计模式-可复用面向对象软件设计的基础-行为模式" class="headerlink" title="设计模式-可复用面向对象软件设计的基础-行为模式"></a>设计模式-可复用面向对象软件设计的基础-行为模式</h1><p>行为模式是通过将多个类通过继承\组合的形式形成对方法的处理,主要有以下几种</p><ol><li>责任链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板模式</li><li>访问者模式</li></ol><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><blockquote><p>责任链模式是使得多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系,这些对象的处理过程逻辑上形成链状结构,请求沿着这条链依次被不同的对象进行处理。标准的定义是直到有一个对象处理请求为止，我自己理解应该是依次进行处理，而不是有一个处理即止，因为如果只有一个处理，那么责任链模式与策略模式类似。责任链模式是通过将请求需要依次处理的场景从显的客户端一个一个调用的过程，升级成了将请求传入和由责任链客户端去串联整个调用过程，并且这样更容易扩展步骤。</p></blockquote><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/2021-chain-of-responsibility.svg" alt="责任链模式"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>AbstractLogger.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractLogger</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> INFO <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> DEBUG <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ERROR <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> level<span class="token punctuation">;</span>    <span class="token comment">//责任链中的下一个元素</span>   <span class="token keyword">protected</span> <span class="token class-name">AbstractLogger</span> nextLogger<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextLogger</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span> nextLogger<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>nextLogger <span class="token operator">=</span> nextLogger<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>level <span class="token operator">&lt;=</span> level<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token function">write</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>nextLogger <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         nextLogger<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">abstract</span> <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ChainPatternDemo.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainPatternDemo</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AbstractLogger</span> <span class="token function">getChainOfLoggers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token class-name">AbstractLogger</span> errorLogger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ErrorLogger</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">AbstractLogger</span> fileLogger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLogger</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">AbstractLogger</span> consoleLogger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConsoleLogger</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>       errorLogger<span class="token punctuation">.</span><span class="token function">setNextLogger</span><span class="token punctuation">(</span>fileLogger<span class="token punctuation">)</span><span class="token punctuation">;</span>      fileLogger<span class="token punctuation">.</span><span class="token function">setNextLogger</span><span class="token punctuation">(</span>consoleLogger<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> errorLogger<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">AbstractLogger</span> loggerChain <span class="token operator">=</span> <span class="token function">getChainOfLoggers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       loggerChain<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>INFO<span class="token punctuation">,</span> <span class="token string">"This is an information."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       loggerChain<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span>          <span class="token string">"This is a debug level information."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       loggerChain<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>ERROR<span class="token punctuation">,</span>          <span class="token string">"This is an error information."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ErrorLogger、FileLogger、ConsoleLogger都是AbstractLogger.java的子类，在客户端中，通过提供setNextHandler的方法，客户端可以根据业务场景自由组合链的顺序</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>将请求封装成为一个对象，从而使得你可以用不同的请求对客户进行参数化</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>命令模式主要是将请求和对请求执行的动作责任分离,让两者都可以独立进行演化。适合请求内容是类似于信号量的场景，接受者可以根据这个请求内容进行不同的处理</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/commanduml.jpg" alt="命令模式"></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul><li>Command<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 执行方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>Command.java 定义的抽象命令类，所有具体命令的接口</p><ul><li><p>PlayCommand.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//具体的执行类</span>    <span class="token keyword">private</span> <span class="token class-name">AudioPlayer</span> myAudio<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">PlayCommand</span><span class="token punctuation">(</span><span class="token class-name">AudioPlayer</span> audioPlayer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        myAudio <span class="token operator">=</span> audioPlayer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 执行方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        myAudio<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PlayCommand是具体的命令执行类，内部具有一个execute方法,该方法会执行该命令定义的动作</p></li><li><p>Keypad.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Keypad</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Command</span> playCommand<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPlayCommand</span><span class="token punctuation">(</span><span class="token class-name">Command</span> playCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>playCommand <span class="token operator">=</span> playCommand<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">//执行播放方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        playCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>keyPad作为请求类，再次对命令进行一次封装，便于客户端进行调用，这里可以不用再次封装，自己通过客户端进行调用</p><ul><li>client.java<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Julia</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token comment">//创建接收者对象</span>        <span class="token class-name">AudioPlayer</span> audioPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建命令对象</span>        <span class="token class-name">Command</span> playCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlayCommand</span><span class="token punctuation">(</span>audioPlayer<span class="token punctuation">)</span>         <span class="token comment">//创建请求者对象</span>        <span class="token class-name">Keypad</span> keypad <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Keypad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">setPlayCommand</span><span class="token punctuation">(</span>playCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//执行具体的类</span>        keypad<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>客户端通过调用请求类==Keypad==的指定方法，keyPad会调用具体的命令封装类进行执行。其实命令模式只是将请求和对应的动作进行分离，便于复杂请求场景的扩展</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/interpreter_pattern_uml_diagram.jpg" alt="解释器模式"></p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="意图-3"><a href="#意图-3" class="headerlink" title="意图"></a>意图</h3><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露聚合对象内部表示的模式</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>游标(Cursor)</p><h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>迭代器模式是为了将内部元素和访问/遍历动作分离开，通过增加一个迭代器，通过迭代器来访问内部元素。</p><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg" alt="迭代器模式"></p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="意图-4"><a href="#意图-4" class="headerlink" title="意图"></a>意图</h3><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互</p><h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p>由于面向对象鼓励按照行为进行类的划分，因此系统中会存在大量的类。如果不同的类之间都要相互引用来完成一个行为的话不符合面向对象的特性，因此需要有一个中介来将服务聚合起来，相当于将细小的行为进行一次聚合形成较大的行为，这样不用关注细小的行为对象。</p><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/mediator_pattern_uml_diagram.jpg" alt="中介者模式"></p><p>中介者模式在功能上类似于门面模式，但是门面模式着重于对子系统类的封装，中介者模式着重是对行为的封装和调和各个子行为从而形成一个大的行为，因此门面模式是结构型而中介者模式是行为型。</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="意图-5"><a href="#意图-5" class="headerlink" title="意图"></a>意图</h3><p>在不破坏对象封装性的前提下，捕获一个对象的内部状态，并将该状态保存在对象之外。在需要时，可以根据这个数据进行恢复。类似于游戏中的存档点设置。</p><h3 id="别名-1"><a href="#别名-1" class="headerlink" title="别名"></a>别名</h3><p>token</p><h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><p>备忘录模式针对于那些需要进行暂存的数据或对象，在不破坏封装性的前提下。</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/memento_pattern_uml_diagram.jpg" alt="备忘录模式"></p><p>CareTaker.java 负责保存每个阶段的对象状态</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="意图-6"><a href="#意图-6" class="headerlink" title="意图"></a>意图</h3><p>定义对象之间的一种一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都会得到通知</p><h3 id="别名-2"><a href="#别名-2" class="headerlink" title="别名"></a>别名</h3><p>依赖(Dependents),发布-订阅(Publish-Subscribe)</p><h3 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h3><p>在一个系统中一个对象的改变会导致引起相关对象的改变，如果要保持这样的一致性会导致对象间强依赖。观察者模式就是通过发布-订阅模式将通知的职责从动作类中强制依赖转换为通知的模式</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/observer_pattern_uml_diagram.jpg" alt="观察者模式"></p><p>Subject作为被观察者中维护一个所有观察者的引用，Observer作为被观察者维护一个Subject的引用，将自己组成到被观察者中<br>可参考<br><a href="../../../../../2020/05/06/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/#more">观察者模式</a></p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>spring中的ApplicationListener和ApplicationEvent、ApplicationEventPublisherAware分别作为被观察者、观察者和客户端</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="意图-7"><a href="#意图-7" class="headerlink" title="意图"></a>意图</h3><p>允许一个对象在其内部状态发生改变时改变它的行为。从表象上来看就是对象可以根据内部状态执行不同的业务逻辑。</p><h3 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h3><p>一个对象的行为取决于内部状态进行驱动时，状态模式可以将状态和行为分离，减少分支的条件语句。</p><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png" alt="状态模式"></p><p>可以看到doAction()方法中才会执行具体的行为，不同的状态具有不同的行为，通过context维护状态，当状态发生改变时，对应的行为也随之发生改变</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="意图-8"><a href="#意图-8" class="headerlink" title="意图"></a>意图</h3><p>策略模式是将不同的算法单独定义起来，通过不同的场景选择不同的算法。将客户端中的条件分支去掉，并且支持扩展。</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" alt="策略模式"></p><p>Context中的strategy类是具体执行的算法，这里有两种设计方案，第一种就是UML图中的写法，将Contetxx作为每次行动的容器，每次执行前都先进行赋值。第二种是Context持有一个Strategy的List根据添加选择算法、</p><p>策略模式在实际工作中大量使用到，因为消除了条件判断减少了分支。通过增加类的方式来减少分支，结构上便于扩展了 </p><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h3 id="意图-9"><a href="#意图-9" class="headerlink" title="意图"></a>意图</h3><p>定义一个方法的骨架，通过继承的方式让子类可以改变特点行为，使得不用重新定义算法的顺序就能改变行为。</p><h3 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h3><p>模板方法的出现主要是为了解决重复定义的算法执行顺序并且具体执行有差异的场景</p><h3 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg" alt="模板模式"></p><p>模板模式与策略模式的区别在于模板模式是通过继承的方式来改变行为，策略模式是通过改变委托对象的方式来改变行为；策略模式针对的场景是相同类在处理不同的业务场景时候算法的选择问题，模板模式针对的是相同的类在处理相同的业务场景下算法细微的差异结构上。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="意图-10"><a href="#意图-10" class="headerlink" title="意图"></a>意图</h3><p>将数据和数据操作分离</p><h3 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h3><p>对一个对象需要进行多次操作时，为了避免这些操作将对象污染，可以通过访问者模式将数据和操作进行隔离。实现不同的访问者访问不同的数据。</p><h3 id="结构-10"><a href="#结构-10" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/visitor_pattern_uml_diagram.jpg" alt="访问者模式"></p><p>访问者模式的核心是在于数据对象会针对不同的访问者定义出不同的行为，由于访问者知道被访问的数据对象中的数据结构，因此访问者可以根据不同的对象定义出不同的行为</p><p>访问者的好处在于将数据对象的操作延迟到的访问者那一步中去了，通过定义不同的访问者可以执行不同的动作。</p><h2 id="设计模式思维导图"><a href="#设计模式思维导图" class="headerlink" title="设计模式思维导图"></a>设计模式思维导图</h2><p><a href="https://imgtu.com/i/gJVn2Q"><img src="https://z3.ax1x.com/2021/05/08/gJVn2Q.png" alt="设计模式思维导图"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-可复用面向对象软件设计的基础-行为模式&quot;&gt;&lt;a href=&quot;#设计模式-可复用面向对象软件设计的基础-行为模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-可复用面向对象软件设计的基础-行为模式&quot;&gt;&lt;/a&gt;设计模式-可复用面向对象软件</summary>
      
    
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-可复用面向对象软件设计的基础-结构型模式</title>
    <link href="https://agmtopy.gitee.io/2021/04/24/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2021/04/24/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-24T15:33:53.000Z</published>
    <updated>2021-04-27T17:01:14.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-可复用面向对象软件设计的基础-结构型模式"><a href="#设计模式-可复用面向对象软件设计的基础-结构型模式" class="headerlink" title="设计模式-可复用面向对象软件设计的基础-结构型模式"></a>设计模式-可复用面向对象软件设计的基础-结构型模式</h1><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><blockquote><p>结构型模式涉及到的是如何组织类和对象之间的引用关系,以便获得更大的组织结构和更好的可扩展性。结构性模式往往采用继承和组合两种手段来实现，关注的重点在于对象之间相互组合引用的关系上。主要有以下几种具体的模式：</p></blockquote><ol><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ol><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><blockquote><p>将一个类的接口转换成客户端所期望能使用的另外一个接口。Adapter模式使原本由于接口不兼容不能在一起使用的类能够通过一个中间适配类从而能一起工作了</p></blockquote><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>Wrapper</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210223-adapter.png" alt="适配器模式"><br>可以看到原本AudioPlayer不能直接引用AdvanceMediaPlayer，但是通过MediaAdapter实现AudioPlayer同样的接口后，在MediaAdapter中引用AdvanceMediaPlayer实现去执行具体的方法，从而迂回实现AdvanceMediaPlayer的调用</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><blockquote><p>将抽象部分和它的实现部分分离，从而使得两者都可以独立的变化。出现桥接模式的原因在因为继承接口-实现方法这种模式下接口定义好的方法子类必须按照定义进行实现，缺乏灵活性(PS:继承方式是一种强约束的关系，适用于强约束的场合)</p></blockquote><h3 id="别名-1"><a href="#别名-1" class="headerlink" title="别名"></a>别名</h3><p>Hadnle/Body</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2018/06/1528771072-8457-5780d2384acdbb60ec07fc3c71a1.png" alt="桥接模式"></p><p>Abstraction和Implementor都是抽象类，由于Abstraction内部持有Implementor抽象类，从而使得这两个抽象类都可以独立的发展，桥接模式的核心应该是将业务上不同的抽象部分单独分离开，独立演化，关注的应该是业务上抽象的功能分离和在抽象对象类的组合。通过分离和组合更好的描述一个类</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote><p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。适用于希望忽略组合对象和单个对象的不同，用户将统一的使用组合结构中的所有对象。</p></blockquote><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/cztr0P"><img src="https://z3.ax1x.com/2021/04/25/cztr0P.png" alt="cztr0P.png"></a><br>提供Component接口(抽象构件)，该接口有两个实现分别是容器构件(Composlte)、叶子构件(Leaf)。客户端通过直接使用Component接口，来忽略具体是单个对象还是组合对象提供的服务。composlte对象实现了Componet所定义的管理叶子节点的方法Add()、Remove()、GetChild()</p><p>组合模式在实现上有两种方法：1.透明组合模式、2.安全组合模式。<br>透明组合模式的特点是叶子节点和容器构件都要实现相同的接口，但是叶子节点和抽象构件节点其实都相互冗余了部分不属于自己的方法。<br>安全组合模式指的是在抽象构件中不会声明任何有关容器构件的方法，而是在容器构件中去声明并实现该方法</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="java-awt-Container"><a href="#java-awt-Container" class="headerlink" title="java.awt.Container"></a>java.awt.Container</h4><ul><li>Container.java<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>Container类内部管理一个<b>Component</b>的集合引用，这里采用的是安全的组合模式因此管理集合中的元素的方法是在Container中实现的</li></ul><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><blockquote><p>动态的为目标对象添加一些额外的职责，装饰模式(Decorator)在功能上与继承类似都是增强目标方法，但是装饰模式在结构上是向上的，而继承在结构上是向下的。装饰模式更加的灵活，没有继承那种强依赖的关系。</p></blockquote><h3 id="别名-2"><a href="#别名-2" class="headerlink" title="别名"></a>别名</h3><p>包装器-Wrapper</p><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/gpGYfe"><img src="https://z3.ax1x.com/2021/04/26/gpGYfe.jpg" alt="装饰器模式"></a></p><p>Component是顶层接口，分别别目标对象和装饰器对象实现，装饰器对象通过内部持有目标对象的一个引用，客户端在调用目标类的时候，实际上是通过调用装饰类的提供出来的方法。装饰器在持有目标类的引用后就可以在执行方法前后都进行自定义增强处理，从而实现对目标类的增强</p><p>装饰器的优点在于：</p><ol><li>比静态继承灵活且无强依赖性</li><li>避免类继承结构过高</li></ol><p>这个缺点不甚理解：</p><blockquote><p>装饰类和目标类是不一样的，装饰类对于其他对象来说是透明的</p></blockquote><ol start="4"><li>过多的类(个人认为不是缺点，类按照职责划分本来就会产生更多的小类，而不是一个大而全的类)</li></ol><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，使得子系统中的一组接口都实现该接口，对外提供一个相同的接口。</p></blockquote><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>复杂的子系统有多个类，每个类暴露出一些公共方法这些方法相互调用并对外提供一个服务，这个时候外部客户端并不关心子系统的内部调用，就可以通过Facade的模式将子系统暴露出去的接口整理成独立的接口，如下图所示：<br><a href="https://imgtu.com/i/gCcIqx"><img src="https://z3.ax1x.com/2021/04/27/gCcIqx.png" alt="门面模式"></a></p><ul><li><p>Facade<br>将请求发送给子系统对象</p></li><li><p>Subsystem class<br>实现子系统功能<br>处理有Facade指派的任务</p></li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul><li><p>JdbcUtil.java<br>JdbcUtil将有关jdbc的操作封装成为一个方法，对外提供服务</p></li><li><p>RequestFacade.java<br>Tomcat的RequestFacade.java</p></li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>运用共享技术有效的支持大量细粒度的对象，通俗的来将就是缓存具体对象，在使用时返回该对象。与单例模式类似，区别在于单例模式要保证全局唯一。享元模式不用保证全局唯一，并且可以继续创建对象。享元模式会通过内部状态和外部状态两个标识来保证对象行为的内部一致性和外部差异性</p></blockquote><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/gC5iBd"><img src="https://z3.ax1x.com/2021/04/28/gC5iBd.png" alt="享元模式"></a></p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><ul><li>String常量池</li><li>线程池</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问</p></blockquote><h3 id="别名-3"><a href="#别名-3" class="headerlink" title="别名"></a>别名</h3><p>Surrogate</p><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>代理模式为对象提供了一个可自定义的访问对象，可以实现<b>远程代理</b>、<b>虚代理</b>、<b>保护代理</b>、<b>智能指引</b>等功能<br>虚代理:指的是也就是动态代理，将初始化延迟到运行时<br>保护代理/虚代理:都是对代理对象的增强</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><a href="https://z3.ax1x.com/2021/04/28/gC5ujg.png">![代理模式]</a>](<a href="https://imgtu.com/i/gC5ujg">https://imgtu.com/i/gC5ujg</a>)</p><p>代理模式侧重于对目标对象的访问控制上，装饰模式侧重于对目标对象功能增强上。代理模式主要是对不可见的对象进行访问的代理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-可复用面向对象软件设计的基础-结构型模式&quot;&gt;&lt;a href=&quot;#设计模式-可复用面向对象软件设计的基础-结构型模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-可复用面向对象软件设计的基础-结构型模式&quot;&gt;&lt;/a&gt;设计模式-可复用面向对</summary>
      
    
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-可复用面向对象软件设计的基础-对象创建型模式</title>
    <link href="https://agmtopy.gitee.io/2021/04/17/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2021/04/17/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-17T07:17:24.000Z</published>
    <updated>2021-04-22T16:33:17.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-可复用面向对象软件设计的基础-对象创建型模式"><a href="#设计模式-可复用面向对象软件设计的基础-对象创建型模式" class="headerlink" title="设计模式-可复用面向对象软件设计的基础-对象创建型模式"></a>设计模式-可复用面向对象软件设计的基础-对象创建型模式</h1><h2 id="对象创建型模式"><a href="#对象创建型模式" class="headerlink" title="对象创建型模式"></a>对象创建型模式</h2><blockquote><p>对象创建型模式抽象了对象的实例化过程.帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类型创建模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另外一个对象</p></blockquote><p>创建型模式的主要特点是该模式聚焦于对象的创建上，关注于对象创建的过程。因为同一个类不同的实例化过程会对该类所表现出来的行为产生影响。从而在创建时，通过不同的设计模式将该过程抽象出来适应不同的场景</p><p>创建型模式主要有以下5种类型：</p><ol><li>抽象工厂模式</li><li>构造器模式</li><li>工厂模式</li><li>原型模式</li><li>单例模式</li></ol><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</p></blockquote><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>Kit</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>为解决对象工厂的创建问题。当一个业务场景需要多个工厂实例来创建对象时，如何创建这些工厂就可以使用抽象工厂模式来进行。这个模式操作的对象是是工厂对象，而不是具体工厂对象产生的实例对象。这样设计的好处是对外部来说只需要依赖AbstractFactory和AbstractProduct就可以了，不用关系具体BeanFactory和ProductFactory是怎么样被创建和依赖的。对AbstractFactory内部实现了Factory和Product的聚合。坏处在于增加一个Producty时会同时修改Abstract和创建新的具体的BeanFactory。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg" alt="抽象工厂模式"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><ul><li><p>AbstractFactory.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>AbstractFactory抽象类定义获取对象的方法</p></li><li><p>ObjectFactory1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Shape</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> objectType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>objectType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"object1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>objectType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"object2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ObjectFactory1作为工厂类继承抽象工厂类，并实现具体的抽象方法生产对象</p></li><li><p>Client</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">&#123;</span>    <span class="token comment">//1. 生成工厂类</span>    <span class="token keyword">public</span> <span class="token class-name">AbstractFactory</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> classType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//2. 通过工厂类生成产品</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">AbstractFactory</span> factory <span class="token operator">=</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token string">"classType"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> obj <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token string">"objectType"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>在客户端中主要有两步，第一个是获取具体的工厂类。第二个是根据工厂类获取对应的产品。从上面的代码中我们可以看到工厂的生成和产品的生成都需要按照不同的类型来选择生成的具体实现。抽象工厂模式管理的是工厂类。</p><h4 id="Spring中的抽象工厂模式"><a href="#Spring中的抽象工厂模式" class="headerlink" title="Spring中的抽象工厂模式"></a>Spring中的抽象工厂模式</h4><p><strong>AbstractBeanFactory__主要有三个实现类__XmlBeanFactory(已过时)__、__AbstractAutowireCapableBeanFactory__、__DefaultListableBeanFactory</strong><br>其中主要使用的是作为自动装配的工厂类AbstractAutowireCapableBeanFactory</p><h2 id="build模式"><a href="#build模式" class="headerlink" title="build模式"></a>build模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><blockquote><p>将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同含义的对象。构造者模式要求构造对象足够复杂并且能够按照部分参数进行处理，构造者模式将内部对象初始化的细节封装起来，外部对象之间调用即可</p></blockquote><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/cqsLl9"><img src="https://z3.ax1x.com/2021/04/22/cqsLl9.png" alt="构造者模式"></a></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul><li>lombok中的@Builder</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserParam</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//DELOMBOK之后的代码</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserParam</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>        <span class="token class-name">UserParam</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">UserParamBuilder</span> <span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserParamBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">UserParamBuilder</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>            <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>            <span class="token class-name">UserParamBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token class-name">UserParamBuilder</span> <span class="token function">userName</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token class-name">UserParamBuilder</span> <span class="token function">password</span><span class="token punctuation">(</span><span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token class-name">UserParam</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserParam</span><span class="token punctuation">(</span>userName<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token string">"UserParam.UserParamBuilder(userName="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">+</span> <span class="token string">", password="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到lombok的@Builder注解只是在内部设置了一个静态方法和静态类来生成build方式，将__Direct__的职责交给类的使用者去处理了。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><blockquote><p>定义一个创建对象的接口，让子类决定实例化具体的类对象。Factort Method使得类的实例化延迟到了子类使用的时候。</p></blockquote><h3 id="别名-1"><a href="#别名-1" class="headerlink" title="别名"></a>别名</h3><p>虚构造器(Virtual Constructor)</p><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/cOCXVJ"><img src="https://z3.ax1x.com/2021/04/22/cOCXVJ.jpg" alt="工厂模式"></a></p><p>在图中可以看到产品必须抽象出一个接口，然后在通过工厂定义创建产品的方法。通过集成工厂接口实现不同的产品的初始化过程。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h4 id="spring工厂模式"><a href="#spring工厂模式" class="headerlink" title="spring工厂模式"></a>spring工厂模式</h4><ul><li>FactoryBean.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取具体的类</span><span class="token annotation punctuation">@Nullable</span><span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>    <span class="token comment">//获取类的类型</span><span class="token annotation punctuation">@Nullable</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//是否是单例</span><span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型T是抽象的产品的接口,在FactoryBean的实现类上可以根据构造器或者在调用getObject()方法之前调用初始化方法来对生成的对象进行自定义的参数配置,这样做的好处是可以不改变调用端的逻辑从而增加一个产品子类</p><p>在具体的实现上,工厂模式有两种方式,1. 工厂类作为抽象类,提供抽象方法,由实现该类的子类具体的去做初始化产品的操作;2.工厂类不做为抽象类,并且提供默认的产品创建</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="意图-3"><a href="#意图-3" class="headerlink" title="意图"></a>意图</h3><blockquote><p>用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象</p></blockquote><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/cOmRSJ"><img src="https://z3.ax1x.com/2021/04/23/cOmRSJ.png" alt="原型模式"></a></p><p>原型模式是通过拷贝一个现有对象生成一个新的对象,需要主要的是原型模式是深拷贝而不是浅拷贝</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="意图-4"><a href="#意图-4" class="headerlink" title="意图"></a>意图</h3><blockquote><p>保证一个全局只有一个类,并且提供一个访问它的全局访问点</p></blockquote><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><a href="https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg"><img src="https://z3.ax1x.com/2021/04/23/cOmRSJ.png" alt="单例模式"></a></p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>Spring中的单例模式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-可复用面向对象软件设计的基础-对象创建型模式&quot;&gt;&lt;a href=&quot;#设计模式-可复用面向对象软件设计的基础-对象创建型模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-可复用面向对象软件设计的基础-对象创建型模式&quot;&gt;&lt;/a&gt;设计模式-</summary>
      
    
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-可复用面向对象软件设计的基础</title>
    <link href="https://agmtopy.gitee.io/2021/04/15/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://agmtopy.gitee.io/2021/04/15/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-15T12:31:01.000Z</published>
    <updated>2021-04-17T07:16:34.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-可复用面向对象软件设计的基础"><a href="#设计模式-可复用面向对象软件设计的基础" class="headerlink" title="设计模式-可复用面向对象软件设计的基础"></a>设计模式-可复用面向对象软件设计的基础</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><ul><li>设计模式列表</li></ul><ol><li>Abstract Factory<blockquote><p>提供一个<b>创建</b>一系列相关或相互依赖对象的接口,而无需指定它们具体的类</p></blockquote></li><li>Adapter<blockquote><p>将一个类的接口转换成客户端希望的另外一个接口.Adapter模式使得原本由于接口不兼容而不能在一起工作的那些类可以在一起工作</p></blockquote></li><li>Bridge<blockquote><p>使得抽象部分与它的实现部分分离,使得它们都可以独立的变化</p></blockquote></li><li>Builder<blockquote><p>将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的对象</p></blockquote></li><li>Chain of Responsibility<blockquote><p>为解除请求的发送者和接受者之间的耦合,使得多个对象都有机会处理这个请求.将这些处理对象连成链,并沿着这条链传递该请求,直到链尾</p></blockquote></li><li>Command<blockquote><p>将一个请求封装成为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录日志,以及支持可取消的操作</p></blockquote></li><li>Composite<blockquote><p>将对象组合成树形结构以表示’部分-整体’的层次机构.Composite使得客户对单个或复合对象的使用具有一致性</p></blockquote></li><li>Decorator<blockquote><p>动态的给一个对象添加一些额外的职责.就扩展功能而言Decorator比字节生产子类更为灵活</p></blockquote></li><li>Facade<blockquote><p>为子系统中的一组接口提供一个一致的界面,Facade定义了一个高层次的接口,这个接口使得子系统更加易用</p></blockquote></li><li>Factory Method<blockquote><p>定义一个用于创建对象的接口,让子类去决定将那个类进行实列化,Factory Method使得类的实例化延迟到了子类中</p></blockquote></li><li>Flyweight<blockquote><p>运用共享技术有效的支持大量细粒度的对象</p></blockquote></li><li>Interpreter<blockquote><p>给定一个语言,定义它的文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子</p></blockquote></li><li>Iterator<blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素,而又不需要暴露该对象的内部表示</p></blockquote></li><li>Mediator<blockquote><p>用一个中介对象来封装一系列的对象交互.中介者使得各个对象不需要显示的相互引用,从而使得其耦合松散,而且可用独立地改变它们之间的交互</p></blockquote></li><li>Memento<blockquote><p>在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可以将该对象恢复到保存状态</p></blockquote></li><li>Observer<blockquote><p>定义对象间的一种一对多的依赖关系,以便于当一个对象的状态发生改变时,所有依赖于它的对象都可以得到通知并自动刷新</p></blockquote></li><li>Prototype<blockquote><p>用原型实例指定创建对象的种类,并通过拷贝这个原型来创建新的对象</p></blockquote></li><li>Proxy<blockquote><p>为其他对象提供一个代理以控制这个对象的访问</p></blockquote></li><li>Singleton<blockquote><p>保证一个类仅有一个实例.并提供一个访问它的全局访问点</p></blockquote></li><li>State<blockquote><p>允许一个对象在其内部状态改变时改变它的行为.对象看起来似乎修改了它所属的类.</p></blockquote></li><li>Strategy<blockquote><p>定义一系列的算法,把它们封装起来,使得它们之间可以相互替换,使得算法的变化可以独立与客户</p></blockquote></li><li>Template Method<blockquote><p>定义一个操作中算法的骨架,而将一些具体步骤延迟到子类中去实现.Template Method使得之类可以复用父类定义的算法,并且进行细节的修改</p></blockquote></li><li>visitor<blockquote><p>表示一个作用于某对象结构中的各元素的操作.使得你可以在不改变各元素类的前提下定义作用于这些元素的新操作</p></blockquote></li></ol><ul><li>根据类型划分</li></ul><table><thead><tr><th></th><th></th><th>目的</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td>创建型</td><td>结构型</td><td>行为型</td></tr><tr><td>范围</td><td>类</td><td>Factory Method</td><td>Adapter(类)</td><td>Interpreter</br>Template Method</td></tr><tr><td></td><td>对象</td><td>Abstract Factory</br>Builder</br>Prototype</br>Singleton</td><td>Adapter(对象)</br>Bridge</br>Composite</br>Decorator</br>Facade</br>Flyweight</br>Proxy</br></td><td>Chain of Responsibility</br>Command</br>Iterator</br>Mediator</br>Memento</br>Observer</br>State</br>Strategy</br>Visitor</td></tr></tbody></table><ul><li>设计模式之间的关系<br><a href="https://imgtu.com/i/cRdD4H"><img src="https://z3.ax1x.com/2021/04/15/cRdD4H.jpg"></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-可复用面向对象软件设计的基础&quot;&gt;&lt;a href=&quot;#设计模式-可复用面向对象软件设计的基础&quot; class=&quot;headerlink&quot; title=&quot;设计模式-可复用面向对象软件设计的基础&quot;&gt;&lt;/a&gt;设计模式-可复用面向对象软件设计的基础&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>寻找两个正序数组中的中位数</title>
    <link href="https://agmtopy.gitee.io/2021/04/02/13.LeetCode/10.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://agmtopy.gitee.io/2021/04/02/13.LeetCode/10.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2021-04-02T15:22:03.000Z</published>
    <updated>2021-04-02T15:24:39.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寻找两个正序数组中的中位数-LeetCode4"><a href="#寻找两个正序数组中的中位数-LeetCode4" class="headerlink" title="寻找两个正序数组中的中位数_LeetCode4"></a>寻找两个正序数组中的中位数_LeetCode4</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p></blockquote><p>示例 1：<br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p><p>示例 2：<br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><p>示例 3：<br>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000</p><p>示例 4：<br>输入：nums1 = [], nums2 = [1]<br>输出：1.00000</p><p>示例 5：<br>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p><p>提示：<br>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106</p><h2 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寻找两个正序数组中的中位数-LeetCode4&quot;&gt;&lt;a href=&quot;#寻找两个正序数组中的中位数-LeetCode4&quot; class=&quot;headerlink&quot; title=&quot;寻找两个正序数组中的中位数_LeetCode4&quot;&gt;&lt;/a&gt;寻找两个正序数组中的中位数_Lee</summary>
      
    
    
    
    <category term="算法" scheme="https://agmtopy.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://agmtopy.gitee.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>转置矩阵</title>
    <link href="https://agmtopy.gitee.io/2021/04/02/13.LeetCode/9.%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/"/>
    <id>https://agmtopy.gitee.io/2021/04/02/13.LeetCode/9.%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</id>
    <published>2021-04-01T16:59:29.000Z</published>
    <updated>2021-04-02T15:22:03.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转置矩阵-LeetCode867"><a href="#转置矩阵-LeetCode867" class="headerlink" title="转置矩阵_LeetCode867"></a>转置矩阵_LeetCode867</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p></blockquote><p>示例 1：</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[1,4,7],[2,5,8],[3,6,9]]<br>示例 2：</p><p>输入：matrix = [[1,2,3],[4,5,6]]<br>输出：[[1,4],[2,5],[3,6]]</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> matrix<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种解法错误,因为只考虑了行数和列数相等的情况,没有考虑行数和列数不相等的二维数组</p><h3 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>matrix<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种解法能通过,但是内存消耗比较大,因为是先创建了一个数组,然后对原数组中的每个元素遍历确定位置</p><h3 id="第三种解法"><a href="#第三种解法" class="headerlink" title="第三种解法"></a>第三种解法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r <span class="token operator">*</span> c<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        temp<span class="token punctuation">[</span>i<span class="token operator">/</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">%</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token operator">%</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">/</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种解法巧妙的运用到了取余和模除两种,但是在空间复杂度上和第二种类似,由于数组具有不可变性,因此想要实现空间复杂度小的代码很难实现.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;转置矩阵-LeetCode867&quot;&gt;&lt;a href=&quot;#转置矩阵-LeetCode867&quot; class=&quot;headerlink&quot; title=&quot;转置矩阵_LeetCode867&quot;&gt;&lt;/a&gt;转置矩阵_LeetCode867&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="算法" scheme="https://agmtopy.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://agmtopy.gitee.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>MySQL总结</title>
    <link href="https://agmtopy.gitee.io/2021/03/30/6.mysql/MySQL%E6%80%BB%E7%BB%93/"/>
    <id>https://agmtopy.gitee.io/2021/03/30/6.mysql/MySQL%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-30T14:27:04.000Z</published>
    <updated>2021-04-01T16:44:01.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过以上几篇文章分别介绍了MySQL的文件系统/索引/锁/事务等功能点,这篇文章将对这些知识点进行汇总,描述出MySQL大概的架构</p></blockquote><h2 id="文件数据"><a href="#文件数据" class="headerlink" title="文件数据"></a>文件数据</h2><p> MySQL在文件数据上可以划分为<strong>MySQL系统数据</strong>/<strong>存储引擎数据</strong></p><ul><li>文件数据<ul><li>系统文件</li><li>参数文件<br>参数文件指的是系统运行时的参数,主要分为’静态参数’和’动态参数’</li><li>日志文件</li><li>系统错误日志文件</li><li>二进制(binlog)<br>binlog目前有三种记录格式分别是STATEMENT/ROW/MIXED;RC和STATEMENT格式不兼容,因为binlog的是在事务进行提交时写入</li><li>慢查询日志</li><li>查询日志</li><li>套接字文件<br>套接字文件是UNIX下使用套接字链接方式打开的socket文件</li><li>pid文件</li><li>表结构文件<br>定义表结构的文件,每个表都有一个frm的表结构文件</li></ul></li><li>InnoDB存储引擎文件<ul><li>表空间文件<br>实际存储数据的文件,名称为ibdata1的文件作为共享表空间文件,MySQL也支持为每个表单独设置表空间文件,后缀名为.ibd</li><li>redolog<br>redoLog又称为重做日志,文件名称为ib_logfile0/ib_logfile1</li></ul></li></ul><p><a href="https://imgtu.com/i/cESwqK"><img src="https://z3.ax1x.com/2021/04/01/cESwqK.png" alt="cESwqK.png"></a></p><h2 id="索引系统"><a href="#索引系统" class="headerlink" title="索引系统"></a>索引系统</h2><p>MySQL的索引系统主要是由于B+ Tree索引作为底层数据结构,也有采用Hash自适应索引场景.</p><ul><li>索引<ul><li>分类<ul><li>B+Tree索引<br>B+ TREE索引作为MySQL底层数据结构的好处是在于B+TREE平衡且层级不高并且叶子节点可以作为聚集索引</li><li>全文索引<br>MySQL的全文索引也是采用倒排算法,通过关键字来进行文档映射,现实工作中未涉及到,因此未详细研究</li><li>Hash索引<br>InnoDB只支持自适应的Hash索引,不能显示的去创建并且要满足Hash索引自动创建的条件(等值查询/命中范围/查询频率)</li></ul></li></ul></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul><li>锁<ul><li><p>锁分类</p><ul><li>行级锁<ul><li>共享锁(S锁)<br>共享锁允许事务同时读取同一行数据</li><li>排他锁(X锁)<br>排他锁是独占锁,不允许其他事务读取或操作数据</li></ul></li><li>表锁<ul><li>意向共享锁(IS锁)<br>意向共享锁是表维度的锁,意向共享锁是在事务读取表中某行数据时候自动加上的,同理意向排他锁也是这个逻辑;设计意向锁的主要目的是在于当事务想要获取到表锁时,可以直接通过是否能获取到意向锁来判断,相当于一个表级别的锁标志</li><li>意向排他锁(IX锁)</li></ul></li><li>锁算法<ul><li>行锁<br>行锁的作用范围是对数据的某一行进行操作</li><li>间隙锁<br>间隙锁是对数据间隙进行上锁,这样可以防止数据出现幻读的情况</li><li>Next-Key Lock<br>行锁+间隙锁就是Next-Key Lock</li><li>锁降级<br>当发现可以用行数时,Next-Key会降级成行锁</li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2></li></ul></li><li>事务<ul><li>事务的隔离级别<ul><li>串行化(Serializable)</li><li>读未提交(Read Uncommitted)</li><li>读已提交(Read Committed)</li><li>可重复读(Repeatable Read)</li></ul></li><li>串行化<br>串行化指的是事务按照串行化执行的结果执行,InnoDB的串行化是通过增加读锁的方式来实现的</li><li>读未提交<br>读未提交指的是当前事务可以读取到其他事务尚未提交的数据,底层实现是当前事务直接返回记录上的最新值</li><li>读已提交<br>读已提交指的是事务中的SQL在执行时会去读取最后一次提交的数据信息</li><li>可重复读<br>可重复读指的是事务开始时会分配一个全局唯一且自增的事务ID,并且可重复读只能读取到小于等于该事务id的数据;快照数据是通过UNDO LOG实现的</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过以上几篇文章分别介绍了MySQL的文件系统/索引/锁/事务等功能点,这篇文章将对这些知识点进行汇总,描述出MySQL大概的架构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文件数据&quot;&gt;&lt;a href=&quot;#文件数据&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="https://agmtopy.gitee.io/2021/03/27/6.mysql/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>https://agmtopy.gitee.io/2021/03/27/6.mysql/MySQL%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-03-27T07:09:33.000Z</published>
    <updated>2021-03-30T14:24:27.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h2><p>事务是数据库与文件系统最重要的差异之一,数据库通过事务保证了数据的ACID特性,分别是原子性/一致性/隔离性/持久性</p><h2 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h2><p>事务可以划分为:<br>1.扁平事务以及带有保存点的扁平事务<br>2.链事务<br>3.嵌套事务<br>4.分布式事务</p><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>InnoDB通过日志系统来实现事务,redo log可以保证事务的原子性/一致性/持久性,undo log可以保证事务的原子性和持久性</p><h3 id="redo-log的作用"><a href="#redo-log的作用" class="headerlink" title="redo log的作用"></a>redo log的作用</h3><p>redo log是重做日志,通过每次事务提交前先修改该事务要修改的页,在提交过程中如果中断,通过redo log就可以继续提交事务</p><h3 id="undo-log的作用"><a href="#undo-log的作用" class="headerlink" title="undo log的作用"></a>undo log的作用</h3><p>undo log是回滚日志,通过记录每个事务开始时的数据,在回滚发生中断时,可以根据undo log 继续进行事务回滚</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log由两部分组成’redo log buffer’和’redo log file’,在进行事务connit之前都会将事务的所有日志写入日志文件中进行持久化<br>InnoDB提供一个参数’innodb_flush_log_at_trx_commit’来控制redo log的刷盘策略,0:由master thread进行控制 1:每次提交后进行同步刷盘 2:每次提交后只是将数据提交给文件系统,不进行主动刷盘操作</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log是回滚日志,是逻辑日志并不是redo log的物理日志,只是在逻辑上保证了数据回滚到原始状态.例如用户执行一个insert操作,在undo log里面就需要一个delete操作</p><h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><p>多版本控制,InnoDB会在行记录上默认增加两个隐藏列来作为MVVC实现的基础,分别是DB_TRX_ID-最新一次事务提交版本号/DB_ROLL_PTR-删除事务的版本号<br>数据行和undo log组成了不同版本之间的数据链,通过对比版本号和undo log日志将所需要的数据还原出来</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事务的定义&quot;&gt;&lt;a href=&quot;#事务的定义&quot; class=&quot;headerlink&quot; title=&quot;事务的定义&quot;&gt;&lt;/a&gt;事务的定义&lt;/h2&gt;&lt;p&gt;事务是数据库与文件系统最重要的差异之一,数据库通过事务保证了数据的ACID特性,分别是原子性/一致性/隔离性/持久性</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引与锁</title>
    <link href="https://agmtopy.gitee.io/2021/03/21/6.mysql/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%94%81/"/>
    <id>https://agmtopy.gitee.io/2021/03/21/6.mysql/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%94%81/</id>
    <published>2021-03-21T06:12:10.000Z</published>
    <updated>2021-03-30T14:24:08.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>InnoDB存储引擎支持以下几种索引结构:</p><ol><li>B+树索引</li><li>全文索引</li><li>哈希索引</li></ol><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>结构为’B+树’的索引有聚集索引/辅助索引<br>聚集索引是以主键来构造B+树,在叶子节点中存放行记录,也就是叶子节点称为数据页.<br>辅助索引是以索引key来构造B+树,叶子节点记录的是主键,因此在进行查找是会进行一次读取聚集索引的操作</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引指的是将存储与数据库中的全部数据中的任意内容信息查询出来的技术.<br>全文索引主要是用倒排索引的技术来进行实现,倒排索引需要用到一个索引辅助表,对全文中的值进行分词和索引定位</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引指的是用哈希算法来存储索引的结构,InnoDB的哈希索引不能由用户自定义,而是由客户进行多次查询和命中某种条件后会将B+树索引进行升级转换成哈希索引,这种算法有点类似JVM中对热点代码的JIT技术,提前将热点数据拿出来</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>锁是数据库系统区别于文件系统的一个关键特性.锁机制用于管理对共享资源的并发访问.InnoDB存储引擎会在行级别上对表数据上锁.</p></blockquote><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p>InnoDB存储引擎实现了两种标准的行级锁</p><ul><li>共享锁(S Lock),允许事务读一行数据</li><li>排他锁(X Lock),允许事务删除或更新一行数据</li></ul><p>InnoDB存储引擎支持多粒度锁定,这种锁定允许事务在行级上的锁和表级上的锁同时存在.<br>为了支持在不同粒度上进行加锁操作,InnoDB存储引擎支持意向锁,意向锁可以分为’意向共享锁’/‘意向排他锁’<br>意向共享锁:事务想要获得一张表中的某几行的共享锁<br>意向排他锁:事务想要获得一张表中的某几行的排他锁</p><h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>‘一致性非锁定读’指的是InnoDB通过行的多版本控制系统,在读取时不必等待X锁的释放.<br>RC隔离级别下,一致性非锁定读一定是读取最新的一份快照数据<br>RR隔离级别下,一致性非锁定读一定是读取事务开始时的一份快照数据</p><h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><p>InnoDB通过两种操作显式的支持一致性锁定读,第一种是</p><ul><li>SELECT * FOR UPDATE 加X锁</li><li>SELECT * LOCK IN SHARE MODE 加S锁</li></ul><h3 id="自增计数"><a href="#自增计数" class="headerlink" title="自增计数"></a>自增计数</h3><p>InnoDB的自增计数是通过表上的一个自增长计数器来进行的,当插入SQL执行完毕后该自增计数器就完成自增操作并提交</p><h3 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h3><ol><li>Record Lock:行锁</li><li>Gap Lock:间隙锁</li><li>Next-Key Lock:行锁+间隙锁</li></ol><ul><li>Next-Key Lock是默认InnoDB默认采用的锁定算法,但是当查询时使用到了聚集索引时会降级成’Record Lock’锁.<br>这里有一个小疑问,InnoDB对于Insert的操作会检查插入记录的下一条记录是否被锁定,如果锁定则不允许操作 </li></ul><p>Next-Key Loc只在RR隔离模式下使用,主要是为了解决RR模式下的幻读问题(这是又有一个疑问了既然RR模式读取的是数据的快照,按理说这个时候应该没有新插入数据的快照,为什么要这样设计喃)</p><ul><li><p>阻塞<br>阻塞指的是不同锁之间的兼容关系,在某些时刻需要等待另外一个事务中的锁释放.在默认情况下InnoDB的存储引擎在大部分情况下都不会对异常进行回滚.</p></li><li><p>死锁<br>死锁指的是两个以上的事务在执行过程中相互等待.解决死锁最简单的方法是超时机制.MySQL检测超时机制是通过’等待图’的机制来进行死锁检测.</p></li><li><p>等待图检测机制<br>通过保存锁信息和事务等待链表形成一张图结构,检测图中是否存在回路,如果存在回路证明发生了死锁.</p></li><li><p>死锁回滚<br>对于死锁异常,InnoDB会选择回滚UNDO量最小的事务进行回滚</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;InnoDB存储引擎支持以下几种索引结构:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;B+树索引&lt;/li&gt;
&lt;li&gt;全文索引&lt;/li&gt;
&lt;li&gt;哈希索引&lt;/</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术疑问</title>
    <link href="https://agmtopy.gitee.io/2021/03/20/6.mysql/MySQL%E6%8A%80%E6%9C%AF%E7%96%91%E9%97%AE/"/>
    <id>https://agmtopy.gitee.io/2021/03/20/6.mysql/MySQL%E6%8A%80%E6%9C%AF%E7%96%91%E9%97%AE/</id>
    <published>2021-03-20T10:12:31.000Z</published>
    <updated>2021-03-30T14:24:39.582Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录&lt;&lt;MySQL技术内幕-InnoDB存储引擎&gt;&gt;阅读中存在的疑问点</p></blockquote><ul><li>P77 日志文件<blockquote><p>如果使用RC隔离级别会出现类似数据丢失更新的现象,从而出现主从数据库上的数据不一致</p></blockquote></li></ul><p>bin_log的记录格式为’STATENEBT’是,会出现这样的情况为什么喃?</p><p>原因:</p><blockquote><ol><li>bin_log的记录顺序是commit的顺序,而不是执行顺序</li><li>RC中SQL的执行是立即执行的<br>这样如果bin_log记录格式如果是sql,就会出现丢失数据的场景</li></ol></blockquote><hr><ul><li><p>P268 锁</p><blockquote><p>InnoDB对于Insert的操作会检查插入记录的下一条记录是否被锁定,如果锁定则不允许操作</p></blockquote></li><li><p>P269 解决幻读</p><blockquote><p>在RR模式下通过Next-Key Locking机制来解决幻读,既然MVVC是读取快照,为什么还需要Next-Key Locking机制来解决幻读问题</p></blockquote></li></ul><p>InnoDB实际上是把读取拆分成两种类型</p><ul><li>快照读<br>通过读取undo log,并且对比版本号得到事务开始时的数据,这种主要是select 操作,对数据加s锁</li><li>当前读<br>当前读指的是通过Next-Key Locking 机制将对数据的读取操作序列化,解决幻读问题</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/334408495">知乎MVCC的解答</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录&amp;lt;&amp;lt;MySQL技术内幕-InnoDB存储引擎&amp;gt;&amp;gt;阅读中存在的疑问点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;P77 日志文件&lt;blockquote&gt;
&lt;p&gt;如果使用RC隔离级别会出现类似数据丢失更新的现象,</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL文件和表结构</title>
    <link href="https://agmtopy.gitee.io/2021/03/20/6.mysql/MySQL%E6%96%87%E4%BB%B6%E5%92%8C%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
    <id>https://agmtopy.gitee.io/2021/03/20/6.mysql/MySQL%E6%96%87%E4%BB%B6%E5%92%8C%E8%A1%A8%E7%BB%93%E6%9E%84/</id>
    <published>2021-03-20T03:21:19.000Z</published>
    <updated>2021-03-30T14:23:44.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL文件体系"><a href="#MySQL文件体系" class="headerlink" title="MySQL文件体系"></a>MySQL文件体系</h2><p>MySql文件体系主要分为:</p><ol><li>参数文件<br>参数文件的定义是作为存储MySql初始化参数的作用,负责记录各种参数</li><li>日志文件:<br>这里的日志文件主要是系统操作日志,主要有错误日志文件,二进制日志文件,慢查询日志文件等</li><li>socket文件:<br>UNIX域套接字所需文件</li><li>pid文件<br>MySql实例进程的ID文件</li><li>MySQL表结构文件<br>用来存放MySQL表结构定义文件</li><li>存储引擎文件<br>存储引擎文件存放了真正的记录和索引数据</li></ol><p>主要关心的是日志文件和存储引擎文件</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>日志文件主要有错误日志,二进制日志,慢查询日志,查询日志文件<br>二进制日志就是bin_log文件,会记录所有对MySql数据库执行更新的操作,就算最后数据未发生改变;<br>当使用支持事务的存储引擎时,所有未提交的二进制日志会被记录到一个缓存中(当超过缓存大小时会记录到临时文件中),等待该事务提交时直接将缓存刷新到bin_log中<br>bin_log的记录格式有三种(记录执行SQL,记录更新数据,混合模式),在’记录执行SQL’的模式下主从复制不能使用RC模式</p><h3 id="存储引擎文件"><a href="#存储引擎文件" class="headerlink" title="存储引擎文件"></a>存储引擎文件</h3><p>存储引擎文件主要有’表空间文件’,重做日志文件(redo log)</p><h4 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h4><p>表空间文件指的是实际存储数据的文件,分为两种类型默认的表空间,这种表空间是共享数据存储的模式,另外一种是独自的表空间,为每一张表单独生产独立的表空间文件存放数据/索引/插入缓冲BITMAP,但是该表其余的数据还是放到默认的表空间中</p><h4 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h4><p>重做日志文件是innoDB用来保证数据完整性的关键,默认采用一个重做日志组下面有两个镜像重做日志文件的架构.<br>redo_log是在sql执行过程中不断的进行写入和复制,这里和bin_log有所差异,bin_log是在事务提交后进行的写入.<br>redo_log的记录对象是对每个页的更改的物理记录,redo_log记录的是向前的更新记录.</p><h2 id="MySQL表结构"><a href="#MySQL表结构" class="headerlink" title="MySQL表结构"></a>MySQL表结构</h2><p>MySQL的文件结构是如何数据如何在物理上的结构,MySQL对于数据在逻辑上的结构可以划分为索引组织表,InnoDO的存储结构,行记录结构,页记录结构以及视图等</p><h3 id="数据存储的方式"><a href="#数据存储的方式" class="headerlink" title="数据存储的方式"></a>数据存储的方式</h3><p>数据存储格式可以分为’堆表’/‘索引组织表’</p><ul><li>堆表指的是数据的存放是无序的,是根据空闲磁盘空间来决定存放位置;</li><li>索引组织表指的是在存放数据时是按照主键索引来进行存放的.InnoDB的B+树索引结构就是一种索引组织表的形式.</li></ul><h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>InnoDB的逻辑存储结构划分为4级,分别是表空间-段空间-区空间-页空间,页空间上存储的就是一行一行的数据了</p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB逻辑存储上最上层的操作单位,一个表空间存储了所属该表的全部数据(data,index)</p><h3 id="段空间"><a href="#段空间" class="headerlink" title="段空间"></a>段空间</h3><p>对表空间内的数据按照类型进行划分,又可以划分为数据段/索引段/回滚段等,这些不同的类型数据,被称为段空间</p><p>——逻辑-物理分割层——</p><h3 id="区空间"><a href="#区空间" class="headerlink" title="区空间"></a>区空间</h3><p>区空间是由连续的磁盘空间组成,默认区空间大小为1MB,为了保证区空间的连续性还会一次向磁盘申请多个区空间.区空间实际存储了段空间内的数据.</p><h3 id="页空间"><a href="#页空间" class="headerlink" title="页空间"></a>页空间</h3><p>页空间是InnoDB最小的磁盘管理单位,在InnoDB中每个页的大小为16KB,因此一个区可以存储64个页.页按照类型可以划分为</p><ol><li>数据页</li><li>undo页</li><li>系统页</li><li>事务数据页</li><li>插入缓冲页(BitMap/Free List)</li><li>二进制大对象页</li></ol><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>InnoDB中的数据是按照行来进行存储的,行数据的记录格式按照类型可以分为两类.Compact和Redundant两种类型.</p><ul><li><p>Redundant<br>Redundant类型是为了兼容之前版本而设计的</p></li><li><p>Compact<br>Compact格式是MySQL5.0中引入的,目的是高效的存储数据.</p></li><li><p>数据结构</p></li></ul><table><thead><tr><th>变长字段长度列表</th><th>NULL标志位</th><th>记录头信息</th><th>列数据…</th><th>事务ID</th><th>回滚指针</th></tr></thead></table><p>特别要注意’事务ID’和’回滚指针’这两项与隔离级别和事务回滚有关;<br>NULL,在行的数据结构中都不占用任何存储空间,因为在行的数据结构中有NULL标志位来处理NULL</p><ul><li>Varchar类型长度<br>Varchar类型在MySQL中的定义是最大能存储65535个字节,并且是该行所有的Varchar类型长度之和.由于一个页的大小为16KB,因此在Varchar的类型长度实际上是超过一页的大小,这样就会导致一页上不能存储一行数据.这里InnoDB采用了溢出页的方式来进行处理,page上只保留数据头信息,而溢出页上存储溢出的信息(溢出指的是数据大小溢出InnoDB设定的额定大小,而不是page页的大小)</li></ul><h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>InnoDB的数据页结构指的是页空间中数据页的结构,主要由数据系统信息和用户记录信息组成</p><ul><li>数据系统结构<br>数据系统结构主要是由文件头/页头/Infimun-Supremum Records/页目录等组成,标记了该块区域的系统信息</li><li>Infimun-Supremum Records指的是一个小于数据主键的区间起始值和终止值.这两个值会在B+树中进行存储</li><li>页目录指的是指的是标记用户数据的相对位置的结构<blockquote><p>在进行数据查找时,会先从B+树中查询到数据对应的页,将页加载到内存中后,根据页目录来对用户数据进行二分查找(重点)</p></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://my.oschina.net/xinxingegeya/blog/474895">MySQL聚簇索引&amp;聚集索引&amp;索引组织表</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL文件体系&quot;&gt;&lt;a href=&quot;#MySQL文件体系&quot; class=&quot;headerlink&quot; title=&quot;MySQL文件体系&quot;&gt;&lt;/a&gt;MySQL文件体系&lt;/h2&gt;&lt;p&gt;MySql文件体系主要分为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数文件&lt;br&gt;参数文件的定</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL体系结构与存储引擎</title>
    <link href="https://agmtopy.gitee.io/2021/03/15/6.mysql/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://agmtopy.gitee.io/2021/03/15/6.mysql/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2021-03-15T13:54:51.000Z</published>
    <updated>2021-03-30T14:24:02.022Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要介绍MySql的整体体系结构和存储引擎</p></blockquote><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>概念上’数据库’是文件的集合,是依照某种数据模型组织起来并存放与存储器中的数据;’数据库实列’是程序是一个用户进程,是用户对’数据库’操作的软件.<br>MySql主要由以下几部分组成</p><ol><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲组件</li><li>插件式存储引擎(存储引擎是基于表的 ,而不是基于数据库的)</li><li>物理文件</li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul><li><p>概述<br>存储引擎是与MySql物理文件进行交互的一种插件,存储引擎的底部是物理存储层,包括二进制日志文件,数据文件,错误文件,慢查询日志,undo/redo日志等</p></li><li><p>一次select的过程<br>下图是一次select的过程,从图中得知存储引擎位于是物理文件和程序数据之间<br><a href="https://imgtu.com/i/6r8Q7q"><img src="https://s3.ax1x.com/2021/03/15/6r8Q7q.png" alt="6r8Q7q.png"></a></p></li><li><p>InnoDB的体系架构</p></li></ul><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html"><img src="https://dev.mysql.com/doc/refman/8.0/en/images/innodb-architecture.png" alt="InnoDB架构"></a></p><ol><li>实列层<br>实列层主要包括’线程’和’内存’两个部分<br>a. 后台线程主要有</li></ol><ul><li>Master Thread<br>主线程主要负责将缓冲池中的数据异步刷新到磁盘中,保证数据的一致性</li><li>I/O Thread<br>I/O Thread 主要是负责AIO(Async IO)请求的回调</li><li>Purge Thread<br>Purge Thread的作用是事物在被提交后undolog就可能不在被使用了,因此需要Purge Thread线程来回收并分配的undo页</li><li>Page Cleaner Thread<br>Page Cleaner Thread的作用是回收分配脏页</li></ul><p>小结:Master Thread和I/O Thread一个负责异步刷新数据一个负责AIO的回调,Purge Thread和Page Cleaner Thread一个负责回收分配undolog一个负责回收分配脏页</p><p>b. 内存</p><ul><li>缓冲池<br>InnoDB存储引擎是基于磁盘存储,其中的数据是按照页的方式进行管理.由于CPU和磁盘速度中的差异因此用缓冲池技术来提高数据库的整体性能<br>缓冲池是一块内存区域,在数据库进行读取页操作时,会首先将从内存中的数据放到缓冲池中,在下一次读取相同页时,会直接读取缓冲池中的页数据.<br>对于数据库中的页的修改,首先会修改缓冲池中的页,然后以一定的频率刷新到磁盘,这种机制被称为CheckPoint<br>缓冲池中的数据页类型分为:</li></ul><ol><li>索引页</li><li>数据页</li><li>undo页</li><li>插入缓冲</li><li>自适应哈希索引</li><li>InnoDB存储的锁信息</li><li>数据字典</li></ol><ul><li><p>LRU list,Freen lst,Flush list<br>数据库中的缓冲池是通过LRU算法来进行管理,但是InnoDB中的LRU算法是经过优化的,将新数据放到列表3/8处</p></li><li><p>重做日志缓冲<br>重做日志首先会放到缓冲区,然后按照一定的频率刷新到日志文件上,有三种情况会刷新重做日志:1.Master Thread每一秒都会将日志缓冲刷新到日志文件,2.每个事务提交时都会将重做日志刷新到文件,3.当重做日志缓冲池剩余空间小于1/2时,会将日志刷新到文件上</p></li><li><p>额外的内存池<br>额外的内存池作为缓冲池的备用,但缓冲池不够的时候,就会从额外的内存池中申请</p></li><li><p>Checkpoint技术<br>Mysql中数据的持久性是通过Write Ahead Log策略来保证,也就是先写日志文件,在修改数据文件.当宕机导致数据丢失时,会通过重做日志来进行数据恢复.<br>如果重做日志太大会导致数据恢复的很慢,因此mysql使用CheckPoint的技术来保证,CheckPoint是将缓冲池中的内存页刷新到磁盘的动作</p></li></ul><h2 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h2><p>Master Thread具有最高级别的线程优先级,内部有多个循环组成:主循环,后台循环,刷新循环,暂停循环.<br>Master Thread主要分为1s执行一次的操作:</p><ol><li>日志缓冲刷新到磁盘,即使这个事务还没提交</li><li>合并插入缓冲</li><li>最多刷新100个InnoDB的缓冲池中的脏页到磁盘</li><li>如果当前没有用户活动,就切换到backgroud loop<br>10s执行一次的操作:</li><li>刷新100个脏页到磁盘</li><li>合并至多5个插入缓冲</li><li>将日志缓冲刷新到磁盘</li><li>删除无用的Undo页</li><li>刷新100个或者10个脏页</li></ol><h2 id="InnoDB特点"><a href="#InnoDB特点" class="headerlink" title="InnoDB特点"></a>InnoDB特点</h2><ol><li>插入缓冲(Insert Buffer)</li><li>两次写(Double Write)</li><li>自适应哈希索引(Adaptive Hash Index)</li><li>异步IO(Async IO)</li><li>刷新邻接页(Flush Neighbor Page)</li></ol><h2 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h2><ol><li>Insert Buffer<br>Insert Buffer是在插入数据时将辅助索引先放到Insert Buffer中,然后在按照一定的频率将Insert Buffer中的数据和辅助索引页的子节点进行合并,这样能够提高非聚集索引的插入性能</li><li>Change Buffer<br>Change Buffer作为Insert Buffer的升级,会将所有对非聚集索引的操作进行缓冲</li><li>Insert Buffer的内部结构<br>Insert Buffer的数据结构是B+树,在Mysql4.1之前每张表都有一颗B+树;在现在的版本中全局只有一颗B+树,负责对所有表的辅助索引进行Insert Buffer,默认为ibdata1<br>Insert Buffer的非叶子节点是由space(待插入记录表的表空间id),offer(偏移量)构成;叶子节点是由space,offer,metadata(操作辅助索引的元数据-顺序,标识,类型)</li><li>merge Insert Buffer的过程<br>在三种情况下,MySql会将Insert Buffer刷新到辅助索引文件中,并且虽然Insert Buffer是有序的,但是在刷新时,是随机选取Insert Buffer中的一个页进行刷新,做这个的目的是为了保证公平性而舍弃顺序性.以下的三种情况会进行Inser Buffer的刷新</li><li>辅助索引页被读取到缓冲池中</li><li>Insert Buffer BitMap记录Insert Buffer可用空间不足时</li><li>Master Thread线程对Insert Buffer的刷新</li></ol><h2 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h2><p>两次写指的是当在直接写入某页时发生宕机,会有丢失数据的风险.通过向将脏页的数据转移到内存中的doublewrite buffer中,在将doublewrite中的数据同步写到共享表空间的物理磁盘文件上,第二次才将doublewrite buffer中的文件刷新到数据文件(.ibd)中,这样可以尽量保证数据文件的完整性</p><h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p>自适应哈希索引指的是连续对热点数据的多次查询后会根据B+树索引生成对应的哈希索引,加快查询性能</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>异步IO可以提高操作磁盘的效率,</p><h2 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h2><p>刷新邻接页指的是对脏页所在区的页进行检测,发现是脏页一并进行刷新.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;主要介绍MySql的整体体系结构和存储引擎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;体系结构&quot;&gt;&lt;a href=&quot;#体系结构&quot; class=&quot;headerlink&quot; title=&quot;体系结构&quot;&gt;&lt;/a&gt;体系结构&lt;/h2&gt;&lt;p&gt;概念上’数据</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识(一)</title>
    <link href="https://agmtopy.gitee.io/2021/03/08/16.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/1.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://agmtopy.gitee.io/2021/03/08/16.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/1.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-03-08T13:06:46.000Z</published>
    <updated>2021-03-27T16:13:16.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><ol><li>广域网 WAN(Wide Area Network),作用范围在几十至几千公里</li><li>城域网 MAN(Metropolitan Area Network),作用范围在五至五十公里</li><li>局域网 LAN(Local Area Network),作用范围在一功能左右</li><li>个人局域网 PAN(Personal Area Network),通常作用范围为10米左右,通过无线连接起来的个人局域网又称为WPAN</li></ol><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><ol><li>速率:指的是连接在计算机网络上的主机在数字信道上传送数据的速率.通俗来讲就是单位时间内能发送的数据量</li><li>带宽:指的是网络的通信线路所能传送数据的能力.通俗来讲就是网络线路承载数据的宽度</li><li>吞吐量:指的是单位时间内通过某个网络的数据量</li><li>时延:指的是数据通过网络从一端传送到另外一端的时间(总时延=发送时延+传播时延+处理时延+排队时延)</li><li>时延带宽积:指的是传播时延*贷款表示以比特为单位的链路长度</li><li>往返时间RTT:指的是从发送端发送数据开始到发送端接受到接受端的响应为止</li><li>利用率:指的是信道利用率和网络利用率</li></ol><h2 id="计算机网络协议划分"><a href="#计算机网络协议划分" class="headerlink" title="计算机网络协议划分"></a>计算机网络协议划分</h2><ol><li><p>OSI七层协议</p><ol start="7"><li>应用层</li><li>表示层</li><li>会话层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ol></li><li><p>TCP/IP四层协议</p><ol start="4"><li>应用层(TELNET,FTP,SMTP)</li><li>运输层(TCP/UDP)</li><li>网际层(IP)</li><li>网络接口层<br>由于TCP/IP协议中的网络接口层是对通信链路的一个抽象因此并无具体实现,因此又折中出了一个五层协议的架构</li></ol></li><li><p>五层协议</p><ol start="5"><li>应用层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ol></li></ol><h2 id="TCP和UDP的异同"><a href="#TCP和UDP的异同" class="headerlink" title="TCP和UDP的异同"></a>TCP和UDP的异同</h2><p>TCP和UDP都是运输层协议,TCP在设计是可靠的(因此有三次握手)</p><h2 id="TCP-IP协议族的沙漏模型"><a href="#TCP-IP协议族的沙漏模型" class="headerlink" title="TCP/IP协议族的沙漏模型"></a>TCP/IP协议族的沙漏模型</h2><p>应用层 :  HTTP   SMTP    DNS  RTP   H.323  SIP<br>           \     /       \    /     \      /<br>运输层 :     TCP            UDP        SCTP<br>              \             |          /<br>网际层 :                    IP<br>               /            |            <br>网络接口层:  接口1          接口2         接口3</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><ol><li>单向通信<br>信号只能沿着一个方向移动</li><li>双向交替通信(半双工通信)<br>单位时间内信号只能沿着一个方向移动</li><li>双向同时通信<br>单位时间内信号可向不同的方向移动</li></ol><h2 id="网际层协议-IP"><a href="#网际层协议-IP" class="headerlink" title="网际层协议-IP"></a>网际层协议-IP</h2><p>HTTP是什么?<br>HTTP是一种超文本传输协议(Hypertext Transfer Protocol),主要是由于</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;计算机网络的类别&quot;&gt;&lt;a href=&quot;#计算机网络的类别&quot; class=&quot;headerlink&quot; title=&quot;计</summary>
      
    
    
    
    
    <category term="网络协议" scheme="https://agmtopy.gitee.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>延迟队列的实现思路</title>
    <link href="https://agmtopy.gitee.io/2021/01/20/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/12.%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
    <id>https://agmtopy.gitee.io/2021/01/20/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/12.%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</id>
    <published>2021-01-20T14:04:32.000Z</published>
    <updated>2021-03-27T16:13:16.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="延迟队列的实现思路"><a href="#延迟队列的实现思路" class="headerlink" title="延迟队列的实现思路"></a>延迟队列的实现思路</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>延迟队列指的是元素按照延迟时间进行排序形成并且到时后能自动弹出的有序队列,底层数据结构既可以是数组也可以是链表</p></blockquote><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>按照倒计时触发的业务场景,例如电商网站中的订单未支付自动取消,竞拍,日历待办提醒的场景,以及用定时任务扫表触发的业务场景</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>如果让你来设计延时队列,你需要怎么样来设计?<br>先来个基础1.0的设计:要实现延时队列需要两个角色,第一个是存储信息的队列,第二个角色是’计时器’负责监视队列中的消息时候到期</p><p>图示2</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//1.队列的角色</span>    <span class="token class-name">DelayQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DelayedTask</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">DelayedTask</span> task1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayedTask</span><span class="token punctuation">(</span><span class="token number">1_0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"_1:"</span> <span class="token operator">+</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">DelayedTask</span> task5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayedTask</span><span class="token punctuation">(</span><span class="token number">1_5L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"_2:"</span> <span class="token operator">+</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task1<span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2.计时器的角色</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">DelayedTask</span> task <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        task<span class="token punctuation">.</span><span class="token function">getRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>源码解析<blockquote><p>DelayQueue底层采用的是PriorityQueue,一种提供优先级的队列,poll()方法如下:</p></blockquote></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//PriorityQueue是线程不安全的,因此需要用lock</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">E</span> first <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> first<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的延时队列可以解决单个进程下的延迟队列场景,但是无法解决多个应用下的场景,那么如何在实现分布式的延迟队列喃?<br>先从问题分析,我们想要实现的是分布式的延迟队列,并且知道延迟队列是由定时器和队列构成,定时器由客户端实现,那么问题就变成了我们要实现一个分布式的具有优先级的队列结构,聪明的你一定就想到了这不是redis中的zset嘛?对,下面我们来看一下基于redis实现延迟队列的1.0版本</p><h3 id="基于Redis的延迟队列"><a href="#基于Redis的延迟队列" class="headerlink" title="基于Redis的延迟队列"></a>基于Redis的延迟队列</h3><blockquote><p>zset定义:排序集合，类似于集合，但每个字符串元素都与一个称为得分的浮点值相关联。 元素总是按它们的分数排序，因此与Sets不同，可以检索一系列元素</p></blockquote><ul><li>zset<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RedissonClient</span> redisClient <span class="token operator">=</span> <span class="token function">getRedisClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">RScoredSortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> zset <span class="token operator">=</span> redisClient<span class="token punctuation">.</span><span class="token function">getScoredSortedSet</span><span class="token punctuation">(</span><span class="token string">"redisDelayQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    zset<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getTimeLong</span><span class="token punctuation">(</span><span class="token number">10L</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    zset<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getTimeLong</span><span class="token punctuation">(</span><span class="token number">20L</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    zset<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getTimeLong</span><span class="token punctuation">(</span><span class="token number">15L</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> values <span class="token operator">=</span> zset<span class="token punctuation">.</span><span class="token function">valueRange</span><span class="token punctuation">(</span><span class="token function">getTimeLong</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token function">getTimeLong</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        values<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">RedissonClient</span> <span class="token function">getRedisClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"redis://localhost:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">RedissonClient</span> client <span class="token operator">=</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> client<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Long</span> <span class="token function">getTimeLong</span><span class="token punctuation">(</span><span class="token class-name">Long</span> seconds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusSeconds</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span><span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEpochMilli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>RedissonDelayedTask<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RedissonClient</span> redisClient <span class="token operator">=</span> <span class="token function">getRedisClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">RBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> blockingFairQueue <span class="token operator">=</span> redisClient<span class="token punctuation">.</span><span class="token function">getBlockingQueue</span><span class="token punctuation">(</span><span class="token string">"RedissonDelayed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">RDelayedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> delayedQueue <span class="token operator">=</span> redisClient<span class="token punctuation">.</span><span class="token function">getDelayedQueue</span><span class="token punctuation">(</span>blockingFairQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    delayedQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    delayedQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    delayedQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingFairQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>Redisson也实现了延迟队列(RedissonDelayedQueue),,底层数据结构使用的是zset,list,发布/订阅,并且也不是想我们现在这样通过while和方式来监听变化的,感兴趣的童鞋可以看一下Redisson实现时使用的Lua脚本</p><blockquote><p>目前Redisson基于reids的延迟队列在功能上很完善了作为延迟队列来说已经是满足的了,但是作为一个延时消息队列来说还缺少重试机制,ACK,因此下面介绍两种基于MQ实现延迟队列的方式</p></blockquote><h3 id="基于RabbitMQ的延迟队列"><a href="#基于RabbitMQ的延迟队列" class="headerlink" title="基于RabbitMQ的延迟队列"></a>基于RabbitMQ的延迟队列</h3><h4 id="基于TTL的实现方式"><a href="#基于TTL的实现方式" class="headerlink" title="基于TTL的实现方式"></a>基于TTL的实现方式</h4><blockquote><p>基于生存时间(TTL)和死信队列(DLX)特性实现的延迟队列;TTL指的是每条消息都有一个生存时间,超过过期时间后消息就会进入一个特殊队列,这个队列就是死信队列(DLX),DLX可以将消息重新投递到指定的队列中,consumer只需要订阅这个队列就可以实现延迟消费的功能</p></blockquote><ul><li>Provider</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>consumer</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="基于插件的实现方式"><a href="#基于插件的实现方式" class="headerlink" title="基于插件的实现方式"></a>基于插件的实现方式</h4><h3 id="基于RocketMQ的延迟队列"><a href="#基于RocketMQ的延迟队列" class="headerlink" title="基于RocketMQ的延迟队列"></a>基于RocketMQ的延迟队列</h3><h2 id="限制和扩展"><a href="#限制和扩展" class="headerlink" title="限制和扩展"></a>限制和扩展</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/343811173">Redisson 延时队列原理详解</a><br><a href="https://blog.csdn.net/u010059975/article/details/104537570">kafka延迟消息原因</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;延迟队列的实现思路&quot;&gt;&lt;a href=&quot;#延迟队列的实现思路&quot; class=&quot;headerlink&quot; title=&quot;延迟队列的实现思路&quot;&gt;&lt;/a&gt;延迟队列的实现思路&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RocketMQ" scheme="https://agmtopy.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>日常笔记</title>
    <link href="https://agmtopy.gitee.io/2020/12/27/1.%E6%9D%82%E8%AE%B0/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2020/12/27/1.%E6%9D%82%E8%AE%B0/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-27T13:45:26.000Z</published>
    <updated>2021-03-27T16:13:16.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日常笔记"><a href="#日常笔记" class="headerlink" title="日常笔记"></a>日常笔记</h1><blockquote><p>用于记录常用的命令，灵感，待办之类的</p></blockquote><h2 id="docker-command"><a href="#docker-command" class="headerlink" title="docker command"></a>docker command</h2><ol><li>mysql 启动命令</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -p <span class="token number">3306</span>:3306 --name mysql_1 -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> -d mysql:5.7.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>mongo 启动命令</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -itd --name mongo -p <span class="token number">27017</span>:27017 mongo --auth<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>设置账户</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> //创建用户并授权 db.createUser<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>user: <span class="token string">"axonUser"</span>, pwd: <span class="token string">"123456"</span>, roles <span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>role: <span class="token string">"readWrite"</span>, db: <span class="token string">"interviewTest"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //更新用户权限db.grantRolesToUser<span class="token punctuation">(</span><span class="token string">"axonUser"</span>,<span class="token punctuation">[</span><span class="token punctuation">&#123;</span>role:<span class="token string">"readWrite"</span>, db:<span class="token string">"axon"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.RabbitMQ 启动命令</p><ul><li>windows cmd</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name rabbitmq -p <span class="token number">5672</span>:5672 -p <span class="token number">15672</span>:15672 -v E:<span class="token punctuation">\</span>dockerfile<span class="token punctuation">\</span>RabbitMQ:/var/lib/rabbitmq --hostname myRabbit -e <span class="token assign-left variable">RABBITMQ_DEFAULT_VHOST</span><span class="token operator">=</span>my_vhost  -e <span class="token assign-left variable">RABBITMQ_DEFAULT_USER</span><span class="token operator">=</span>admin -e <span class="token assign-left variable">RABBITMQ_DEFAULT_PASS</span><span class="token operator">=</span>admin rabbitmq:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>启动RabbitMQ admin命令</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">docker exec <span class="token operator">-</span>it rabbitmq rabbitmq<span class="token operator">-</span>plugins enable rabbitmq_management<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;日常笔记&quot;&gt;&lt;a href=&quot;#日常笔记&quot; class=&quot;headerlink&quot; title=&quot;日常笔记&quot;&gt;&lt;/a&gt;日常笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;用于记录常用的命令，灵感，待办之类的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;dock</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="guava" scheme="https://agmtopy.gitee.io/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>《Java异步编程实战》笔记</title>
    <link href="https://agmtopy.gitee.io/2020/12/12/1.%E6%9D%82%E8%AE%B0/java%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2020/12/12/1.%E6%9D%82%E8%AE%B0/java%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-12T08:45:36.000Z</published>
    <updated>2021-03-27T16:13:16.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Java异步编程实战》笔记"><a href="#《Java异步编程实战》笔记" class="headerlink" title="《Java异步编程实战》笔记"></a>《Java异步编程实战》笔记</h1><h2 id="第一章-认识异步编程"><a href="#第一章-认识异步编程" class="headerlink" title="第一章 认识异步编程"></a>第一章 认识异步编程</h2><p>基础概念和场景介绍。略…</p><h2 id="第二章-显示使用线程和线程池实现异步编程"><a href="#第二章-显示使用线程和线程池实现异步编程" class="headerlink" title="第二章 显示使用线程和线程池实现异步编程"></a>第二章 显示使用线程和线程池实现异步编程</h2><p>线程和线程池的使用做了个简介，重点讲了一下线程池的实现原理</p><ul><li>线程池的实现原理<b>ThreadPoolExecutor</b></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>       w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>       w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allow interrupts</span>       <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>           <span class="token comment">//如果当前还有任务</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 判断线程池状态</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                   <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                       <span class="token comment">//执行任务</span>                       task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                       <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span>               <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                   task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                   w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                   w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>           <span class="token punctuation">&#125;</span>           completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>           <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意两个地方:1.Thread会被包装成worker对象用<b>HashSet</b>保存;2.Task是用<b>BlockingQueue</b>来进行保存</p></blockquote><h2 id="第三章-基于JDK中的Futrue实现异步编程"><a href="#第三章-基于JDK中的Futrue实现异步编程" class="headerlink" title="第三章 基于JDK中的Futrue实现异步编程"></a>第三章 基于JDK中的Futrue实现异步编程</h2><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><ul><li>run()</li><li>get()</li><li>cancel()<blockquote><p>注意一下FutureTask的state是用volatile进行修饰，结果outcome是用state的内存屏障技术来保证可见性的</p></blockquote></li></ul><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><ul><li>runAsync()</li><li>supplyAsync()</li><li>thenRun()</li><li>thenAccept()</li><li>thenApply()</li><li>whenComplete()</li><li>thenCompose()</li><li>thenCombine()</li><li>allOf()</li><li>anyOf()</li><li>completeExeceptionally() 异常处理</li></ul><blockquote><p>CompletableFuture默认是用ForkJoinPool,这里需要注意下</p></blockquote><h2 id="Spring框架中的异步执行"><a href="#Spring框架中的异步执行" class="headerlink" title="Spring框架中的异步执行"></a>Spring框架中的异步执行</h2><h3 id="TaskExecutor"><a href="#TaskExecutor" class="headerlink" title="TaskExecutor"></a>TaskExecutor</h3><p>略…</p><h3 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h3><p>@EnableAsync是通过AsyncConfigurationSelector进行加载，</p><h2 id="基于反应式编程实现异步编程"><a href="#基于反应式编程实现异步编程" class="headerlink" title="基于反应式编程实现异步编程"></a>基于反应式编程实现异步编程</h2><blockquote><p>反应式编程是一种涉及数据流和变化传播的异步编程范式。这意味着可以通过所采用的编程语言轻松的表达静态或动态数据流。</p></blockquote><p>反应式编程主要是强调对数据的处理过程是主动的，是以数据为核心参与对象的过程。传统的编程模型下是以业务流程为核心，通过业务流程将数据串联起来。</p><h3 id="Reactive-Streams规范"><a href="#Reactive-Streams规范" class="headerlink" title="Reactive Streams规范"></a>Reactive Streams规范</h3><blockquote><p> Reactive Streams规范是提供一个使用非阻塞回压功能对异步流进行处理的标准，也就是定义反应式编程的规范</p></blockquote><h3 id="基于RxJava实现异步编程"><a href="#基于RxJava实现异步编程" class="headerlink" title="基于RxJava实现异步编程"></a>基于RxJava实现异步编程</h3><p>==RxJava==是Reactive Extensions的java语言实现，具体的使用方法可参考官网</p><h3 id="基于Reactor实现异步编程"><a href="#基于Reactor实现异步编程" class="headerlink" title="基于Reactor实现异步编程"></a>基于Reactor实现异步编程</h3><p>==Reactor==是另外一个Java语言下的是Reactive实现，目前在webFlux中作为反应式框架进行使用</p><p>这里有一个软件发展的趋势就是传统的编程模型是基于cpu多核技术发展的还不是很好的时候提出来的，已经不太适用于现代多核cpu架构。因此基于现代cpu多核架构和传统软件架构面对的问题，提出了反应式编程模型。这种编程方式也许不是很便于人类理解，但是确拥有更高的资源利用率。如果未来出现一个像spring对于java那样对于反应式编程的框架，反应式编程理念应该会得到更好的发展。</p><h2 id="Web-Servlet的异步非阻塞处理"><a href="#Web-Servlet的异步非阻塞处理" class="headerlink" title="Web Servlet的异步非阻塞处理"></a>Web Servlet的异步非阻塞处理</h2><p>在Servlet3.0中提供了异步处理能力，让请求线程和处理线程不在是1：1的关系了,这里就可以更好的利用服务器的性能。<br>这里有一个问题什么Servlet 3才提出的异步处理能力喃？<br>这是因为servlet是基http1.1的方案，http1.1开始支持http可以保持长连接的形式，hhtp1.1方案是1999年开始<br>在Servlet3.1中提供了非阻塞I/O的处理方式:Web容器中的非阻塞请求处理有助于增加Web容器可同时处理请求的数量，允许我们在ServletInputStream上通过函数setReadListener注册一个监听器，该监听器在发现内核中有数据时才会进行回调处理函数。</p><h3 id="spring-MVC的异步处理能力"><a href="#spring-MVC的异步处理能力" class="headerlink" title="spring MVC的异步处理能力"></a>spring MVC的异步处理能力</h3><blockquote><p>Spring MVC是围绕前端控制器模式设计，由中央处理器Servlet DispatcheaServlet作为请求处理进行路由分派，实际请求处理工作由可配置处理类进行执行。在Spring MVC中通过调用request.startAsync()将ServletRequest设置为异步模式，这样可以让Servlet在推出的同时，让响应保持打开状态。</p></blockquote><h2 id="Spring-web-Flux"><a href="#Spring-web-Flux" class="headerlink" title="Spring web Flux"></a>Spring web Flux</h2><p>webFlux与spring mvc的对比<br><img src="https://docs.spring.io/spring-framework/docs/current/reference/html/images/spring-mvc-and-webflux-venn.png" alt="webFlux vs spring mvc"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.infoworld.com/article/2077995/java-concurrency-asynchronous-processing-support-in-servlet-3-0.html?page=1">infoworld关于servlet 3.0的介绍</a><br><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html">spring官网关于webFlux的文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《Java异步编程实战》笔记&quot;&gt;&lt;a href=&quot;#《Java异步编程实战》笔记&quot; class=&quot;headerlink&quot; title=&quot;《Java异步编程实战》笔记&quot;&gt;&lt;/a&gt;《Java异步编程实战》笔记&lt;/h1&gt;&lt;h2 id=&quot;第一章-认识异步编程&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="java并发" scheme="https://agmtopy.gitee.io/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础概念入门(二)</title>
    <link href="https://agmtopy.gitee.io/2020/11/29/1.%E6%9D%82%E8%AE%B0/Docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>https://agmtopy.gitee.io/2020/11/29/1.%E6%9D%82%E8%AE%B0/Docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8(%E4%BA%8C)/</id>
    <published>2020-11-29T13:32:37.000Z</published>
    <updated>2020-11-30T15:52:16.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h2><blockquote><p>Dockerfile文件是用来构建镜像的文本文件，文本文件中包含了一系列构建镜像所需的指令和说明</p></blockquote><h2 id="java基础环境"><a href="#java基础环境" class="headerlink" title="java基础环境"></a>java基础环境</h2><ul><li>Dockerfile</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 基础镜像版本</span>FROM java:latest<span class="token comment"># 设置工作目录</span>WORKDIR /app<span class="token comment"># 复制初始文件到工作目录中</span>COPY <span class="token builtin class-name">.</span> /app<span class="token comment"># 设置Java环境变量</span>ENV <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/binENV <span class="token assign-left variable">JRE_HOME</span><span class="token operator">=</span><span class="token variable">$&#123;JAVA_HOME&#125;</span>/jreENV <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>.:<span class="token variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="token variable">$&#123;JRE_HOME&#125;</span>/lib<span class="token comment"># 编译</span>RUN <span class="token punctuation">[</span><span class="token string">"/usr/lib/jvm/java-8-openjdk-amd64/bin/javac"</span>,<span class="token string">"Docker_java.java"</span><span class="token punctuation">]</span><span class="token comment"># 运行</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/usr/lib/jvm/java-8-openjdk-amd64/bin/java"</span>, <span class="token string">"Docker_java"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dockerfile文件需要在当前工作目录下编写，Docker_java.java文件也需要在当前工作目录下</p><ul><li><p>Docker_java.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Docker_java</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello Docker!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>build命令和启动命令</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -rm 表示构建完成后删除中间镜像</span><span class="token comment"># -f  表示指定Dockerfile文件,默认为当前目录下的Dockerfile文件 </span><span class="token comment"># -t  表示对镜像打tag</span>docker build --rm -f <span class="token string">"Dockerfile"</span> -t docker_java:0.0.1<span class="token comment">#运行命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>docker run docker_java:0.0.1</code></pre><pre class="line-numbers language-none"><code class="language-none">## mysql环境&gt; 构建一个账号名称为test,密码为test并且自定义初始化sqlmysql容器- Dockerfile&#96;&#96;&#96;bash#基础版本FROM mysql:5.7.22#环境变量ENV TZ&#x3D;Asia&#x2F;Shanghai \    MYSQL_DATABASE&#x3D;test \    MYSQL_USER&#x3D;test \    MYSQL_PASSWORD&#x3D;test \    MYSQL_ROOT_PASSWORD&#x3D;test#将sql目录下的文件全部拷贝到目标文件夹下COPY sql&#x2F;. &#x2F;docker-entrypoint-initdb.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>init.sql</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">USE</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>table_a<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>table_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>sync_pk<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>hos_code<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>study_iuid<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token punctuation">`</span>study_content<span class="token punctuation">`</span> <span class="token keyword">mediumtext</span> <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci <span class="token punctuation">,</span><span class="token punctuation">`</span>study_state<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>remark<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>sync_pk<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_unicode_ci <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>构建命令</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build --rm -f <span class="token string">"Dockerfile"</span> -t mysqlc:0.0.1 <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>运行命令<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#与mysql启动一致</span>docker run -itd --name mysql_local mysqlc:0.0.1 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Dockerfile文件&quot;&gt;&lt;a href=&quot;#Dockerfile文件&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile文件&quot;&gt;&lt;/a&gt;Dockerfile文件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Dockerfile文件是用来构建</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何优化复杂流程分析和建模思考</title>
    <link href="https://agmtopy.gitee.io/2020/11/08/1.%E6%9D%82%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E5%92%8C%E5%BB%BA%E6%A8%A1%E6%80%9D%E8%80%83/"/>
    <id>https://agmtopy.gitee.io/2020/11/08/1.%E6%9D%82%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E5%92%8C%E5%BB%BA%E6%A8%A1%E6%80%9D%E8%80%83/</id>
    <published>2020-11-07T17:02:10.000Z</published>
    <updated>2020-11-30T15:52:16.931Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>架构的核心挑战是如何处理当下或未来可能出现的快速增长的软件复杂性，因此越是大型系统在架构设计上越是要简单。</p></blockquote><h2 id="软件的复杂度为什么会增加？"><a href="#软件的复杂度为什么会增加？" class="headerlink" title="软件的复杂度为什么会增加？"></a>软件的复杂度为什么会增加？</h2><p>先阐述观点在实际开发中软件的复杂性是随着时间愈发陡峭的，复杂度的提升近似于y=x^2的曲线。主要是基于以下几个情况得出的结论：</p><ol><li><B>软件的复杂程度是逐渐迭代出来的</B><br>拿我之前的项目举例，最开始业务需求可能只是围绕商品的一个业务，根据这个业务设计流程，后来慢慢的迭代过程中逐渐把商品相关的属性完善从而又能支撑起开展其他的业务流程。随着业务流程的膨胀和交汇，软件的复杂度会不断的增加。</li><li><B>代码迭代过程中的理解和维护</B><br>软件对应的实体即为代码，在相同的架构下不同的理解会有不同的代码实现。由于大型项目往往是多人进行协作开发，需要统一大家的理解。通俗的说法就是多个人写出来的代码就像一个人写出来的一样，要完成这样的合作往往是很困难的。这里在补充阐述一下，并不是反对有着强烈个人代码风格的方式，主要还是想表达的是同一团队在面对同一项目时对软件的架构、技术、业务理解应该是尽量要<B>趋同<B>的。</li></ol><blockquote><p>业务架构师最重要的工作不是设计软件结构，而是应该通过API、团队设计准则、细节的关注把控来控制软件复杂度的增长。</p></blockquote><h2 id="如何定义软件复杂的维度？"><a href="#如何定义软件复杂的维度？" class="headerlink" title="如何定义软件复杂的维度？"></a>如何定义软件复杂的维度？</h2><p>软件的复杂度可以定义为让人理解和维护修改的困难程度，因此我们可以将软件的复杂程度拆分为两个部分</p><ol><li>软件的认知成本：理解软件的接口、设计和实现上的成本，简单说就是看懂代码的时间成本和脑力成本</li><li>软件的协同成本：修改维护软件时，所需要付出的成本<br>举个例子来说，软件的扩展性不好就是协同成本过高，会导致新增功能时需要进行大量修改，并且修改后还会进一步的增加认知负担</li></ol><h3 id="认知负担"><a href="#认知负担" class="headerlink" title="认知负担"></a>认知负担</h3><ol><li>定义新的概念带来的认知负担，这种负担与所定义的概念与现实模型的关联度相关</li><li>逻辑符合思维习惯的程度</li></ol><ul><li>逻辑是否符合思维习惯的程度，这个因人而异，最好在实际的开发过程中有统一的规范，例如强烈建议使用卫语句、使用Optional等</li><li>模型失配：模型的失配指的是定义的模型与现实世界的业务模型存在较大差异所带来的</li></ul><ol start="3"><li>接口设计不当</li></ol><ul><li><p>需要调用者使用初始化才能正常工作的接口。将初始化的职责放到了调用方，但是调用方在面对复杂的初始化参数时，就需要去了解每个参数所代表的动作和意义，承担了本来属于接口实现所承担的职责。这里可以使用工厂模式来进行处理，在接口工厂类中根据接口提供的场景进行处理</p></li><li><p>一个接口中不同的方法提供了相同的功能</p></li></ul><ol start="4"><li><p>违反开闭原则，一个简单的修改需要在多处中进行更新<br>在业务开发中，往往会为了进度或者害怕新的改动会改变已有代码的逻辑因此去copy-past大量类似的逻辑和功能，这样会导致一个简单的修改需要更多的精力在多处中进行去更新，代码的复杂度也会提高</p></li><li><p>命名 尽量要做到通过的命名就知道变量、方法、类、模块等要<B>做什么</B>，重点在于做什么上面而不是是什么上面。</p></li></ol><h3 id="协同成本"><a href="#协同成本" class="headerlink" title="协同成本"></a>协同成本</h3><blockquote><p>协同成本是新增、修改功能所付出的时间成本和脑力成本。</p></blockquote><ol><li><p>在微服务架构下，模块/服务的切分是和团队对齐的，即”组织架构决定系统架构”,组织架构最佳的划分是按照系统架构来进行的，当组织划分不好时，往往会导致重复的工作。</p></li><li><p>服务间相互依赖，服务间相互依赖主要有两种种形式组和、继承。继承会呈现出更强制的关系，因此也会有更大的协同复杂性。</p></li><li><p>可测试性带来的协同成本。这里指的是由于单元测试不完善需要更完善的集成测试来保证软件的正确性。</p></li><li><p>文档  降低协同成本的一个好方法就是完善文档，包括业务文档、设计文档、接口文档等，但是这部分工作并不会直接产生效益，因此积极性都不是很高。</p></li></ol><h2 id="如何应对软件不断增长的复杂度？"><a href="#如何应对软件不断增长的复杂度？" class="headerlink" title="如何应对软件不断增长的复杂度？"></a>如何应对软件不断增长的复杂度？</h2><p> 每一次无意识的代码的改动都会产生依赖/耦合从而增加系统的复杂性，软件的复杂程度恶化到一定程度后就会导致系统不可避免的失败。因此需要我们对复杂度增加采用零容忍的态度。</p><ul><li><p>软件的复杂度带来的影响往往是滞后的，在看到影响时也许已经过去了很久</p></li><li><p>在进行代码review时，每一个额外的复杂度设计在整个系统的角度下都显得微不足道，但是千里之堤以蝼蚁之溃。</p></li><li><p>破窗效应Broken window：一个建筑，当有了一个破窗而不及时修补，这个建筑就会被侵入住认为是无人居住的、风雨更容易进来，更多的窗户被人有意打破，很快整个建筑会加速破败。这就是破窗效应，在软件的质量控制上这个效应非常恰当,所以有问题尽快修补。</p><p>零容忍，并不是不让复杂度增长：我们都知道这是不可能的。我们需要的是尽力控制。因为进度而临时打破窗户也能接受，但是要尽快补上。</p><h2 id="基于复杂业务如何分析？"><a href="#基于复杂业务如何分析？" class="headerlink" title="基于复杂业务如何分析？"></a>基于复杂业务如何分析？</h2></li></ul><h3 id="业务的差异性"><a href="#业务的差异性" class="headerlink" title="业务的差异性"></a>业务的差异性</h3><p> if/else是由于业务上不同的场景会有不同的业务逻辑，这样的差异性可以很方便的用if/else实现，但是不符合开闭原则，在扩展时代码会堆砌的越来越庞大。</p><p> 如何消除if/else？</p><ul><li><p>多态扩展:利用面向对象的多态特性，实现代码的复用和扩展</p></li><li><p>代码分离:对不同的场景用不同的代码流程来实现业务和代码的隔离</p></li><li><p>多态扩展<br>多态扩展有继承和组合两种方式。继承的话不要使用重载特性，重载特性不是继承父类的方法。组合类似于策略模式，也就是把需要扩展的部分进行抽象、封装成需要被组合的对象。用多态的特性来移除业务的差异性，这样也更符合实体之间的关系。</p></li><li><p>代码分离<br>代码分离，代码的冗余和复用性不好，但是同样会达到业务代码彼此独立的状态</p></li></ul><h3 id="多维分析"><a href="#多维分析" class="headerlink" title="多维分析"></a>多维分析</h3><p>根据我们的分析在面对业务的差异时，我们可以用多态扩展和代码分离来实现，但是什么时候来用多态扩展？什么时候用代码分离楠?对于这个问题我们可以采用<B>矩阵分析法</B></p><p>我们可以用一个矩阵，纵轴代表业务场景、横轴代表步骤，里面的内容代表每一个动作，这样我们就可以得到这样的一个表格</p><table><thead><tr><th>-</th><th>step0</th><th>step1</th><th>step2</th></tr></thead><tbody><tr><td>business0</td><td>1.action0<br>2.action1</td><td>1.action1</td><td>1.action1<br>2.action2</td></tr><tr><td>business1</td><td>同上</td><td>同上</td><td>1.action1</td></tr><tr><td>business2</td><td>无</td><td>无</td><td>1.action1</td></tr></tbody></table><p>通过这样一个矩阵我们就可以分析出business0和business1适用于多态扩展，而business2更加适用于代码分离来进行实现。</p><p>这样的矩阵在OOP里被称为分析矩阵，主要是用来分析业务涉及要素过多、信息量太大的场景。</p><h3 id="流程分解"><a href="#流程分解" class="headerlink" title="流程分解"></a>流程分解</h3><p>流程分解是对业务过程进行详细的分解，然后在使用<B>结构化</B>的方法聚合成一个个step，在将step组合成业务，最后形成一个类似于金字塔形状自上而下的流程认知。</p><h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p>领域模型指的是模型对象避免使用贫血模式，而应该使用充血模式，让模型具有业务逻辑，从而在复用模型的时候就能复用业务逻辑。充血的模型也更符合现实模型中对象的定义。</p><h2 id="分析矩阵"><a href="#分析矩阵" class="headerlink" title="分析矩阵"></a>分析矩阵</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分析矩阵的定义来源于《设计模式解析》第16章,作者通过以下几个方法步骤完成对系统中变化的分析，从而设计出合适的模式</p><blockquote><p>1.找到某种特定情况下最重要的特性，并用矩阵将他们关联起来<br>2.继续处理其他情况，并且按需扩展矩阵<br>3.用新的概念扩展分析矩阵<br>4.在行维度发现规则<br>5.在列维度发现特定情况<br>6.从分析中确定模式<br>7.得到高层设计</p></blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>最开始需求很简单：只处理美国和加拿大的订单。系统必须进行处理的特性清单如下：</p><ul><li>为美国和加拿大构建一个销售订单系统</li><li>根据所在国家计算运费</li><li>运费还应该以所在国家的货币进行支付</li><li>在美国，税额需按当地计算</li><li>使用美国邮政规则验证地址</li><li>在加拿大使用联邦快递发货时，需要同时缴纳联邦政府销售税和地方销售税</li><li>加拿大邮寄包裹有违禁品邮寄限制</li><li>美国的订单号继承于加拿大订单号规则，又有所改变</li></ul><p>从使用场景我们可以得知，需求分为两种：美国、加拿大，因此我们可以根据需求场景分析得出这样的矩阵</p><table><thead><tr><th>情况</th><th>过程</th></tr></thead><tbody><tr><td>美国</td><td>1.使用美元计费<br>2.使用美国邮政规则校验地址<br>3.按照当地计算税额<br>4.美制加拿大规则订单号规则</td></tr><tr><td>加拿大</td><td>1.使用美元计费<br>2.使用美国邮政规则校验地址<br>3.按照加拿大规定计算销售税4. 违禁品邮寄限制5.加拿大规则订单号规则</td></tr></tbody></table><p>通过这样一个具有详细功能的矩阵，我们可以直接提炼出按照步骤进行分解的矩阵</p><table><thead><tr><th>步骤</th><th>美国</th><th>加拿大</th></tr></thead><tbody><tr><td>货币单位</td><td>美元</td><td>加元</td></tr><tr><td>校验规则</td><td>美国邮政规则</td><td>加拿大邮政规则</td></tr><tr><td>计算税额</td><td>美国税额政策</td><td>加拿大税额政策</td></tr><tr><td>邮寄限制</td><td>未知</td><td>加拿大邮寄限制</td></tr><tr><td>订单号规则</td><td>美制加拿大规则</td><td>加拿大规则</td></tr></tbody></table><p>通过这个矩阵我们发现美国的邮寄限制未知，这样我们可以询问业务专家得到答案。通过这样的矩阵我们还可以分析出</p><table><thead><tr><th>步骤</th><th>美国</th><th>加拿大</th></tr></thead><tbody><tr><td>货币单位</td><td>多态扩展</td><td>多态扩展</td></tr><tr><td>校验规则</td><td>代码分离</td><td>代码分离</td></tr><tr><td>计算税额</td><td>代码分离</td><td>代码分离</td></tr><tr><td>邮寄限制</td><td>代码分离</td><td>代码分离</td></tr><tr><td>订单号规则</td><td>多态扩展</td><td>多态扩展</td></tr></tbody></table><blockquote><p>参考文档</p></blockquote><ul><li><a href="https://developer.aliyun.com/article/770886">警惕软件复杂度困局</a></li><li><a href="https://mp.weixin.qq.com/s/u7geoZNpLtfr_crkXVHjAg">面对复杂业务，if-else coder 如何升级</a></li><li><a href="https://developer.aliyun.com/article/712581">如何写复杂业务代码？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;架构的核心挑战是如何处理当下或未来可能出现的快速增长的软件复杂性，因此越是大型系统在架构设计上越是要简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;软件的复杂度为什么会增加？&quot;&gt;&lt;a href=&quot;#软件的复杂度为什么会增加？&quot; clas</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="领域建模" scheme="https://agmtopy.gitee.io/tags/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
</feed>
