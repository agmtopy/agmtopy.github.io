<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2025-03-09T14:14:18.168Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何深入理解ChatGPT等大语言模型-笔记</title>
    <link href="https://agmtopy.gitee.io/2025/03/07/1.%E6%9D%82%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ChatGPT%E7%AD%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2025/03/07/1.%E6%9D%82%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ChatGPT%E7%AD%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B-%E7%AC%94%E8%AE%B0/</id>
    <published>2025-03-07T15:49:06.000Z</published>
    <updated>2025-03-09T14:14:18.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何深入理解ChatGPT等大语言模型-笔记"><a class="header-anchor" href="#如何深入理解ChatGPT等大语言模型-笔记"></a>如何深入理解ChatGPT等大语言模型-笔记</h2><p>根据Andrej Kaparthy分享的<a href="https://www.youtube.com/watch?v=7xTGNNLPyMI">Deep Dive into LLMs like ChatGPT</a>视频，以下是我在学习过程中的一些笔记：</p><h3 id="预训练阶段"><a class="header-anchor" href="#预训练阶段"></a>预训练阶段</h3><ul><li>数据收集阶段</li></ul><ol><li>收集数据,通过爬虫技术收集大量文本数据</li><li>对数据进行清洗,去除无用信息</li><li>压缩数据,形成词表(token)</li></ol><ul><li>构建神经网络模型</li></ul><ol><li>根据词表预测下一个词的概率</li><li>对概率进行调整,使其更加正确,也就是<B>神经网络训练的过程</B><br>这里使用的是Transformer模型,这个不太懂 TODO,后面在了解</li></ol><ul><li>推理过程<br>推理过程简单来说就是根据步骤2生成的模型,在结合输入的文本,预测下一个词的概率;</li></ul><h4 id="基础模型"><a class="header-anchor" href="#基础模型"></a>基础模型</h4><ol><li>基础模型也具备上下文学习能力</li></ol><h3 id="监督式-微调阶段"><a class="header-anchor" href="#监督式-微调阶段"></a>监督式-微调阶段</h3><p>由于基础模型只能做到预测下一个词语的能力,不能理解文本的含义,所以需要对基础模型进行微调<br>微调的方式是通过对话的方式来进行调整,然后将调整后的数据重新训练基础模型,使其具备对话的能力</p><p>类似的文档数据集,可以参考(Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT)[<a href="https://huggingface.co/datasets/Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT">https://huggingface.co/datasets/Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT</a>]</p><p>微调阶段更重要的作用是修正基础模型的一些错误,使其更加准确,以及让模型知道自己的边界在哪里,从而解决<B>模型幻觉问题 </B></p><ul><li>模型需要分步思考<br>LLM模型在给出结果时,会依赖上一步输出的token,因此要避免一个步骤中就让模型给出最终的答案,而是分步思考,使用上一步的输出作为下一步的输入,这样可以减少模型幻觉问题或者让模型使用其他工具来实现;</li></ul><h3 id="强化学习阶段"><a class="header-anchor" href="#强化学习阶段"></a>强化学习阶段</h3><p><B>强化学习</B>指的是模型在给出答案后,会根据结果来增加能输出正确答题的路径的概率,减少错误答案的路径的概率,在不断的迭代中,模型会更加准确;<br>对于有明确答案的问题,可以使用LLM评判模型给出的答案是否正确,从而进行强化学习;<br>对于没有明确答案的问题,通常使用另外一个神经网络模型来模拟人类的评判标准,来进行评分,从而进行强化学习;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fineweb-v1">FineWeb: decanting the web for the finest text data at scale</a><br><a href="https://tiktokenizer.vercel.app/?model=cl100k_base">Tiktokenizer</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何深入理解ChatGPT等大语言模型-笔记&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#如何深入理解ChatGPT等大语言模型-笔记&quot;&gt;&lt;/a&gt;如何深入理解ChatGPT等大语言模型-笔记&lt;/h2&gt;
&lt;p&gt;根据Andrej Kaparthy</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="AI" scheme="https://agmtopy.gitee.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>第一章-前言</title>
    <link href="https://agmtopy.gitee.io/2024/12/12/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E8%A8%80/"/>
    <id>https://agmtopy.gitee.io/2024/12/12/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E8%A8%80/</id>
    <published>2024-12-12T13:08:02.000Z</published>
    <updated>2025-03-06T15:24:57.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-前言"><a class="header-anchor" href="#第一章-前言"></a>第一章-前言</h2><h3 id="互联网架构演变历史"><a class="header-anchor" href="#互联网架构演变历史"></a>互联网架构演变历史</h3><h4 id="1-业务架构"><a class="header-anchor" href="#1-业务架构"></a>1. 业务架构</h4><p>1.1 单体架构<br>在互联网早期发展中,主要以单体架构为主,按照业务-&gt;应用层-&gt;数据层进行简单划分;<br>每一个业务系统就是一个单独的业务团队,数据和人员(组织关系)都是独立的,造成数据隔离和组织单体化的问题;</p><p>1.2 中台战略<br>由阿里提出来的,理念是<B>共享</B>,共享业务、系统、组织架构上的一种落地方式和实施办法;<br>关键字:共享、节约成本、协助;<br>中台战略主要分为数据中台和业务中台两层能力,如图所示:</p><p>#TODO</p><p>1.3 去中台战略</p><ol><li>中台的复用率不高,提炼和维护中台所花费的代价抵不上中台复用带来的价值</li></ol><h4 id="2-数据架构"><a class="header-anchor" href="#2-数据架构"></a>2. 数据架构</h4><ul><li>数据库架构</li></ul><ol><li><p>单体数据库架构<br>web项目通过JDBC直连单体数据库</p></li><li><p>主从读写<br>数据库采用读写分离架构,主库负责写操作,从库负责读操作;<br>涉及到的中间件:sharding-jdbc,mycat</p></li><li><p>分库分表<br>分库分表有两种方式:一种是横向切分,一种是纵向切分:</p></li></ol><ul><li><p>横向拆分指的是按照记录进行拆分</p></li><li><p>纵向拆分指的是按照字段进行拆分</p></li><li><p>高速缓存<br>引入redis来解决热数据的问题;<br>缓存带来的问题:</p></li></ul><ol><li>缓存击穿(单一key失效)</li><li>缓存穿透(无效key访问)</li><li>缓存雪崩(大量key失效)</li><li>缓存一致性</li></ol><ul><li>数据多样化</li></ul><ol><li>分布式文件系统:HDFS,FastDFS</li><li>nosql:mongodb,redis</li><li>搜索引擎:Elasticsearch</li></ol><h4 id="3-应用架构"><a class="header-anchor" href="#3-应用架构"></a>3. 应用架构</h4><ol><li><p>单机调优<br>上古时代使用tomcat或者jboos进行部署时,对单机进行调优,比如JVM参数优化、数据库连接池优化等;</p></li><li><p>动静分离<br>前端静态资源独立部署到前置服务器上</p></li><li><p>SOA架构<br>SOA架构需要引入ESB(企业服务总线)来进行整体调度</p></li><li><p>微服务架构<br>微服务架构是SOA架构的一种改进,微服务架构是一套系统和理念;</p></li></ol><h4 id="4-部署架构"><a class="header-anchor" href="#4-部署架构"></a>4. 部署架构</h4><ol><li><p>单机部署<br>小型项目直接部署到单机上</p></li><li><p>集群部署<br>集群部署主要是为了解决单机瓶颈问题,比如单机CPU、内存、IO瓶颈;</p></li><li><p>多层代理<br>多层代理使用负载均衡器来解决单机瓶颈问题;</p></li><li><p>异地访问<br>异地访问主要是为了解决跨地域访问延迟问题;</p></li><li><p>云平台<br>云平台主要是为了解决自建机房的成本问题,通常使用docker、k8s等技术;</p></li></ol><h4 id="5-架构思想"><a class="header-anchor" href="#5-架构思想"></a>5. 架构思想</h4><ol><li>知行合一,做之前,先思考意义</li><li>原生由于定制,约定大于配置</li><li>什么都要,最后什么都要不了</li><li>控制技术欲,不要瞎折腾</li><li>留下扩展,但是不要想到100年以后</li><li>没有最好的,只有最合适的</li><li>够用就好,用的越花,风险越大</li><li>简约最美</li></ol><h3 id="容器化技术概览"><a class="header-anchor" href="#容器化技术概览"></a>容器化技术概览</h3><p>应用部署方式的演变:从硬件虚拟化(操作系统虚拟化))到容器虚拟化(容器虚拟化的演变;</p><h4 id="什么是容器化"><a class="header-anchor" href="#什么是容器化"></a>什么是容器化</h4><blockquote><p>容器化是将应用程序或服务及其依赖或者配置,一起打包为容器映像的一种软件构建及部署技术;</p></blockquote><p><img src="" alt="容器化架构"></p><ul><li>什么是docker</li></ul><blockquote><p>docker是go语言研发的容器引擎,基于容器化技术和沙箱机制的应用部署技术;<br>可适用于自动化测试、打包、持续集成、发布等场景,以下是Docker的优点:</p></blockquote><ol><li>更高效的系统资源利用率</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>更轻松的迁移</li></ol><p>当然docker也有缺点:</p><ol><li>隔离性不如虚拟机</li><li>性能高于虚拟机,但是低于物理机</li></ol><p>docker的应用场景:<br>1.微服务部署场景<br>2. DevOps场景</p><p>额外需要注意的是,对docker文件的修改只会体现在当前层,对其他层的修改会采用标记删除-复制修改的方式进行;</p><h3 id="Zookeeper"><a class="header-anchor" href="#Zookeeper"></a>Zookeeper</h3><h3 id="Zookeeper基础及高级应用"><a class="header-anchor" href="#Zookeeper基础及高级应用"></a>Zookeeper基础及高级应用</h3><ul><li><p>Zookeeper数据模型<br>Zookeeper的数据模型是一个树形目录结构,类似于文件系统的目录结构,通过k-v的方式来进行存储,key是由’/'分割的路径;<br>每个Znode节点可以存储的数据大小为1MB,选择1Mb的原因是基于zookeeper作为分布式协调服务的高性能和稳定性考量,其设计初衷就是用于协调服务,而非存储大量数据;</p></li><li><p>Zookeeper节点类型</p></li></ul><ol><li>持久化节点(默认类型)</li><li>持久化顺序节点</li><li>临时节点</li><li>临时顺序节点<br>另外还有容器节点和超时节点等</li></ol><h4 id="Zookeeper应用场景"><a class="header-anchor" href="#Zookeeper应用场景"></a>Zookeeper应用场景</h4><ul><li>分布式锁</li></ul><blockquote><p>分布式锁指的是在分布式环境下,跨进程\跨主机\跨网络的共享资源,实现互斥访问,保证一致性;在Zookeeper中,锁就是一个数据节点;</p></blockquote><p>普通实现:通过注册<B>临时节点</B>,各个客户端抢占创建临时节点的方式,来获取锁,其他未抢占到该节点的客户端通过监听该节点的变化来重新获取锁;<br>这种方式存在的问题是: 羊群效应,指的是持有锁的客户端释放锁之后,其他所有客户端由于是通过watch机制监听该节点,导致所有客户端都会收到通知,然后重新发起竞争锁的请求,从而造成大量无效竞争;<br>解决方案是:通过临时顺序节点,每个客户端在创建锁的时候,都会创建一个临时顺序节点,然后通过监听前一个节点的变化来获取锁;</p><ul><li>分布式锁-读写锁</li></ul><blockquote><p>通过Zk实现分布式读写锁,是通过将临时顺序节点分为<B>读锁节点</B>和<B>写锁节点</B>来进行实现;</p></blockquote><ol><li>读请求时,通过判断当前读节点,如果没有比自己更小的节点或者比自己小的节点都是读节点,那么获取读锁成功,如果比自己小的节点中有写锁节点,那么获取读锁失败;</li><li>写请求时,通过判断当前写节点,如果没有比自己更小的节点,那么获取读锁成功,如果自己不是最小的节点,那么获取读锁失败;</li><li>读锁或者写锁完成操作后,都要进行释放;</li></ol><ul><li>配置中心</li></ul><blockquote><p>使用zookeeper作为配置中心,主要是通过客户端来监听配置节点的变化来实现;</p></blockquote><ul><li>注册中心</li></ul><blockquote><p>使用zookeeper作为注册中心,是通过客户端来注册服务节点,调用端监听服务节点的变化来实现;</p></blockquote><ul><li>Curator客户端的实现</li></ul><ol><li>InterProcessMutex:分布式可重入排他锁</li><li>InterProcessSemaphoreV2:分布式信号量</li></ol><h4 id="Zookeeper选举策略"><a class="header-anchor" href="#Zookeeper选举策略"></a>Zookeeper选举策略</h4><ul><li>ZAB协议</li></ul><p>Zookeeper的选举策略是基于ZAB协议来进行实现的,ZAB协议是一种对<B>Paxos算法</B>的简化实现,是专门未Zookeeper设计的支持崩溃恢复的原子广播协议;<br>基于该协议zk实现了一种主备模式(即Leader和Follower模式)的系统架构来保证集群中的各个节点的数据一致性;<br>在ZAB协议下,节点分为两个角色:<B>Leader</B>和<B>Follower</B>,第三个角色是Observer,Observer不参与投票;<br>Leader: 唯一，负责写操作和协调,一个zk集群中同一时刻只会有一个Leader,Leader发起并维护与各个follower和Observer的心跳,Leader通过心跳来维护集群中各个节点的状态,同时将写操作广播到各个节点<br>Follower: 多数，负责读操作并参与选举,同时Follower会响应Leader的心跳,并且接受Leader的写操作广播;Follower也可以响应客户端的写操作,然后将写操作转发给Leader,来进行完成;<br>Observer: 可选，专注于读操作，不参与选举,Observer的设计是为了提供读能力,因此被设计为数据是满足最终一致性的,因此可能会有读取数据延迟的问题,解决这个问题的方法是:1.强制Sync,2.客户端优先连接到Leader或者follower,3.对于强一致性的业务场景不使用Observer;</p><ul><li>ZAB协议的两种模式</li></ul><ol><li>崩溃恢复模式:一旦Leader服务器进入崩溃或者网络原因导致与集群中的过半follower失去连接,那么就会进入崩溃恢复模式;zk集群会进入选举阶段,通过投票的方式来选出新的Leader;</li><li>消息广播模式:Leader选出之后,就会进入消息广播模式;在该模式下,Leader会进行消息广播,需要注意的是<B>满足过半节点即可</B>,这是和Paxos算法的区别;</li></ol><ul><li>zk的选举过程<br>Zookeeper的选举过程分为两类,第一类是<B>服务器启动时的Leader选举流程</B>、<B>异常恢复场景Leader的选举过程</B><br>首先介绍几个概念:</li></ul><ol><li>zxid:zxid是一个64位的数字,高32位是epoch(leader纪元),低32位是当前leader纪元内事务ID,节点初始化时为0|0;</li><li>serverid:也被称为<B>myId</B>,代表服务器的ID,是一个32位的数字,初始化是通过myid文件进行初始化的;</li><li>Quorum:集群中过半的节点数量;</li></ol><p>leader选举流程大致可以分为以下几个步骤:</p><ol><li>集群启动时,每个节点都会初始化自己的zxid和serverid;</li><li>集群启动时,每个节点都会发起投票,投的都是自己,并且将投票信息广播出去</li><li>每个节点通过对比自己的(zxid,serverid)和接收到的投票信息,来确定自己的投票结果,并且将投票信息广播出去;</li><li>当某个节点收到的投票信息数量达到过半时,该节点就会成为Leader;</li><li>Leader选举完成后,Leader会进行消息广播;</li></ol><h4 id="Zookeeper集群-ZAB协议"><a class="header-anchor" href="#Zookeeper集群-ZAB协议"></a>Zookeeper集群&amp;ZAB协议</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章-前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#第一章-前言&quot;&gt;&lt;/a&gt;第一章-前言&lt;/h2&gt;
&lt;h3 id=&quot;互联网架构演变历史&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#互联网架构演变历史&quot;&gt;&lt;/a&gt;互联</summary>
      
    
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>深入分析JavaParser原理之基础用法(一)</title>
    <link href="https://agmtopy.gitee.io/2024/09/13/23.JavaParser%E5%88%86%E6%9E%90/1.%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90JavaParser%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>https://agmtopy.gitee.io/2024/09/13/23.JavaParser%E5%88%86%E6%9E%90/1.%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90JavaParser%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</id>
    <published>2024-09-13T13:00:29.000Z</published>
    <updated>2024-10-21T16:46:45.113Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分析JavaParser原理之基础用法(一)</h1><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>JavaParser是一个基于JavaCC的开源项目，它是一个解析器生成器和抽象语法树(AST)处理工具</p><h2 id="使用示例"><a class="header-anchor" href="#使用示例"></a>使用示例</h2><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分析JavaParser原理之基础用法(一)&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;JavaParser是一个基于JavaCC的开源项目，它是一个解析器生成器和抽象语法树</summary>
      
    
    
    
    <category term="JavaParser" scheme="https://agmtopy.gitee.io/categories/JavaParser/"/>
    
    
    <category term="JavaParser" scheme="https://agmtopy.gitee.io/tags/JavaParser/"/>
    
  </entry>
  
  <entry>
    <title>JDK21对比JDK8语法升级指南</title>
    <link href="https://agmtopy.gitee.io/2024/04/01/12.JVM/51.jdk21%E5%AF%B9%E6%AF%94jdk8%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/"/>
    <id>https://agmtopy.gitee.io/2024/04/01/12.JVM/51.jdk21%E5%AF%B9%E6%AF%94jdk8%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/</id>
    <published>2024-04-01T14:06:00.000Z</published>
    <updated>2024-05-23T15:37:17.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK21对比JDK8语法升级指南"><a class="header-anchor" href="#JDK21对比JDK8语法升级指南"></a>JDK21对比JDK8语法升级指南</h2><p>JDK8经过JDK11(LTS)、JDK17(LTS)、JDK21(LTS)等多个长期支持JDK版本,目前最新版本已经到了JDK22(non lts),下一个长期支持版本为JDK25,因此长时间内JDK21都会是一个生产版本,下面从三个三个方面了解JDK8升级到JDK21中语法层面的内容:<B>新语法特性</B>、<B>新API</B>、<B>并发</B>;</p><h3 id="新语法特性"><a class="header-anchor" href="#新语法特性"></a>新语法特性</h3><ol><li><p>Record<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/RecordKeyword1.java">RecordKeyword1.java</a><br><a href="(https://openjdk.org/jeps/432)">JEP 432: Record Patterns (Second Preview)</a></p></li><li><p>instanceof增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Instanceof2.java">Instanceof2.java</a><br><a href="https://openjdk.org/jeps/394">JEP 394: Pattern Matching for instanceof</a></p></li><li><p>Sealed Classes:密封类<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Permits3.java">Permits3.java</a><br><a href="https://openjdk.org/jeps/397">JEP 397: Sealed Classes (Second Preview)</a></p></li><li><p>TextBlock:文本块增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/TextBlock4.java">TextBlock4.java</a><br><a href="https://openjdk.org/jeps/378">JEP 378: Text Blocks</a></p></li><li><p>switch增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Switch6.java">Switch6.java</a><br><a href="https://openjdk.org/jeps/361">JEP 361: Switch Expressions</a></p></li><li><p>var:局部变量类型<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Var7.java">Var7.java</a><br><a href="https://openjdk.org/jeps/323">JEP 323: Local-Variable Syntax for Lambda Parameters</a></p></li><li><p>Interface Private Method<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/InterfacePrivate8.java">InterfacePrivate8</a><br><a href="https://openjdk.org/jeps/213">JEP 213: Milling Project Coin</a></p></li></ol><h3 id="新API"><a class="header-anchor" href="#新API"></a>新API</h3><ol><li><p>Collection:集合新增方法<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/SequencedCollection1.java">SequencedCollection1.java</a><br>[<a href="https://openjdk.org/jeps/431">https://openjdk.org/jeps/431</a>](JEP 431: Sequenced Collections)</p></li><li><p>BigDecimal.Two<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/BigDecimalTwo4.java">BigDecimalTwo4.java</a></p></li><li><p>HexFormat:16进制转换<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/HexFormat5.java">HexFormat5.java</a></p></li><li><p>Stream.toList<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StreamToList6.java">StreamToList6.java</a></p></li><li><p>Stream.MapMulti:flatMap<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StreamToList6.java">StreamToList6.java</a></p></li><li><p>Collectors.Teeing:集合合并<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/CollectorsTeeing8.java">CollectorsTeeing8.java</a></p></li><li><p>String增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StringIncrease9.java">StringIncrease9.java</a></p></li><li><p>Collectors.of:集合初始化<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/CollectionsFactoryMethods10.java">CollectionsFactoryMethods10.java</a></p></li><li><p>Flow API:实现响应式规范<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/MyPublisher11.java">MyPublisher11.java.java</a></p></li><li><p>Arrays.Mismatch:差集<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/ArraysMismatch12.java">ArraysMismatch12.java</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDK21对比JDK8语法升级指南&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JDK21对比JDK8语法升级指南&quot;&gt;&lt;/a&gt;JDK21对比JDK8语法升级指南&lt;/h2&gt;
&lt;p&gt;JDK8经过JDK11(LTS)、JDK17(LTS)、JDK2</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>1.高并发系统实战-如何解决缓存不同步</title>
    <link href="https://agmtopy.gitee.io/2024/02/27/21.%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/"/>
    <id>https://agmtopy.gitee.io/2024/02/27/21.%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/</id>
    <published>2024-02-27T13:35:37.000Z</published>
    <updated>2024-03-09T03:40:30.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高并发系统实战-如何解决缓存不同步"><a class="header-anchor" href="#高并发系统实战-如何解决缓存不同步"></a>高并发系统实战-如何解决缓存不同步</h2><p>使用缓存需要注意的地方:</p><ol><li>使用缓存需要考虑性价比</li><li>防止穿透缓存直接查询数据库场景</li><li>设置TTL</li></ol><p>缓存数据刷新场景:</p><ol><li><p>单条数据更新场景<br>常见的方法是通过’先更新数据库在删除缓存’的方式来进行出来,更严格的场景是通过延迟双删或者MQ的方式通知删除</p></li><li><p>避免大量临时缓存同时到期失效</p></li><li><p>对于高并发更新缓存的场景可以采用’singleflight(请求合并)'来进行优化</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高并发系统实战-如何解决缓存不同步&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#高并发系统实战-如何解决缓存不同步&quot;&gt;&lt;/a&gt;高并发系统实战-如何解决缓存不同步&lt;/h2&gt;
&lt;p&gt;使用缓存需要注意的地方:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用缓存需要</summary>
      
    
    
    
    <category term="极客时间" scheme="https://agmtopy.gitee.io/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
    
    <category term="高并发" scheme="https://agmtopy.gitee.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="缓存" scheme="https://agmtopy.gitee.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之美</title>
    <link href="https://agmtopy.gitee.io/2023/11/25/13.LeetCode/20.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E4%B8%80/"/>
    <id>https://agmtopy.gitee.io/2023/11/25/13.LeetCode/20.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E4%B8%80/</id>
    <published>2023-11-25T09:20:21.000Z</published>
    <updated>2023-11-27T15:00:12.072Z</updated>
    
    <content type="html"><![CDATA[<h1>数据结构与算法之美</h1><h2 id="链表"><a class="header-anchor" href="#链表"></a>链表</h2><p><img src="https://github.com/agmtopy/noteBook/blob/bcb7ec20e534a7a98747839531829e14b116a23b/png/J-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/S-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89.png?raw=true" alt="链表的定义"></p><p>链表的主要比较对象是数组,最大的差别在于内存空间是否连续不连续上,对于不连续的内存空间就需要<B>索引</B>或<B>下标</B>方式来标识;</p><p>回文串问题如何解决?</p><p>链表解决技巧:</p><ol><li>理解指针或引用的含义</li><li>警惕指针丢失和内存泄漏</li><li>哨兵概念,利用哨兵节点简化编程难度,用哨兵节点来屏蔽首尾节点的特殊处理逻辑</li><li>重点留意边界条件处理<br>如果链表为空时，代码是否能正常工作？<br>如果链表只包含一个结点时，代码是否能正常工作？<br>如果链表只包含两个结点时，代码是否能正常工作？<br>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li><li>画图举例操作</li></ol><p>练习题LeetCode对应编号：206，141，21，19，876</p><h2 id="栈"><a class="header-anchor" href="#栈"></a>栈</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;数据结构与算法之美&lt;/h1&gt;
&lt;h2 id=&quot;链表&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/agmtopy/noteBook/blob/bcb7ec2</summary>
      
    
    
    
    <category term="算法" scheme="https://agmtopy.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://agmtopy.gitee.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>深入理解分布式事务-原理与实践-分布式事务基础</title>
    <link href="https://agmtopy.gitee.io/2023/11/21/19.%E5%88%86%E5%B8%83%E5%BC%8F/1.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E4%B8%80/"/>
    <id>https://agmtopy.gitee.io/2023/11/21/19.%E5%88%86%E5%B8%83%E5%BC%8F/1.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E4%B8%80/</id>
    <published>2023-11-20T16:03:27.000Z</published>
    <updated>2023-12-21T16:13:34.194Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式事务基础</h1><h2 id="事务的基本概念"><a class="header-anchor" href="#事务的基本概念"></a>事务的基本概念</h2><h3 id="ACID"><a class="header-anchor" href="#ACID"></a>ACID</h3><ol><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ol><h3 id="事务的类型"><a class="header-anchor" href="#事务的类型"></a>事务的类型</h3><ul><li><p>扁平事务<br>事务操作中最常见、最简单的事务,无法单独提交整个事务中的部分事务,只能把整个事务全部提交或者回滚;</p></li><li><p>带有保存点的扁平事务<br>内部带有保存点的事务,可以将当前事务回滚到此位置;</p></li><li><p>链式事务<br>链式事务是在带有保存点的扁平事务的基础上,自动将当前事务的上下文隐式的传递给下一事务,也就是说一个事务的提交操作和下一个事务的开始操作合并在一起是具备原子性的;</p></li><li><p>嵌套事务<br>嵌套事务指的是有多个事务处于嵌套状态,共同完成一项任务的处理,整个任务具备原子性;嵌套事务最外层有一个顶层事务,只有当顶层事务完成后才会整体提交;</p></li><li><p>分布式事务基础<br>分布式事务指的是事务的参与者、事务所在的服务器、涉及的资源服务器以及事务管理器分别位于不同的分布式系统下的一个整体事务;</p></li></ul><h3 id="本地事务"><a class="header-anchor" href="#本地事务"></a>本地事务</h3><p>本地事务通常是由关系型数据库本身的事务特性来进行实现的,优缺点:</p><p>优点:</p><ol><li>严格支持ACID特性</li><li>事务可靠,关系型数据的事务是经过严格论证的</li><li>本地事务执行效率高</li><li>事务是由DBMS完成</li><li>不涉及网络通信</li></ol><p>缺点:</p><ol><li>不具备分布式事务的处理能力</li><li>一次事务处理过程只能连接一个支持事务的数据库,即不能用于多个事务性数据库;</li></ol><h3 id="MySql事务基础"><a class="header-anchor" href="#MySql事务基础"></a>MySql事务基础</h3><ul><li>并发带来的问题</li></ul><ol><li>更新丢失</li><li>脏读</li></ol><h2 id="Mysql事务的实现原理"><a class="header-anchor" href="#Mysql事务的实现原理"></a>Mysql事务的实现原理</h2><h2 id="Spring事务的实现原理"><a class="header-anchor" href="#Spring事务的实现原理"></a>Spring事务的实现原理</h2><h2 id="分布式事务的基本概念"><a class="header-anchor" href="#分布式事务的基本概念"></a>分布式事务的基本概念</h2><h2 id="分布式事务的理论基础"><a class="header-anchor" href="#分布式事务的理论基础"></a>分布式事务的理论基础</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式事务基础&lt;/h1&gt;
&lt;h2 id=&quot;事务的基本概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#事务的基本概念&quot;&gt;&lt;/a&gt;事务的基本概念&lt;/h2&gt;
&lt;h3 id=&quot;ACID&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#AC</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="读书笔记" scheme="https://agmtopy.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计_实现领域驱动设计-第二章</title>
    <link href="https://agmtopy.gitee.io/2023/10/28/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://agmtopy.gitee.io/2023/10/28/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-10-28T14:08:00.000Z</published>
    <updated>2023-11-20T15:53:38.008Z</updated>
    
    <content type="html"><![CDATA[<h1>如何理解领域、子域和限界上下文</h1><p>从三个问题开始:</p><ol><li>什么是领域?</li><li>什么是子域?</li><li>什么是限界上下文?</li></ol><h2 id="什么是领域"><a class="header-anchor" href="#什么是领域"></a>什么是领域?</h2><blockquote><p>从广义上来讲,<B>领域</B>是一个组织所做的事情以及其中包含的一切;</p></blockquote><p>这段话的解释应该是,领域是公司或组织所要提供的服务所对应的所有事情,这些事情就是领域;</p><p><B>领域</B>这个词的范围很大,承载太多的含义,领域既可以表示整个系统,也可以标识其中的某个核心域或者支撑子域;在DDD中一个领域被划分为多个<B>子域</B>,领域模型在<B>限界上下文</B>上下文中完成设计/开发;</p><p><img src="https://github.com/agmtopy/noteBook/blob/99706f9bc20ab65b10cc39b038f0b4248b599af3/png/s-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9B%BE2.1%E4%B8%80%E4%B8%AA%E5%90%AB%E6%9C%89%E5%AD%90%E5%9F%9F%E5%92%8C%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E9%A2%86%E5%9F%9F,%E6%A8%A1%E5%9E%8B.png?raw=true" alt=""></p><p>看一个含有子域和限界上下文的领域模型例子:</p><p>最外层中最大的实线表示的就是这个领域驱动模型中的<B>领域</B>,这个领域表示的是一个电子商务系统的领域是由于多个子域和限界上下文组成;<br>在内层中用虚线划分出来的就是<B>子域</B>,可以看到在<B>电子商务系统</B>的领域下有产品目录子域、订单子域、发票子域、物流子域;<br>在内层中还可以看到实线划分出来的<B>界限上下文</B>,界限上下文将不同的子域连接在了一起;</p><p>从上述的例子中<B>电子商务系统</B>就是一个领域,它表示的是电商公司的核心业务,这样我们可以得出领域即业务的结论;</p><h2 id="什么是子域"><a class="header-anchor" href="#什么是子域"></a>什么是子域;</h2><p>从上面的例子中可以看到子域就是更小的范围,子域并不是一定要做的很大,并且包含很多的功能;有些时候,子域可以简单到只包含一套算法,这套算法可能对于业务系统来说非常重要,但是并不包含在这套系统的核心域中;</p><p>子域又可以被划分成:<B>核心域</B>、<B>支撑域</B>、<B>通用域</B>三个部分;</p><p><img src="https://github.com/agmtopy/noteBook/blob/36f56f3815b4b3b5abcf5231aa48ae19410365d3/png/s-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9B%BE2.2%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E5%AD%90%E5%9F%9F%E5%92%8C%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png?raw=true" alt=""></p><p><B>核心域</B>是最高优先级、最资深的领域转换和最优秀的开发团队进行主导,在实施DDD的过程中,需要关注核心域;<br><B>支撑域</B>通常是用来支撑我们的业务的,虽然对于业务的某些方面重要,但是不是核心;<br><B>通用域</B>指的是可以被应用与整个业务系统,类似于基础框架,底层模型;</p><p>实施DDD的过程中应该尽量避免将关注点聚焦在<B>实体</B>、<B>值对象</B>之上,这样会导致缺少一种更广阔的视野,会导致不同的核心杂糅在一起,导致他们将两个模型创建成一个;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;如何理解领域、子域和限界上下文&lt;/h1&gt;
&lt;p&gt;从三个问题开始:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是领域?&lt;/li&gt;
&lt;li&gt;什么是子域?&lt;/li&gt;
&lt;li&gt;什么是限界上下文?&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;什么是领域&quot;&gt;&lt;a class=&quot;header-ancho</summary>
      
    
    
    
    <category term="领域驱动" scheme="https://agmtopy.gitee.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/"/>
    
    
    <category term="领域驱动" scheme="https://agmtopy.gitee.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码分析(一)</title>
    <link href="https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/20.Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/20.Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/</id>
    <published>2023-06-27T15:14:13.000Z</published>
    <updated>2023-07-30T08:21:47.088Z</updated>
    
    <content type="html"><![CDATA[<h1>Netty源码分析(一)</h1><h2 id="简述"><a class="header-anchor" href="#简述"></a>简述</h2><p>从IO到NIO体现了java对于流操作的一个变迁,在到构建Netty,这一个系列文章主要讲述的就是Netty框架,第一篇文章从NIO出发;<br>主要分为:<br>Socket编程、IO模型、Netty简介、Netty示例,下面就开始今天的学习吧!</p><h2 id="Socket编程"><a class="header-anchor" href="#Socket编程"></a>Socket编程</h2><p>Socket最早是在4.3BSD UNIX中内置的’Berkeley Socket’演化而来,主要是用于实现进程间的通信;</p><h3 id="Socket通信模型"><a class="header-anchor" href="#Socket通信模型"></a>Socket通信模型</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.Socket%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B.png?raw=true" alt="Socket通信模型"></p><p>Socket通信模型如上图所示,Socket是作为应用层与传输层之间协议,对应用层来说只要按照Socket设计的协议进行调用就可以进行通信了;</p><p>常用的Socket类型有两种:“Stream Sockets”(串流式 Sockets)和&quot;Datagram Sockets&quot;(讯息式 Sockets),Stream Sockets底层使用的是TCP协议,Datagram Sockets底层使用的是UDP协议;</p><blockquote><p>CP 会在传输层对将上层送来的过大数据分割成多个 TCP 段（TCP segments），而 UDP 本身不会，UDP 是信息导向的（message oriented），若 UDP 信息过大时（整体数据包长度超过 MTU），则会由 host 或 router 在 IP 层对数据包进行分割，将一个 IP packet 分割成多个 IP fragments。IP fragmention 的缺点是，到达端的系统需要做 IP 数据包的重组，将多个 fragments 重组合并为原本的 IP 数据包，同时也会增加数据包遗失的可能性。如将一个 IP packet 分割成多个 IP fragments，只要其中一个 IP fragment 遗失了，到达端就会无法顺利重组 IP 数据包，因而造成数据包的遗失，若是高可靠度的应用，则上层协议需重送整个 packet 的数据。</p></blockquote><h3 id="简单示例"><a class="header-anchor" href="#简单示例"></a>简单示例</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/HttpServer01.kt">HttpServer01.kt</a></p><p>开启8880端口,然后返回字符串&quot;socket&quot;,通过这个程序可以看到影响程序响应的因素是在于对响应的一个处理速度,示例中的程序是采用new Thread的方式,但是在还有很多改进的空间:使用线程池;</p><p>这种I/O模型是标准的select/poll模型,有以下这些缺点:</p><ol><li>每次调用需要将数据从用户态拷贝到内核态</li><li>select需要遍历内核态传递进来的全部fd（file descriptor）是指向一个打开的文件或I/O设备的数字标识符</li><li>select支持的文件描述符只有1024个</li></ol><h2 id="NIO模型"><a class="header-anchor" href="#NIO模型"></a>NIO模型</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.IO%E6%A8%A1%E5%9E%8B.png?raw=true" alt="IO模型"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.IO%E6%A8%A1%E5%9E%8B.png?raw=true" alt="IO复用"></p><h2 id="Netty模型"><a class="header-anchor" href="#Netty模型"></a>Netty模型</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.Netty%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png?raw=true" alt="Netty整体流程"></p><p>下面根据这个整体流程先写一个简单示例;</p><h3 id="Netty基本组件"><a class="header-anchor" href="#Netty基本组件"></a>Netty基本组件</h3><h4 id="NioEventLoop组件"><a class="header-anchor" href="#NioEventLoop组件"></a>NioEventLoop组件</h4><p>NioEventLoop同时处理<B>客户端连接</B>、<B>读写客户端发送过来的数据</B></p><h4 id="Channel组件"><a class="header-anchor" href="#Channel组件"></a>Channel组件</h4><h4 id="ByteBuf"><a class="header-anchor" href="#ByteBuf"></a>ByteBuf</h4><h4 id="Pipeline"><a class="header-anchor" href="#Pipeline"></a>Pipeline</h4><p>使用逻辑链,来解析数据</p><h4 id="Channel-Handler"><a class="header-anchor" href="#Channel-Handler"></a>Channel Handler</h4><h3 id="执行过程"><a class="header-anchor" href="#执行过程"></a>执行过程</h3><h4 id="服务端执行流程"><a class="header-anchor" href="#服务端执行流程"></a>服务端执行流程</h4><ol><li><p>创建服务端Channel<br>bind():用户代码入口 -&gt;   initAndRegister():初始化并注册  -&gt;  newChannel():创建服务端Channel</p></li><li><p>初始化服务端Channel</p><p>NioServerSocketChannel.class初始化方法:<br>1. newSocket()通过JDK来创建原生Channel<br>2. NioServerSockerChannelConfig配置TCP参数<br>3. AbstractNioChannel<br>3.1 configureBlocking 设置阻塞/非阻塞模式<br>3.2 AbstractChannel创建id/unsafe/pipeline</p></li></ol><p>添加 ServerBootstrapAcceptor -&gt; ServerBootstrapAcceptor.init()</p><p>添加Handler,</p><ol start="3"><li>注册selector</li></ol><p>在创建和注册channel完成以后,会调用EventLoopGroup接口的实现类进行注册;</p><p>整体流程:</p><ol><li>bind()作为入口</li><li>AbstractBootstrap#initAndRegister作为实现方法</li><li>通过EventLoopGroup的子类,NioEventLoopGroup的父类MultithreadEventLoopGroup实现的<B>register()</B>实现</li></ol><p>register()执行的时候是通过MultithreadEventExecutorGroup#next()方法获取事件处理器,next()方法是通过<a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorChooserFactory.java#L34">DefaultEventExecutorChooserFactory#newChooser</a>来进行选择,选择EventExecutor[] executors数组中的元素时,对于偶数和奇数的处理方式不同;</p><p>register()方法<B>EventLoopGroup#register(Channel channel)</B>接口定义的将传入的channel注册到EvetLoop的方法;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    channel<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> promise<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java#L188">EmbeddedEventLoop</a></p><p>EventLoopGroup通过调用<B>channel.register</B>方法来进行处理;</p><ol start="4"><li>端口绑定<ol><li>AbstractBootstrap#doBind</li><li>AbstractBootstrap#doBind0</li><li>AbstractUnsafe#bind</li><li>NioSocketChannel#doBind</li><li>NioSocketChannel#doBind0</li><li>SocketUtils#bind</li><li>事件广播</li></ol></li></ol><p>'端口绑定’这个功能分为两个动作:1-操作端口绑定、2-绑定事件进行广播</p><p>上述1~6的步骤都是将Netty将设置的端口通过JDK底层方法进行绑定,在绑定完成后是通过后续<B>事件广播</B>功能将这一事件广播出去</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//端口绑定完成以后isActive()返回true</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasActive <span class="token operator">&amp;&amp;</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//广播事件 @TODO</span>            pipeline<span class="token punctuation">.</span><span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>pipeline.fireChannelActive()</B>方法会调用到<B>HeadContext#channelActive</B></p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><h2 id="NioEventLoop组件-v2"><a class="header-anchor" href="#NioEventLoop组件-v2"></a>NioEventLoop组件</h2><ol><li>默认情况下,Netty服务端会启动多少线程?什么时候启动?</li><li>Netty如何解决JDK空轮询问题?</li><li>Netty如何保证异步串行无锁化?</li></ol><h3 id="NioEventLoop创建过程"><a class="header-anchor" href="#NioEventLoop创建过程"></a>NioEventLoop创建过程</h3><h4 id="创建核心线程数"><a class="header-anchor" href="#创建核心线程数"></a>创建核心线程数</h4><p>在我们的示例代码中可以看到</p><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> bossGroup <span class="token operator">=</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">val</span> workerGroup <span class="token operator">=</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>NioEventLoopGroup有两种构造方法,一种传参,一种不传参数,进入构造方法可以看到:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置线程数量</span><span class="token keyword">public</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Executor</span><span class="token punctuation">)</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//不设置线程数量时</span><span class="token keyword">protected</span> <span class="token class-name">MultithreadEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">Executor</span> executor<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>nThreads <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> DEFAULT_EVENT_LOOP_THREADS <span class="token operator">:</span> nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_EVENT_LOOP_THREADS<span class="token punctuation">;</span><span class="token comment">//设置线程数量为配置参数值或默认当前核心数*2</span><span class="token keyword">static</span> <span class="token punctuation">&#123;</span>    DEFAULT_EVENT_LOOP_THREADS <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">SystemPropertyUtil</span><span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>            <span class="token string">"io.netty.eventLoopThreads"</span><span class="token punctuation">,</span> <span class="token class-name">NettyRuntime</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"-Dio.netty.eventLoopThreads: &#123;&#125;"</span><span class="token punctuation">,</span> DEFAULT_EVENT_LOOP_THREADS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建线程执行器"><a class="header-anchor" href="#创建线程执行器"></a>创建线程执行器</h4><h3 id="NioEventLoop启动过程"><a class="header-anchor" href="#NioEventLoop启动过程"></a>NioEventLoop启动过程</h3><h3 id="NioEventLoop执行逻辑"><a class="header-anchor" href="#NioEventLoop执行逻辑"></a>NioEventLoop执行逻辑</h3><ol start="4"><li>业务逻辑:对数据包进行拆包 -&gt; 数据类型处理器</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.kancloud.cn/luoyoub/network-programming/2237006">Socket通信模型</a><br><a href="https://beej-zhcn.netdpi.net/whatissocket/liang_zhong_internet_sockets">Beej’s Guide to Network Programming简体中文</a><br><a href="https://www.cnblogs.com/ZhuChangwu/p/11237899.html">Netty中的策略模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Netty源码分析(一)&lt;/h1&gt;
&lt;h2 id=&quot;简述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;
&lt;p&gt;从IO到NIO体现了java对于流操作的一个变迁,在到构建Netty,这一个系列文章主要讲述的就是Netty框</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Netty" scheme="https://agmtopy.gitee.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty实战第一章</title>
    <link href="https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/25.Netty%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://agmtopy.gitee.io/2023/06/27/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/25.Netty%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2023-06-27T15:14:13.000Z</published>
    <updated>2023-10-23T14:50:02.682Z</updated>
    
    <content type="html"><![CDATA[<h1>Netty实战第一章</h1><h2 id="简述"><a class="header-anchor" href="#简述"></a>简述</h2><p>在学习Netty源码的过程中,十分吃力看来还是需要先从<B>使用</B>在到<B>研究</B>过程,因此将《Netty实战》一书重新拾起,以下是相关笔记;</p><h2 id="Netty基础组件"><a class="header-anchor" href="#Netty基础组件"></a>Netty基础组件</h2><ol><li>Channel;</li><li>回调</li><li>Future</li><li>事件和ChannelHandler</li></ol><h3 id="Channel"><a class="header-anchor" href="#Channel"></a>Channel</h3><p>Channel是对Java NIO的一个抽象;</p><blockquote><p>代表一个到实体(例如硬件设备、文件、网络套接字)的开发连接,可以执行<B>读操作</B>和<B>写操作</B>,可以把Channel看作传入或传出数据的载体.因此它们可以被打开或关闭;</p></blockquote><h3 id="回调"><a class="header-anchor" href="#回调"></a>回调</h3><p>一个<B>回调</B>其实就是一个方法,一个指向已经被提供给另外一个方法的方法的引用,这使得后者方法可以在适当的时候来回调前者;</p><h3 id="Future"><a class="header-anchor" href="#Future"></a>Future</h3><p><B>Future</B>提供了另外一种在操作完成时通知应用程序的方式.这个对象可以看作是一个异步操作的结果的<B>占位符</B>;它将在未来的某个时刻完成,并提供对其结果的访问;在JDK中提供的已有的Future实现,需要手动检查对于操作是否完成或者需要柱塞,十分繁琐;因此在Netty提供了<B>ChannelFuture</B>实现,用于在执行异步操作的时候使用;</p><h3 id="事件和ChannelHandler"><a class="header-anchor" href="#事件和ChannelHandler"></a>事件和ChannelHandler</h3><p>Netty中使用不同的事件来通知我们状态的改变或者操作的状态,如下图所示的事件驱动</p><p>!(ChannelHandler链的入站和出站事件)[]</p><hr><ul><li><p>Future、回调和ChannelHandler<br>Netty的异步编程模型是建立在Future和回调的概念之上的,而将事件分派到ChannelHandler的方法则是建立在这个基础之上更高层的概念;</p></li><li><p>选择器、事件和EventLoop<br>Netty通过触发事件将Selector从应用程序中抽象出来,简化了原来需要手动编写的派发代码.在netty内部会为每一个Channel分配一个EventLoop用于处理所有事件,包括:</p></li></ul><ol><li>注册感兴趣的事件</li><li>将事件派发给ChannelHandler</li><li>安排进一步动作</li></ol><p>EventLoop本身就是一个线程驱动,其处理了一个Channel的所有I/O事件,并且在该EventLoop的整个生命周期内都不会发生改变;</p><h2 id="Netty的Hello-World"><a class="header-anchor" href="#Netty的Hello-World"></a>Netty的Hello World</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.Echo%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8.png?raw=true" alt="Echo客户端与服务端"></p><p>服务端是可以同时处理多个客户端连接的,客户端在建立一个连接之后,它会先服务端发送一个或者多个消息,反过来,服务器邮费将每个消息发回客户端,这就是典型的<B>请求⇌响应</B>模式;</p><h3 id="服务端代码"><a class="header-anchor" href="#服务端代码"></a>服务端代码</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoServerHandler.kt">EchoServerHandler</a></p><ul><li>EchoServerHandler实现了业务处理逻辑</li></ul><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoServer.kt">EchoServer</a></p><p>EchoServer创建引导过程:</p><ul><li>创建一个ServerBootstrap的实例来进行引导和绑定服务器</li><li>创建并分配一个<B>NioEventLoopGroup</B>实例以进行事件的处理,如接受新连接以及读写数据</li><li>指定服务器绑定的本地InetSocketAddress</li><li>使用一个EchoServerHandler实例初始化每一个新的Channel</li><li>调用ServerBootstrap.bind()方法以绑定服务器</li></ul><h3 id="客户端代码"><a class="header-anchor" href="#客户端代码"></a>客户端代码</h3><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoClient.kt">EchoClient.kt</a><br><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/master/src/main/kotlin/simple/echo/EchoClientHandler.kt">EchoClientHandler.kt</a></p><p>EchoClientHandler业务逻辑:</p><ul><li>channelActive - 在到服务器的连接已经建立之后将被调用</li><li>channelRead - 当从服务器收到一条消息时被调用</li><li>exceptionCaught - 在处理过程中引发异常时将被调用</li></ul><p><B>channelRead</B>方法,每当接收到数据时,都会调用这个方法,需要注意的是,它在接受服务器发送的消息时可能会被<B>分段接收</B>;<br>举一个例子就是,当服务器发送5 Byte时,客户端不能保证这5 Byte会被一次性全部接收,可能是第一次接受到3 Byte,第二次接受到2 Byte;或者反之亦然;</p><p>TCP协议作为一个面向流的协议,它会保证数据流会按照服务端的发送顺序来进行接收;</p><p>EchoClient引导逻辑:</p><ul><li>与服务端引导逻辑类似</li><li>创建BootStrap,客户端这里是<B>BootStrap</B>,不是ServerBootStrap</li><li>指定EventLoopGroup处理客户端事件</li><li>选择NIO传输的Channel类型</li><li>设置服务端的地址</li><li>设置业务处理链</li></ul><h3 id="执行结果"><a class="header-anchor" href="#执行结果"></a>执行结果</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.Echo%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png?raw=true" alt="Echo客户端与服务器执行结果"></p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>通过Echo服务端与客户端的配合,我们初步了解到了创建一个Netty程序需要有两部分组成:<B>引导程序</B>、<B>业务处理</B>,接下来我们详细的了解一下Netty的组件和设计;</p><h2 id="Netty的组件和设计"><a class="header-anchor" href="#Netty的组件和设计"></a>Netty的组件和设计</h2><p>Netty的组件设计可以分为两个大类:<B>Netty网络抽象的代表</B>和<B>管理数据流和业务逻辑组件</B>;</p><p>Netty网络抽象的代表:</p><ul><li>Channel - 对Socket的抽象</li><li>EventLoop - 控制流、多线程处理、并发</li><li>ChannelFuture - 异步通知</li></ul><p>管理数据流和业务逻辑组件:</p><ul><li>ChannelHandler - 业务程序逻辑的容器</li><li>ChannelPipeline - 事件处理链</li></ul><h3 id="Channel接口"><a class="header-anchor" href="#Channel接口"></a>Channel接口</h3><p>Channel是对Socket的抽象接口,提供的API用于简化Socket类使用的复杂性,常见的实现类有:</p><ul><li>EmbeddedChannel</li><li>LocalServerChannel</li><li>NioDatagramChannel</li><li>NioSctpChannel</li><li>NioSocketChannel</li></ul><h3 id="EventLoop接口"><a class="header-anchor" href="#EventLoop接口"></a>EventLoop接口</h3><blockquote><p>EventLoop接口是Netty的核心抽象,用于处理连接的生命周期中所发生的事件;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.EventLoop%E6%8E%A5%E5%8F%A3%E7%B1%BB.png?raw=true" alt="EventLoop接口类"></p><h3 id="ChannelFuture"><a class="header-anchor" href="#ChannelFuture"></a>ChannelFuture</h3><p>在Netty中所有的I/O操作都是异步进行处理的,因为一个操作可能不会立即返回结果,所以Netty中定义了<B>一种用于在之后某个事件点确定其结果的方法</B>,这个结果就是<B>ChannelFuture</B>,其addListener方法注册了一个ChannelFutureListener,以便在某个操作完成时得到通知;</p><h3 id="ChannelPipeline"><a class="header-anchor" href="#ChannelPipeline"></a>ChannelPipeline</h3><p>ChannelPipeline为ChannelHandler链提供了容器,并定义了用于在该链上传播入站和出站事件流的API.当Channel被创建时,它被自动分配到它专属的ChannelPipenlines上;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.ChannelInboundHandler%E4%B8%8EChannelOutboundHandler.png?raw=true" alt="ChannelHandler的in/out实现接口"></p><p>ChannelHandler安装到ChannelPipeline中的过程如下所示:</p><ul><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中</li><li>当ChannelInitializer.initChannel()方法被调用时,ChannelInitializer将在ChannelPipline中安装一组自定义的ChannelHandler</li><li>ChannelInitializer将它自己从ChannelPipeline中移除</li></ul><p>源代码如下:</p><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/ChannelInitializer.java#L126">ChannelInitializer.java</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initMap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Guard against re-entrance.</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span>            <span class="token comment">// We do so to prevent multiple calls to initChannel(...).</span>            <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ctx<span class="token punctuation">.</span><span class="token function">isRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ctx<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/a12a0124efc418438a7179a42d4826f5db5676ba/src/main/kotlin/simple/echo/EchoClient.kt#L24">EchoClient</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>object <span class="token operator">:</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    override fun <span class="token function">initChannel</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> <span class="token class-name">SocketChannel</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ctx<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">EchoClientHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ChannelInitializer.initChannel()将一组自定义的ChannelHandler注册到ChannelPipeline链上;ChannelHandler是专门为支持广泛的用途而设计,可以将它看作为是处理往来ChannelPipeline事件的任何代码的通用容器;使得事件流经ChannelPipline是ChannelHandler的工作,它们是在应用程序的初始化或者引导阶段被安装的;</p><h3 id="ChannelHandler"><a class="header-anchor" href="#ChannelHandler"></a>ChannelHandler</h3><p>在Netty中以适配器的形式提供了大量默认的ChannelHandler实现类,用于简化应用程序处理逻辑的开发过程;常用的适配器类有:<B>ChannelHandlerAdapter</B>、<B>ChannelInboundHandlerAdapter</B>、<B>ChannelOutboundHandlerAdapter</B>、<B>ChannelDuplexHandler</B></p><ul><li>编码器和解码器</li></ul><blockquote><p>当你通过Netty发送或接收一个消息的时候,就将会发生一次数据转换,也就是说字节码会转换为另外一种格式,通常就是一个java对象;如果是出站消息,则会发生相反方向的转换:它将从它的当前格式被编码为字节;Netty为编码器和解码器提供了不同类型的抽象类;</p></blockquote><p>Netty提供的编码器和解码器适配器类都实现了<B>ChannelOutboundHandler接口</B>或者<B>ChannelInboundHandler接口</B></p><h3 id="引导程序"><a class="header-anchor" href="#引导程序"></a>引导程序</h3><p>从上面的例子中可以看到,我们在设置Netty的客户端或者服务端配置时,首先选择引导类<B>BootStrap</B>或者<B>ServerBootStrap</B>,下面是这两种引导类下一些区别;</p><table><thead><tr><th>类别</th><th>BootStrap</th><th>ServerBootStrap</th></tr></thead><tbody><tr><td>网络编程的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td>EventLoopGroup的数目</td><td>1</td><td>2</td></tr></tbody></table><p><img src="https://github.com/agmtopy/noteBook/blob/e1480b344e9bbe0242507dc79c7fdef266030bef/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E5%85%B7%E6%9C%89%E4%B8%A4%E4%B8%AAEventLoopGroup%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8.png?raw=true" alt="具有两个EventLoopGroup的服务器"></p><p>服务器设置两组不同的Channel,第一组只包含服务器自身的已绑定到某个本地端口的正在监听的套接字、第二组将包含所有已创建的用来处理传入的客户端连接的Channel;<br>与ServerChannel相关联的EventLoopGroup将分配一个负责为传入连接请求创建Channel的EventLoop;一旦连接被接受,第二个EventLoopGroup将会给它的Channel分配一个EventLoop;</p><h2 id="传输"><a class="header-anchor" href="#传输"></a>传输</h2><p>Netty中最为重要的知识,传输-可以使用<B>阻塞传输</B>、<B>异步传输</B>、Local等方式,在Netty中它为所有的传输实现都提供了通用的API;</p><h3 id="例子"><a class="header-anchor" href="#例子"></a>例子</h3><ol><li>JDK阻塞处理的例子</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/PlainOioServer.kt">PlainOioServer.java</a></p><p>在这段代码在每次接受连接时都会创建一个新的线程。这会导致大量的线程被创建和销毁，消耗大量的系统资源。为了避免这种情况，可以使用线程池来管理线程，重复使用现有的线程来处理新的连接、或者使用非柱塞的方式来进行,下面是一个非阻塞的例子;</p><ol start="2"><li>JDK非阻塞的例子</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/PlainNioServer.kt">PlainNioServer.java</a></p><p>从阻塞切换到非阻塞的代码十分复杂,下面看一下Netty是如何屏蔽这部分差异的</p><ol start="3"><li>使用Netty的阻塞网络处理</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/NettyOioServer.kt">NettyOioServer.java</a></p><ol start="4"><li>使用Netty的非阻塞网络处理</li></ol><p><a href="https://github.com/agmtopy/netty-in-action-kotlin/blob/c02cbc3a6c6b48aa4f6503dad68876ee680c95a1/src/main/kotlin/simple/transmission/NettyNioServer.kt#L18C1-L18C1">NettyNioServer.java</a></p><p>可以看到Netty切换网络通道只需要调整<B>NioEventLoopGroup</B>、<B>NioServerSocketChannel</B>即可;</p><h3 id="传输API"><a class="header-anchor" href="#传输API"></a>传输API</h3><blockquote><p>传输API的核心是interface Channel,它被用于所有的I/O操作,Channel类的层次结构如下所示:</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/e1480b344e9bbe0242507dc79c7fdef266030bef/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.Channel%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png?raw=true" alt="Channel接口的层次结构"></p><p>每一个Channel都会被分配一个<B>ChannelPipeline</B>和<B>ChannelConfig</B>,ChannelConfig中包含了该Channel的所有配置设置,并且<B>支持热更新</B>;<br>由于Channel是独一无二的,所以为了保证顺序Channel实现了Comparable接口;</p><p><a href="https://github.com/netty/netty/blob/4bd20067ace14b3dfd14e4a4bb9cbe480e97d3b0/transport/src/main/java/io/netty/channel/Channel.java#L77">Channel.java</a></p><p>ChannelPipeline是用于持有处理入站和出站以及业务处理事件的<B>ChannelHandler</B>实例,在代码中主要是add/remove/get等方法;<br>ChannelPipeline是典型的过滤器模式,数据经过不同的ChannelHandler进行处理;</p><p>在上一个步骤中引出了一个重要的类<B>ChannelHandler</B>,它实现了所有应用程序用于处理状态变化以及数据处理的逻辑,常用的类型有:</p><ol><li>数据格式转换,将数据同二进制格式转换为业务格式,反之亦然</li><li>提供异常的通知</li><li>提供Channel变为活动的或者非活动的通知</li><li>提供当Channel注册到EventLoop或者从EventLoop注销时的通知</li><li>提供有关用户自定义事件的通知</li></ol><p>channel重要的方法列表:</p><p><img src="https://github.com/agmtopy/noteBook/blob/f979c8e58879f1619e010dc459ca4e67871ece33/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.Channel%E7%9A%84%E6%96%B9%E6%B3%95.png?raw=true" alt="channel的方法"></p><p>channel是<B>线程安全</B>的,可以多个线程同时操作;</p><h3 id="内置的传输类型"><a class="header-anchor" href="#内置的传输类型"></a>内置的传输类型</h3><p>Netty内置了一些开箱即用的传输;这些传输包括jdk、linux等的特殊类型;</p><table><thead><tr><th>名称</th><th>包</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.nio</td><td>使用java.nio.channels包作为基础,基于选择器的方式</td></tr><tr><td>Epooll</td><td>io.netty.channel.epoll</td><td>由JNI驱动的epoll()和非阻塞I/O,这个传输支持只有在Linux上可用的多种特性.如SO_REUSEPORT,比NIO传输更快,并且是完全非阻塞的;</td></tr><tr><td>OIO</td><td>io.netty.channel.socket.oio</td><td>使用java.net包作为基础,使用的是阻塞流</td></tr><tr><td>Local</td><td>io.netty.channel.local</td><td>在JVM内部通过管道进行通信的本地传输形式</td></tr><tr><td>Embedded</td><td>io.netty.channel.embedded</td><td>测试channelHandler使用</td></tr></tbody></table><h4 id="NIO-非阻塞I-O"><a class="header-anchor" href="#NIO-非阻塞I-O"></a>NIO-非阻塞I/O</h4><p>NIO提供了一个所有I/O操作的全异步的实现,它是基于JDK1.4引入的NIO子系统中的选择器API来进行实现;</p><p>选择器背后的基本概念是充当一个<B>注册表</B>,在哪里你将可以请求在Channel的状态发生变化时得到通知,可能发生的状态变化有:</p><ul><li>新的Channel已被接受并且就绪</li><li>Channel连接已经完成</li><li>Channel有已经就绪的可供读取的数据</li><li>Channel可用于写数据</li></ul><p>选择器运行在一个检查状态变化并对其做出相应响应的线程上,在应用程序对状态的改变做出响应之后,选择器状态会被重置,然后继续重复这过程;</p><p><img src="https://github.com/agmtopy/noteBook/blob/4e4b9a4baccf9ccc5a16f77baa36b9117dc23f1e/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.%E9%80%89%E6%8B%A9%E5%B9%B6%E5%A4%84%E7%90%86%E7%8A%B6%E6%80%81%E7%9A%84%E5%8F%98%E5%8C%96%E8%BF%87%E7%A8%8B.png?raw=true" alt="选择并处理状态的变化"></p><p><img src="https://github.com/agmtopy/noteBook/blob/4e4b9a4baccf9ccc5a16f77baa36b9117dc23f1e/png/N-Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.%E9%9B%B6%E6%8B%B7%E8%B4%9D.png?raw=true" alt="零拷贝"></p><p>零拷贝其实在Windows下有API进行支持;</p><h4 id="Epooll-用于Linux的本地非阻塞传输"><a class="header-anchor" href="#Epooll-用于Linux的本地非阻塞传输"></a>Epooll-用于Linux的本地非阻塞传输</h4><p>Netty为Linux提供了一组NIO API,其以一种和它本身的设计更加一致的方式使用epoll,实现类是<B>EpollEventLoopGroup</B></p><h4 id="OIO-旧的阻塞I-O"><a class="header-anchor" href="#OIO-旧的阻塞I-O"></a>OIO-旧的阻塞I/O</h4><blockquote><p>Netty的OIO传输实现代表了一种折中的办法;它可以通过常规的传输API使用,但是由于它是建立在java.net包的阻塞实现之上的,所以它不是异步的;Netty利用<B>SO_TIMEOUT</B>这个Socket标识,它指定了等待一个I/O操作完成的最大毫秒数.如果这个操作在指定时间间隔内没有完成,则将会抛出一个<B>SocketTimeout_Exception</B>,Netty将捕获这个异常并继续循环处理,在下次运行EventLoop时,它将再次尝试;</p></blockquote><p><img src="" alt="OIO的处理逻辑"></p><h4 id="用于JVM内部通信的Local传输"><a class="header-anchor" href="#用于JVM内部通信的Local传输"></a>用于JVM内部通信的Local传输</h4><blockquote><p>Netty提供了一个Local传输,用于在同一个JVM中运行的客户端和服务端程序之间的异步通信.在这个传输中,和服务器Channel相关联的SocketAddress并没有绑定物理网络地址;</p></blockquote><h4 id="Embedded-传输"><a class="header-anchor" href="#Embedded-传输"></a>Embedded 传输</h4><blockquote><p>Netty提供了一种额外的传输方式,使得你可以将一组ChannelHandler作为帮助器嵌入到其他的ChannelHandler内部;</p></blockquote><h2 id="ByteBuf"><a class="header-anchor" href="#ByteBuf"></a>ByteBuf</h2><p>网络数据的基本单位是字节,Java NIO提供了<B>ByteBuffer&lt;/B作为它的字节容器,但是这个类使用过于复杂;因此Netty在内部进行了分封装,通过API提供了两个类:<B>ByteBuf</B>和<B>ByteBufHolder</B>;</p><p>ByteBuf内部会维护两个不同的<B>索引</B>,一个用于读取,一个用于写入,当你从ByteBuf中读取数据时,它的readderIndex将会递增已经被读取过的字节数.同样的,当你写入ByteBuf时,它的writeIndex也会进行递增;</p><ol><li><p>堆缓冲区<br>最常用的ByteBuf模式就是将数据存储在JVM的堆空间中;</p></li><li><p>直接缓冲区<br><B>直接缓存区</B>是另外一种ByteBuf模式,我们期望用用于对象创建的内存分配永远都来自于堆中,但这并不是必须的,在JDK 1.4中引入的ButeBuffer类允许JVM实现通过本地调用来分配内存;这样可以避免每次在调用本地I/O操作之前将缓冲区的内容复制到一个中间缓冲区中;<br>“直接缓冲区的内存将驻留在常规的会被垃圾回收的堆内存之外”,直接缓冲区的主要缺点是<B>相对与基于堆内存的缓冲区,它们的分配和释放都比较昂贵</B></p></li><li><p>复合缓冲区<br><B>复合缓冲区</B>指的是,它为多个ByteBuf提供一个聚合视图,通过这个聚合视图可以根据需要进行添加和删除ByteBuf实例,用于补充JDK中的ByteBuffer中缺失的这个特性;<br>Netty中通过ByteBuf的子类 -&gt; CompositeByteBuf来实现这个功能,它提供了一个将多个缓冲区聚合成为单个合并缓冲区的虚拟实现;</p></li></ol><h2 id="字节级操作"><a class="header-anchor" href="#字节级操作"></a>字节级操作</h2><ol><li>随机访问索引</li><li>顺序访问索引</li><li>可丢弃字节</li><li>可读字节</li><li>可写字节</li><li>索引管理</li><li>查找操作</li><li>派生缓冲区</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Netty实战第一章&lt;/h1&gt;
&lt;h2 id=&quot;简述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;
&lt;p&gt;在学习Netty源码的过程中,十分吃力看来还是需要先从&lt;B&gt;使用&lt;/B&gt;在到&lt;B&gt;研究&lt;/B&gt;过程,因此将《Net</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Netty" scheme="https://agmtopy.gitee.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>G1GC的算法与实现之实现篇笔记</title>
    <link href="https://agmtopy.gitee.io/2023/05/06/20.%E7%AC%94%E8%AE%B0/41.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2023/05/06/20.%E7%AC%94%E8%AE%B0/41.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-05T21:32:23.000Z</published>
    <updated>2023-06-26T15:24:52.567Z</updated>
    
    <content type="html"><![CDATA[<h1>《深入Java虚拟机：JVM G1GC的算法与实现》-实现篇笔记</h1><p>在上一篇文章中我们记录了G1GC的算法包括<B>内存结构</B>、<B>标记位图</B>、<B>SATB本地队列</B>、<B>转移专用记忆集合</B>等关键组成部分,接下我们会对HotSpotVM的具体实现方法进行分析;</p><h2 id="HotSpot的代码结构"><a class="header-anchor" href="#HotSpot的代码结构"></a>HotSpot的代码结构</h2><p>HotSpot的源码位于src/hotspot下,如下所示</p><table><thead><tr><th>文件夹</th><th>说明</th></tr></thead><tbody><tr><td>cpu</td><td>依赖CPU的代码</td></tr><tr><td>os</td><td>依赖操作系统的代码</td></tr><tr><td>os_cpu</td><td>依赖操作系统和CPU的代码</td></tr><tr><td>share</td><td>通用代码</td></tr></tbody></table><p>在share下又划分为以下文件结构</p><table><thead><tr><th>文件夹</th><th>说明</th></tr></thead><tbody><tr><td>ci</td><td>C1编译器</td></tr><tr><td>classfile</td><td>Java类文件的定义</td></tr><tr><td>gc</td><td>GC部分</td></tr><tr><td>interpreter</td><td>Java解释器</td></tr><tr><td>oops</td><td>对象结构的定义</td></tr><tr><td>runtime</td><td>VM运行时所需库</td></tr></tbody></table><p>参考<a href="https://github.com/openjdk/jdk/tree/master/src/hotspot/share">openjdk</a></p><p>HotSpot内部的大部分代码都是继承与以下两个类中的一个:</p><ul><li>CheapObj类</li><li>AllStatic类</li></ul><p>下面对这两个类进行分析:</p><ul><li>CheapObj类</li></ul><blockquote><p>CheapObj类是一个由C的堆内存空间来管理的类,CheapObj类的子类实例都会被分配到C的堆内存上;</p></blockquote><ul><li>AllStatic类</li></ul><blockquote><p>AllStatic类是一个&quot;仅带有静态信息&quot;的特殊类,继承AllStatic的类不需要创建实例;</p></blockquote><p>由于HotSpotVM需要运行于各种操作系统之上.因此,开发者为HotSpotVM设计了一种巧妙的结构(接口),使得它能够通过统一的接口来处理各种操作系统的API;</p><ul><li>os.hpp</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">class os<span class="token operator">:</span> AllStatic <span class="token punctuation">&#123;</span>  friend class VMStructs<span class="token punctuation">;</span>  friend class JVMCIVMStructs<span class="token punctuation">;</span>  friend class MallocTracker<span class="token punctuation">;</span><span class="token comment">//省略</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>os类中定义的成员函数在HotSpotVM中都有对应的各种操作系统实现:</p><ol><li>os/posix/vm/os_posix.cpp</li><li>os/linux/vm/os_linux.cpp</li><li>os/windows/vm/os_windows.cpp</li><li>os/solaris/vm/os_solaris.cpp<br>在构建OpenJDK时,hotspot会从以上文件中,选择与当前系统对应的文件进行编译和链接;</li></ol><p>当VM调用os.hpp时,对于操作系统下的实现类就会执行具体方法;</p><ul><li>os_windows.cpp</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef _DEBUG#include &lt;crtdbg.h&gt;#endif#include &lt;windows.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;stat.h&gt;#include &lt;sys&#x2F;timeb.h&gt;#include &lt;objidl.h&gt;#include &lt;shlobj.h&gt;&#x2F;&#x2F;省略....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>os_windows.cpp</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef _DEBUG#include &lt;crtdbg.h&gt;#endif&#x2F;&#x2F; put OS-includes here# include &lt;sys&#x2F;types.h&gt;# include &lt;sys&#x2F;mman.h&gt;# include &lt;sys&#x2F;stat.h&gt;# include &lt;sys&#x2F;select.h&gt;# include &lt;pthread.h&gt;# include &lt;signal.h&gt;# include &lt;endian.h&gt;# include &lt;errno.h&gt;# include &lt;dlfcn.h&gt;&#x2F;&#x2F;省略....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在不同的实现下引入了不同的<B>.h</B>文件;</p><h2 id="堆结构"><a class="header-anchor" href="#堆结构"></a>堆结构</h2><p>堆结构大体上可以划分为两个部分:</p><ol><li>程序员选择的GC算法所使用的内存空间</li><li>常驻内存空间</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/VM%E5%A0%86%E5%88%92%E5%88%86.png?raw=true" alt="VM堆划分"></p><p>常驻内存空间通常是用于分配类型信息或方法信息等永久存在的对象,该空间几乎不会随着GC算法的变化而变化;</p><blockquote><p>在 JDK 8 及之后的版本中，永久代已经被移除，被一个称为元空间（Metaspace）的区域所取代。因此，可以说 JDK 8 及之后的版本中没有永久代这一概念。不过，元空间和永久代的作用类似，都是用于存放类信息等元数据的区域，只不过它们的实现方式和内存模型不同。 元空间和永久代最大的不同在于，元空间使用本地内存（native memory）存储元数据，而不是像永久代一样使用虚拟机内存（Java heap）来存储。这样的好处是可以避免永久代出现的内存溢出问题，因为元空间的大小可以根据需要动态调整，并且可以使用操作系统的内存分配器来管理内存。另外，元空间与永久代相比还有一些其他的不同点，例如元空间可以通过命令行参数来配置大小、元空间的垃圾回收机制与永久代不同等等。但是，从常驻内存空间的角度来说，可以认为元空间已经取代了永久代，成为了 Java 虚拟机中存放类信息等元数据的常驻内存区域。</p></blockquote><p>在JVM中是通过<B>Universe:initialize_heap</B>来实现创建堆内存的功能,如下所示,会根据<B>create_heap()</B>、<B>initialize()</B>方法选择不同的实现;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%88%9B%E5%BB%BA%E5%A0%86%E5%86%85%E5%AD%98%E9%80%89%E6%8B%A9%E6%89%A7%E8%A1%8C%E7%B1%BB.png?raw=true" alt="创建堆内存选择执行类"></p><p>下面详细看一下<B>G1CollectedHeap</B>,其中有三个重要的成员变量:</p><ol><li><B>_hrs</B>:通过数组维护所有的HeapRegion</li><li><B>_young_list</B>:新生代HeapRegion的链表</li><li><B>_free_region_list</B>:空闲HeapRegion的链表</li></ol><blockquote><p>管理各个区域是通过<B>HeapRegion</B>类来实现的,在G1CollectedHeap中为了快速找到每一个HeapRegion,因此用HeapRegionSeq（Heap Region Sequence）是用于表示堆区域（Heap Region）的序列或集合的地址,_hrs就是指向HeapRegionSeq的指针;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC%E5%A0%86%E7%BB%93%E6%9E%84.png?raw=true" alt="G1GC堆的结构"></p><h2 id="分配器"><a class="header-anchor" href="#分配器"></a>分配器</h2><h3 id="内存分配的流程"><a class="header-anchor" href="#内存分配的流程"></a>内存分配的流程</h3><p>Vm堆空间申请 -&gt; VM堆空间分配 -&gt; 对象的分配<br>下图展示这个过程</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%B5%81%E7%A8%8B.png?raw=true" alt="内存分配的流程"></p><p>需要注意的是在Linux上,用于实现内存申请和分配的是<B>mmap()</B>,在Linux中没有申请内存空间的概念,调用mmap()后就会分配内存空间,不过并不是立即分配物理空间,在这这中间还有一层虚拟内存;只有在分配到的内存空间被访问时才会实际发生物理内存分配;</p><h3 id="对象分配的流程"><a class="header-anchor" href="#对象分配的流程"></a>对象分配的流程</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.jpg?raw=true" alt="对象分配的流程"></p><h3 id="TLAB"><a class="header-anchor" href="#TLAB"></a>TLAB</h3><p>TLAB(Thread Local Allocation Buffer,线程本地分配缓冲区)是对象分配的要点之一;<br>VM是所有线程共享的内存空间,因此当需要在VM堆上分配对象时,必须锁定整个堆,以防止其他线程同时分配对象;<br>但是为了让不同线程工作于不同的CPU核心上时需要分配对象时不用等待VM堆上的锁释放,因此引入了TLAB的概念,解决思路就是让各个线程拥有自己的专用对象分配缓冲区,从而减少锁定次数;<br>当一个线程第一次分配对象时,它会从VM堆中得到一定大小的内存空间,然后作为它自己的缓冲区保存下来,当这个线程需要分配对象时,优先从这块专用区域进行分配;</p><h2 id="对象结构"><a class="header-anchor" href="#对象结构"></a>对象结构</h2><ul><li>oopDesc类</li></ul><blockquote><p>oopDesc类是所有GC目标对象的抽象基类,继承自oopDesc的类实例都是GC的目标对象;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/429872403e969e497aff2255a0064c748a8385e8/png/j-jvm/oopDesc%E7%B1%BB.png?raw=true" alt="oopDesc类"></p><blockquote><p>在第第56行代码中的_mark变量是对象头,_mark中不仅保存了标记-清除算法的标记,还保存了对象所需的其他各种信息;在oopDesc中有一个指向自己类的指针,在代码的<br>第57行_metadata.在大部分情况下,这个联合体中保存的是_klass变量的值,kass保存的是指向对象类的指针.</p></blockquote><ul><li>klass<br>klass继承于oopDesc,用来表示类型信息,Klass的实例是作为klassOop的一部分创建出来的;</li></ul><h2 id="HotSpot的线程管理"><a class="header-anchor" href="#HotSpot的线程管理"></a>HotSpot的线程管理</h2><p>在Windws和Linux中都有用于调用操作系统线程的库,在Windows上我们使用的是Windows Api调用线程,在Linux上我们使用的是POSIX线程标准的Pthreads库来调用线程;</p><p>在HotSpotVm内可以使用相同的方式调用不同操作系统得益于设计出来’线程抽象层’,最重要的就是<B>Thread</B>;</p><h3 id="Thread类"><a class="header-anchor" href="#Thread类"></a>Thread类</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/Thread%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png?raw=true" alt="Thread类的继承关系"></p><p>在Thread类中通过定义<B>虚函数run()</B>,子类进行实现,其中<B>JavaThread</B>表示的就是Java语言级别运行的线程,<B>NameThread类</B>是支持线程命名的,我们可以通过为对NameThread实例设置一个唯一名字;</p><h3 id="线程的什么周期"><a class="header-anchor" href="#线程的什么周期"></a>线程的什么周期</h3><ol><li>创建Thread类的实例</li><li>创建线程(调用os:create_thread)</li><li>开始线程处理(调用os:start_thread)</li><li>结束线程处理</li><li>释放Thread类实例</li></ol><p>一个windows下创建线程的例子:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadFunc(LPVOID);int main()&#123;    HANDLE hThread;    DWORD threadId;    hThread &#x3D; CreateThread(NULL, 0, ThreadFunc, 0, 0, &amp;threadId); &#x2F;&#x2F; 创建线程    printf(&quot;我是主线程， pid &#x3D; %d\n&quot;, GetCurrentThreadId());      &#x2F;&#x2F; 输出主线程pid    Sleep(2000);&#125;DWORD WINAPI ThreadFunc(LPVOID p)&#123;    printf(&quot;我是子线程， pid &#x3D; %d\n&quot;, GetCurrentThreadId()); &#x2F;&#x2F; 输出子线程pid    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程的互斥处理"><a class="header-anchor" href="#线程的互斥处理"></a>线程的互斥处理</h3><ul><li>什么是互斥处理?</li></ul><blockquote><p>如果线程共享内存空间,那么就会出现多个线程同时在一个地址上进行读写的情况.有些数据会被其他线程所改变,并且这样的改变是意料之外的;对于这样被修改的对象,被称为&quot;临界区&quot;.对于&quot;临界区&quot;的处理必须要按照原子操作;</p></blockquote><ul><li>如何实现互斥处理?</li></ul><ol><li><p>使用互斥量<br>互斥量可以是全局锁/标识/互斥原语等,个人理解互斥量主要是两个特点:全局可见和唯一持有</p></li><li><p>监视器<br>线程之间通过监视器来完成互斥和协助,在jvm中监视器是由Object中的monitor对象头来进行实现,</p></li></ol><blockquote><p><B>互斥方式可以避免线程使用共享数据时被其它线程干扰，而协作方式则帮助多个线程共同完成同一个目标</B></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《深入Java虚拟机：JVM G1GC的算法与实现》-实现篇笔记&lt;/h1&gt;
&lt;p&gt;在上一篇文章中我们记录了G1GC的算法包括&lt;B&gt;内存结构&lt;/B&gt;、&lt;B&gt;标记位图&lt;/B&gt;、&lt;B&gt;SATB本地队列&lt;/B&gt;、&lt;B&gt;转移专用记忆集合&lt;/B&gt;等关键组成部分,接下我们会对HotSp</summary>
      
    
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/categories/jvm/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记</title>
    <link href="https://agmtopy.gitee.io/2023/04/05/20.%E7%AC%94%E8%AE%B0/40.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2023/04/05/20.%E7%AC%94%E8%AE%B0/40.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-04-05T08:55:33.000Z</published>
    <updated>2023-04-27T14:49:25.448Z</updated>
    
    <content type="html"><![CDATA[<h1>《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记</h1><p>这一篇文章主要是用于记录《深入Java虚拟机：JVM G1GC的算法与实现》一书中<B>算法篇</B>部分的笔记,主要分为引子、并发标记、转移、软实时性、分代G1GC模式;</p><h2 id="G1-GC是什么"><a class="header-anchor" href="#G1-GC是什么"></a>G1 GC是什么?</h2><p>在G1GC之前JVM中存在的垃圾收集器主要是<B>Parallel Scavenge</B>和<B>Parallel Old</B>,在jdk9将G1设置为默认处理器后,截至现在的jdk 20都是默认的垃圾收集器,目前G1GC就是JDK平台跨最多版本的默认垃圾收集器;</p><p>G1GC设计的出发点与之前的GC收集器有明显的不同,之前的不管是串行的Serial还是并发Paraller都是基于<B>吞吐量</B>和<B>缩短最大暂停时间</B>来进行设计的;<br>目前JVM的生态或者说面向的应用还是偏向于Web处理方面的,这一类应用的特点短、快,因此需要具有<B>软实时性</B>和<B>高吞吐量</B>的垃圾收集器;</p><blockquote><p>软实时性指的是处理时间可以超出最后期限,但是超出最后期限的频率很重要.只有超出的频率在用户能够容忍的范围之内,才能称之为&quot;软实时性&quot;<br>举一个栗子: 公司都允许每个考勤周期内迟到2或者3次,公司可以容忍这种情况发生,但是超过规定的次数之后就不能忍受了,这种行为就叫&quot;软实时性&quot;;与之相反的&quot;硬实时性&quot;,例如&quot;职务侵占&quot;公司就一次都不能忍受;</p></blockquote><p>咱们已经了解了为什么需要重头开始设计一个GC算法了,下面就看一下具体的内存结构和算法实现.</p><h3 id="G1GC的内存结构"><a class="header-anchor" href="#G1GC的内存结构"></a>G1GC的内存结构</h3><ul><li>内存布局</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png?raw=true" alt="G1GC内存布局"></p><p>首先G1GC的内存布局最大的特点是抛弃了内存中对于老年代和年轻代的内存范围划分,而是采用区域(region),默认大小为1MB的形式进行划分.<br>对于region内存的大小用户可以随意设置,但是在内部会将用户设置的值向上调整为2的指数幂(2^n),1000kb-&gt;1024kb;</p><ul><li>对象引用</li></ul><p>这里的对象引用指的不是对象与对象之间的引用,而是在GC查找对象时持有的引用关系,一个典型的栗子就是老年代中引用年轻代存储关系的<B>记忆集</B>;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png?raw=true" alt="G1GC 跨代引用布局"></p><ul><li>Card Table</li></ul><blockquote><p>Card Tables and Concurrent Phases  If a garbage collector does not collect the entire heap (an incremental collection), the garbage collector needs to know where there are pointers from the uncollected part of the heap into the part of the heap that is being collected. This is typically for a generational garbage collector in which the uncollected part of the heap is usually the old generation, and the collected part of the heap is the young generation. The data structure for keeping this information (old generation pointers to young generation objects), is a remembered set. A card table is a particular type of remembered set. Java HotSpot VM uses an array of bytes as a card table. Each byte is referred to as a card. A card corresponds to a range of addresses in the heap. Dirtying a card means changing the value of the byte to a dirty value; a dirty value might contain a new pointer from the old generation to the young generation in the address range covered by the card. 如果垃圾收集器不收集整个堆而是进行增量收集，则垃圾收集器需要知道从堆的未收集部分到正在收集的堆部分的指针在哪里。 这通常适用于分代垃圾收集器，其中堆的未收集部分通常是老年代，堆中已收集的部分是新生代。 保存此信息的数据结构（指向年轻代对象的老年代指针）是一个记忆集(RS)。 Card Table是一种特殊类型的记忆集。 Java HotSpot VM 使用字节数组作为卡片表。 每个字节称为一张卡片。 一张卡片对应堆中的一个地址范围。 弄脏一张卡片意味着将字节的值更改为脏值； 一个脏值可能包含一个新的指针，在卡覆盖的地址范围内从老一代到年轻一代。</p></blockquote><p>Card Table是用于简化年轻代收集,类似与一个被老年代持有年轻代对象的索引,在年轻代进行垃圾收集时按图索骥就可以把这些被跨代引用的对象找出来,之后会详细的讲述一下执行过程;</p><h3 id="执行过程"><a class="header-anchor" href="#执行过程"></a>执行过程</h3><p>G1GC底层算法是<B>标记-压缩</B>算法,这样的话它的执行步骤可以划分为两个部分:</p><ol><li>并发标记阶段<br>并发标记阶段主要是在尽量不暂停mutator线程(即访问和修改Manage Object的线程,如所有Java Thread及其Attach到JVM的thread)的情况下标记出存活的对象,而且在标记过程中会记录下每个区域(region)内存活的对象数量;</li><li>转移压缩阶段<br>转移压缩阶段主要是将待回收区域内的存活对象复杂到其他空闲区域中,然后将空闲出来的区域标记为空闲状态,类似于GC算法,但是是以单位进行的;</li></ol><p>需要注意的是<B>并发标记</B>和<B>转移压缩</B>在处理顺序上是没有先后顺序的,并发标记的结果对于转移压缩阶段也不是必须的.</p><hr><p>上面简单的描述了一下G1GC的执行过程,下面我们来详细的看一下<B>并发标记阶段</B>做的事情</p><h2 id="并发标记阶段"><a class="header-anchor" href="#并发标记阶段"></a>并发标记阶段</h2><h3 id="标记位图"><a class="header-anchor" href="#标记位图"></a>标记位图</h3><p>首先解释&quot;并发标记&quot;是在标记什么?</p><blockquote><p>并发标记是在标记所有的存活对象和可以回收的对象,并发标记并不是直接在对象内存上添加标记,而是在<B>标记位图</B>上</p></blockquote><p>标记位图如图所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/74172d16f52935f2a49645d6f14132e0b6d966f5/png/j-jvm/%E6%A0%87%E8%AE%B0%E4%BD%8D%E5%9B%BE.png?raw=true" alt="标记位图"></p><p>标记位图是对<B>region</B>中分配的对象进行一个类似于索引标记的数据结构,每个bit位对应一个对象,默认最小的对象为8字节,0代表活动对象;</p><p>每个region都有两个<B>标记位图</B>分别是nextBitMap和prevBitMap用于保存本次的位图和上一次的位图;</p><p>由于在并发标记阶段Mutator线程可以继续分配对象或者yuang GC,会破坏已经进行过标记的内存区域,因此需要用4个标记位来确定,分别是<B>bottom</B>、<B>TOP</B>、<B>prevTAMS</B>、<B>nextTAMS</B></p><p>bottom-TOP范围表示的开始标记前的某个区域的底部和顶部<br>TAMS(Top-at-Mark-Start,标记开始时的top)，prevTAMS和nextTAMS即上/下一次的标记的top</p><p>nextTAMS-TOP范围表示就就是标记过程中新产生的对象所占用的区域</p><h3 id="执行步骤"><a class="header-anchor" href="#执行步骤"></a>执行步骤</h3><p>并发标记过程包括以下5个步骤:</p><ol><li>初始标记阶段</li><li>并发标记阶段</li><li>最终标记阶段</li><li>存活对象计数阶段</li><li>收尾阶段</li></ol><h4 id="初始标记阶段"><a class="header-anchor" href="#初始标记阶段"></a>初始标记阶段</h4><ol><li>创建标记位图<blockquote><p>在初始化阶段,GC线程会首先创建Next MarkBitmap</p></blockquote></li><li>对GC Root可达对象进行扫描和标记,为了防止GC Root对象变化,<B>Mutator是暂停执行的</B>,这里需要注意的是初始标记阶段有且只会对GC Root的可达对象进行标记</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png?raw=true" alt="初始标记阶段结果"></p><h4 id="并发标记阶段-v2"><a class="header-anchor" href="#并发标记阶段-v2"></a>并发标记阶段</h4><blockquote><p>并发标记阶段,GC线程会继续扫描在初始化阶段被标记过的对象,分析它们的引用关系,完成大部分存活对象的标记</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png?raw=true" alt="并发标记阶段结果"></p><p>在并发标记阶段GC线程和Mutator线程是并发执行的,那么是如何解决<B>标记遗漏</B>问题的楠?</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC_%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5_%E6%A0%87%E8%AE%B0%E9%81%97%E6%BC%8F.png?raw=true" alt="标记遗漏"></p><p>首先说一下<B>标记遗漏</B>产生的原因,从上图中可以看到我们的GC线程已经标记到第二层对象,这个时候Mutator线程将Obj1-Obj3直接的引用关系去除,并且GCRoot-Obj3产生新的引用关系,由于Obj1标记完成后已经没有下属的任何引用那么就不会在标记Obj3,就发生了标记遗漏,可以看到发生标记遗漏的两个条件:</p><ul><li>新产生一条或多条从黑色对象(已标记对象)到白色对象(未标记对象)的新引用;</li><li>删除灰色对象(正在标记对象)到白色对象的引用关系;</li></ul><p>那么解决标记遗漏的问题就在于对这两个关系的破坏或者记录:</p><blockquote><p>在CMS中采用的是增量更新(Incremental Update)方案,破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次;</p></blockquote><blockquote><p>在G1GC中采用的是原始快照(Snapshot At The Beginning,SATB)方案,破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次;</p></blockquote><p>这里重新扫描的是灰色对象,然后是在快照中扫描,快照指的是GC在开始时对象之间的引用关系,这里会产生一个问题,将本来已经可以进行回收的对象标记为活动的,系统设计上应该是要保证没有漏掉的对象,防止不能回收掉这些内存.</p><p>G1GC采用的是<B>写屏障</B>技术来记录对象之间引用关系的变化,对于新分配的对象直接认为这部分对象是已经标记完成;</p><h4 id="最终标记阶段"><a class="header-anchor" href="#最终标记阶段"></a>最终标记阶段</h4><p>最终标记阶段是对<B>SATB本地队列</B>进行扫描,因为在并发标记介绍以后本地的SATB队列容量可能不满,不会刷新到全局SATB队列中,因此需要全局暂停来处理这些&quot;残留的SATB本地队列&quot;;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%85%A8%E5%B1%80SATB%E7%BB%93%E6%9E%84.png?raw=true" alt="全局SATB与局部SATB之间的关系"></p><p>最终标记处理的就是上图中mutator1线程和mutator2线程对于的局部SATB队列;</p><h4 id="存活对象计数阶段"><a class="header-anchor" href="#存活对象计数阶段"></a>存活对象计数阶段</h4><p>通过上面三个标记步骤(初始、并发、最终)将本次GC需要进行内存收集的对象标记出来了,这个时候就需要扫描各个区域的<B>next标记位图</B>,统计各个区域内存活对象的字节数目;<br>这个计数步骤可以和mutator是并发执行的,但是不能和转移线程(Remembered set)线程并行执行,因为如果并行执行会破坏region内的计数正确性;</p><h4 id="收尾阶段"><a class="header-anchor" href="#收尾阶段"></a>收尾阶段</h4><p>在上面两个步骤(标记、计数)中我们已经得到GC所需的最重要的两个信息:</p><ol><li>标记完成后存活对象和死亡对象之间的区分(标记位图)</li><li>存活对象的内存占用(内存占用字节数量)</li></ol><p>有上面俩组数据之后,才能进行</p><ul><li>转移压缩</li></ul><p>转移压缩过程中涉及到一个比较重要的概念<B>转移效率</B>,指的是&quot;死亡对象的字节数 % 转移所需时间&quot;,换句话说,转移效率指的是<B>转移1个字节所需时间</B>;</p><p>这里的转移指的是是对于存活对象转移的耗时,因为在一个需要对象回收比较多的region区域内,只需要将少量的存活对象转移出去,这块region就可以进行回收了;</p><p>通过<B>历史转移效率</B>的数据,就可以尝试预测下次内存需要进行回收的时间;</p><h4 id="小结"><a class="header-anchor" href="#小结"></a>小结</h4><p>在标记阶段主要是通过两种数据结构<B>标记位图</B>、<B>SATB</B>来实现对region的标识和计数,流程上分为:</p><ol><li>初始标记阶段 -&gt; GCRoot出发</li><li>并发标记阶段 -&gt; 上一步中散发的引用的对象</li><li>最终标记阶段 -&gt; 标记局部SATB中的对象</li><li>计数/收尾阶段 -&gt; 计数统计和转移</li></ol><p>对局部SATB的操作使用的是前置写屏障技术来实现的;</p><p>下面详细用一节来介绍一下转移的具体过程;</p><h2 id="GC的转移功能"><a class="header-anchor" href="#GC的转移功能"></a>GC的转移功能</h2><h3 id="转移的先决条件"><a class="header-anchor" href="#转移的先决条件"></a>转移的先决条件</h3><p>首先说一下为什么需要转移,由于内存特性会出现碎片化,因此需要对内存进行整理,才能继续分配对象,整理这个步骤具体的操作就是通过转移来实现的;</p><p>转移功能是通过具体的<B>转移专用记忆集合</B>来快速索引对象的,记录的是区域与区域之间的对象间的引用关系;通过使用转移专用记忆集合,在转移时即使不扫描所有区域内的对象,也可以查询到待转移对象<br>所在区域被其他区域引用的情况,从而简化单个区域回收的转移处理步骤;</p><blockquote><p>G1GC是通过卡表(card table)来进行实现转移专用记忆集合的元素的;</p></blockquote><p>在上图&quot;G1GC 跨代引用布局&quot;图列中的<B>Remembered Set</B>就是<B>转移专用记忆集合</B>,记录的元素就是card table的元素地址,如下所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E8%BD%AC%E7%A7%BB%E4%B8%93%E7%94%A8%E8%AE%B0%E5%BF%86%E9%9B%86%E5%90%88%E7%9A%84%E6%9E%84%E9%80%A0.png?raw=true" alt="转移专用记忆集合"></p><blockquote><p>每个区域都有一个<B>转移专业记忆集合</B>,它是通过hash列表实现的,key为引用本区域的其他区域地址,value为一个数组,元素是引用区域对应的<B>卡表</B>中的元素;<br>通过RS和Card Table这样的数据结构,在进行跨代引用对象的转移时可以快速的根据数据来进行查找;</p></blockquote><p>RS的写入是由专用的<B>转移专用记忆集合维护线程</B>来进行维护的,可以和mutator线程并发执行;</p><h3 id="转移的执行步骤"><a class="header-anchor" href="#转移的执行步骤"></a>转移的执行步骤</h3><p>转移的执行步骤可以分为以下三个:</p><ol><li><p>选择回收集合<br>指的是根据上述标记阶段得到的信息来选择被转移的区域.被选中的区域被称为<B>回收集合</B>;</p></li><li><p>根转移<br>指的是将回收集合中的由GC Root对象直接引用的对象和被其他区域引用的对象转移到其他空间中;</p></li><li><p>转移<br>指的是以2步骤中转移的对象作为起点扫描其子孙对象,然后将这些对象转移到其他空间中;</p></li></ol><h4 id="选择回收集合"><a class="header-anchor" href="#选择回收集合"></a>选择回收集合</h4><p>这个步骤是G1GC算法的核心部分,在选择需要进行回收的集合时,是按照两个原则来进行选择:</p><ul><li><B>转移效率高</B>的区域优先</li><li>整体区域转移预测的暂停时间需要在用户的容忍范围之内</li></ul><p>在标记的最后一个步骤<B>收尾阶段</B>中我们介绍了什么是<B>转移效率</B>的概念,简单的理解就是存活的对象越少,这个region的转移效率就越高;<br>然后根据转移效率对所有region进行排序,就可以得到一个region数组;<br>每一个region都有一个预测的转移暂停时间,G1GC在选择本次的<B>回收集合</B>就是从region数据从上到下依次累积预测暂停时间,直到大于等于用户的容忍时间阀值,这个子集就是<br>本次需要进行回收的集合;</p><blockquote><p>G1GC中的G1是Garbage First的简称,翻译成中文指的是&quot;垃圾优先的垃圾回收&quot;算法,而<B>转移效率从高到低的顺序</B>就是垃圾优先的具体实现方法;</p></blockquote><h4 id="根转移步骤"><a class="header-anchor" href="#根转移步骤"></a>根转移步骤</h4><p><B>根转移</B>指的是将对象或者引用转移到其他区域,包括三类数据:</p><ol><li>由根直接引用的对象</li><li>并发标记处理中的对象</li><li>由其他区域对象直接引用的回收集合内的对象</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E7%A7%BB.png?raw=true" alt="对象转移"></p><p>对象转移分为三类:</p><ol><li>对于引用到回收集合内的对象,将该对象添加到<B>转移队列</B>中,然后进行回收;</li><li>对于引用到回收集合外的对象,将更新其他对象的转移专用记忆集合;</li><li>对于其他对象引用到回收对象时,更新回收对象的转移专用记忆集合;</li></ol><h4 id="转移"><a class="header-anchor" href="#转移"></a>转移</h4><blockquote><p>在完成根转移之后,哪些被转移队列引用的对象将会<B>依次进行转移</B>.直到转移队列都被清空,转移就全部完成了;至此,回收集合内所有存活的对象都被成功转移到存活区域了;</p></blockquote><h4 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h4><p>在<B>转移阶段</B>是整个G1GC最核心的思想实现,一个是&quot;垃圾优先的垃圾回收&quot;算法的实现,一个是&quot;根对象转移算法&quot;的实现;</p><h2 id="软实时性"><a class="header-anchor" href="#软实时性"></a>软实时性</h2><p>G1GC是如何实现软实时性的?</p><p>在G1GC中用户可以设置以下三个值:</p><ol><li><p>可用内存的上限<br>通过Xmn/xmx来指定堆空间最小/最大值,避免内存被过度占用,Xmn不建议使用,这个值会破坏我们对于暂停时间上限的配置</p></li><li><p>G1GC暂停时间上限<br>使用-XX:MaxGCPauseMillis=200 为所需的最大暂停时间设置目标值,默认值为 200 毫秒.这里有一个前提是在一个GC单位时间内的暂停时间上限;</p></li><li><p>GC单位时间<br>对于GC单位时间的配置,没有找到相关资料,但是肯定是有这个概念的;避免通过频繁的GC来达到暂停时间少的目的;</p></li></ol><p>G1GC是根据<B>预测转移时间</B>和<B>预测可信度</B>这两个计算结果来实现软实时性的;</p><blockquote><p>在G1GC内部有一个<B>调度队列</B>,其中的元素是暂停处理的开始时间和结束时间的组合.G1GC使用这个队列来高效的调度GC的暂停任务.调度队列中保存了最近一次<br>暂停处理的开始时间和介绍时间.调度队列中的元素有上限,如果添加元素时超过上限,队列头部最早添加的元素就会被删除;</p></blockquote><p>如下展示一下<B>GC暂停处理的调度过程</B></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/G1GC-%E6%9A%82%E5%81%9C%E5%A4%84%E7%90%86%E7%9A%84%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png?raw=true" alt="GC暂停处理的调度过程"></p><p>图中<B>1</B>表示的是在当前时间开始预测下一次发生GC的暂停时间为X,第2步表示如果此时开始GC,在一个GC的单位时间之内会超过设定的GC暂停时间的上限,因此不进行暂停;<br>在第3步中,如果将暂停时间延迟,在GC的单位时间内不会超过设定的GC暂停时间上限;<br>需要注意的是<B>调度程序会保证在任意截取的GC单位时间内,总的GC暂停时间都不会超过用户设置的GC暂停时间上限</B>,当然在某些特殊情况下也会超出设置的暂停时间上限,这就是G1GC所保证的&quot;乱实时性&quot;,这些特殊情况包括但是不限于&quot;GC的预测时间不准确&quot;和&quot;堆内存空间不足&quot;等;</p><h2 id="分代G1GC模式"><a class="header-anchor" href="#分代G1GC模式"></a>分代G1GC模式</h2><p>在上述的<B>并发标记阶段</B>、<B>转移阶段</B>都是介绍的G1GC的进行GC时的算法和实现,在G1GC的实现中是引入了<B>分代</B>的概念的,下面来介绍一下G1GC的分代;</p><h3 id="为什么要进行分代"><a class="header-anchor" href="#为什么要进行分代"></a>为什么要进行分代?</h3><blockquote><p>分代:通过给对象引入&quot;年龄&quot;的做法来标记对象的重要程度,从而提升GC的效率;</p></blockquote><h3 id="GC模式划分"><a class="header-anchor" href="#GC模式划分"></a>GC模式划分</h3><ul><li>纯G1GC模式</li><li>分代G1GC模式</li></ul><p>两者之间的不同点:</p><p>内存划分的不同:</p><ul><li>区域是分代的</li><li>回收集合的选择是分代的</li></ul><blockquote><p>在分代G1GC模式中,区域会被划分成<B>新生代区域</B>和<B>老年代区域</B>两类;和其他分代算法类似,分代G1GC的对象也保存了自身在各次转移中存活下来的次数.新生代区域存放新生代对象,老年代区域存放老年代对象;</p></blockquote><p>在G1GC中新生代区域GC被称为<B>完全新生代GC</B>,老年代区域GC被称为部分新生代GC,他们之间的区别在于回收集合的选择,完全新生代GC是将<B>所有的新生代区域</B>选入回收集合,部分新生代GC是将<B>所有的新生代区域以及一部分老年代区域</B>选入回收集合中;</p><p>回收方式的不同:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E6%96%B0%E7%94%9F%E4%BB%A3GC%E7%9A%84%E8%BF%87%E7%A8%8B.jpg?raw=false" alt="新生代GC的过程"></p><p>从上图中可以看到部分新生代GC会将一部分老年代区域中的对象进行回收;</p><h3 id="新生代区域"><a class="header-anchor" href="#新生代区域"></a>新生代区域</h3><p>新生代区域会被划分成两类:</p><ul><li>创建区域</li><li>存活区域</li></ul><p>创建区域指的是用于存放刚刚生成一次都没有经历过转移的对象,存活区域用来保存至少转移过一次的对象;</p><p>在新生代区域中不会应用<B>转移转移写屏障</B>,因为新生代中的对象都是会被回收的,因此被引用方不会保存新生代的专用写屏障;</p><h2 id="算法篇的总结"><a class="header-anchor" href="#算法篇的总结"></a>算法篇的总结</h2><p><img src="https://raw.githubusercontent.com/agmtopy/noteBook/master/png/j-jvm/mutator%E5%92%8CGC%E7%9A%84%E6%89%A7%E8%A1%8C%E5%85%B3%E7%B3%BB.png" alt="mutator和GC的执行关系"></p><p>在大多数时候转移专用记忆集维护线程都是和mutator并发执行的,但是在GC的存活对象计数阶段记忆维护线程也是暂停的.888888</p><p>G1GC的优点:</p><ol><li>G1GC具备软实时性,可以由用户控制GC的暂停时间</li><li>能够充分发挥高配置机器的性能,做到并发执行</li><li>通过写屏障将处理粒度调整为更粗维度的卡片粒度,从而降低了写屏障发生的频率</li><li>通过对象的转移,实现了区域内没有内存碎片</li></ol><p>G1GC的缺点:</p><ol><li>适用与多核处理器的设备;</li><li>区域内不会出现碎片化,但是整个堆会按照区域出现碎片化;</li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><ul><li>《深入Java虚拟机：JVM G1GC的算法与实现》中村成洋(作者) 吴炎昌,杨文轩 (译者)</li><li>《垃圾回收的算法与实现》中村成洋,相川光,竹内郁雄 (作者) 丁灵 (译者)<br><a href="https://wiki.openjdk.org/display/HotSpot/G1GC+Feedback">G1GC Feedback</a><br><a href="https://www.huminxi.com/2022/07/06/java%208%20vs%20java%2017%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">Java 8 vs Java 17 垃圾收集器</a><br><a href="https://www.bilibili.com/video/BV15B4y1972U/">G1GC最初的设计思路（上）</a><br><a href="https://developer.aliyun.com/article/1097566">JVM垃圾回收-记忆集和卡表</a><br><a href="https://zhuanlan.zhihu.com/p/444691935">图解 Remembered Set、Card Table、Write Barrier</a><br><a href="https://tech.meituan.com/2016/09/23/g1.html">Java Hotspot G1 GC的一些关键技术</a><br><a href="https://docs.oracle.com/en/java/javase/18/gctuning/garbage-first-g1-garbage-collector1.html#GUID-58968F63-9EAF-487E-A884-CF0831EA6D31">HotSpot Virtual Machine Garbage Collection Tuning Guide</a><br><a href="https://zhuanlan.zhihu.com/p/115501055">Java Memory：认识SafeRegion</a><br><a href="https://tschatzl.github.io/2022/08/04/concurrent-marking.html">Concurrent Marking in G1</a><br><a href="http://www.noobyard.com/article/p-smfxguqn-od.html">最清晰易懂的G1GC资料</a><br><a href="https://segmentfault.com/a/1190000039300766">SATB的一些理解</a><br><a href="https://www.zhihu.com/question/456166411">G1并发标记的原始快照（SATB）的过程是怎样的？</a><br><a href="https://www.jfokus.se/jfokus17/preso/Write-Barriers-in-Garbage-First-Garbage-Collector.pdf">Write Barriers in Garbage First Garbage Collector</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《深入Java虚拟机：JVM G1GC的算法与实现》-算法篇笔记&lt;/h1&gt;
&lt;p&gt;这一篇文章主要是用于记录《深入Java虚拟机：JVM G1GC的算法与实现》一书中&lt;B&gt;算法篇&lt;/B&gt;部分的笔记,主要分为引子、并发标记、转移、软实时性、分代G1GC模式;&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/categories/jvm/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java性能权威指南-性能测试的方法和工具</title>
    <link href="https://agmtopy.gitee.io/2023/03/24/20.%E7%AC%94%E8%AE%B0/30.Java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://agmtopy.gitee.io/2023/03/24/20.%E7%AC%94%E8%AE%B0/30.Java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2023-03-24T13:44:02.000Z</published>
    <updated>2023-04-05T08:53:03.580Z</updated>
    
    <content type="html"><![CDATA[<h1>Java性能权威指南-性能测试的方法和工具</h1><h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><p>记录在阅读《Java性能权威指南》过程中的一些笔记和感悟,主要会分为一下几个部分:性能测试方式方法、影响性能的原因、如何进行调优;下面第一部分就是对<B>性能测试方式方法</B>进行分析</p><h2 id="性能测试的四项原则"><a class="header-anchor" href="#性能测试的四项原则"></a>性能测试的四项原则</h2><p>当一个应用出现性能瓶颈或者性能方面的问题时，往往不能一眼发现问题的根源，会从多个方向去猜测原因,毫无头绪，因此对应用进行性能测试是了解当前阀值的一个好方法;</p><p>性能测试时有几项原则，可以更好的帮助我们进行分析</p><ol><li>测试真实的应用</li></ol><p>在真实的应用上进行性能测试,因为如果你的测试目标和真实的应用不是同一个时,很多影响性能的因素会导致判断错误;</p><ol start="2"><li>理解批处理流逝时间、吞吐量和响应时间</li></ol><ul><li>批处理流逝时间指的是<B>一个批处理作业从开始运行到结束的时间间隔</B></li><li>吞吐量指的是单位时间内完成的工作量,常见的指标有:TPS(事务数/1s)、RPS(请求数/1s)、OPS(操作数/1s)</li></ul><ol start="3"><li><p>用统计方法应对性能的变化<br>在小样本的数据下结果会存在较大的差异,因此要采用大量的数据集来消除这种差异;</p></li><li><p>尽早的开始测试<br>这一点对于性能测试来说个人不太认同,尽早的开始测试应该是对应用代码进行测试,来保证业务上的正确性;</p></li></ol><h2 id="性能测试的种类"><a class="header-anchor" href="#性能测试的种类"></a>性能测试的种类:</h2><ol><li>微基准测试</li></ol><blockquote><p>用来测量微小代码单元的性能<br>主要是用于测试代码片段的性能,有两个问题:测试代码复杂/对于性能准确性会因为偏差造成不准</p></blockquote><ol start="2"><li>宏基准测试</li></ol><blockquote><p>宏基准测试是以真实世界中的业务为测试目标来进行测试的一种方法，是用于评估系统的整体性能;</p></blockquote><ol start="3"><li>介基准测试</li></ol><blockquote><p>介基准测试是微基准测试和宏基准测试之间的测试方法,是用于评估组成真实业务规则中的一系列子方法;</p></blockquote><h2 id=""><a class="header-anchor" href="#"></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java性能权威指南-性能测试的方法和工具&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;记录在阅读《Java性能权威指南》过程中的一些笔记和感悟,主要会分为一下几个部分:性能测试方</summary>
      
    
    
    
    <category term="性能" scheme="https://agmtopy.gitee.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cola4.0的工程实践</title>
    <link href="https://agmtopy.gitee.io/2022/12/24/1.%E6%9D%82%E8%AE%B0/Cola4.0%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/12/24/1.%E6%9D%82%E8%AE%B0/Cola4.0%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-24T03:30:46.000Z</published>
    <updated>2023-01-28T03:14:34.853Z</updated>
    
    <content type="html"><![CDATA[<h1>Cola4.0的工程实践</h1><p>cola在今年迎来了4.0版本,在最新的版本中对<B>包结构</B>进行了调整以及将COLA项目整体划分为两个部分<B>COLA架构</B>和<B>COLA组件</B>;<br>下面先简单的介绍COLA的改变,再介绍CLOA4.0的工程实践</p><h2 id="COLA的改变"><a class="header-anchor" href="#COLA的改变"></a>COLA的改变</h2><p>COLA4.0的改变主要是聚焦与COLA架构和COLA组件两个部分:</p><ol><li>COLA架构：关注应用架构的定义和构建，提升应用质量。</li><li>COLA组件：提供应用开发所需要的可复用组件，提升研发效率。<br>作者Frank画了两张图很好的表现出来</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/COLA4.0%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.png?raw=true" alt="COLA4.0分层模型"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/COLA%E6%9E%B6%E6%9E%84%E6%8A%BD%E8%B1%A1.png?raw=true" alt="COLA架构抽象"></p><h2 id="COLA-4-0d的实践"><a class="header-anchor" href="#COLA-4-0d的实践"></a>COLA 4.0d的实践</h2><h3 id="创建项目"><a class="header-anchor" href="#创建项目"></a>创建项目</h3><p>创建项目命令与之前的相同还是执行以下命令即可:</p><blockquote><p>mvn archetype:generate  -DgroupId=com.agmtopy.demo  -DartifactId=cola-demo  -Dversion=1.0.0-SNAPSHOT  -Dpackage=com.agmtopy.demo  -DarchetypeArtifactId=cola-framework-archetype-web  -DarchetypeGroupId=com.alibaba.cola  -DarchetypeVersion=4.3.1</p></blockquote><p>稍微注意修改 #groupId#/#artifactId#/#package#;<br>这个命令在PowerShell不能执行,参数传递错误,需要在CMD或者shell下执行</p><p>创建完成项目后可以看到项目目录如下:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_pom.jpg?raw=true" alt="cola项目结构_maven"></p><p>使用<B>gradle init</B>将maven转换成gradle项目</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_gradle.jpg?raw=true" alt="cola项目结构_gradle"></p><p>在maven项目转换成gradle项目时遇到几个问题:</p><ol><li>gradle ext定义常量在使用kotlin定义时,方式为<B>val</B></li><li>主build.gradle.kts引入BOM,子项目使用组件版本问题未解决,现在还是通过在子项目中直接引入的目标组件</li></ol><p>项目build成功后,通过<B>Application.main</B>启动即可访问</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola_helloworld.jpg?raw=true" alt="cola_helloworld"></p><h3 id="项目结构"><a class="header-anchor" href="#项目结构"></a>项目结构</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84_gradle.jpg?raw=true" alt="cola项目结构_gradle"></p><p>通过<B>cola-framework-archetype-web</B>创建出来的项目结构如上所示,这个结构比较符合标准项目的定义;<br>在实际使用中结合目前团队现有方案我进行了部分调整,调整后的结构如下所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/cola/cola%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5.png?raw=true" alt="项目实践"></p><pre class="line-numbers language-none"><code class="language-none">├‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧integrationtest‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧‧┤├╌╌╌╌╌╌╌╌╌api&#x2F;app╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌batch╌╌╌╌╌╌╌╌╌╌╌╌╌┤                           ├╌╌╌╌╌╌╌╌╌╌joblay╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌business&#x2F;configure╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌domain╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌infrastructure&#x2F;common╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个结构中调整的地方如下:<br>新增:<B>integrationtest</B>作为通用测试的模块<br>新增:<B>configure</B>作为业务配置的模块,专门处理业务配置<br>改变:<B>adapter</B>模块扩充为<B>api/app/batch</B>三个模块,其中app和batch作为实例的启动入口<br>改变:<B>app</B>模块扩充为<B>joblay/business/configure</B>三个模块,作为业务处理<br>改变:<B>infrastructure</B>层新增加<B>common</B>模块,承载通用处理和工具类的职能<br>删除:删除<B>start</B>模块,将启动模块下沉到<B>app</B>和<B>batch</B>中</p><p>在这个模块设计中<B>joblay</B>存在的意义是用来实现批量业务领域内的功能;由于<B>app</B>和<B>batch</B>都只是承担start的功能;</p><p>项目地址为<B><a href="https://github.com/agmtopy/cola-demo">https://github.com/agmtopy/cola-demo</a></B></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/significantfrank/article/details/110934799?spm=1001.2014.3001.5502">COLA 4.0：应用架构的最佳实践</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Cola4.0的工程实践&lt;/h1&gt;
&lt;p&gt;cola在今年迎来了4.0版本,在最新的版本中对&lt;B&gt;包结构&lt;/B&gt;进行了调整以及将COLA项目整体划分为两个部分&lt;B&gt;COLA架构&lt;/B&gt;和&lt;B&gt;COLA组件&lt;/B&gt;;&lt;br&gt;
下面先简单的介绍COLA的改变,再介绍CLOA4.</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="cola" scheme="https://agmtopy.gitee.io/tags/cola/"/>
    
  </entry>
  
  <entry>
    <title>Groowy脚本实现业务场景下动态性规则的实践</title>
    <link href="https://agmtopy.gitee.io/2022/12/16/1.%E6%9D%82%E8%AE%B0/Groowy%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8A%A8%E6%80%81%E6%80%A7%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/12/16/1.%E6%9D%82%E8%AE%B0/Groowy%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%8A%A8%E6%80%81%E6%80%A7%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-12-16T13:39:20.000Z</published>
    <updated>2023-01-04T16:56:04.305Z</updated>
    
    <content type="html"><![CDATA[<h1>Groowy脚本实现业务场景下动态性规则的实践</h1><h2 id="前言："><a class="header-anchor" href="#前言："></a>前言：</h2><p>在复杂的业务中我们往往会采用分层的思想来降低每一层的复杂度，应用层还会采用一些设计模式来预留出对于未来的扩展；在面对<br>复杂和易变的业务场景下，作为开发者，我们更期望程序框架底座能够保持稳定，而对”<B>扩展</B>”更期望可以做到能快速响应业务需求的变化和做到隔离性；<br>由于程序语言的特性，有些语言不能做到实时热编译和部署，需要借助其他工具来实现这一个效果，在jvm平台上Groovy脚本语言就非常适合这种场景。<br>接下来以一个具体的业务需求来作为“引子”，来展开是这个需求实现过程中的一些思考和实践;</p><h2 id="需求背景"><a class="header-anchor" href="#需求背景"></a>需求背景</h2><p>原始需求简化后得出的核心目标就是对业务数据进行巡检,本身从功能上来讲比较简单;在系统设计出发的时候就明确了本次的功能目标:</p><ol><li>向上会抽象出<B>巡检功能</B>的核心领域,并且支持扩展</li><li>向下会设计出基础设施层来作为支撑</li></ol><p>向上这一部分工作开展的比较顺利,因为是基于现实诉求抽象公共特性/接口;但是向下这一部分设计在落地的时候遇到一些问题,有三个阶段分别是:</p><ol><li>采用手动编译java代码</li><li>采用开源框架编译加载java代码</li><li>使用Groovy动态脚本</li></ol><h3 id="设计评审"><a class="header-anchor" href="#设计评审"></a>设计评审</h3><p>在实现这个需求的时候,做技术方案设计评审的时候,我提供了两种实现基础设施层的技术方案:<br>第一种是通过easy-rules提供出一个一个散列开的业务校验规则执行器,这样做的优点是在于技术成本最低,且代码可读性好,但是没有动态编译执行的能力<br>第二种是通过引入动态语言实现,这样做的优点是程序具有动态编译执行的能力,缺点是在于技术成本略高,Groovy脚本语言需要一定的学习成本</p><p>最后的技术评审经过大家的沟通交流最后决定采用第一种方案来进行实现;</p><h3 id="方案实施"><a class="header-anchor" href="#方案实施"></a>方案实施</h3><p>在按照第一种方案进行实施的时候,遇到一个问题,代码的重复度太高;因为业务需求的本质就只是<B>对比</B>,因此最开始想采用反射来降低代码的重复度,将需要检查的字段放在Map进行处理;<br>在继续沿着这方面思考,就想到了既然是用Map来获取校验规则,那可不可以将校验规则写入配置中心或者数据库,再进行动态加载楠;<br>沿着这个思路开始查找java文件进行动态编译的框架<a href="https://github.com/jOOQ/jOOR">joor</a>,在进行快速验证的时候发现joor可以做到对java文件的动态编译,但是在JDK8上有部分编译错误无法实现业务的扩展性;<br>这个时候似乎只有一种选择了,就是采用<B>Groovy</B>来进行实现</p><h2 id="Groovy使用"><a class="header-anchor" href="#Groovy使用"></a>Groovy使用</h2><h3 id="整体执行流程"><a class="header-anchor" href="#整体执行流程"></a>整体执行流程</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/excalidraw/Untitled-2022-09-08-1533.png?raw=true" alt="整体执行流程"></p><p>在流程中抽象的比较方法是作为所有动态脚本的父类,默认采用了反射的反射来或者Object中指定的字段</p><h3 id="DynamicUtil的设计"><a class="header-anchor" href="#DynamicUtil的设计"></a>DynamicUtil的设计</h3><p>从四个问题开始入手:</p><ol><li>如何简化Groovy的学习成本,从而推广出去?</li><li>如何保证性能?</li><li>如何保证动态脚本的安全性?</li><li>如何保证动态脚本的代码质量(动态脚本的单元测试如何进行)?</li></ol><h4 id="对于如何简化Groovy的学习成本"><a class="header-anchor" href="#对于如何简化Groovy的学习成本"></a>对于如何简化Groovy的学习成本?</h4><p>项目初期可以采用<B>GroovyClassLoader</B>来执行<B>Java脚本</B></p><ul><li>DynamicUtil</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">GroovyClassLoader</span> groovyClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroovyClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> helloScript <span class="token operator">=</span> <span class="token string">"package com.agmtopy.source.groovy;\n"</span> <span class="token operator">+</span>                <span class="token string">"\n"</span> <span class="token operator">+</span>                <span class="token string">"class Hello &#123;\n"</span> <span class="token operator">+</span>                <span class="token string">"    public String method(String name) &#123;\n"</span> <span class="token operator">+</span>                <span class="token string">"        System.out.println(\"hello, \" + name);\n"</span> <span class="token operator">+</span>                <span class="token string">"        return name;\n"</span> <span class="token operator">+</span>                <span class="token string">"    &#125;\n"</span> <span class="token operator">+</span>                <span class="token string">"&#125;\n"</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span> helloClass <span class="token operator">=</span> groovyClassLoader<span class="token punctuation">.</span><span class="token function">parseClass</span><span class="token punctuation">(</span>helloScript<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">GroovyObject</span> object <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">GroovyObject</span><span class="token punctuation">)</span> helloClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> ret <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">invokeMethod</span><span class="token punctuation">(</span><span class="token string">"method"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 控制台输出"hello, world"</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印world</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Hello.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>agmtopy<span class="token punctuation">.</span>source<span class="token punctuation">.</span>groovy</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在上面这个例子中,我们执行的脚本就是java语法规则的脚本;这样如何简化Groovy脚本的问题就可以得到解决;<br>在整个执行框架稳定以后,还是需要推广Groovy脚本,java语法的脚本只是一个中间过渡方案!</p><h4 id="如何保证脚本的执行性能"><a class="header-anchor" href="#如何保证脚本的执行性能"></a>如何保证脚本的执行性能?</h4><p>这里的性能指的是两方面:<B>编译</B>和<B>执行</B>,我们先来看Groovy是如何编译脚本的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Class</span> <span class="token function">parseClass</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">GroovyCodeSource</span> codeSource<span class="token punctuation">,</span> <span class="token keyword">boolean</span> shouldCacheSource<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CompilationFailedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取cacheKey:scriptTest+name 进行MD5</span>    <span class="token class-name">String</span> cacheKey <span class="token operator">=</span> <span class="token function">genSourceCacheKey</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//sourceCache是一个类似与Map类型的类</span>    <span class="token keyword">return</span> sourceCache<span class="token punctuation">.</span><span class="token function">getAndPut</span><span class="token punctuation">(</span>            cacheKey<span class="token punctuation">,</span>            key <span class="token operator">-></span> <span class="token function">doParseClass</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">,</span>            shouldCacheSource    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">Class</span> <span class="token function">doParseClass</span><span class="token punctuation">(</span><span class="token class-name">GroovyCodeSource</span> codeSource<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">validate</span><span class="token punctuation">(</span>codeSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span> answer<span class="token punctuation">;</span>  <span class="token comment">// Was neither already loaded nor compiling, so compile and add to cache.</span>    <span class="token class-name">CompilationUnit</span> unit <span class="token operator">=</span> <span class="token function">createCompilationUnit</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> codeSource<span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//省略...</span>        <span class="token comment">//创建ClassCollector,class类属性相关的收集对象</span>    <span class="token class-name">ClassCollector</span> collector <span class="token operator">=</span> <span class="token function">createCollector</span><span class="token punctuation">(</span>unit<span class="token punctuation">,</span> su<span class="token punctuation">)</span><span class="token punctuation">;</span>    unit<span class="token punctuation">.</span><span class="token function">setClassgenCallback</span><span class="token punctuation">(</span>collector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开始执行编译命令</span>    unit<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>goalPhase<span class="token punctuation">)</span><span class="token punctuation">;</span>    answer <span class="token operator">=</span> collector<span class="token punctuation">.</span>generatedClass<span class="token punctuation">;</span>    <span class="token class-name">String</span> mainClass <span class="token operator">=</span> su<span class="token punctuation">.</span><span class="token function">getAST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMainClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token operator">:</span> collector<span class="token punctuation">.</span><span class="token function">getLoadedClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token class-name">String</span> clazzName <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">definePackageInternal</span><span class="token punctuation">(</span>clazzName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置到classCache中</span>        <span class="token function">setClassCacheEntry</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置为answer</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazzName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mainClass<span class="token punctuation">)</span><span class="token punctuation">)</span> answer <span class="token operator">=</span> clazz<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> answer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中,执行流程如下</p><p>doParseClass() -&gt; createCollector() -&gt; unit.compile(goalPhase) -&gt; ClassCollector.call() -&gt; ClassCollector.createClass()</p><p>创建class对象的过程是在<B>ClassCollector.createClass</B>方法中,在这个方法中可以看到最后是调用的java.security.SecureClassLoader#defineClass()</p><ul><li>ClassCollector.createClass</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span> <span class="token function">createClass</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> code<span class="token punctuation">,</span> <span class="token class-name">ClassNode</span> classNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">BytecodeProcessor</span> bytecodePostprocessor <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytecodePostprocessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fcode <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytecodePostprocessor<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fcode <span class="token operator">=</span> bytecodePostprocessor<span class="token punctuation">.</span><span class="token function">processBytecode</span><span class="token punctuation">(</span>classNode<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fcode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//GroovyClassLoader extends SecureClassLoader</span>    <span class="token class-name">GroovyClassLoader</span> cl <span class="token operator">=</span> <span class="token function">getDefiningClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//这里通过SecureClassLoader.defineClass 来进行加载</span>    <span class="token class-name">Class</span> theClass <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>classNode<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fcode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fcode<span class="token punctuation">.</span>length<span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">getAST</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadedClasses<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>theClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//省略...</span>    <span class="token keyword">return</span> theClass<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里还有一个点是在创建<B>GroovyClassLoader</B>时,都是通过<B>new InnerLoader</B>的方式来创建</p><blockquote><p>return java.security.AccessController.doPrivileged((PrivilegedAction<InnerLoader>) () -&gt; new InnerLoader(GroovyClassLoader.this));</p></blockquote><p>这是因为Class对象是通过ClassLoader+class的方式来定位确定唯一一个类的,InnerLoader每次都会创建一个新的对象,这样可能会导致Metaspace内存溢出,虽然在Groovy3.0以后针对这个问题已经进行过优化了,但是还是强烈建议通过内存将脚本编译后的<B>GroovyObject</B>缓存下来,本身脚本的再次编译和加载都是一个较为消耗性能的动作;</p><p>我们下面继续对<B>执行性能</B>来进行分析,在网上大多数资料对于Groovy的脚本执行性能的分析,github中关于这方面的issue也比较少,并且大部分是针对与Groovy和Java进行对比的;<br>下面有几个关于Groovy脚本执行的建议:</p><ol><li>尽量使用静态类型,由于Groovy是动态语言,在将动态特性编译成为静态语言时是比较消耗性能的</li><li>oracle官方对于Groovy的5条性能建议</li></ol><h4 id="如何保证动态脚本的安全性"><a class="header-anchor" href="#如何保证动态脚本的安全性"></a>如何保证动态脚本的安全性?</h4><p>如何保证动态脚本的安全性?其实也是分为两个方面考虑的:</p><ol><li>执行安全性</li></ol><blockquote><p>执行安全性指的是在执行脚本时是否会影响到我的宿主进程?如何规避这种风险?</p></blockquote><ol start="2"><li>脚本本身的安全性</li></ol><blockquote><p>脚本本身的安全性指的是脚本语义是否正确/正常以及可信</p></blockquote><p>下面对着两方面进行分析和设计:</p><p><B>脚本执行的安全性</B>方面最主要的考虑是错误的脚本是否会影响到主进程的执行?主要从下面几个方面考虑:</p><ol><li>内存<blockquote><p>内存主要还是考虑堆栈内存即可,一个是成员变量的空间分配,一个是while造成死循环使栈溢出等;可以在定义<B>GroovyClassLoader</B>时进行排除</p></blockquote></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">SecureASTCustomizer</span> secure <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecureASTCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建SecureASTCustomizer</span>secure<span class="token punctuation">.</span><span class="token function">setClosuresAllowed</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 禁止使用闭包</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> tokensBlacklist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tokensBlacklist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Types</span><span class="token punctuation">.</span>*<span class="token operator">*</span>KEYWORD_WHILE<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加关键字黑名单 while和goto</span>tokensBlacklist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Types</span><span class="token punctuation">.</span>*<span class="token operator">*</span>KEYWORD_GOTO<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setTokensBlacklist</span><span class="token punctuation">(</span>tokensBlacklist<span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setIndirectImportCheckEnabled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置直接导入检查</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"com.alibaba.fastjson.JSONObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>secure<span class="token punctuation">.</span><span class="token function">setImportsBlacklist</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>线程</li></ol><blockquote><p>对与线程方面的考虑主要是执行线程需要使用单独的线程池进行处理,这样做的目的是防止动态脚本的执行线程阻塞业务线程;第二个是动态脚本中应该禁止使用线程池来进行处理,这方面的考量主要是基于脚本业务代码尽量的要简单高效和可读性,引入线程池会增加脚本的复杂度和可维护性</p></blockquote><ol start="3"><li>数据库/资源的管理</li></ol><blockquote><p>对与数据库和其他资源的访问,我是持有拒绝的态度,主要观点还是和脚本中实现线程池类似,还有一点是脚本中进行数据变更和资源处理缺少了代码版本控制这一个环节;</p></blockquote><p><B>脚本本身的安全性</B>主要指的是脚本开发/提测/上线整个流程的安全和监控性,在这方面Vivo提供了一套内部使用的流程如下:</p><p><img src="https://static001.geekbang.org/infoq/ac/acf787602d9e4bf20abded0c80525565.png" alt="Groovy整体流程"></p><p>在这个过程中,除了code review部分需要开发者进行参与,其他部分都可以依托CI/CD工具实现自动化执行;<br>有了这样一个流程,其实是可以解决脚本本身的安全性的问题的;</p><h4 id="如何保证动态脚本的代码质量"><a class="header-anchor" href="#如何保证动态脚本的代码质量"></a>如何保证动态脚本的代码质量?</h4><p>动态脚本的代码质量如何进行保证,一方面是可以通过良好的code review机制来提高质量,另外一方面是需要建设好单元测试框架;<br>如何建立好动态脚本的单元测试?<br>首先是方便,在开发人员的角度一个工具只有在足够的简单方便的情况下才会乐意去进行使用,其次是流程规范.<br>目前执行的过程是在特定的测试包下,开发脚本,然后进行单元测试,在单元测试通过后在写入数据库中;<br>后续实践出更好的方案在进行更新</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>以上通过Groovy实现了动态特性的同时引入了一些尚未解决的问题:<br>执行性能/单元测试,后续在实践过程中也会对这些问题持续的进行更新.</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/en/cloud/paas/app-builder-cloud/visual-builder-groovy/best-practices-for-groovy-performance.html">oracle官方对于Groovy 性能的最佳实践</a><br><a href="https://www.huangchaoyu.com/2021/10/16/groovy%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%AE%B9%E6%98%93%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/">groovy静态编译容易引发的问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Groowy脚本实现业务场景下动态性规则的实践&lt;/h1&gt;
&lt;h2 id=&quot;前言：&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;
&lt;p&gt;在复杂的业务中我们往往会采用分层的思想来降低每一层的复杂度，应用层还会采用一些设计</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="guava" scheme="https://agmtopy.gitee.io/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>Class文件格式与加载</title>
    <link href="https://agmtopy.gitee.io/2022/12/03/12.JVM/9.Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8A%A0%E8%BD%BD/"/>
    <id>https://agmtopy.gitee.io/2022/12/03/12.JVM/9.Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-12-03T15:02:44.000Z</published>
    <updated>2022-12-04T10:14:51.378Z</updated>
    
    <content type="html"><![CDATA[<h1>Class文件格式与加载</h1><h2 id="类文件结构"><a class="header-anchor" href="#类文件结构"></a>类文件结构</h2><ul><li>类文件结构也就是Class文件的结构<ul><li>魔数:用于标识Class文件的版本</li><li>常量池:主要用于保存<strong>字面量(类似于字符串等)</strong> 和 <strong>符号引用(类和接口的全限定名\字段名称以及描述符\方法名称和描述符);</strong> 由于jvm在加载Class文件时才会进行<B>动态连接</B>,因此需要保存这些方法或接口的信息</li><li>访问标识:标识这个Class的类型(接口/类/public/abstract/final等)</li><li>类索引、父类索引与接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul></li></ul><h2 id="虚拟机类加载机制"><a class="header-anchor" href="#虚拟机类加载机制"></a>虚拟机类加载机制:</h2><ul><li>虚拟机把描述类的数据从Class文件加载到内存中,并对数据进行校验、转换解析、初始化的过程,最终形成可以被虚拟机之间使用的Java类型对象,就是虚拟机类的加载过程.</li></ul><h3 id="类加载的步骤"><a class="header-anchor" href="#类加载的步骤"></a>类加载的步骤</h3><ol><li>加载</li><li>连接:验证→准备→解析</li><li>初始化</li><li>使用</li><li>卸载</li></ol><p>在执行顺序上:加载→验证→准备→解析→初始化,这五个步骤的顺序是固定的;</p><h4 id="加载"><a class="header-anchor" href="#加载"></a>加载</h4><ol><li>通过类的全限定名来获取定义此类的二进制字节流</li><li>将二进制字节流转换为方法区运行时的数据结构</li><li>在内存中创建这个类的Class对象,作为方法区类结构的方法映射</li></ol><ul><li>对于HotSpot虚拟机而言,Class对象比较特殊,它虽然是对象,但是存放在方法区内,作为访问类结构的对象接口</li></ul><h4 id="验证"><a class="header-anchor" href="#验证"></a>验证</h4><ol><li>文件格式的验证:文件格式\运行版本等</li><li>元数据的验证:对字节码语义信息的分析,</li><li>字节码内容的验证:通过程序来校验方法块中的内容是否正确</li></ol><p>验证阶段贯穿[加载、准备、解析]，并不是严格的线性的顺序</p><h4 id="准备"><a class="header-anchor" href="#准备"></a>准备</h4><ol><li>为类变量分配内存并设置初始值的过程，对于类变量也仅仅是进行类型初始值的赋值(零值)</li><li>final修饰的类变量在这个阶段会直接进行赋实际值的过程，因为final修饰的值会被当作常量</li></ol><h4 id="解析"><a class="header-anchor" href="#解析"></a>解析</h4><ul><li>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程<ol><li>解析阶段会触发类的加载，当为找到Class对象时会根据类的全限定明进行加载</li><li>对字段会按照继承顺序从下先上进行查找，并校验访问权限</li><li>对类方法和接口方法的解析与字段类似</li></ol></li></ul><h4 id="初始化"><a class="header-anchor" href="#初始化"></a>初始化</h4><p>初始化就是在执行<B>clint()</B>的过程</p><p><B>clint()</B>是编译器自动收集类中所有的类变量赋值动作和静态语句块合并生成的</p><p>静态代码块可以对在它之后的类变量进行赋值，但是不能进行访问；因为类变量在<strong>准备阶段</strong>就完成的零值的赋值</p><p>虚拟机内部保证了在执行器之类的<B>clint()</B>方法之前先执行父类的<B>clint()</B>方法</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/ClassLoader_flow.jpg?raw=true" alt="Class文件整体加载结构"></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.geeksforgeeks.org/classloader-in-java/">java中的类加载器</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Class文件格式与加载&lt;/h1&gt;
&lt;h2 id=&quot;类文件结构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#类文件结构&quot;&gt;&lt;/a&gt;类文件结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类文件结构也就是Class文件的结构
&lt;ul&gt;
&lt;li&gt;魔数:用于标识Class</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>性能监控与故障处理工具</title>
    <link href="https://agmtopy.gitee.io/2022/12/01/1.%E6%9D%82%E8%AE%B0/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://agmtopy.gitee.io/2022/12/01/1.%E6%9D%82%E8%AE%B0/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2022-12-01T15:11:20.000Z</published>
    <updated>2022-12-03T14:59:38.223Z</updated>
    
    <content type="html"><![CDATA[<h1>性能监控与故障处理工具</h1><p>介绍处理jvm的相关问题办法以及相关工具的一个持续更新的集合</p><h2 id="📚-经验"><a class="header-anchor" href="#📚-经验"></a>📚 经验</h2><h3 id="CPU占用率高"><a class="header-anchor" href="#CPU占用率高"></a>CPU占用率高</h3><ul><li>通过jvm工具排查</li></ul><ol><li>通过<strong>top</strong>命令查询进程号</li><li>通过<strong>top -Hp <pid></strong> 查到线程号,转换成为<strong>16进制</strong></li><li>通过<strong>jstack <pid> |grep 16进制线程号 -A 10</strong> 找到CPU当前执行的方法堆栈</li></ol><ul><li>通过arthas排查</li></ul><ol><li>thread</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看线程状态(默认只显示10个线程)</span>thread <span class="token comment"># 查看全部线程状态</span>thread --all<span class="token comment"># 查看指定线程执行状态</span>thread --pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="OOM问题"><a class="header-anchor" href="#OOM问题"></a>OOM问题</h3><ol><li>启动命令中设置</li></ol><blockquote><p><B>-XX:+HeapDumpOnOutOfMemoryError</B> 配合<B> -XX:HeapDumpPath</B><br>在OOM时生成dump文件</p></blockquote><ol start="2"><li>线上命令</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#生成堆转储快照dump文件命令</span>  jmap -dump:format<span class="token operator">=</span>b,file<span class="token operator">=</span>heapdump.hprof pid<span class="token comment"># 生成堆栈信息文件命令</span>  jstack -l pid <span class="token operator">>></span> stack.txt<span class="token comment"># Arthas命令</span>  heapdump<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程问题"><a class="header-anchor" href="#线程问题"></a>线程问题</h3><ul><li>线程池提交任务不执行</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># arthas排查</span><span class="token comment"># 获取ClassLoad Hash</span>sc -d com.agmtopy.source.executer.ExecutorServiceUtil<span class="token comment"># 获取对象</span>ognl -x <span class="token number">1</span> <span class="token string">'@com.agmtopy.source.executer.ExecutorServiceUtil@threadPoolExecutor'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>线程死锁</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> <span class="token comment"># arthas排查</span>Thread -b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="⚙-工具"><a class="header-anchor" href="#⚙-工具"></a>⚙ 工具</h2><p><B>Arthas</B>强烈推荐</p><h2 id="📒-常用命令"><a class="header-anchor" href="#📒-常用命令"></a>📒 常用命令</h2><h3 id="网络"><a class="header-anchor" href="#网络"></a>网络</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 采样tcp连接</span><span class="token function">lsof</span> -p 进程号 <span class="token operator">></span> /tmp/进程号_lsof.txt<span class="token comment"># 查看指定端口</span><span class="token function">netstat</span> -tnlp <span class="token operator">|</span> <span class="token function">grep</span> :8080ss -tunlp <span class="token operator">|</span><span class="token function">grep</span> :8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排查网络问题步骤:</p><ol><li>ping 目标地址</li><li>丢包<br>a. 链路中断<br>b. 抖动<br>c. 出口堵塞</li><li>能通<br>a. 检查dns和域名解析</li></ol><blockquote><p>/etc/resolv.conf 或者 dig 或者 nslookup :url</p></blockquote><p>b. 检查端口</p><blockquote><p>telnet -&gt; 如果全部端口不通检查<B>安全组策略</B>;部分端口不通检查<B>负载均衡白名单</B></p></blockquote><ol start="3"><li>不通<br>检查ip设置/网卡驱动/物理链路</li></ol><h3 id="内存"><a class="header-anchor" href="#内存"></a>内存</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 系统内存分布</span>pmap -pid<span class="token comment"># 内存占用</span>jmap -heap 进程号 <span class="token operator">></span> /tmp/进程号_jmap_heap.txt<span class="token comment"># 保存进程堆栈</span>jmap -dump:format<span class="token operator">=</span>b,file<span class="token operator">=</span>/tmp/进程号_jmap_dump.hprof 进程号<span class="token comment"># 内存对象占比</span>jmap -histo <span class="token number">1</span> <span class="token operator">|</span><span class="token function">more</span><span class="token comment"># GC</span>jstat -gcutil 进程号 <span class="token operator">></span> /tmp/进程号_jstat_gc.txtjstat -gcutil <span class="token number">1</span> 1s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CPU"><a class="header-anchor" href="#CPU"></a>CPU</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看系统上下文切换</span><span class="token function">vmstat</span> -w <span class="token number">1</span><span class="token comment"># 查看进程上下文切换</span>pidstat -p /PID -wtu  <span class="token number">5</span><span class="token comment"># 打印系统负载快照</span><span class="token function">top</span> -b -n <span class="token number">2</span> <span class="token operator">></span> /tmp/top.txt<span class="token function">top</span> -H -n <span class="token number">1</span> -p pid <span class="token operator">></span> /tmp/pid_top.txt<span class="token comment"># 进程列表</span><span class="token function">ps</span> -mp-o THREAD,tid,time <span class="token operator">|</span> <span class="token function">sort</span> -k2r <span class="token operator">></span> /tmp/进程号_threads.txt<span class="token comment"># 线程信息</span>jstack -l 进程号 <span class="token operator">></span> /tmp/进程号_jstack.txt<span class="token comment"># Arthas</span>thread thread -tidthread -all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="I-O"><a class="header-anchor" href="#I-O"></a>I/O</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">strace</span> -p pidiotop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;性能监控与故障处理工具&lt;/h1&gt;
&lt;p&gt;介绍处理jvm的相关问题办法以及相关工具的一个持续更新的集合&lt;/p&gt;
&lt;h2 id=&quot;📚-经验&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#📚-经验&quot;&gt;&lt;/a&gt;📚 经验&lt;/h2&gt;
&lt;h3 id=&quot;CPU占</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="工具" scheme="https://agmtopy.gitee.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>jvm-垃圾回收器及算法基础</title>
    <link href="https://agmtopy.gitee.io/2022/12/01/12.JVM/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://agmtopy.gitee.io/2022/12/01/12.JVM/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-12-01T14:02:27.000Z</published>
    <updated>2022-12-03T14:59:41.787Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收器及算法基础</h1><h2 id="前提介绍"><a class="header-anchor" href="#前提介绍"></a>前提介绍</h2><p>垃圾回收器(GC)的理论研究在很早直接就开始了,大概是在60年代lisp语言就开始使用内存分配和垃圾回收机制来管理程序的内存了,近现代这一方向也是保持着极高的研究热度,从G1-&gt;ZGC</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/excalidraw/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80.png?raw=true" alt="大纲"></p><h2 id="算法基础"><a class="header-anchor" href="#算法基础"></a>算法基础</h2><p>对内存空间的回收首先需要解决一个问题那些是需要进行回收的对象,针对这个问题有两种处理方案:</p><ul><li><p>引用计数算法<br>引用计数是通过对对象被引用次数来标识是否有效,存在循环引用问题,可以通过可达性分析的步骤来解决</p></li><li><p>根标记算法,从<strong>GC Roots</strong>开始遍历整个内存对象是否可达的方式来标记需要回收的对象</p><p>首先<strong>GC Roots</strong>对象包括以下的几种:</p><ul><li>虚拟机栈中引用指向的对象(reference)</li><li>方法区中类静态属性引用的对象(静态属性对象,虽然不在栈帧中)</li><li>方法区常量引用的对象(例如常量池中的对象)</li><li>本地方法栈中引用的对象</li></ul></li></ul><h2 id="对象"><a class="header-anchor" href="#对象"></a>对象</h2><ul><li><p>对象的回收</p><p>对象的回收是一个非常严肃的动作,错误的回收将会是一场对用户的灾难,因此在JVM的实现中,对于GC线程的优先级设置的非常低,其次是在标记对象不可达后,还会声明会执行一次<strong>对象</strong>的**finalize()**方法,对于这个方法是否执行完成不做保证(防止死循环/wait time)</p><ul><li>finalize():用于GC回收前对象最后一次自救的方法,但是只会执行一次,防止内存溢出</li></ul></li><li><p>对象的分配</p><p>对象的分配与垃圾收集器的选择有关,对象是优先在Eden区进行分配,</p><p>进入老年代的几种场景:</p><ol><li>大对象直接进入老年代</li><li>长期存活的对象(16次GC)</li><li>动态对象年龄判断(一半相同年龄的对象直接进入老年代)</li></ol></li></ul><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><ul><li><p>标记类</p><p>标记-清除算法/标记-整理算法/复制算法</p><ul><li>标记整理算法是通过时间换空间形式的一种体现,通过整理回收后的内存碎片来达到可以继续分配的目的</li><li>复制算法是空间换时间的体现,通过预留一倍的空间来达到内存回收完成后没有内存碎片的问题</li></ul></li><li><p>分代类</p><p>分代算法主要是根据对象的存活周期,将对象划分为不同区域,在不同的区域上采取不同的算法来处理</p></li></ul><h2 id="HotSopt实现"><a class="header-anchor" href="#HotSopt实现"></a>HotSopt实现</h2><ul><li><p>枚举根节点</p><p>通过<strong>OopMap</strong>的的方式来快速查找GC Roots枚举</p></li><li><p>安全点</p><p>由于引用关系的变化会不断的影响GC Roots,因此HotSpot不是每条指令都会生成OopMap,而只在特定的位置才会产生OopMap,这种特殊的位置被称为<strong>Safe pint</strong>,有两种进入Safe point的方式:</p><ul><li>抢占式</li><li>主动中断式:主动中断的方式是通过设置<strong>中断标记</strong></li></ul></li><li><p>安全区域</p><p>安全区域被称为Safe Region,指的是一段不会改变引用关系的代码,在执行GC时是不会处理已进入Safe Region的线程,当这些线程在离开Sefe Region时也会检查GC是否完成</p></li></ul><h2 id="垃圾收集器"><a class="header-anchor" href="#垃圾收集器"></a>垃圾收集器</h2><ul><li><p>Parallel Scavenge收集器</p></li><li><p>Parallel  Old收集器</p><p>两种Parallel收集器分别是jdk8中默认是年轻代和老年代的垃圾收集器</p><ul><li><p>Parallel Scavenge收集器</p><p>用于<strong>新生代,<strong>关注</strong>吞吐量</strong>的多线程并行收集器</p><p>CMS是关注于停顿时间,尽可能的缩短用户线程的停顿时间,适合于有交互的web系统</p><p>Parallel是关注于吞吐量尽可能的在单位时间内多执行用户代码,缩小GC时间,适用于后台任务</p></li><li><p>Parallel Old收集器</p><p>是老年代的标记-整理算法的多线程垃圾收集器</p></li><li><p>CMS收集器(<strong>三标一清</strong>)</p><p>CMS收集器是以最短停顿时间为目标的垃圾收集器,是基于标记-清除算法演化而来,分为:</p><ol><li>初始标记阶段</li><li>并发标记阶段</li><li>重新标记阶段</li><li>并发清除阶段</li></ol><p>在初始标记和重新标记阶段会STW的方式来进行,因为初始化标记是查找**GC Roots,**重新标记是对并发标记阶段结果修正也需要STW;</p><p>整个CMS中最耗时的<strong>并发标记</strong>和<strong>并发清理阶段</strong>都可以和用户线程一起执行</p><p>CMS垃圾收集器的问题:</p><ol><li>参与线程过高,按照(coreSize+3)/4的方式分配</li><li>无法处理浮动垃圾,对于在重新标记后产生的垃圾只能在下一次GC时进行处理,占用空间,当老年代达到一个阈值后会出发full GC,当CMS在运行时产生内存不足会激活serial GC</li><li>内存碎片问题,通过full GC的方式解决</li></ol></li><li><p>G1收集器</p><ul><li>从jdk9开始G1就作为默认的垃圾处理器</li><li>在整体上G1是标记-整理算法,局部上是标记-复制算法</li></ul></li><li><p>Shenandoah/ZGC收集器</p><ul><li>亚毫秒级</li><li>无分区设计</li></ul></li></ul></li></ul><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.baeldung.com/jvm-zgc-garbage-collector">ZGC简介:可扩展的实验性低延迟 JVM 垃圾收集器</a><br><a href="https://xie.infoq.cn/article/586f901cf8f38dd2f63b54a44">ZGC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收器及算法基础&lt;/h1&gt;
&lt;h2 id=&quot;前提介绍&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提介绍&quot;&gt;&lt;/a&gt;前提介绍&lt;/h2&gt;
&lt;p&gt;垃圾回收器(GC)的理论研究在很早直接就开始了,大概是在60年代lisp语言就开始使用内存分配和垃圾回</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm-内存布局设计</title>
    <link href="https://agmtopy.gitee.io/2022/11/30/12.JVM/7.%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/"/>
    <id>https://agmtopy.gitee.io/2022/11/30/12.JVM/7.%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-11-30T14:13:23.000Z</published>
    <updated>2022-12-03T14:57:50.139Z</updated>
    
    <content type="html"><![CDATA[<h1>内存布局设计</h1><p>JVM的内存设计上是划分为两个大的区域的<B>启动时向操作系统分配的程序内存区域</B>、<B>直接对系统内存进行操作的区域</B>,后者不属于JVM管理,我们主要是分析前者</p><h2 id="大体结构"><a class="header-anchor" href="#大体结构"></a>大体结构</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/jvm%E6%80%BB%E8%A7%88.png?raw=true" alt="JVM架构图"></p><ol><li>程序计数器<ol><li><p>程序计数器是用来记录当前线程所执行的字节码的行号指示器,字节码解释器在工作时就是通过改变这个计数器的值来记录当前执行的指令.</p><p>它是JVM层次的指令执行记录与硬件层次的指令地址寄存器(IR)的区别在于程序计数器只是一段内存区域,通过软件实现的记录虚拟机字节码的执行地址,当执行Native方法时,该区域值为空</p></li><li><p>为什么要有程序计数器?</p><ol><li>在于jvm提交给CPU执行的指令不是一次性全部提交过去的,而是根据java的业务逻辑通过jvm编译在提交给CPU相应的指令,所以需要对IR进行抽象</li></ol></li></ol></li><li>Java虚拟机栈<ol><li>虚拟机栈描述的是Java方法执行时候的内存模型:线程在执行方法时都会创建相应独立的栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息;</li><li>虚拟机栈是由一个个栈帧组成的</li><li>局部变量表用于存储编译器可知的各种基本数据类型的值引用、对象引用、returnAddres类型(指向一个指令的类型,指的是方法返回的指令地址)</li></ol></li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E7%BA%BF%E7%A8%8B%E5%B8%A7%E6%A0%88.png?raw=true" alt="栈帧"></p><ol><li><p>本地方法栈</p><p>本地方法栈是用于表示对本地方法(native)执行的’c stack’</p></li><li><p>java堆</p><p>java堆是java进程管理的最大的一块内存区域,这个区域允许所有线程访问,作用是在这个区域分配对象实例空间;堆所分配的内存空间不需要是连续的(物理/逻辑上都是一样),在HotSpot中堆空间在默认情况下是申请的连续分配</p></li><li><p>方法区</p><p>方法区用于虚拟机加载类信息、常量池、静态变量、即时编译器编译后的代码数据等</p></li><li><p>常量池</p><p>常量池用于存放在编译期产生的各种字符串、符号引用以及允许运行期动态添加</p></li><li><p>直接内存</p></li></ol><p>直接内存指的是通过Native方法直接分配的堆外内存部分</p><h2 id="堆上内存分配过程"><a class="header-anchor" href="#堆上内存分配过程"></a>堆上内存分配过程</h2><p>堆上内存分配过程约等于对象的堆内存分配过程,堆上内存分配需要并发分配的问题,目前有两种处理方案:</p><ol><li>通过CAS机制加上失败重试来保证操作的原子性</li><li>通过本地线程分配缓冲(TLAB)的方式来保证,核心思想就是通过预先划分线程独占的内存空间来<strong>尽量避免从堆上直接分配内存从而避免频繁的锁竞争</strong></li></ol><h2 id="对象的内存布局"><a class="header-anchor" href="#对象的内存布局"></a>对象的内存布局</h2><p>对象的内存布局可以划分为三个区域:对象头(Header)、实例数据、对齐填充部分</p><ol><li><p>header</p><ol><li>Mark Word:通过标识来复用同一地址空间,列如对象哈希码/锁指针/偏向锁信息等</li><li>类型指针:用于标识对象的类元数据,其中数组类型要表示元素的类型以及元素的个数</li></ol></li><li><p>实例数据</p><ol><li>实例数据部分是用于存储业务数据的部分,在分配内存时会尽量遵守相同类型(宽度)的数据分配到一起</li></ol></li><li><p>对齐部分</p><ol><li>对齐部分不一定存在,由于jvm虚拟机分配内存是8个字节的整数倍,header部分设计是就遵守此规范,但是实例数据部分不一定能恰好遵循,因此需要进行数据填充来符合此规范</li></ol><h2 id="对象的访问定位"><a class="header-anchor" href="#对象的访问定位"></a>对象的访问定位</h2><p>在栈帧中通过<strong>reference</strong>来表示对象的指针,然后通过refernce查找对象的方式可以分为两种实现方案:</p><ol><li>直接通过指针来返回</li><li>通过句柄的方式来返回</li></ol><p>HotSpot是通过第二种方式来进行访问的,优点是**快,**缺点是在GC时需要修改栈帧中的reference数据</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.png?raw=true" alt="对象地址"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;内存布局设计&lt;/h1&gt;
&lt;p&gt;JVM的内存设计上是划分为两个大的区域的&lt;B&gt;启动时向操作系统分配的程序内存区域&lt;/B&gt;、&lt;B&gt;直接对系统内存进行操作的区域&lt;/B&gt;,后者不属于JVM管理,我们主要是分析前者&lt;/p&gt;
&lt;h2 id=&quot;大体结构&quot;&gt;&lt;a class=&quot;heade</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>多线程是否会影响执行效率</title>
    <link href="https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/"/>
    <id>https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/</id>
    <published>2022-11-15T14:50:30.000Z</published>
    <updated>2022-11-18T12:51:34.947Z</updated>
    
    <content type="html"><![CDATA[<h1>多线程是否会影响执行效率</h1><h2 id="前提"><a class="header-anchor" href="#前提"></a>前提</h2><p>今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的</p><blockquote><p>在同一机器/操作系统上,使用n个线程处理X个任务是不是和使用n*m个线程处理X个任务效率相同?</p></blockquote><p>这样的观点是基于<B>RR-时间片轮转</B>来进行推导的;我不太认同这种观点,直觉上认为参与处理的任务过多或过少都会影响执行效率;下面先进行这两种观点的推导然后在进行实际的验证</p><h2 id="时间片轮转"><a class="header-anchor" href="#时间片轮转"></a>时间片轮转</h2><p>假设前提:</p><ol><li>操作系统对进程的调度是采用的<B>时间片轮转</B>算法来进行处理的,时间片划分的大小为1s;</li><li>每个Task需要消耗单核CPU执行0.5s</li><li>不考虑线程上下文切换耗时</li></ol><p>根据以上的前提可以得出下面这个运行图例:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%201%20%E9%A1%B5.drawio.png?raw=true" alt="2Thread执行示例"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%202%20%E9%A1%B5.drawio.png?raw=true" alt="4Thread执行示例"></p><p>从上图中可以看到无论是2Thread来进行执行还是4Thread来进行执行对于任务的执行耗时其实都是没有任何影响的,因为这其实是1000个Task与2个执行core之间的关系;</p><p>这种说法正确的前提必须是满足<B>假设前提</B>中的3点</p><h2 id="线程过多过少都会影响执行效率"><a class="header-anchor" href="#线程过多过少都会影响执行效率"></a>线程过多过少都会影响执行效率</h2><p>这种观点主要是基于《Java并发编程实战》一书中的观点:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F.jpg?raw=true" alt="推算线程池大小"></p><p>N<sub>cpu</sub> ：指的是执行机器上的物理核心数,额外注意使用容器启动的核心数<br>U<sub>cpu</sub> ：指的期望的对CPU的使用率<br>W/C ：指的是等待时间与计算时间的比例,对于计算密集型与IO密集型这个值还有所区别</p><p>例子:</p><p>N<sub>Thread</sub> = 2 * 0.8 * (1 + 10/2) = 8</p><p>如果需要N<sub>Thread</sub>持续增长时需要<B>W/C</B>比例更大,这是不可能实现的,由于w/c是由于Task决定的;<br>以上是通过反证法的方式来解释提高N<sub>Thread</sub> 并不能增加并发执行效率的原因;</p><p>实际在运用过程中还需要注意<B>Amdahl定律</B>和线程引入造成的性能开销</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/amdahl%E5%AE%9A%E5%BE%8B.jpg?raw=true" alt="Amdahl定律"></p><p>Amdahl定律就是表达并发执行线程池数并不能提高效率,而是并发度提高才能提高执行效率</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%BC%95%E5%85%A5%E7%9A%84%E5%BC%80%E9%94%80.jpg?raw=true" alt="线程引入造成的性能开销"></p><p>频繁的线程切换会引起性能损耗</p><h2 id="实例分析"><a class="header-anchor" href="#实例分析"></a>实例分析</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecutorServiceUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> taskNum <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">LinkedBlockingQueue</span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span>taskNum <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">8192</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]正在执行... %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> st <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">extracted</span><span class="token punctuation">(</span>latch<span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> et <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]执行耗时[%s]ms %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> et <span class="token operator">-</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>            QUEUE<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">extracted</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> taskNum<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>latch<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> taskId<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>        <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">,</span> <span class="token keyword">int</span> taskId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> latch<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>taskId <span class="token operator">=</span> taskId<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> min<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">isPrime2</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPrime2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> sqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqrt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/jvmsource/blob/master/src/main/java/com/agmtopy/source/executer/ExecutorServiceUtil.java">ExecutorServiceUtil.java</a></p><p>这是一个循环求解0~10W之间的素数的程序,下面是分别在Windows/Linux上执行的结果</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux.jpg?raw=true" alt="Linux下的执行结果"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows.jpg?raw=true" alt="Windows下的执行结果"></p><p>操作系统的线程调度策略还是会影响性能的.Linux的线程调度要稍微比Windows的优秀一点点,下面使用<B>vmstat</B>和<B>pidstat</B>分析</p><ul><li>vmstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vmstat</span> -w <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vmstat.jpg?raw=true" alt="vmstat执行结果"></p><ul><li>pidstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pidstat -p /PID -wtu  <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pidstat.jpg?raw=true" alt="pidstat执行结果"></p><p>主要关心<B>cswch/s</B>和<B>nvcswch/s</B>、<B>in</B>和<B>cs</B>指标，表示的是<B>线程上下文切换</B>的一个频率,在线程不断的增加以后可以看到这几个指标在快速的向上增长<br>不管是从windows还是linux的一个执行结果来看，线程的增加都会导致程序的下降,但是这种下降并不是很明显，也许是得益于现代操作系统对线程切换的不断优化吧</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>一个线程池中核心线程数与最大线程数的数量是会受到多个方面因素共同影响的，例如<B>操作系统</B>、<B>物理核心逻辑线程</B> 以及任务类型(计算密集型/IO密集型)都有关系,因此在使用线程池时对于线程池的<B>6个</B>参数一定要有思考以后在进行创建相应的线程池;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/13834692/threads-configuration-based-on-no-of-cpu-cores/13958877#13958877">Threads configuration based on no. of CPU-cores</a><br><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a><br><a href="https://research.cs.wisc.edu/multifacet/amdahl/">Amdahl’s Law in the Multicore Era</a><br><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html">Linux vmstat命令实战详解</a><br><a href="https://timzhouyes.github.io/2020/04/29/Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/">Java常见的性能问题和排查</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;多线程是否会影响执行效率&lt;/h1&gt;
&lt;h2 id=&quot;前提&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;
&lt;p&gt;今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在同一机</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="多线程" scheme="https://agmtopy.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
