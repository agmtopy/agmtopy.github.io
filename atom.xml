<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2021-10-12T16:24:29.997Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rocketmq索引实现原理之IndexService</title>
    <link href="https://agmtopy.gitee.io/2021/10/13/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/15.rocketmq%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BIndexService/"/>
    <id>https://agmtopy.gitee.io/2021/10/13/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/15.rocketmq%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BIndexService/</id>
    <published>2021-10-12T16:23:46.000Z</published>
    <updated>2021-10-12T16:24:29.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rocketmq索引实现原理之IndexService"><a href="#rocketmq索引实现原理之IndexService" class="headerlink" title="rocketmq索引实现原理之IndexService"></a>rocketmq索引实现原理之IndexService</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rocketmq索引实现原理之IndexService&quot;&gt;&lt;a href=&quot;#rocketmq索引实现原理之IndexService&quot; class=&quot;headerlink&quot; title=&quot;rocketmq索引实现原理之IndexService&quot;&gt;&lt;/a&gt;rocke</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RocketMQ" scheme="https://agmtopy.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>G1GC的算法与实现</title>
    <link href="https://agmtopy.gitee.io/2021/09/26/12.JVM/6.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://agmtopy.gitee.io/2021/09/26/12.JVM/6.G1GC%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-26T14:48:01.000Z</published>
    <updated>2021-10-10T02:54:07.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="G1GC的算法与实现-算法篇"><a href="#G1GC的算法与实现-算法篇" class="headerlink" title="G1GC的算法与实现-算法篇"></a>G1GC的算法与实现-算法篇</h1><p>根据《深入Java虚拟机-JVM G1GC的算法与实现》-算法篇整理而来,该篇主要由以下章节组成</p><ul><li>第一章 G1GC是什么?</li><li>第二章 并发标记</li><li>第三章 转移</li><li>第四章 软实时性</li><li>第五章 分代G1GC模式</li><li>第六章 算法篇总结 </li></ul><h2 id="G1GC是什么"><a href="#G1GC是什么" class="headerlink" title="G1GC是什么?"></a>G1GC是什么?</h2><blockquote><p>Garbage-First (G1) 垃圾收集器是一种服务端的垃圾收集器，针对具有大内存和多处理器的机器。它尝试尽量满足用户设定的垃圾收集 (GC) 暂停时间，同时实现高吞吐量。GC操作（例如全局标记）与应用程序线程同时执行。<br>这是JDK官方对于G1的定义,这里作者提出一个结论G1的特点是非常非常的关注实时性,并且实时性分为<B>软实时性</B>/<B>硬实时性</B><br>硬实时性指的是硬性强制要求的，如果达不到指定时间就会返回失败的处理;<br>软实时性指的是柔性的，对于设定的指定时间只是一个期望，不会做强制的要求限制;<br>额外一点是<B>G1是支持4G以上的堆内存进行垃圾收集</B></p></blockquote><h3 id="G1出现的背景"><a href="#G1出现的背景" class="headerlink" title="G1出现的背景"></a>G1出现的背景</h3><p>在G1出现之前的GC处理器主要是通过增量GC或者是并发GC来提高STW的暂停时间，但是这样缩短时间会造成吞吐量下降。<br>G1的出现是为了解决在期望的暂停时间周围尽量的完成更大的GC吞吐量。目前GC的关注点都是在尽可能的减少暂停时间，而不是增大吞吐量上，这可能是因为堆中的对象大多属于是朝生夕死的类型</p><h3 id="G1的目前的现状"><a href="#G1的目前的现状" class="headerlink" title="G1的目前的现状"></a>G1的目前的现状</h3><p>G1在JDK9中就作为默认的垃圾回收器，现阶段G1在最后一次增强是在JDK14中增加对NUMA(非统一内存访问)的增强。在JDK14中新增了ZGC收集器，并且预计将ZGC在未来的JDK版本中作为默认GC</p><h2 id="G1GC的执行过程"><a href="#G1GC的执行过程" class="headerlink" title="G1GC的执行过程"></a>G1GC的执行过程</h2><p>所有GC在执行过程可以都划分为</B>标记</B>和<B>整理</B>两个大的步骤，不同的是具体的执行过程会有差别</p><h3 id="G1GC的标记过程"><a href="#G1GC的标记过程" class="headerlink" title="G1GC的标记过程"></a>G1GC的标记过程</h3><p>G1GC的标记过程是<B>并发标记</B>,但是目前的GC还做不到全局并发，只能在某些标记步骤中做到并发。G1的标记过程划分为五个步骤分别是</p><ul><li>初始标记阶段</li><li>并发标记阶段</li><li>最终标记阶段</li><li>存活对象计数阶段</li><li>收尾工作</li></ul><hr><ul><li><p>初始化标记阶段<br><b>初始化标记阶段</b>只对<b>根引用对象</b>进行标记这个过程也称为根扫描，由于mutator(用户线程)会修改根对象引用，因此在者一步是需要将mutator暂停下来，这里之所以没有采用读/写屏障的技术来实现并发个人猜测是因为mutator会频繁修改根对象，因此在此处保证并发后的性能损耗远远大于顺序执行所带来的性能损耗。<br>在初始化标记阶段只会对根引用对象进行标记到特定的内存中称为<b>标记位图</b></p></li><li><p>并发标记阶段<br><b>并发标记阶段</b>的特点是GC线程与mutator线程是并发执行的，在mutator线程修改根对象引用时会采用<b>写屏障</b>来记录对象之间引用关系的变化。<br>SATB是记录对象之间逻辑引用关系的结构，全称为Snapshot At The Beginning(初始快照),在并发标记过程中产生的新对象会作为“已完成扫描和标记”的对象，在mutator线程发生对标记对象的修改时，SATB专用写屏障也会将该对象记录到SATB队列中。SATB队列在实现上采用与线程绑定的形式来进行，当队列装满时，将会添加到全局SATB队列中。</p></li></ul><p>log</p><blockquote><p>并发指的是更多的指的是软件领域的无序执行，不同任务之间没有顺序关系的一种软件启动方式</br>并行更多的指的是在硬件领域不同指令在同一时刻执行的</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://tech.meituan.com/2016/09/23/g1.html">https://tech.meituan.com/2016/09/23/g1.html</a><br><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;G1GC的算法与实现-算法篇&quot;&gt;&lt;a href=&quot;#G1GC的算法与实现-算法篇&quot; class=&quot;headerlink&quot; title=&quot;G1GC的算法与实现-算法篇&quot;&gt;&lt;/a&gt;G1GC的算法与实现-算法篇&lt;/h1&gt;&lt;p&gt;根据《深入Java虚拟机-JVM G1GC的</summary>
      
    
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
    <category term="G1" scheme="https://agmtopy.gitee.io/tags/G1/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq的存储实现原理之commitlog</title>
    <link href="https://agmtopy.gitee.io/2021/09/09/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/13.rocketmq%E7%9A%84%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bcommitlog/"/>
    <id>https://agmtopy.gitee.io/2021/09/09/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/13.rocketmq%E7%9A%84%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bcommitlog/</id>
    <published>2021-09-09T15:17:09.000Z</published>
    <updated>2021-10-10T04:08:48.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rocketmq的存储实现原理之commitlog"><a href="#rocketmq的存储实现原理之commitlog" class="headerlink" title="rocketmq的存储实现原理之commitlog"></a>rocketmq的存储实现原理之commitlog</h1><p>在之前的《rocketmq的存储原理》文章中分析了rocketmq的存储过程主要是通过两个类来实现的分别是commitlog和MappedFile，这篇文章重点分析commitlog这个类的实现</p><h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><p>comitlog对象是通过三个方法来负责初始化处理过程分别是构造方法<b>commitLog()</b>/加载方法<b>load()</b>/启动方法<b>start()</b>,这里将commitlog的对象初始化过程和load过程以及启动-start过程都划分为初始化过程中</p><h3 id="commitLog-构造方法"><a href="#commitLog-构造方法" class="headerlink" title="commitLog()构造方法"></a>commitLog()构造方法</h3><p>CommitLog()构造方法的调用链如图所示<br><img src="https://i.loli.net/2021/09/10/s2fcpiQdSHC8Tyv.png" alt="CommitLog()"><br>可以看到在Broker启动过程中会通过<B>DefaultMessageStore</B>来调用<B>Commitlog</B>构造方法,commitlog的构造方法主要是做初始化日志环境的功能，下面详细的看一下<B>commitLog()</B>方法的实现</p><ul><li>CommitLog构造方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CommitLog</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">DefaultMessageStore</span> defaultMessageStore<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//1. 初始化文件信息在内存中的映射的queue</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MappedFileQueue</span><span class="token punctuation">(</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStorePathCommitLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMappedFileSizeCommitLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultMessageStore<span class="token punctuation">.</span><span class="token function">getAllocateMappedFileService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2. 设置默认的消息存储</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMessageStore <span class="token operator">=</span> defaultMessageStore<span class="token punctuation">;</span>    <span class="token comment">//3. 设置刷盘策略</span>    <span class="token comment">//TODO 这里的刷盘策略'FlushCommitLogService'是使用final关键字进行修饰的，在初始化完成以后就不允许更新刷盘策略的。暂时还不知道为什么这样做</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">FlushDiskType</span><span class="token punctuation">.</span>SYNC_FLUSH <span class="token operator">==</span> defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFlushDiskType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//设置同步刷盘策略</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>flushCommitLogService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroupCommitService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//设置异步刷盘策略</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>flushCommitLogService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlushRealTimeService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//4. 设置消息提交策略为实时提交,CommitRealTimeService继承FlushCommitLogService并作为默认的提交策略，具体实现类还有GroupCommitService/FlushRealTimeService</span>    <span class="token comment">//TODO 这里的抽象不是很好，将提交策略通过内部类的方式来隐藏实现</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commitLogService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommitRealTimeService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//5. 设置默认响应策略</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>appendMessageCallback <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAppendMessageCallback</span><span class="token punctuation">(</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMaxMessageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//6. 初始化提交消息线程</span>    putMessageThreadLocal <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">PutMessageThreadLocal</span><span class="token punctuation">(</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMaxMessageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//7. 初始化提交消息的锁，TODO  会根据配置初始化出可重入锁或自旋锁??</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>putMessageLock <span class="token operator">=</span> defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isUseReentrantLockWhenPutMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">PutMessageReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">PutMessageSpinLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>步骤1~7是初始化日志环境的工作，依次是</p><ul><li>初始化messagequeue\messafestore</li><li>设置刷盘策略、提交策略、响应策略</li><li>初始化提交线程池</li></ul><hr><h3 id="load-方法"><a href="#load-方法" class="headerlink" title="load()方法"></a>load()方法</h3><p>在构造方法完成后<B>BrokerController</B>会继续调用<B>DefaultMessageStore</B>load()方法,来对<B>CommitLog</B>对象进行加载</p><ul><li>BrokerController.load</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//initialize()方法执行message加载动作</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//省略...</span>    result <span class="token operator">=</span> result <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>messageStore<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//省略...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>DefaultMessageStore.load()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> loadResult <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1. 通过是否存在临时文件判断是否上一次正常退出</span>        <span class="token keyword">boolean</span> lastExitOK <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isTempFileExist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"last shutdown &#123;&#125;"</span><span class="token punctuation">,</span> lastExitOK <span class="token operator">?</span> <span class="token string">"normally"</span> <span class="token operator">:</span> <span class="token string">"abnormally"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2. TODO 这里的判断是多余的</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> scheduleMessageService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//执行调度</span>            loadResult <span class="token operator">=</span> loadResult <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scheduleMessageService<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//3. 加载CommitLog</span>        loadResult <span class="token operator">=</span> loadResult <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commitLog<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4.加载loadConsumeQueue</span>        loadResult <span class="token operator">=</span> loadResult <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">loadConsumeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5.创建成功后续操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadResult<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//初始化文件存储的检查对象</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>storeCheckpoint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StoreCheckpoint</span><span class="token punctuation">(</span><span class="token class-name">StorePathConfigHelper</span><span class="token punctuation">.</span><span class="token function">getStoreCheckpoint</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>messageStoreConfig<span class="token punctuation">.</span><span class="token function">getStorePathRootDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//加载index的管理服务</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>indexService<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>lastExitOK<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//根据上次服务是否异常中断进行状态恢复</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">recover</span><span class="token punctuation">(</span>lastExitOK<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"load over, and the max phy offset = &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMaxPhyOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"load exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        loadResult <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//加载失败时,关闭 TODO 这里就只有文件映射服务(MappedFileService)需要关闭吗?</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loadResult<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>allocateMappedFileService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> loadResult<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在DefaultMessageStore.load的第3步会将commitLog进行加载,其他方法是对异常恢复、延迟消息处理队列服务、ConsumerQueue进行加载。<br>下面介绍一下commitLog.loan的加载过程</p><ul><li>CommitLog.load()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//加载mappedFileQueue</span>    <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileQueue<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"load commit log "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>result <span class="token operator">?</span> <span class="token string">"OK"</span> <span class="token operator">:</span> <span class="token string">"Failed"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到CommitLog.load()方法就是加载<B>MappedFileQueue</B></p><ul><li>MappedFileQueue.load()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 加载commit log文件 */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//默认地址为System.getProperty("user.home") + File.separator + "store" + File.separator + "commitlog"; @see org.apache.rocketmq.store.config.MessageStoreConfig.storePathCommitLog</span>    <span class="token class-name">File</span> dir <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>storePath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//文件不存在时,直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span> <span class="token operator">||</span> files<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//对文件按照升序进行排序 TODO 这里也是多余的文件的命名规则是有序</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">File</span> file <span class="token operator">:</span> files<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//commitLog的文件大小默认为1G TODO 这个大小是介于性能和容量之间的一个选择</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>file <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> file<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" length not matched message store config value, please check it manually"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//设置MappedFile对象信息</span>            <span class="token class-name">MappedFile</span> mappedFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MappedFile</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mappedFileSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            mappedFile<span class="token punctuation">.</span><span class="token function">setWrotePosition</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            mappedFile<span class="token punctuation">.</span><span class="token function">setFlushedPosition</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            mappedFile<span class="token punctuation">.</span><span class="token function">setCommittedPosition</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mappedFileSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//将MappedFile对象添加到mappedFiles，注意是通过CopyOnWriteArrayList容器进行保存</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>mappedFiles<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>mappedFile<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"CommitLog  call MappedFileQueue load &#123;&#125; :OK"</span><span class="token punctuation">,</span> file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"CommitLog  call MappedFileQueue load &#123;&#125; :ERROR"</span><span class="token punctuation">,</span> file<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mappedFiles.load()方法主要通过指定的文件路径加载文件，并将文件对象通过CopyOnWriteArrayList容器进行存放<br>CopyOnWriteArrayList是读无锁-写有锁的容器，存储commitLog信息</p><h3 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h3><ul><li>commitLog.Start()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//1.启动刷盘线程</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>flushCommitLogService<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2.判断是否启动异步提交</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultMessageStore<span class="token punctuation">.</span><span class="token function">getMessageStoreConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTransientStorePoolEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>commitLogService<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>commitLog.start()方法主要是启动刷盘线程和判断是否启动异步提交</p><h2 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h2><p>CommitLog底层是通过<B>asyncPutMessage()</B>方法来实现异步向文件系统提交的，下面我们先根据asyncPutMessage()来分析从上至下的调用链过程</p><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><p>通过Arthas分析<B>asyncPutMessage()</B>的调用过程如图所示</p><p><img src="https://i.loli.net/2021/09/13/rbDHVqyCkc8XJoj.jpg" alt="/调用链路.jpg"></p><ul><li>arthas cmd</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stack org.apache.rocketmq.store.CommitLog asyncPutMessage  -n <span class="token number">5</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从图中可以看处理整个调用过程从网络I/O到文件I/O是非常短的</p><pre class="line-numbers language-log" data-language="log"><code class="language-log">@org.apache.rocketmq.store.CommitLog.asyncPutMessage()    at org.apache.rocketmq.store.DefaultMessageStore.asyncPutMessage(DefaultMessageStore.java:435)    at org.apache.rocketmq.broker.processor.SendMessageProcessor.asyncSendMessage(SendMessageProcessor.java:314)    at org.apache.rocketmq.broker.processor.SendMessageProcessor.asyncProcessRequest(SendMessageProcessor.java:101)    at org.apache.rocketmq.broker.processor.SendMessageProcessor.asyncProcessRequest(SendMessageProcessor.java:82)    at org.apache.rocketmq.remoting.netty.NettyRemotingAbstract$1.run(NettyRemotingAbstract.java:225)    at org.apache.rocketmq.remoting.netty.RequestTask.run(RequestTask.java:80)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NettyRemotingAbstract -&gt; SendMessageProcessor -&gt; CommitLog 三个类就完成了处理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rocketmq的存储实现原理之commitlog&quot;&gt;&lt;a href=&quot;#rocketmq的存储实现原理之commitlog&quot; class=&quot;headerlink&quot; title=&quot;rocketmq的存储实现原理之commitlog&quot;&gt;&lt;/a&gt;rocketmq的存储</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RocketMQ" scheme="https://agmtopy.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq的存储实现原理之MappedFile</title>
    <link href="https://agmtopy.gitee.io/2021/09/09/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/14.rocketmq%E7%9A%84%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BMappedFile/"/>
    <id>https://agmtopy.gitee.io/2021/09/09/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/14.rocketmq%E7%9A%84%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BMappedFile/</id>
    <published>2021-09-09T15:17:09.000Z</published>
    <updated>2021-10-12T16:23:09.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rocketmq的存储实现原理之MappedFile"><a href="#rocketmq的存储实现原理之MappedFile" class="headerlink" title="rocketmq的存储实现原理之MappedFile"></a>rocketmq的存储实现原理之MappedFile</h1><p><B>MappedFile</B>是RoketMq处理底层文件的类,在上面一篇文章中已经了解了如何通过<B>CommitLog</B>类来处理请求以及如何通过<B>MappedFile</B>来实现底层存储的<br><B>MappedFile</B>的整体逻辑是</p><h2 id="MappedFile"><a href="#MappedFile" class="headerlink" title="MappedFile"></a>MappedFile</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rocketmq的存储实现原理之MappedFile&quot;&gt;&lt;a href=&quot;#rocketmq的存储实现原理之MappedFile&quot; class=&quot;headerlink&quot; title=&quot;rocketmq的存储实现原理之MappedFile&quot;&gt;&lt;/a&gt;rocketmq</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RocketMQ" scheme="https://agmtopy.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Nacos使用指南</title>
    <link href="https://agmtopy.gitee.io/2021/09/05/17.Nacos/0.Nacos%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://agmtopy.gitee.io/2021/09/05/17.Nacos/0.Nacos%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2021-09-05T13:41:02.000Z</published>
    <updated>2021-09-08T16:20:50.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos使用指南"><a href="#Nacos使用指南" class="headerlink" title="Nacos使用指南"></a>Nacos使用指南</h1><p>Nacos的定位是注册中心，支持目前主流的分布式架构K8S/RPC/RESTful。主要功能有</p><ul><li>服务发现和服务健康监测</li><li>动态配置服务</li><li>动态 DNS 服务</li><li>服务及其元数据管理</li></ul><h2 id="构建Nacos"><a href="#构建Nacos" class="headerlink" title="构建Nacos"></a>构建Nacos</h2><h3 id="Nacos-docker"><a href="#Nacos-docker" class="headerlink" title="Nacos docker"></a>Nacos docker</h3><ul><li><p>clone项目</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/nacos-group/nacos-docker.git<span class="token builtin class-name">cd</span> nacos-docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>单机模式 Derby</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose -f example/standalone-derby.yaml up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>注意一定要启动docker desktop或者docker进程，然后就经过漫长的编译环节，编译完成后docker镜像会自动启动</p><p><img src="https://i.loli.net/2021/09/08/xpdPVki2fA18yh3.jpg" alt="/镜像image.jpg"></p><ul><li>测试服务状态</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -X POST <span class="token string">'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2021/09/08/yt43erZ8ED2SoBm.jpg" alt="/服务注册.jpg"><br>Nacos提供的服务以RESTful风格进行提供，因此可以直接通过http请求进行操作</p><h3 id="Nacos-Cons"><a href="#Nacos-Cons" class="headerlink" title="Nacos Cons"></a>Nacos Cons</h3><ul><li>服务地址<br><a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></li><li>账号/密码<br>nacos/nacos<br>这个账号/密码是存放在数据库中的，可以进行更改</li></ul><p><img src="https://i.loli.net/2021/09/08/qSbWEAl1zR4Cpxa.jpg" alt="/nacos_admin.jpg"></p><h3 id="spring-boot示例"><a href="#spring-boot示例" class="headerlink" title="spring boot示例"></a>spring boot示例</h3><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><ul><li>ConfigExample</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NacosException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> serverAddr <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> dataId <span class="token operator">=</span> <span class="token string">"nacos.cfg.dataId1"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> group <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>    <span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PropertyKeyConst</span><span class="token punctuation">.</span>SERVER_ADDR<span class="token punctuation">,</span> serverAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建连接</span>    <span class="token class-name">ConfigService</span> configService <span class="token operator">=</span> <span class="token class-name">NacosFactory</span><span class="token punctuation">.</span><span class="token function">createConfigService</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取配置</span>    <span class="token class-name">String</span> content <span class="token operator">=</span> configService<span class="token punctuation">.</span><span class="token function">getConfig</span><span class="token punctuation">(</span>dataId<span class="token punctuation">,</span> group<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"content1:"</span> <span class="token operator">+</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//设置监听</span>    configService<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span>dataId<span class="token punctuation">,</span> group<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receiveConfigInfo</span><span class="token punctuation">(</span><span class="token class-name">String</span> configInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"recieve:"</span> <span class="token operator">+</span> configInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">Executor</span> <span class="token function">getExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//推送配置</span>    <span class="token keyword">boolean</span> isPublishOk <span class="token operator">=</span> configService<span class="token punctuation">.</span><span class="token function">publishConfig</span><span class="token punctuation">(</span>dataId<span class="token punctuation">,</span> group<span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>isPublishOk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    content <span class="token operator">=</span> configService<span class="token punctuation">.</span><span class="token function">getConfig</span><span class="token punctuation">(</span>dataId<span class="token punctuation">,</span> group<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"content2:"</span> <span class="token operator">+</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//移除配置</span>    <span class="token keyword">boolean</span> isRemoveOk <span class="token operator">=</span> configService<span class="token punctuation">.</span><span class="token function">removeConfig</span><span class="token punctuation">(</span>dataId<span class="token punctuation">,</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>isRemoveOk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    content <span class="token operator">=</span> configService<span class="token punctuation">.</span><span class="token function">getConfig</span><span class="token punctuation">(</span>dataId<span class="token punctuation">,</span> group<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"content3:"</span> <span class="token operator">+</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos使用指南&quot;&gt;&lt;a href=&quot;#Nacos使用指南&quot; class=&quot;headerlink&quot; title=&quot;Nacos使用指南&quot;&gt;&lt;/a&gt;Nacos使用指南&lt;/h1&gt;&lt;p&gt;Nacos的定位是注册中心，支持目前主流的分布式架构K8S/RPC/RESTful。</summary>
      
    
    
    
    <category term="框架" scheme="https://agmtopy.gitee.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Nacos" scheme="https://agmtopy.gitee.io/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>如何编写JavaAgent</title>
    <link href="https://agmtopy.gitee.io/2021/07/03/12.JVM/5.%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99JavaAgent/"/>
    <id>https://agmtopy.gitee.io/2021/07/03/12.JVM/5.%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99JavaAgent/</id>
    <published>2021-07-03T15:11:15.000Z</published>
    <updated>2021-09-26T14:48:14.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何编写JavaAgent"><a href="#如何编写JavaAgent" class="headerlink" title="如何编写JavaAgent"></a>如何编写JavaAgent</h1><p>这篇文章是根据MegaEase的袁伟老师的分享而来,地址是<a href="https://www.youtube.com/watch?v=ujhqct2POLU">How To Write a JavaAgent</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="java-agent是什么？"><a href="#java-agent是什么？" class="headerlink" title="java agent是什么？"></a>java agent是什么？</h3><p>java agent是jdk1.5时候推出的一个在运行时动态修改class,从而达到动态修改行为的目的</p><h3 id="能做什么？"><a href="#能做什么？" class="headerlink" title="能做什么？"></a>能做什么？</h3><p>功能与AOP类似，它的优势在与彻底和业务代码隔离，可以完成AOP相同的事情，并且不入侵业务代码，适合于日志采集、链路追踪等基础组件</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>java agent主要可以在两个时间点进行加载：</p><ol><li>JVM启动时</li><li>目标方法运行时</li></ol><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="https://i.loli.net/2021/07/11/uUxsh1JqQzaSXAW.png" alt="项目结构"></p><h4 id="启动时加载示例"><a href="#启动时加载示例" class="headerlink" title="启动时加载示例"></a>启动时加载示例</h4><ul><li>AgentExampleDemo</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentExampleDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> instrumentation<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"premain start..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>AgentTarget</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentTarget</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始打印...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>build.gradle</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">  //重新定义MANIFEST.MF  jar <span class="token punctuation">&#123;</span>    manifest <span class="token punctuation">&#123;</span>        attributes <span class="token string">'Premain-Class'</span><span class="token builtin class-name">:</span> <span class="token string">'com.agmtopy.source.agent.AgentExampleDemo'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>javaagent启动参数</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-javaagent:build/libs/jvmsource-1.0-SNAPSHOT.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2021/07/11/kH6wQJD5my7bxuX.png" alt="Idea设置"></p><ul><li>运行结果</li></ul><p><a href="https://imgtu.com/i/R7rfyV"><img src="https://z3.ax1x.com/2021/07/07/R7rfyV.png" alt="结果"></a></p><blockquote><p>这是第一种使用agent的方式,在目标代码运行前使用,java agent代码与目标方法进行组合的方式进行执行</p></blockquote><h3 id="运行时加载示例"><a href="#运行时加载示例" class="headerlink" title="运行时加载示例"></a>运行时加载示例</h3><p>目标方法远行时加载要使用到javassist这个工具帮助我们修改class,注意javassist有两个项目,要使用<b>org.javassist</b>😂才可以</p><pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">implementation &quot;org.javassist:javassist:3.28.0-GA&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>修改AgentTarget</li></ol><p>保持jvm运行,以便通过Attach的方式进行替换</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentTarget</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始打印...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>在AgentExampleDemo中增加agentmain方法</li></ol><ul><li>AgentExampleDemo</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * attach:方式运行 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">agentmain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"agentmain start..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 显示执行时间</span>    inst<span class="token punctuation">.</span><span class="token function">addTransformer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShowExecTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//重写载入新的字节码</span>        inst<span class="token punctuation">.</span><span class="token function">retransformClasses</span><span class="token punctuation">(</span><span class="token class-name">AgentTarget</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnmodifiableClassException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>增加ShowExecTime来修改字节码</li></ol><ul><li>ShowExecTime</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** 自定义ClassFileTransformer*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShowExecTime</span> <span class="token keyword">implements</span> <span class="token class-name">ClassFileTransformer</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transform</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span> <span class="token class-name">String</span> className<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> classBeingRedefined<span class="token punctuation">,</span> <span class="token class-name">ProtectionDomain</span> protectionDomain<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classfileBuffer<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IllegalClassFormatException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//只针对目标包下进行耗时统计</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>className<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"com/agmtopy/source/agent"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> classfileBuffer<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正在加载类："</span> <span class="token operator">+</span> className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ClassPool</span> classPool <span class="token operator">=</span> <span class="token class-name">ClassPool</span><span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            classPool<span class="token punctuation">.</span><span class="token function">appendClassPath</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoaderClassPath</span><span class="token punctuation">(</span>loader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">CtClass</span> cl <span class="token operator">=</span> classPool<span class="token punctuation">.</span><span class="token function">makeClass</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>classfileBuffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 所有方法，统计耗时</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">CtMethod</span> method <span class="token operator">:</span> cl<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始修改:"</span> <span class="token operator">+</span> method <span class="token operator">+</span><span class="token string">" 方法"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//需要通过`addLocalVariable`来声明局部变量</span>                method<span class="token punctuation">.</span><span class="token function">addLocalVariable</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">,</span> <span class="token class-name">CtClass</span><span class="token punctuation">.</span>longType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//插入 开始语句</span>                method<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token string">"start = java.lang.System.currentTimeMillis();"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getLongName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//创建并插入 打印语句 System.out.println("方法：test， 执行时间：" + (System.currentTimeMillis() - start));</span>                <span class="token class-name">String</span> statement <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"java.lang.System.out.println(\"方法：%s， 执行时间：\" + (java.lang.System.currentTimeMillis() - start));"</span><span class="token punctuation">,</span> methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                method<span class="token punctuation">.</span><span class="token function">insertAfter</span><span class="token punctuation">(</span>statement<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformed <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">toBytecode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> transformed<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> classfileBuffer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>transform()方法是通过javassist来修改字节码,在方法执行前后插入局部变量，然后打印方法执行耗时</p><ol start="4"><li>运行jar进行替换字节码替换</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 修改指定运行中的代码 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 传入目标 JVM pid</span>    <span class="token class-name">VirtualMachine</span> vm <span class="token operator">=</span> <span class="token class-name">VirtualMachine</span><span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token string">"6068"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vm<span class="token punctuation">.</span><span class="token function">loadAgent</span><span class="token punctuation">(</span><span class="token string">"D:\\project\\jvmsource\\build\\libs\\jvmsource-1.0-SNAPSHOT.jar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>修改MANIFEST.MF<br>需要将<b>Agent-Class</b>写入MANIFEST.MF文件</li></ol><ul><li>gradle</li></ul><pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">jar &#123;    manifest &#123;        attributes &#39;Can-Redefine-Classes&#39;: true        attributes &#39;Can-Retransform-Classes&#39;: true        attributes &#39;Agent-Class&#39;: &#39;com.agmtopy.source.agent.AgentExampleDemo&#39;        attributes &#39;Premain-Class&#39;: &#39;com.agmtopy.source.agent.AgentExampleDemo&#39;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>执行字节码替换</li></ol><p>6.1 先将项目构建成为jar包<br>6.2 运行AgentTarget<br>不需要使用-javaagent的方式进行启动<br><img src="https://i.loli.net/2021/07/11/d3kZXA769yheB8L.png" alt="AgentTarget结果"><br>6.3 执行字节码替换</p><ul><li>运行结果<br><img src="https://i.loli.net/2021/07/11/bksIl8USHRMc72d.png" alt="运行结果"></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>java agent的原理根据加载时机还是可以分为两类入口，一类是启动时将agent class挂载到目标JVM上，另外一类入口是运行时动态加载，采用的是JVM attach技术</p><h3 id="启动时加载原理分析"><a href="#启动时加载原理分析" class="headerlink" title="启动时加载原理分析"></a>启动时加载原理分析</h3><h4 id="分析目标方法调用链"><a href="#分析目标方法调用链" class="headerlink" title="分析目标方法调用链"></a>分析目标方法调用链</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentExampleDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> instrumentation<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"premain start..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//打印调用栈</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">StackTraceElement</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">StringBuffer</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            buffer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"index: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" ClassName: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" Method Name : "</span> <span class="token operator">+</span> elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2021/07/07/f4o2qQryOKwpWPL.png" alt="调用栈"></p><p>通过调用栈可以分析出是<B>InstrumentationImpl</B>调用<B>premain()</B>方法的,下面开始分析InstrumentationImpl</p><h4 id="InstrumentationImpl"><a href="#InstrumentationImpl" class="headerlink" title="InstrumentationImpl"></a>InstrumentationImpl</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InstrumentationImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Instrumentation</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><B>InstrumentationImpl</B>实现<B>Instrumentation</B>,<B>Instrumentation</B>接口是JVM定义对字节码操作的接口，我们按照调用链的顺序倒叙进行分析（执行、触发）</p><ol><li>permain执行过程分析</li></ol><p>由于<B>InstrumentationImpl.loadClassAndCallPremain()</B>方法已经最顶层的java代码入口，通过方法名称查找可以在<B>JPLISAgent.h</B>文件中查询到该方法名称被定义成为一个常量</p><ul><li>JPLISAgent.h</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define JPLIS_INSTRUMENTIMPL_PREMAININVOKER_METHODNAME      &quot;loadClassAndCallPremain&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该常量被<B>JPLISAgent.c</B>的<B>createInstrumentationImpl</B>方法所使用</p><ul><li>JPLISAgent.c</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">jboolean createInstrumentationImpl(JNIEnv *jnienv,JPLISAgent *agent)&#123;    &#x2F;&#x2F;省略....    &#x2F;* Now look up the method ID for the pre-main caller (we will need this more than once) *&#x2F;    if (!errorOutstanding)    &#123;        &#x2F;&#x2F;①获取到调用permain方法MethodId        premainCallerMethodID &#x3D; (*jnienv)-&gt;GetMethodID(jnienv,                                                       implClass,                                                       JPLIS_INSTRUMENTIMPL_PREMAININVOKER_METHODNAME,                                                       JPLIS_INSTRUMENTIMPL_PREMAININVOKER_METHODSIGNATURE);    &#125;    if (!errorOutstanding)    &#123;        agent-&gt;mInstrumentationImpl &#x3D; resultImpl;        &#x2F;&#x2F;②指针赋值        agent-&gt;mPremainCaller &#x3D; premainCallerMethodID;        agent-&gt;mAgentmainCaller &#x3D; agentmainCallerMethodID;        agent-&gt;mTransform &#x3D; transformMethodID;    &#125;        &#x2F;&#x2F;省略....    return !errorOutstanding;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段方法主要是做两件事，第一是获取到调用permain方法MethodId；第二件事是将这个MethodId传递出去,分析mPremainCaller的使用可以得到该值在’processJavaStart’中使用</p><p><img src="https://i.loli.net/2021/07/07/WbT3LyNCQilShcv.png" alt="mPremainCaller"></p><ul><li>processJavaStart</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">result &#x3D; startJavaAgent(agent, jnienv,                        agent-&gt;mAgentClassName,                         agent-&gt;mOptionsString,                        agent-&gt;mPremainCaller);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>processJavaStart通过前面获取到的MethodId启动javaAgent，下面我们分析<B>statrJavaAgent</B></p><ul><li>statrJavaAgent</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//...</span>success <span class="token operator">=</span> <span class="token function">invokeJavaAgentMainMethod</span><span class="token punctuation">(</span>jnienv<span class="token punctuation">,</span>                                    agent<span class="token operator">-></span>mInstrumentationImpl<span class="token punctuation">,</span>                                    agentMainMethod<span class="token punctuation">,</span>                                    classNameObject<span class="token punctuation">,</span>                                    optionsStringObject<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用</B>invokeJavaAgentMainMethod</B>传入对象、方法ID、实参，执行定义的premain方法</p><p>通过上面的分析知道了permai执行的过程，继续看一下permain方法是如何触发的</p><ol start="2"><li>permain触发过程分析</li></ol><p><B>processJavaStart</B>方法是执行permain的入口，它在<B>JPLISAgent.h</B>中进行定义的,在源代码中全局搜索：<B> JPLISAgent *</B>可以找到JPLISAgent是在&lt;InvocationAdapter.c&gt;中重新进行过赋值</p><ul><li>InvocationAdapter.c</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">void JNICALL eventHandlerVMInit(jvmtiEnv *jvmtienv,                    JNIEnv *jnienv,                    jthread thread)  &#123;      JPLISAgent *agent &#x3D; environment-&gt;mAgent;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>eventHandlerVMInit</B>方法在<B>JPLISAgent.c</B>的<B>initializeJPLISAgent</B>方法中被设置为回调方法</p><ul><li>initializeJPLISAgent</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;关键执行逻辑if (jvmtierror &#x3D;&#x3D; JVMTI_ERROR_NONE)&#123;    jvmtiEventCallbacks callbacks;    memset(&amp;callbacks, 0, sizeof(callbacks));    &#x2F;&#x2F;设置JVM回调    callbacks.VMInit &#x3D; &amp;eventHandlerVMInit;    jvmtierror &#x3D; (*jvmtienv)-&gt;SetEventCallbacks(jvmtienv,                                                &amp;callbacks,                                                sizeof(callbacks));    check_phase_ret_blob(jvmtierror, JPLIS_INIT_ERROR_FAILURE);    jplis_assert(jvmtierror &#x3D;&#x3D; JVMTI_ERROR_NONE);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这里可以看到在初始化JPLISAgent时候就设置了JVM初始化完成后会回调InvocationAdapter来执行<B>permain</B>方法</p><ol start="3"><li>JPLISAgent的初始化</li></ol><p>回溯<B>initializeJPLISAgent</B>方法可以找到分别在<B>InvocationAdapter.c</B>的<B>DEF_Agent_OnLoad</B>、<B>DEF_Agent_OnAttach</B>上被调用。这两种方式也正是前面讲到的agent的两种增强方式的入口。</p><p>在JVM启动时最开始加载的是libinstrument动态链接库，然后在动态链接库里面找到JVMTI的入口方法：Agent_OnLoad和Agent_OnAttach。InvocationAdapter.c的定义</p><ul><li>InvocationAdapter.c</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;**  This will be called once for every -javaagent on the command line.*  Each call to Agent_OnLoad will create its own agent and agent data.**  The argument tail string provided to Agent_OnLoad will be of form*  &lt;jarfile&gt;[&#x3D;&lt;options&gt;]. The tail string is split into the jarfile and*  options components. The jarfile manifest is parsed and the value of the*  Premain-Class attribute will become the agent&#39;s premain class. The jar*  file is then added to the system class path, and if the Boot-Class-Path*  attribute is present then all relative URLs in the value are processed*  to create boot class path segments to append to the boot class path.*&#x2F;JNIEXPORT jint JNICALLDEF_Agent_OnLoad(JavaVM *vm, char *tail, void *reserved)&#x2F;**  This will be called once each time a tool attaches to the VM and loads*  the JPLIS library.*&#x2F;JNIEXPORT jint JNICALLDEF_Agent_OnAttach(JavaVM *vm, char *args, void *reserved)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>整体逻辑<br>整体的执行逻辑就是：</li></ol><ul><li>JPLISAgent声明JVM启动时候初始化JPLISAgent</li><li>JPLISAgent初始化时设置InvocationAdapter的回调方法</li><li>JVM初始化完成后执行回调方法</li><li>InvocationAdapter的回调方法执行permain方法</li></ul><h3 id="运行时加载原理分析"><a href="#运行时加载原理分析" class="headerlink" title="运行时加载原理分析"></a>运行时加载原理分析</h3><ol><li>分析字节码<br>使用<B>HSDB</B>查看AgentTarget未进行字节码替换前的数据</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jhsdb hsdb --pid <span class="token number">21656</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>常量池</li></ul><p><img src="https://i.loli.net/2021/07/11/phklzJKYTs7IG16.jpg" alt="替换前的常量池"></p><p><img src="https://i.loli.net/2021/07/11/tkaOxIQ62fbs84K.png" alt="替换后的常量池"><br>明显可以看到常量池中增加了22条指令，这22条指令就是新加入的字节码所要使用到的常量</p><ul><li>方法区</li></ul><p><img src="https://i.loli.net/2021/07/11/3DvWBpyuHQ7I2cM.jpg" alt="替换前的方法区"></p><p><img src="https://i.loli.net/2021/07/11/e9TObiVwDPH7Whv.jpg" alt="替换后的方法区"></p><ol start="2"><li>重新加载字节码原理<br>@TODO</li></ol><blockquote><p>通过字节码对比可以明显的看出在使用<B>Instrumentation.addTransformer();</B>后确实将字节码进行了修改,其实修改字节码还是有两个时机:</p></blockquote><ul><li>一个是在启动编译时,会在jvm启动完毕后在执行permain方法来修改字节码</li><li>一个就是在运行期间动态的修改字节码</li></ul><h3 id="整体执行逻辑"><a href="#整体执行逻辑" class="headerlink" title="整体执行逻辑"></a>整体执行逻辑</h3><p><img src="https://i.loli.net/2021/07/11/sCey6D7USV9LRXo.jpg" alt="整体执行逻辑"></p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ul><li><p>ASM</p></li><li><p>Javassist</p></li><li><p>Byte Buddy</p></li></ul><h3 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h3><table><thead><tr><th>-</th><th>ASM</th><th>Javassist</th><th>Byte Buddy</th></tr></thead><tbody><tr><td>学习成本</td><td>高</td><td>低</td><td>低</td></tr><tr><td>使用方法</td><td>使用字节码方式进行插入,需要了解class类结构和JVM指令集</td><td>提供高级抽象接口和低级字节码接口</td><td>同Javassist,并且提供声明式接口</td></tr><tr><td>性能</td><td>极快</td><td>一般</td><td>快</td></tr></tbody></table><p>详细的对比可参考byteBuddy官方资料:<a href="https://bytebuddy.net/#/tutorial">https://bytebuddy.net/#/tutorial</a></p><h3 id="Byte-Buddy"><a href="#Byte-Buddy" class="headerlink" title="Byte Buddy"></a>Byte Buddy</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>gradle</li></ul><pre class="line-numbers language-gradle" data-language="gradle"><code class="language-gradle">&#x2F;&#x2F;目前最新版本为1.11.6implementation &quot;net.bytebuddy:byte-buddy:LATEST&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>AgentExampleForByteBuddy</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentExampleForByteBuddy</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Advice.OnMethodEnter</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Advice.Origin</span> <span class="token class-name">Executable</span> method<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"byte buddy before : "</span> <span class="token operator">+</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Advice.OnMethodExit</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Advice.Origin</span> <span class="token class-name">Executable</span> method<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"byte buddy after : "</span> <span class="token operator">+</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> arguments<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">AgentBuilder<span class="token punctuation">.</span>Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">AgentBuilder<span class="token punctuation">.</span>RedefinitionStrategy</span><span class="token punctuation">.</span>RETRANSFORMATION<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">AgentBuilder<span class="token punctuation">.</span>InstallationListener<span class="token punctuation">.</span>StreamWriting</span><span class="token punctuation">.</span><span class="token function">toSystemError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token class-name">ElementMatchers</span><span class="token punctuation">.</span><span class="token function">nameContains</span><span class="token punctuation">(</span><span class="token string">"AgentTarget"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">(</span>builder<span class="token punctuation">,</span> td<span class="token punctuation">,</span> cl<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">-></span> builder<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">Advice</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token class-name">AgentExampleForByteBuddy</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token class-name">MethodDescription</span><span class="token operator">::</span><span class="token function">isConstructor</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">installOn</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>AgentTarget</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentTarget</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始打印...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">AgentTarget</span> agentTarget <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AgentTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        agentTarget<span class="token punctuation">.</span><span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"123"</span> <span class="token operator">+</span> <span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里演示的是一个重写加载类的示例:</p><ol><li>通过</B>@Advice.OnMethodEnter</B>和<B>@Advice.OnMethodExit</B>定义执行方法前后插入的字节码</li><li>通过<B>AgentBuilder</B>指定要增强的类和类型</li><li><B>AgentBuilder.with</B>可以添加监听，方便输出调试</li></ol><h3 id="Byte-Byddy常见问题"><a href="#Byte-Byddy常见问题" class="headerlink" title="Byte Byddy常见问题"></a>Byte Byddy常见问题</h3><ul><li>依赖冲突</li></ul><p>处理方案：</p><ol><li><p>构建工具排除</p></li><li><p>使用自定义classLoader加载agent所使用的类<br>通过指定agent类的加载器,让</B>BootstrapClassLoader</B>去加载</p></li></ol><ul><li>Byte-Buddy提供的API</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassInjector<span class="token punctuation">.</span>UsingInstrumentation</span>         <span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">FileJar</span><span class="token punctuation">,</span> <span class="token class-name">ClassInjector<span class="token punctuation">.</span>UsingInstrumentation<span class="token punctuation">.</span>Target</span><span class="token punctuation">.</span>BOOTSTRAP<span class="token punctuation">,</span> instrumentation<span class="token punctuation">)</span>         <span class="token punctuation">.</span><span class="token function">injectRaw</span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span>instrumentation<span class="token punctuation">,</span> <span class="token class-name">ClassFileLocator                 <span class="token punctuation">.</span>ForClassLoader</span><span class="token punctuation">.</span><span class="token function">ofSystemLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">.</span><span class="token function">locate</span><span class="token punctuation">(</span><span class="token string">"com.agmtopy.source.agent.AgentExampleForByteBuddy"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>java agent中传参</li></ul><p>处理方案:</p><ol><li>ThreadLocal</li><li>增加临时的成员变量</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://asm.ow2.io/">https://asm.ow2.io/</a><br><a href="https://www.javassist.org/">https://www.javassist.org/</a><br><a href="https://bytebuddy.net/#/">https://bytebuddy.net/#/</a><br><a href="https://blog.csdn.net/wanxiaoderen/article/details/107079741">https://blog.csdn.net/wanxiaoderen/article/details/107079741</a><br><a href="https://www.cnblogs.com/old-cha/p/13264114.html">https://www.cnblogs.com/old-cha/p/13264114.html</a><br><a href="https://www.cnblogs.com/chiangchou/p/javassist.html#_label9">https://www.cnblogs.com/chiangchou/p/javassist.html#_label9</a><br><a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html</a><br><a href="https://github.com/gzzchh/de-ag">https://github.com/gzzchh/de-ag</a><br><a href="https://gitee.com/mazhimazh/bytecode-examples">https://gitee.com/mazhimazh/bytecode-examples</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何编写JavaAgent&quot;&gt;&lt;a href=&quot;#如何编写JavaAgent&quot; class=&quot;headerlink&quot; title=&quot;如何编写JavaAgent&quot;&gt;&lt;/a&gt;如何编写JavaAgent&lt;/h1&gt;&lt;p&gt;这篇文章是根据MegaEase的袁伟老师的分享而来,</summary>
      
    
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
    <category term="agent" scheme="https://agmtopy.gitee.io/tags/agent/"/>
    
  </entry>
  
  <entry>
    <title>通过WSL2编译JDK源码</title>
    <link href="https://agmtopy.gitee.io/2021/06/19/1.%E6%9D%82%E8%AE%B0/%E9%80%9A%E8%BF%87WSL2%E7%BC%96%E8%AF%91JDK%E6%BA%90%E7%A0%81/"/>
    <id>https://agmtopy.gitee.io/2021/06/19/1.%E6%9D%82%E8%AE%B0/%E9%80%9A%E8%BF%87WSL2%E7%BC%96%E8%AF%91JDK%E6%BA%90%E7%A0%81/</id>
    <published>2021-06-19T11:39:54.000Z</published>
    <updated>2021-06-19T16:44:54.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过WSL2编译JDK源码"><a href="#通过WSL2编译JDK源码" class="headerlink" title="通过WSL2编译JDK源码"></a>通过WSL2编译JDK源码</h1><p>WSL的全称是’Windows Subsystem for Linux’,通过在系统层面对Linux内核进行支持,WSL1只是部分支持Linux内核而WSL2支持完整的Linux内核。不但可以通过WSL运行Linux内核，甚至可以将Windows Docker指定通过WSL2来进行远行</p><h2 id="WSL1-gt-WSL2"><a href="#WSL1-gt-WSL2" class="headerlink" title="WSL1 -&gt; WSL2"></a>WSL1 -&gt; WSL2</h2><ul><li><p>安装Linux发行版<br>WSL1只需要开启Linux子系统并下载linux发行版即可,linux发行版默认是只能通过Windows Store进行下载，也可以通过下载安装包(msi)进行安装,手动选择安装包地址如下(<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual">https://docs.microsoft.com/zh-cn/windows/wsl/install-manual</a>)</p></li><li><p>切换WSL2</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wsl --set-default-version <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动WSL</p></li></ul><ol><li>应用程序直接启动安装Linux发行版</li><li>‘wsl -l -v’ 检查WSL版本,VERSION -&gt; 2即可<br><a href="https://imgtu.com/i/RPsbr9"><img src="https://z3.ax1x.com/2021/06/19/RPsbr9.png" alt="WSL2"></a></li></ol><h2 id="编译JDK"><a href="#编译JDK" class="headerlink" title="编译JDK"></a>编译JDK</h2><p>严谨的说法是编译OpenJDK</p><h3 id="下载JDK源代码"><a href="#下载JDK源代码" class="headerlink" title="下载JDK源代码"></a>下载JDK源代码</h3><p>推荐直接下载,下面是JDK11的源代码地址,直接选择zip file进行下载,也可以选择不同的版本<br><a href="https://jdk.java.net/java-se-ri/11">https://jdk.java.net/java-se-ri/11</a></p><h3 id="准备JDK编译环境"><a href="#准备JDK编译环境" class="headerlink" title="准备JDK编译环境"></a>准备JDK编译环境</h3><h4 id="安装必要程序"><a href="#安装必要程序" class="headerlink" title="安装必要程序"></a>安装必要程序</h4><ul><li>推荐先先切换软件源</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">sed</span> -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list<span class="token function">sudo</span> <span class="token function">apt</span> update -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>安装必要软件</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y <span class="token function">curl</span> <span class="token function">ssh</span> <span class="token function">zip</span> <span class="token function">unzip</span> ant <span class="token function">git</span> build-essential ccache cpio g++ gcc gdb libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libcups2-dev libfreetype6-dev libasound2-dev libelf-dev ccache libfontconfig1-dev autoconf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装BootStrap-JDK"><a href="#安装BootStrap-JDK" class="headerlink" title="安装BootStrap JDK"></a>安装BootStrap JDK</h4><p>BootStrap JDK的作用是编译JDK源代码中的java代码,默认要比编译的JDK小一个版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openjdk-10-jdkjava -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解压JDK源代码"><a href="#解压JDK源代码" class="headerlink" title="解压JDK源代码"></a>解压JDK源代码</h4><p>由于我比较喜欢使用VS code,VS code中已经集成了连接WSL的插件，因此只需要将JDK源代码直接拖拽到Linux的目录下即可。也可以通过WSL进行复制<br>得到JDK源代码后就可以进行解压</p><h4 id="编译JDK源代码"><a href="#编译JDK源代码" class="headerlink" title="编译JDK源代码"></a>编译JDK源代码</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 准备配置(警告不作为异常抛出)</span><span class="token function">bash</span> ./configure --disable-warnings-as-errors<span class="token function">make</span> all<span class="token comment"># 编译失败时推荐先进行clean,在重新进行编译</span><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ol><li>在构建低版本的JDK时可能出现OS版本不支持<br>修改./hotspot/make/linux/Makefile<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 5% 内核版本</span>SUPPORTED_OS_VERSION <span class="token operator">=</span> <span class="token number">2.4</span>% <span class="token number">2.5</span>% <span class="token number">2.6</span>% <span class="token number">2.7</span>% <span class="token number">3</span>% <span class="token number">4</span>%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过WSL2编译JDK源码&quot;&gt;&lt;a href=&quot;#通过WSL2编译JDK源码&quot; class=&quot;headerlink&quot; title=&quot;通过WSL2编译JDK源码&quot;&gt;&lt;/a&gt;通过WSL2编译JDK源码&lt;/h1&gt;&lt;p&gt;WSL的全称是’Windows Subsystem </summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="WSL" scheme="https://agmtopy.gitee.io/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ中NameSrv的详细设计分析</title>
    <link href="https://agmtopy.gitee.io/2021/06/11/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/98.RocketMQ%E4%B8%ADNameSrv%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2021/06/11/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/98.RocketMQ%E4%B8%ADNameSrv%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/</id>
    <published>2021-06-11T14:57:56.000Z</published>
    <updated>2021-09-09T15:17:40.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ中NameSrv的详细设计分析"><a href="#RocketMQ中NameSrv的详细设计分析" class="headerlink" title="RocketMQ中NameSrv的详细设计分析"></a>RocketMQ中NameSrv的详细设计分析</h1><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>NameSrv是RoctetMQ项目下的一个模块，作为RockerMQ中的轻型注册中心,只负责与Topic有关的功能。<br>使用NameSrv来替代ZK等注册中心主要是有两个好处:</p><ol><li>减少整体复杂性<br>一个分布式系统强依赖另外一个分布式系统，增加了整个系统的复杂性(整体代码复杂性、运维的复杂性);<br>使用内置的轻量级注册中心,就可以消除原来与ZK等第三方注册中心的各种协议适配;<br>Namesrv中只需要开发与Topic有关的业务场景;<br>系统维护时也不用在考虑第三方系统的处理机制;</li><li>扩展能力<br>RocketMQ从设计初就考虑过在嵌入式设备上进行部署的能力,因此采用Namesrv的设计能最大限度的掌握系统</li></ol><p>目前Kafka在这方面做的更好，在V2.8之后不但去掉了ZK，并且采用broker集群中通过选举的方式选出leader节点来管理Topic、broker、consumer</p><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><ul><li><p>整体架构<br><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_architecture_3.png" alt="整体架构"><br>Namesrv集群是无状态的设计,每个组件(Broker、Producer、Consumer)都会向每一个Namesrv进行请求,因此Namesrv是选择了可用性</p></li><li><p>功能解析</p></li></ul><ol><li>Topic路由管理</li><li>Remoting远程服务</li><li>定时任务</li><li>KV管理模块</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Namesrv时序图"><a href="#Namesrv时序图" class="headerlink" title="Namesrv时序图"></a>Namesrv时序图</h3><p><a href="https://imgtu.com/i/2jkklQ"><img src="https://z3.ax1x.com/2021/06/16/2jkklQ.png" alt="Namesrv执行流程"></a></p><h3 id="NamesrvStartup"><a href="#NamesrvStartup" class="headerlink" title="NamesrvStartup"></a>NamesrvStartup</h3><h4 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h4><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 主函数入口 */</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">main0</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 具体执行逻辑:避免在main函数中添加过多的逻辑 */</span><span class="token keyword">fun</span> <span class="token function">main0</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> controller <span class="token operator">=</span> <span class="token function">createNamesrvController</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>        <span class="token function">start</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span>        <span class="token keyword">val</span> tip <span class="token operator">=</span>            <span class="token string">"The Name Server boot success. serializeType="</span> <span class="token operator">+</span> RemotingCommand<span class="token punctuation">.</span><span class="token function">getSerializeTypeConfigInThisServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        log<span class="token operator">!!</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>tip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span>tip<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Throwable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 初始化NamesrvController */</span><span class="token keyword">fun</span> <span class="token function">createNamesrvController</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> NamesrvController <span class="token punctuation">&#123;</span>  <span class="token comment">//去除TLS和apache.commons的版本</span>  <span class="token keyword">return</span> <span class="token function">NamesrvController</span><span class="token punctuation">(</span><span class="token function">NamesrvConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">NettyServerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h4><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/**  * 启动NamesrvController  */</span><span class="token keyword">fun</span> <span class="token function">start</span><span class="token punctuation">(</span>controller<span class="token operator">:</span> NamesrvController<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>controller <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"NamesrvController is null"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//NamesrvController执行初始化,如果失败时退出进程</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>controller<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        controller<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    controller<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NamesrvStartup启动时候主要做了以下几个步骤：</p><ol><li>创建NamesrvController</li><li>处理TLS和加载Namesrv配置文件</li><li>启动NamesrvController</li><li>关闭NamesrvController</li></ol><ul><li>NamesrvController<br>NamesrvController主要逻辑很为两个部分初始化和执行</li></ul><ol><li>初始化</li></ol><ul><li>初始化那些东西</li></ul><ol><li><p>配置</p></li><li><p>服务</p></li><li><p>线程池</p></li><li><p>自省</p></li><li><p>加载配置文件</p></li></ol><h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://rocketmq.apache.org/">rocketmq</a><br><a href="https://github.com/apache/rocketmq">rocketmq-github</a><br><a href="https://www.confluent.io/blog/kafka-without-zookeeper-a-sneak-peek/">Apache Kafka Made Simple: A First Glimpse of a Kafka Without ZooKeeper</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RocketMQ中NameSrv的详细设计分析&quot;&gt;&lt;a href=&quot;#RocketMQ中NameSrv的详细设计分析&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ中NameSrv的详细设计分析&quot;&gt;&lt;/a&gt;RocketMQ中NameSrv的</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RocketMQ" scheme="https://agmtopy.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>关于消息队列的一些历史</title>
    <link href="https://agmtopy.gitee.io/2021/05/08/1.%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%86%E5%8F%B2/"/>
    <id>https://agmtopy.gitee.io/2021/05/08/1.%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%86%E5%8F%B2/</id>
    <published>2021-05-08T14:03:28.000Z</published>
    <updated>2021-05-09T08:43:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于消息队列的一些历史"><a href="#关于消息队列的一些历史" class="headerlink" title="关于消息队列的一些历史"></a>关于消息队列的一些历史</h1><p>这是一篇关于消息队列的历史文章，有关消息队列的前世今生的一些信息。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>软件领域的消息队列最早是由Vivek Ranadive参考硬件中的系统总线提出来的,这老哥是一个印度裔,现在还是国王队的老板。<br>硬件领域中的系统总线主要分为数据总线、地址总线、控制总线这几个部分，用来连接不同的设备传输数据使用。<br><a href="https://imgtu.com/i/gJ4Q61"><img src="https://z3.ax1x.com/2021/05/09/gJ4Q61.png" alt="系统总线"></a><br>硬件上的系统总线着重在于通过线连接不同设备之间的交互，而消息队列是软件领域的连接不同系统之间交互的方式有应用层协议，现代的消息队列主要着重点是在于队列上。</p><h2 id="上古时期"><a href="#上古时期" class="headerlink" title="上古时期"></a>上古时期</h2><ul><li><p>1985<br>Vivek Ranadive根据系统总线设计出来的第一个消息系统叫The Information Bus(TIB)，TIB但是主要是在电信和金融领域进行使用。</p></li><li><p>1993<br>IBM MQ是由蓝色巨人IBM与1993年推出的消息队列产品，目前还保持更新现在迭代到了V9版本</p></li><li><p>1997<br>MS MQ是由微软推出的消息队列产品,不由感慨一句微软是真吊，为了.net硬是整了一个全家桶。</p></li></ul><p>这一时期由于各家的MQ产品都是为了旗下其他产品进行服务，为了形成壁垒，各家的MQ产品并未形成一个统一的规范，导致不同公司下的产品并不能使用其他公司的MQ。</p><h2 id="中古时期"><a href="#中古时期" class="headerlink" title="中古时期"></a>中古时期</h2><p>由于早期的MQ产品各自为政的场景下，这一时期主要统一了消息队列的协议，这些协议一直影响到了现在，主要诞生了以下几种协议以及接入规范：</p><ul><li><p> JMS<br>JMS是一套接入MQ中间件产品的接口规范，java为了黏合各家的消息队列试图通过类似于JDBC的方案在java端通过统一的协议，在根据不同产品的驱动去连接MQ。<br>各个厂商根据这套接口规范自行选择客户端进行实现，实现了这个接口规范的客户端可以在java应用程序内自由切换，类似于适配器模式</p></li><li><p>AMQP<br>AMQP是实现消息队列的一种协议，在协议层规定了消息队列应该有的逻辑规范。AMQP与具体的MQ(例如RabbitMQ、ActiveMQ)的关系类似与jvm规范和JVM实现(HotSpot)一样</p></li><li><p>MQTT<br>为嵌入式设备设计的一套消息队列协议</p></li><li><p>STOMP<br>Stomp协议，英文全名Streaming Text Orientated Message Protocol，中文名称为 ‘流文本定向消息协议’。是一种以纯文本为载体的协议（以文本为载体的意思是它的消息格式规范中没有类似XMPP协议那样的xml格式要求，你可以将它看作‘半结构化数据’）<br>双向消息通信协议还有很多，除了AMQP以外其他的大多都是即时消息协议。</p></li><li><p>ActiveMQ<br>在这一时期还有根据AMQP还诞生了ActiveMQ这一开源产品，ActiveMQ是第一个广泛使用到的开源MQ产品</p></li><li><p>RabbitMQ<br>RabbitMQ是2006年诞生的，现在和spring框架同属于vmware。由Erlang开发的。</p></li></ul><h2 id="现代时期"><a href="#现代时期" class="headerlink" title="现代时期"></a>现代时期</h2><p>由于ActiveMQ和RabbitMQ发展了多年，背负着沉重的历史包袱支持这非常全的MQ功能，在现代的MQ使用场景中这些消息队列不符合当下数据爆炸，小型机组成分布式系统的场景了。这时候出现了针对某个细分领域的消息队列框架Kafka、RocketMQ、Pulsar</p><ul><li><p>Kafka<br>Kafka是Linkedin为解决ActiveMQ性能问题而开发的分布式消息队列，目前已经成为大数据领域实际的消息传递组件</p></li><li><p>RocketMQ<br>RocketMQ是阿里开源的消息队列中间件，在设计上参考了kafka,通过java语言进行开发</p></li><li><p>Pulsar<br>Pulsar是雅虎开源的，天然支持多组成并且是计算和存储分离式的实现</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>消息队列的诞生是从金融场景出发，发展到现在最开始的那几种消息队列在功能上已经变得非常臃肿。现代的消息队列根据某一方面的着重点开始进行发展。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://tryrabbitmq.com/">http://tryrabbitmq.com/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于消息队列的一些历史&quot;&gt;&lt;a href=&quot;#关于消息队列的一些历史&quot; class=&quot;headerlink&quot; title=&quot;关于消息队列的一些历史&quot;&gt;&lt;/a&gt;关于消息队列的一些历史&lt;/h1&gt;&lt;p&gt;这是一篇关于消息队列的历史文章，有关消息队列的前世今生的一些信息。&lt;</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-可复用面向对象软件设计的基础-行为模式</title>
    <link href="https://agmtopy.gitee.io/2021/04/29/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2021/04/29/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-29T15:12:03.000Z</published>
    <updated>2021-05-08T13:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-可复用面向对象软件设计的基础-行为模式"><a href="#设计模式-可复用面向对象软件设计的基础-行为模式" class="headerlink" title="设计模式-可复用面向对象软件设计的基础-行为模式"></a>设计模式-可复用面向对象软件设计的基础-行为模式</h1><p>行为模式是通过将多个类通过继承\组合的形式形成对方法的处理,主要有以下几种</p><ol><li>责任链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板模式</li><li>访问者模式</li></ol><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><blockquote><p>责任链模式是使得多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系,这些对象的处理过程逻辑上形成链状结构,请求沿着这条链依次被不同的对象进行处理。标准的定义是直到有一个对象处理请求为止，我自己理解应该是依次进行处理，而不是有一个处理即止，因为如果只有一个处理，那么责任链模式与策略模式类似。责任链模式是通过将请求需要依次处理的场景从显的客户端一个一个调用的过程，升级成了将请求传入和由责任链客户端去串联整个调用过程，并且这样更容易扩展步骤。</p></blockquote><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/2021-chain-of-responsibility.svg" alt="责任链模式"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>AbstractLogger.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractLogger</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> INFO <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> DEBUG <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ERROR <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> level<span class="token punctuation">;</span>    <span class="token comment">//责任链中的下一个元素</span>   <span class="token keyword">protected</span> <span class="token class-name">AbstractLogger</span> nextLogger<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextLogger</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span> nextLogger<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>nextLogger <span class="token operator">=</span> nextLogger<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>level <span class="token operator">&lt;=</span> level<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token function">write</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>nextLogger <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         nextLogger<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">abstract</span> <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ChainPatternDemo.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainPatternDemo</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AbstractLogger</span> <span class="token function">getChainOfLoggers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token class-name">AbstractLogger</span> errorLogger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ErrorLogger</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">AbstractLogger</span> fileLogger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLogger</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">AbstractLogger</span> consoleLogger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConsoleLogger</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>       errorLogger<span class="token punctuation">.</span><span class="token function">setNextLogger</span><span class="token punctuation">(</span>fileLogger<span class="token punctuation">)</span><span class="token punctuation">;</span>      fileLogger<span class="token punctuation">.</span><span class="token function">setNextLogger</span><span class="token punctuation">(</span>consoleLogger<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> errorLogger<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">AbstractLogger</span> loggerChain <span class="token operator">=</span> <span class="token function">getChainOfLoggers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       loggerChain<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>INFO<span class="token punctuation">,</span> <span class="token string">"This is an information."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       loggerChain<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span>          <span class="token string">"This is a debug level information."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       loggerChain<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token class-name">AbstractLogger</span><span class="token punctuation">.</span>ERROR<span class="token punctuation">,</span>          <span class="token string">"This is an error information."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ErrorLogger、FileLogger、ConsoleLogger都是AbstractLogger.java的子类，在客户端中，通过提供setNextHandler的方法，客户端可以根据业务场景自由组合链的顺序</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>将请求封装成为一个对象，从而使得你可以用不同的请求对客户进行参数化</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>命令模式主要是将请求和对请求执行的动作责任分离,让两者都可以独立进行演化。适合请求内容是类似于信号量的场景，接受者可以根据这个请求内容进行不同的处理</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/commanduml.jpg" alt="命令模式"></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul><li>Command<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 执行方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>Command.java 定义的抽象命令类，所有具体命令的接口</p><ul><li><p>PlayCommand.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//具体的执行类</span>    <span class="token keyword">private</span> <span class="token class-name">AudioPlayer</span> myAudio<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">PlayCommand</span><span class="token punctuation">(</span><span class="token class-name">AudioPlayer</span> audioPlayer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        myAudio <span class="token operator">=</span> audioPlayer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 执行方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        myAudio<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PlayCommand是具体的命令执行类，内部具有一个execute方法,该方法会执行该命令定义的动作</p></li><li><p>Keypad.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Keypad</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Command</span> playCommand<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPlayCommand</span><span class="token punctuation">(</span><span class="token class-name">Command</span> playCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>playCommand <span class="token operator">=</span> playCommand<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">//执行播放方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        playCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>keyPad作为请求类，再次对命令进行一次封装，便于客户端进行调用，这里可以不用再次封装，自己通过客户端进行调用</p><ul><li>client.java<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Julia</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token comment">//创建接收者对象</span>        <span class="token class-name">AudioPlayer</span> audioPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建命令对象</span>        <span class="token class-name">Command</span> playCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlayCommand</span><span class="token punctuation">(</span>audioPlayer<span class="token punctuation">)</span>         <span class="token comment">//创建请求者对象</span>        <span class="token class-name">Keypad</span> keypad <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Keypad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">setPlayCommand</span><span class="token punctuation">(</span>playCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//执行具体的类</span>        keypad<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>客户端通过调用请求类==Keypad==的指定方法，keyPad会调用具体的命令封装类进行执行。其实命令模式只是将请求和对应的动作进行分离，便于复杂请求场景的扩展</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/interpreter_pattern_uml_diagram.jpg" alt="解释器模式"></p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="意图-3"><a href="#意图-3" class="headerlink" title="意图"></a>意图</h3><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露聚合对象内部表示的模式</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>游标(Cursor)</p><h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>迭代器模式是为了将内部元素和访问/遍历动作分离开，通过增加一个迭代器，通过迭代器来访问内部元素。</p><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg" alt="迭代器模式"></p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="意图-4"><a href="#意图-4" class="headerlink" title="意图"></a>意图</h3><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互</p><h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p>由于面向对象鼓励按照行为进行类的划分，因此系统中会存在大量的类。如果不同的类之间都要相互引用来完成一个行为的话不符合面向对象的特性，因此需要有一个中介来将服务聚合起来，相当于将细小的行为进行一次聚合形成较大的行为，这样不用关注细小的行为对象。</p><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/mediator_pattern_uml_diagram.jpg" alt="中介者模式"></p><p>中介者模式在功能上类似于门面模式，但是门面模式着重于对子系统类的封装，中介者模式着重是对行为的封装和调和各个子行为从而形成一个大的行为，因此门面模式是结构型而中介者模式是行为型。</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="意图-5"><a href="#意图-5" class="headerlink" title="意图"></a>意图</h3><p>在不破坏对象封装性的前提下，捕获一个对象的内部状态，并将该状态保存在对象之外。在需要时，可以根据这个数据进行恢复。类似于游戏中的存档点设置。</p><h3 id="别名-1"><a href="#别名-1" class="headerlink" title="别名"></a>别名</h3><p>token</p><h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><p>备忘录模式针对于那些需要进行暂存的数据或对象，在不破坏封装性的前提下。</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/memento_pattern_uml_diagram.jpg" alt="备忘录模式"></p><p>CareTaker.java 负责保存每个阶段的对象状态</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="意图-6"><a href="#意图-6" class="headerlink" title="意图"></a>意图</h3><p>定义对象之间的一种一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都会得到通知</p><h3 id="别名-2"><a href="#别名-2" class="headerlink" title="别名"></a>别名</h3><p>依赖(Dependents),发布-订阅(Publish-Subscribe)</p><h3 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h3><p>在一个系统中一个对象的改变会导致引起相关对象的改变，如果要保持这样的一致性会导致对象间强依赖。观察者模式就是通过发布-订阅模式将通知的职责从动作类中强制依赖转换为通知的模式</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/observer_pattern_uml_diagram.jpg" alt="观察者模式"></p><p>Subject作为被观察者中维护一个所有观察者的引用，Observer作为被观察者维护一个Subject的引用，将自己组成到被观察者中<br>可参考<br><a href="../../../../../2020/05/06/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/#more">观察者模式</a></p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>spring中的ApplicationListener和ApplicationEvent、ApplicationEventPublisherAware分别作为被观察者、观察者和客户端</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="意图-7"><a href="#意图-7" class="headerlink" title="意图"></a>意图</h3><p>允许一个对象在其内部状态发生改变时改变它的行为。从表象上来看就是对象可以根据内部状态执行不同的业务逻辑。</p><h3 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h3><p>一个对象的行为取决于内部状态进行驱动时，状态模式可以将状态和行为分离，减少分支的条件语句。</p><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png" alt="状态模式"></p><p>可以看到doAction()方法中才会执行具体的行为，不同的状态具有不同的行为，通过context维护状态，当状态发生改变时，对应的行为也随之发生改变</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="意图-8"><a href="#意图-8" class="headerlink" title="意图"></a>意图</h3><p>策略模式是将不同的算法单独定义起来，通过不同的场景选择不同的算法。将客户端中的条件分支去掉，并且支持扩展。</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" alt="策略模式"></p><p>Context中的strategy类是具体执行的算法，这里有两种设计方案，第一种就是UML图中的写法，将Contetxx作为每次行动的容器，每次执行前都先进行赋值。第二种是Context持有一个Strategy的List根据添加选择算法、</p><p>策略模式在实际工作中大量使用到，因为消除了条件判断减少了分支。通过增加类的方式来减少分支，结构上便于扩展了 </p><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h3 id="意图-9"><a href="#意图-9" class="headerlink" title="意图"></a>意图</h3><p>定义一个方法的骨架，通过继承的方式让子类可以改变特点行为，使得不用重新定义算法的顺序就能改变行为。</p><h3 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h3><p>模板方法的出现主要是为了解决重复定义的算法执行顺序并且具体执行有差异的场景</p><h3 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg" alt="模板模式"></p><p>模板模式与策略模式的区别在于模板模式是通过继承的方式来改变行为，策略模式是通过改变委托对象的方式来改变行为；策略模式针对的场景是相同类在处理不同的业务场景时候算法的选择问题，模板模式针对的是相同的类在处理相同的业务场景下算法细微的差异结构上。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="意图-10"><a href="#意图-10" class="headerlink" title="意图"></a>意图</h3><p>将数据和数据操作分离</p><h3 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h3><p>对一个对象需要进行多次操作时，为了避免这些操作将对象污染，可以通过访问者模式将数据和操作进行隔离。实现不同的访问者访问不同的数据。</p><h3 id="结构-10"><a href="#结构-10" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/visitor_pattern_uml_diagram.jpg" alt="访问者模式"></p><p>访问者模式的核心是在于数据对象会针对不同的访问者定义出不同的行为，由于访问者知道被访问的数据对象中的数据结构，因此访问者可以根据不同的对象定义出不同的行为</p><p>访问者的好处在于将数据对象的操作延迟到的访问者那一步中去了，通过定义不同的访问者可以执行不同的动作。</p><h2 id="设计模式思维导图"><a href="#设计模式思维导图" class="headerlink" title="设计模式思维导图"></a>设计模式思维导图</h2><p><a href="https://imgtu.com/i/gJVn2Q"><img src="https://z3.ax1x.com/2021/05/08/gJVn2Q.png" alt="设计模式思维导图"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-可复用面向对象软件设计的基础-行为模式&quot;&gt;&lt;a href=&quot;#设计模式-可复用面向对象软件设计的基础-行为模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-可复用面向对象软件设计的基础-行为模式&quot;&gt;&lt;/a&gt;设计模式-可复用面向对象软件</summary>
      
    
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-可复用面向对象软件设计的基础-结构型模式</title>
    <link href="https://agmtopy.gitee.io/2021/04/24/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2021/04/24/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-24T15:33:53.000Z</published>
    <updated>2021-04-29T15:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-可复用面向对象软件设计的基础-结构型模式"><a href="#设计模式-可复用面向对象软件设计的基础-结构型模式" class="headerlink" title="设计模式-可复用面向对象软件设计的基础-结构型模式"></a>设计模式-可复用面向对象软件设计的基础-结构型模式</h1><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><blockquote><p>结构型模式涉及到的是如何组织类和对象之间的引用关系,以便获得更大的组织结构和更好的可扩展性。结构性模式往往采用继承和组合两种手段来实现，关注的重点在于对象之间相互组合引用的关系上。主要有以下几种具体的模式：</p></blockquote><ol><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ol><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><blockquote><p>将一个类的接口转换成客户端所期望能使用的另外一个接口。Adapter模式使原本由于接口不兼容不能在一起使用的类能够通过一个中间适配类从而能一起工作了</p></blockquote><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>Wrapper</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210223-adapter.png" alt="适配器模式"><br>可以看到原本AudioPlayer不能直接引用AdvanceMediaPlayer，但是通过MediaAdapter实现AudioPlayer同样的接口后，在MediaAdapter中引用AdvanceMediaPlayer实现去执行具体的方法，从而迂回实现AdvanceMediaPlayer的调用</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><blockquote><p>将抽象部分和它的实现部分分离，从而使得两者都可以独立的变化。出现桥接模式的原因在因为继承接口-实现方法这种模式下接口定义好的方法子类必须按照定义进行实现，缺乏灵活性(PS:继承方式是一种强约束的关系，适用于强约束的场合)</p></blockquote><h3 id="别名-1"><a href="#别名-1" class="headerlink" title="别名"></a>别名</h3><p>Hadnle/Body</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2018/06/1528771072-8457-5780d2384acdbb60ec07fc3c71a1.png" alt="桥接模式"></p><p>Abstraction和Implementor都是抽象类，由于Abstraction内部持有Implementor抽象类，从而使得这两个抽象类都可以独立的发展，桥接模式的核心应该是将业务上不同的抽象部分单独分离开，独立演化，关注的应该是业务上抽象的功能分离和在抽象对象类的组合。通过分离和组合更好的描述一个类</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote><p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。适用于希望忽略组合对象和单个对象的不同，用户将统一的使用组合结构中的所有对象。</p></blockquote><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/cztr0P"><img src="https://z3.ax1x.com/2021/04/25/cztr0P.png" alt="cztr0P.png"></a><br>提供Component接口(抽象构件)，该接口有两个实现分别是容器构件(Composlte)、叶子构件(Leaf)。客户端通过直接使用Component接口，来忽略具体是单个对象还是组合对象提供的服务。composlte对象实现了Componet所定义的管理叶子节点的方法Add()、Remove()、GetChild()</p><p>组合模式在实现上有两种方法：1.透明组合模式、2.安全组合模式。<br>透明组合模式的特点是叶子节点和容器构件都要实现相同的接口，但是叶子节点和抽象构件节点其实都相互冗余了部分不属于自己的方法。<br>安全组合模式指的是在抽象构件中不会声明任何有关容器构件的方法，而是在容器构件中去声明并实现该方法</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="java-awt-Container"><a href="#java-awt-Container" class="headerlink" title="java.awt.Container"></a>java.awt.Container</h4><ul><li>Container.java<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>Container类内部管理一个<b>Component</b>的集合引用，这里采用的是安全的组合模式因此管理集合中的元素的方法是在Container中实现的</li></ul><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><blockquote><p>动态的为目标对象添加一些额外的职责，装饰模式(Decorator)在功能上与继承类似都是增强目标方法，但是装饰模式在结构上是向上的，而继承在结构上是向下的。装饰模式更加的灵活，没有继承那种强依赖的关系。</p></blockquote><h3 id="别名-2"><a href="#别名-2" class="headerlink" title="别名"></a>别名</h3><p>包装器-Wrapper</p><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/gpGYfe"><img src="https://z3.ax1x.com/2021/04/26/gpGYfe.jpg" alt="装饰器模式"></a></p><p>Component是顶层接口，分别别目标对象和装饰器对象实现，装饰器对象通过内部持有目标对象的一个引用，客户端在调用目标类的时候，实际上是通过调用装饰类的提供出来的方法。装饰器在持有目标类的引用后就可以在执行方法前后都进行自定义增强处理，从而实现对目标类的增强</p><p>装饰器的优点在于：</p><ol><li>比静态继承灵活且无强依赖性</li><li>避免类继承结构过高</li></ol><p>这个缺点不甚理解：</p><blockquote><p>装饰类和目标类是不一样的，装饰类对于其他对象来说是透明的</p></blockquote><ol start="4"><li>过多的类(个人认为不是缺点，类按照职责划分本来就会产生更多的小类，而不是一个大而全的类)</li></ol><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote><p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，使得子系统中的一组接口都实现该接口，对外提供一个相同的接口。</p></blockquote><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>复杂的子系统有多个类，每个类暴露出一些公共方法这些方法相互调用并对外提供一个服务，这个时候外部客户端并不关心子系统的内部调用，就可以通过Facade的模式将子系统暴露出去的接口整理成独立的接口，如下图所示：<br><a href="https://imgtu.com/i/gCcIqx"><img src="https://z3.ax1x.com/2021/04/27/gCcIqx.png" alt="门面模式"></a></p><ul><li><p>Facade<br>将请求发送给子系统对象</p></li><li><p>Subsystem class<br>实现子系统功能<br>处理有Facade指派的任务</p></li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul><li><p>JdbcUtil.java<br>JdbcUtil将有关jdbc的操作封装成为一个方法，对外提供服务</p></li><li><p>RequestFacade.java<br>Tomcat的RequestFacade.java</p></li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>运用共享技术有效的支持大量细粒度的对象，通俗的来将就是缓存具体对象，在使用时返回该对象。与单例模式类似，区别在于单例模式要保证全局唯一。享元模式不用保证全局唯一，并且可以继续创建对象。享元模式会通过内部状态和外部状态两个标识来保证对象行为的内部一致性和外部差异性</p></blockquote><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/gC5iBd"><img src="https://z3.ax1x.com/2021/04/28/gC5iBd.png" alt="享元模式"></a></p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><ul><li>String常量池</li><li>线程池</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问</p></blockquote><h3 id="别名-3"><a href="#别名-3" class="headerlink" title="别名"></a>别名</h3><p>Surrogate</p><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>代理模式为对象提供了一个可自定义的访问对象，可以实现<b>远程代理</b>、<b>虚代理</b>、<b>保护代理</b>、<b>智能指引</b>等功能<br>虚代理:指的是也就是动态代理，将初始化延迟到运行时<br>保护代理/虚代理:都是对代理对象的增强</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><a href="https://z3.ax1x.com/2021/04/28/gC5ujg.png">![代理模式]</a>](<a href="https://imgtu.com/i/gC5ujg">https://imgtu.com/i/gC5ujg</a>)</p><p>代理模式侧重于对目标对象的访问控制上，装饰模式侧重于对目标对象功能增强上。代理模式主要是对不可见的对象进行访问的代理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-可复用面向对象软件设计的基础-结构型模式&quot;&gt;&lt;a href=&quot;#设计模式-可复用面向对象软件设计的基础-结构型模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-可复用面向对象软件设计的基础-结构型模式&quot;&gt;&lt;/a&gt;设计模式-可复用面向对</summary>
      
    
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-可复用面向对象软件设计的基础-对象创建型模式</title>
    <link href="https://agmtopy.gitee.io/2021/04/17/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2021/04/17/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-17T07:17:24.000Z</published>
    <updated>2021-04-24T15:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-可复用面向对象软件设计的基础-对象创建型模式"><a href="#设计模式-可复用面向对象软件设计的基础-对象创建型模式" class="headerlink" title="设计模式-可复用面向对象软件设计的基础-对象创建型模式"></a>设计模式-可复用面向对象软件设计的基础-对象创建型模式</h1><h2 id="对象创建型模式"><a href="#对象创建型模式" class="headerlink" title="对象创建型模式"></a>对象创建型模式</h2><blockquote><p>对象创建型模式抽象了对象的实例化过程.帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类型创建模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另外一个对象</p></blockquote><p>创建型模式的主要特点是该模式聚焦于对象的创建上，关注于对象创建的过程。因为同一个类不同的实例化过程会对该类所表现出来的行为产生影响。从而在创建时，通过不同的设计模式将该过程抽象出来适应不同的场景</p><p>创建型模式主要有以下5种类型：</p><ol><li>抽象工厂模式</li><li>构造器模式</li><li>工厂模式</li><li>原型模式</li><li>单例模式</li></ol><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</p></blockquote><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>Kit</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>为解决对象工厂的创建问题。当一个业务场景需要多个工厂实例来创建对象时，如何创建这些工厂就可以使用抽象工厂模式来进行。这个模式操作的对象是是工厂对象，而不是具体工厂对象产生的实例对象。这样设计的好处是对外部来说只需要依赖AbstractFactory和AbstractProduct就可以了，不用关系具体BeanFactory和ProductFactory是怎么样被创建和依赖的。对AbstractFactory内部实现了Factory和Product的聚合。坏处在于增加一个Producty时会同时修改Abstract和创建新的具体的BeanFactory。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg" alt="抽象工厂模式"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><ul><li><p>AbstractFactory.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>AbstractFactory抽象类定义获取对象的方法</p></li><li><p>ObjectFactory1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Shape</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> objectType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>objectType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"object1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>objectType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"object2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ObjectFactory1作为工厂类继承抽象工厂类，并实现具体的抽象方法生产对象</p></li><li><p>Client</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">&#123;</span>    <span class="token comment">//1. 生成工厂类</span>    <span class="token keyword">public</span> <span class="token class-name">AbstractFactory</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> classType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//2. 通过工厂类生成产品</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">AbstractFactory</span> factory <span class="token operator">=</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token string">"classType"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> obj <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token string">"objectType"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>在客户端中主要有两步，第一个是获取具体的工厂类。第二个是根据工厂类获取对应的产品。从上面的代码中我们可以看到工厂的生成和产品的生成都需要按照不同的类型来选择生成的具体实现。抽象工厂模式管理的是工厂类。</p><h4 id="Spring中的抽象工厂模式"><a href="#Spring中的抽象工厂模式" class="headerlink" title="Spring中的抽象工厂模式"></a>Spring中的抽象工厂模式</h4><p><strong>AbstractBeanFactory__主要有三个实现类__XmlBeanFactory(已过时)__、__AbstractAutowireCapableBeanFactory__、__DefaultListableBeanFactory</strong><br>其中主要使用的是作为自动装配的工厂类AbstractAutowireCapableBeanFactory</p><h2 id="build模式"><a href="#build模式" class="headerlink" title="build模式"></a>build模式</h2><h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><blockquote><p>将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同含义的对象。构造者模式要求构造对象足够复杂并且能够按照部分参数进行处理，构造者模式将内部对象初始化的细节封装起来，外部对象之间调用即可</p></blockquote><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/cqsLl9"><img src="https://z3.ax1x.com/2021/04/22/cqsLl9.png" alt="构造者模式"></a></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul><li>lombok中的@Builder</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserParam</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//DELOMBOK之后的代码</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserParam</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>        <span class="token class-name">UserParam</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">UserParamBuilder</span> <span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserParamBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">UserParamBuilder</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>            <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>            <span class="token class-name">UserParamBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token class-name">UserParamBuilder</span> <span class="token function">userName</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token class-name">UserParamBuilder</span> <span class="token function">password</span><span class="token punctuation">(</span><span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token class-name">UserParam</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserParam</span><span class="token punctuation">(</span>userName<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token string">"UserParam.UserParamBuilder(userName="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">+</span> <span class="token string">", password="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到lombok的@Builder注解只是在内部设置了一个静态方法和静态类来生成build方式，将__Direct__的职责交给类的使用者去处理了。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><blockquote><p>定义一个创建对象的接口，让子类决定实例化具体的类对象。Factort Method使得类的实例化延迟到了子类使用的时候。</p></blockquote><h3 id="别名-1"><a href="#别名-1" class="headerlink" title="别名"></a>别名</h3><p>虚构造器(Virtual Constructor)</p><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/cOCXVJ"><img src="https://z3.ax1x.com/2021/04/22/cOCXVJ.jpg" alt="工厂模式"></a></p><p>在图中可以看到产品必须抽象出一个接口，然后在通过工厂定义创建产品的方法。通过集成工厂接口实现不同的产品的初始化过程。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h4 id="spring工厂模式"><a href="#spring工厂模式" class="headerlink" title="spring工厂模式"></a>spring工厂模式</h4><ul><li>FactoryBean.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取具体的类</span><span class="token annotation punctuation">@Nullable</span><span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>    <span class="token comment">//获取类的类型</span><span class="token annotation punctuation">@Nullable</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//是否是单例</span><span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型T是抽象的产品的接口,在FactoryBean的实现类上可以根据构造器或者在调用getObject()方法之前调用初始化方法来对生成的对象进行自定义的参数配置,这样做的好处是可以不改变调用端的逻辑从而增加一个产品子类</p><p>在具体的实现上,工厂模式有两种方式,1. 工厂类作为抽象类,提供抽象方法,由实现该类的子类具体的去做初始化产品的操作;2.工厂类不做为抽象类,并且提供默认的产品创建</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="意图-3"><a href="#意图-3" class="headerlink" title="意图"></a>意图</h3><blockquote><p>用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象</p></blockquote><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/cOmRSJ"><img src="https://z3.ax1x.com/2021/04/23/cOmRSJ.png" alt="原型模式"></a></p><p>原型模式是通过拷贝一个现有对象生成一个新的对象,需要主要的是原型模式是深拷贝而不是浅拷贝</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="意图-4"><a href="#意图-4" class="headerlink" title="意图"></a>意图</h3><blockquote><p>保证一个全局只有一个类,并且提供一个访问它的全局访问点</p></blockquote><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><a href="https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg"><img src="https://z3.ax1x.com/2021/04/23/cOmRSJ.png" alt="单例模式"></a></p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>Spring中的单例模式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-可复用面向对象软件设计的基础-对象创建型模式&quot;&gt;&lt;a href=&quot;#设计模式-可复用面向对象软件设计的基础-对象创建型模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-可复用面向对象软件设计的基础-对象创建型模式&quot;&gt;&lt;/a&gt;设计模式-</summary>
      
    
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-可复用面向对象软件设计的基础</title>
    <link href="https://agmtopy.gitee.io/2021/04/15/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://agmtopy.gitee.io/2021/04/15/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-15T12:31:01.000Z</published>
    <updated>2021-04-17T07:16:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-可复用面向对象软件设计的基础"><a href="#设计模式-可复用面向对象软件设计的基础" class="headerlink" title="设计模式-可复用面向对象软件设计的基础"></a>设计模式-可复用面向对象软件设计的基础</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><ul><li>设计模式列表</li></ul><ol><li>Abstract Factory<blockquote><p>提供一个<b>创建</b>一系列相关或相互依赖对象的接口,而无需指定它们具体的类</p></blockquote></li><li>Adapter<blockquote><p>将一个类的接口转换成客户端希望的另外一个接口.Adapter模式使得原本由于接口不兼容而不能在一起工作的那些类可以在一起工作</p></blockquote></li><li>Bridge<blockquote><p>使得抽象部分与它的实现部分分离,使得它们都可以独立的变化</p></blockquote></li><li>Builder<blockquote><p>将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的对象</p></blockquote></li><li>Chain of Responsibility<blockquote><p>为解除请求的发送者和接受者之间的耦合,使得多个对象都有机会处理这个请求.将这些处理对象连成链,并沿着这条链传递该请求,直到链尾</p></blockquote></li><li>Command<blockquote><p>将一个请求封装成为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录日志,以及支持可取消的操作</p></blockquote></li><li>Composite<blockquote><p>将对象组合成树形结构以表示’部分-整体’的层次机构.Composite使得客户对单个或复合对象的使用具有一致性</p></blockquote></li><li>Decorator<blockquote><p>动态的给一个对象添加一些额外的职责.就扩展功能而言Decorator比字节生产子类更为灵活</p></blockquote></li><li>Facade<blockquote><p>为子系统中的一组接口提供一个一致的界面,Facade定义了一个高层次的接口,这个接口使得子系统更加易用</p></blockquote></li><li>Factory Method<blockquote><p>定义一个用于创建对象的接口,让子类去决定将那个类进行实列化,Factory Method使得类的实例化延迟到了子类中</p></blockquote></li><li>Flyweight<blockquote><p>运用共享技术有效的支持大量细粒度的对象</p></blockquote></li><li>Interpreter<blockquote><p>给定一个语言,定义它的文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子</p></blockquote></li><li>Iterator<blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素,而又不需要暴露该对象的内部表示</p></blockquote></li><li>Mediator<blockquote><p>用一个中介对象来封装一系列的对象交互.中介者使得各个对象不需要显示的相互引用,从而使得其耦合松散,而且可用独立地改变它们之间的交互</p></blockquote></li><li>Memento<blockquote><p>在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可以将该对象恢复到保存状态</p></blockquote></li><li>Observer<blockquote><p>定义对象间的一种一对多的依赖关系,以便于当一个对象的状态发生改变时,所有依赖于它的对象都可以得到通知并自动刷新</p></blockquote></li><li>Prototype<blockquote><p>用原型实例指定创建对象的种类,并通过拷贝这个原型来创建新的对象</p></blockquote></li><li>Proxy<blockquote><p>为其他对象提供一个代理以控制这个对象的访问</p></blockquote></li><li>Singleton<blockquote><p>保证一个类仅有一个实例.并提供一个访问它的全局访问点</p></blockquote></li><li>State<blockquote><p>允许一个对象在其内部状态改变时改变它的行为.对象看起来似乎修改了它所属的类.</p></blockquote></li><li>Strategy<blockquote><p>定义一系列的算法,把它们封装起来,使得它们之间可以相互替换,使得算法的变化可以独立与客户</p></blockquote></li><li>Template Method<blockquote><p>定义一个操作中算法的骨架,而将一些具体步骤延迟到子类中去实现.Template Method使得之类可以复用父类定义的算法,并且进行细节的修改</p></blockquote></li><li>visitor<blockquote><p>表示一个作用于某对象结构中的各元素的操作.使得你可以在不改变各元素类的前提下定义作用于这些元素的新操作</p></blockquote></li></ol><ul><li>根据类型划分</li></ul><table><thead><tr><th></th><th></th><th>目的</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td>创建型</td><td>结构型</td><td>行为型</td></tr><tr><td>范围</td><td>类</td><td>Factory Method</td><td>Adapter(类)</td><td>Interpreter</br>Template Method</td></tr><tr><td></td><td>对象</td><td>Abstract Factory</br>Builder</br>Prototype</br>Singleton</td><td>Adapter(对象)</br>Bridge</br>Composite</br>Decorator</br>Facade</br>Flyweight</br>Proxy</br></td><td>Chain of Responsibility</br>Command</br>Iterator</br>Mediator</br>Memento</br>Observer</br>State</br>Strategy</br>Visitor</td></tr></tbody></table><ul><li>设计模式之间的关系<br><a href="https://imgtu.com/i/cRdD4H"><img src="https://z3.ax1x.com/2021/04/15/cRdD4H.jpg"></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-可复用面向对象软件设计的基础&quot;&gt;&lt;a href=&quot;#设计模式-可复用面向对象软件设计的基础&quot; class=&quot;headerlink&quot; title=&quot;设计模式-可复用面向对象软件设计的基础&quot;&gt;&lt;/a&gt;设计模式-可复用面向对象软件设计的基础&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://agmtopy.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>寻找两个正序数组中的中位数</title>
    <link href="https://agmtopy.gitee.io/2021/04/02/13.LeetCode/10.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://agmtopy.gitee.io/2021/04/02/13.LeetCode/10.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2021-04-02T15:22:03.000Z</published>
    <updated>2021-04-06T15:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寻找两个正序数组中的中位数-LeetCode4"><a href="#寻找两个正序数组中的中位数-LeetCode4" class="headerlink" title="寻找两个正序数组中的中位数_LeetCode4"></a>寻找两个正序数组中的中位数_LeetCode4</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p></blockquote><p>示例 1：<br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2</p><p>示例 2：<br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p><p>示例 3：<br>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000</p><p>示例 4：<br>输入：nums1 = [], nums2 = [1]<br>输出：1.00000</p><p>示例 5：<br>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p><p>提示：<br>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106</p><h2 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寻找两个正序数组中的中位数-LeetCode4&quot;&gt;&lt;a href=&quot;#寻找两个正序数组中的中位数-LeetCode4&quot; class=&quot;headerlink&quot; title=&quot;寻找两个正序数组中的中位数_LeetCode4&quot;&gt;&lt;/a&gt;寻找两个正序数组中的中位数_Lee</summary>
      
    
    
    
    <category term="算法" scheme="https://agmtopy.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://agmtopy.gitee.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>转置矩阵</title>
    <link href="https://agmtopy.gitee.io/2021/04/02/13.LeetCode/9.%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/"/>
    <id>https://agmtopy.gitee.io/2021/04/02/13.LeetCode/9.%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</id>
    <published>2021-04-01T16:59:29.000Z</published>
    <updated>2021-04-02T15:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转置矩阵-LeetCode867"><a href="#转置矩阵-LeetCode867" class="headerlink" title="转置矩阵_LeetCode867"></a>转置矩阵_LeetCode867</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p></blockquote><p>示例 1：</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[1,4,7],[2,5,8],[3,6,9]]<br>示例 2：</p><p>输入：matrix = [[1,2,3],[4,5,6]]<br>输出：[[1,4],[2,5],[3,6]]</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> matrix<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种解法错误,因为只考虑了行数和列数相等的情况,没有考虑行数和列数不相等的二维数组</p><h3 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>matrix<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种解法能通过,但是内存消耗比较大,因为是先创建了一个数组,然后对原数组中的每个元素遍历确定位置</p><h3 id="第三种解法"><a href="#第三种解法" class="headerlink" title="第三种解法"></a>第三种解法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r <span class="token operator">*</span> c<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        temp<span class="token punctuation">[</span>i<span class="token operator">/</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">%</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token operator">%</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">/</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种解法巧妙的运用到了取余和模除两种,但是在空间复杂度上和第二种类似,由于数组具有不可变性,因此想要实现空间复杂度小的代码很难实现.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;转置矩阵-LeetCode867&quot;&gt;&lt;a href=&quot;#转置矩阵-LeetCode867&quot; class=&quot;headerlink&quot; title=&quot;转置矩阵_LeetCode867&quot;&gt;&lt;/a&gt;转置矩阵_LeetCode867&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="算法" scheme="https://agmtopy.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://agmtopy.gitee.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>MySQL总结</title>
    <link href="https://agmtopy.gitee.io/2021/03/30/6.mysql/MySQL%E6%80%BB%E7%BB%93/"/>
    <id>https://agmtopy.gitee.io/2021/03/30/6.mysql/MySQL%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-30T14:27:04.000Z</published>
    <updated>2021-04-01T16:44:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过以上几篇文章分别介绍了MySQL的文件系统/索引/锁/事务等功能点,这篇文章将对这些知识点进行汇总,描述出MySQL大概的架构</p></blockquote><h2 id="文件数据"><a href="#文件数据" class="headerlink" title="文件数据"></a>文件数据</h2><p> MySQL在文件数据上可以划分为<strong>MySQL系统数据</strong>/<strong>存储引擎数据</strong></p><ul><li>文件数据<ul><li>系统文件</li><li>参数文件<br>参数文件指的是系统运行时的参数,主要分为’静态参数’和’动态参数’</li><li>日志文件</li><li>系统错误日志文件</li><li>二进制(binlog)<br>binlog目前有三种记录格式分别是STATEMENT/ROW/MIXED;RC和STATEMENT格式不兼容,因为binlog的是在事务进行提交时写入</li><li>慢查询日志</li><li>查询日志</li><li>套接字文件<br>套接字文件是UNIX下使用套接字链接方式打开的socket文件</li><li>pid文件</li><li>表结构文件<br>定义表结构的文件,每个表都有一个frm的表结构文件</li></ul></li><li>InnoDB存储引擎文件<ul><li>表空间文件<br>实际存储数据的文件,名称为ibdata1的文件作为共享表空间文件,MySQL也支持为每个表单独设置表空间文件,后缀名为.ibd</li><li>redolog<br>redoLog又称为重做日志,文件名称为ib_logfile0/ib_logfile1</li></ul></li></ul><p><a href="https://imgtu.com/i/cESwqK"><img src="https://z3.ax1x.com/2021/04/01/cESwqK.png" alt="cESwqK.png"></a></p><h2 id="索引系统"><a href="#索引系统" class="headerlink" title="索引系统"></a>索引系统</h2><p>MySQL的索引系统主要是由于B+ Tree索引作为底层数据结构,也有采用Hash自适应索引场景.</p><ul><li>索引<ul><li>分类<ul><li>B+Tree索引<br>B+ TREE索引作为MySQL底层数据结构的好处是在于B+TREE平衡且层级不高并且叶子节点可以作为聚集索引</li><li>全文索引<br>MySQL的全文索引也是采用倒排算法,通过关键字来进行文档映射,现实工作中未涉及到,因此未详细研究</li><li>Hash索引<br>InnoDB只支持自适应的Hash索引,不能显示的去创建并且要满足Hash索引自动创建的条件(等值查询/命中范围/查询频率)</li></ul></li></ul></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul><li>锁<ul><li><p>锁分类</p><ul><li>行级锁<ul><li>共享锁(S锁)<br>共享锁允许事务同时读取同一行数据</li><li>排他锁(X锁)<br>排他锁是独占锁,不允许其他事务读取或操作数据</li></ul></li><li>表锁<ul><li>意向共享锁(IS锁)<br>意向共享锁是表维度的锁,意向共享锁是在事务读取表中某行数据时候自动加上的,同理意向排他锁也是这个逻辑;设计意向锁的主要目的是在于当事务想要获取到表锁时,可以直接通过是否能获取到意向锁来判断,相当于一个表级别的锁标志</li><li>意向排他锁(IX锁)</li></ul></li><li>锁算法<ul><li>行锁<br>行锁的作用范围是对数据的某一行进行操作</li><li>间隙锁<br>间隙锁是对数据间隙进行上锁,这样可以防止数据出现幻读的情况</li><li>Next-Key Lock<br>行锁+间隙锁就是Next-Key Lock</li><li>锁降级<br>当发现可以用行数时,Next-Key会降级成行锁</li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2></li></ul></li><li>事务<ul><li>事务的隔离级别<ul><li>串行化(Serializable)</li><li>读未提交(Read Uncommitted)</li><li>读已提交(Read Committed)</li><li>可重复读(Repeatable Read)</li></ul></li><li>串行化<br>串行化指的是事务按照串行化执行的结果执行,InnoDB的串行化是通过增加读锁的方式来实现的</li><li>读未提交<br>读未提交指的是当前事务可以读取到其他事务尚未提交的数据,底层实现是当前事务直接返回记录上的最新值</li><li>读已提交<br>读已提交指的是事务中的SQL在执行时会去读取最后一次提交的数据信息</li><li>可重复读<br>可重复读指的是事务开始时会分配一个全局唯一且自增的事务ID,并且可重复读只能读取到小于等于该事务id的数据;快照数据是通过UNDO LOG实现的</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过以上几篇文章分别介绍了MySQL的文件系统/索引/锁/事务等功能点,这篇文章将对这些知识点进行汇总,描述出MySQL大概的架构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文件数据&quot;&gt;&lt;a href=&quot;#文件数据&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="https://agmtopy.gitee.io/2021/03/27/6.mysql/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>https://agmtopy.gitee.io/2021/03/27/6.mysql/MySQL%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-03-27T07:09:33.000Z</published>
    <updated>2021-03-30T14:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h2><p>事务是数据库与文件系统最重要的差异之一,数据库通过事务保证了数据的ACID特性,分别是原子性/一致性/隔离性/持久性</p><h2 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h2><p>事务可以划分为:<br>1.扁平事务以及带有保存点的扁平事务<br>2.链事务<br>3.嵌套事务<br>4.分布式事务</p><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>InnoDB通过日志系统来实现事务,redo log可以保证事务的原子性/一致性/持久性,undo log可以保证事务的原子性和持久性</p><h3 id="redo-log的作用"><a href="#redo-log的作用" class="headerlink" title="redo log的作用"></a>redo log的作用</h3><p>redo log是重做日志,通过每次事务提交前先修改该事务要修改的页,在提交过程中如果中断,通过redo log就可以继续提交事务</p><h3 id="undo-log的作用"><a href="#undo-log的作用" class="headerlink" title="undo log的作用"></a>undo log的作用</h3><p>undo log是回滚日志,通过记录每个事务开始时的数据,在回滚发生中断时,可以根据undo log 继续进行事务回滚</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log由两部分组成’redo log buffer’和’redo log file’,在进行事务connit之前都会将事务的所有日志写入日志文件中进行持久化<br>InnoDB提供一个参数’innodb_flush_log_at_trx_commit’来控制redo log的刷盘策略,0:由master thread进行控制 1:每次提交后进行同步刷盘 2:每次提交后只是将数据提交给文件系统,不进行主动刷盘操作</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log是回滚日志,是逻辑日志并不是redo log的物理日志,只是在逻辑上保证了数据回滚到原始状态.例如用户执行一个insert操作,在undo log里面就需要一个delete操作</p><h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><p>多版本控制,InnoDB会在行记录上默认增加两个隐藏列来作为MVVC实现的基础,分别是DB_TRX_ID-最新一次事务提交版本号/DB_ROLL_PTR-删除事务的版本号<br>数据行和undo log组成了不同版本之间的数据链,通过对比版本号和undo log日志将所需要的数据还原出来</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事务的定义&quot;&gt;&lt;a href=&quot;#事务的定义&quot; class=&quot;headerlink&quot; title=&quot;事务的定义&quot;&gt;&lt;/a&gt;事务的定义&lt;/h2&gt;&lt;p&gt;事务是数据库与文件系统最重要的差异之一,数据库通过事务保证了数据的ACID特性,分别是原子性/一致性/隔离性/持久性</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引与锁</title>
    <link href="https://agmtopy.gitee.io/2021/03/21/6.mysql/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%94%81/"/>
    <id>https://agmtopy.gitee.io/2021/03/21/6.mysql/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%94%81/</id>
    <published>2021-03-21T06:12:10.000Z</published>
    <updated>2021-03-30T14:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>InnoDB存储引擎支持以下几种索引结构:</p><ol><li>B+树索引</li><li>全文索引</li><li>哈希索引</li></ol><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>结构为’B+树’的索引有聚集索引/辅助索引<br>聚集索引是以主键来构造B+树,在叶子节点中存放行记录,也就是叶子节点称为数据页.<br>辅助索引是以索引key来构造B+树,叶子节点记录的是主键,因此在进行查找是会进行一次读取聚集索引的操作</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引指的是将存储与数据库中的全部数据中的任意内容信息查询出来的技术.<br>全文索引主要是用倒排索引的技术来进行实现,倒排索引需要用到一个索引辅助表,对全文中的值进行分词和索引定位</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引指的是用哈希算法来存储索引的结构,InnoDB的哈希索引不能由用户自定义,而是由客户进行多次查询和命中某种条件后会将B+树索引进行升级转换成哈希索引,这种算法有点类似JVM中对热点代码的JIT技术,提前将热点数据拿出来</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>锁是数据库系统区别于文件系统的一个关键特性.锁机制用于管理对共享资源的并发访问.InnoDB存储引擎会在行级别上对表数据上锁.</p></blockquote><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p>InnoDB存储引擎实现了两种标准的行级锁</p><ul><li>共享锁(S Lock),允许事务读一行数据</li><li>排他锁(X Lock),允许事务删除或更新一行数据</li></ul><p>InnoDB存储引擎支持多粒度锁定,这种锁定允许事务在行级上的锁和表级上的锁同时存在.<br>为了支持在不同粒度上进行加锁操作,InnoDB存储引擎支持意向锁,意向锁可以分为’意向共享锁’/‘意向排他锁’<br>意向共享锁:事务想要获得一张表中的某几行的共享锁<br>意向排他锁:事务想要获得一张表中的某几行的排他锁</p><h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>‘一致性非锁定读’指的是InnoDB通过行的多版本控制系统,在读取时不必等待X锁的释放.<br>RC隔离级别下,一致性非锁定读一定是读取最新的一份快照数据<br>RR隔离级别下,一致性非锁定读一定是读取事务开始时的一份快照数据</p><h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><p>InnoDB通过两种操作显式的支持一致性锁定读,第一种是</p><ul><li>SELECT * FOR UPDATE 加X锁</li><li>SELECT * LOCK IN SHARE MODE 加S锁</li></ul><h3 id="自增计数"><a href="#自增计数" class="headerlink" title="自增计数"></a>自增计数</h3><p>InnoDB的自增计数是通过表上的一个自增长计数器来进行的,当插入SQL执行完毕后该自增计数器就完成自增操作并提交</p><h3 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h3><ol><li>Record Lock:行锁</li><li>Gap Lock:间隙锁</li><li>Next-Key Lock:行锁+间隙锁</li></ol><ul><li>Next-Key Lock是默认InnoDB默认采用的锁定算法,但是当查询时使用到了聚集索引时会降级成’Record Lock’锁.<br>这里有一个小疑问,InnoDB对于Insert的操作会检查插入记录的下一条记录是否被锁定,如果锁定则不允许操作 </li></ul><p>Next-Key Loc只在RR隔离模式下使用,主要是为了解决RR模式下的幻读问题(这是又有一个疑问了既然RR模式读取的是数据的快照,按理说这个时候应该没有新插入数据的快照,为什么要这样设计喃)</p><ul><li><p>阻塞<br>阻塞指的是不同锁之间的兼容关系,在某些时刻需要等待另外一个事务中的锁释放.在默认情况下InnoDB的存储引擎在大部分情况下都不会对异常进行回滚.</p></li><li><p>死锁<br>死锁指的是两个以上的事务在执行过程中相互等待.解决死锁最简单的方法是超时机制.MySQL检测超时机制是通过’等待图’的机制来进行死锁检测.</p></li><li><p>等待图检测机制<br>通过保存锁信息和事务等待链表形成一张图结构,检测图中是否存在回路,如果存在回路证明发生了死锁.</p></li><li><p>死锁回滚<br>对于死锁异常,InnoDB会选择回滚UNDO量最小的事务进行回滚</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;InnoDB存储引擎支持以下几种索引结构:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;B+树索引&lt;/li&gt;
&lt;li&gt;全文索引&lt;/li&gt;
&lt;li&gt;哈希索引&lt;/</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL技术疑问</title>
    <link href="https://agmtopy.gitee.io/2021/03/20/6.mysql/MySQL%E6%8A%80%E6%9C%AF%E7%96%91%E9%97%AE/"/>
    <id>https://agmtopy.gitee.io/2021/03/20/6.mysql/MySQL%E6%8A%80%E6%9C%AF%E7%96%91%E9%97%AE/</id>
    <published>2021-03-20T10:12:31.000Z</published>
    <updated>2021-03-30T14:26:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录&lt;&lt;MySQL技术内幕-InnoDB存储引擎&gt;&gt;阅读中存在的疑问点</p></blockquote><ul><li>P77 日志文件<blockquote><p>如果使用RC隔离级别会出现类似数据丢失更新的现象,从而出现主从数据库上的数据不一致</p></blockquote></li></ul><p>bin_log的记录格式为’STATENEBT’是,会出现这样的情况为什么喃?</p><p>原因:</p><blockquote><ol><li>bin_log的记录顺序是commit的顺序,而不是执行顺序</li><li>RC中SQL的执行是立即执行的<br>这样如果bin_log记录格式如果是sql,就会出现丢失数据的场景</li></ol></blockquote><hr><ul><li><p>P268 锁</p><blockquote><p>InnoDB对于Insert的操作会检查插入记录的下一条记录是否被锁定,如果锁定则不允许操作</p></blockquote></li><li><p>P269 解决幻读</p><blockquote><p>在RR模式下通过Next-Key Locking机制来解决幻读,既然MVVC是读取快照,为什么还需要Next-Key Locking机制来解决幻读问题</p></blockquote></li></ul><p>InnoDB实际上是把读取拆分成两种类型</p><ul><li>快照读<br>通过读取undo log,并且对比版本号得到事务开始时的数据,这种主要是select 操作,对数据加s锁</li><li>当前读<br>当前读指的是通过Next-Key Locking 机制将对数据的读取操作序列化,解决幻读问题</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/334408495">知乎MVCC的解答</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录&amp;lt;&amp;lt;MySQL技术内幕-InnoDB存储引擎&amp;gt;&amp;gt;阅读中存在的疑问点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;P77 日志文件&lt;blockquote&gt;
&lt;p&gt;如果使用RC隔离级别会出现类似数据丢失更新的现象,</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL文件和表结构</title>
    <link href="https://agmtopy.gitee.io/2021/03/20/6.mysql/MySQL%E6%96%87%E4%BB%B6%E5%92%8C%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
    <id>https://agmtopy.gitee.io/2021/03/20/6.mysql/MySQL%E6%96%87%E4%BB%B6%E5%92%8C%E8%A1%A8%E7%BB%93%E6%9E%84/</id>
    <published>2021-03-20T03:21:19.000Z</published>
    <updated>2021-03-30T14:23:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL文件体系"><a href="#MySQL文件体系" class="headerlink" title="MySQL文件体系"></a>MySQL文件体系</h2><p>MySql文件体系主要分为:</p><ol><li>参数文件<br>参数文件的定义是作为存储MySql初始化参数的作用,负责记录各种参数</li><li>日志文件:<br>这里的日志文件主要是系统操作日志,主要有错误日志文件,二进制日志文件,慢查询日志文件等</li><li>socket文件:<br>UNIX域套接字所需文件</li><li>pid文件<br>MySql实例进程的ID文件</li><li>MySQL表结构文件<br>用来存放MySQL表结构定义文件</li><li>存储引擎文件<br>存储引擎文件存放了真正的记录和索引数据</li></ol><p>主要关心的是日志文件和存储引擎文件</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>日志文件主要有错误日志,二进制日志,慢查询日志,查询日志文件<br>二进制日志就是bin_log文件,会记录所有对MySql数据库执行更新的操作,就算最后数据未发生改变;<br>当使用支持事务的存储引擎时,所有未提交的二进制日志会被记录到一个缓存中(当超过缓存大小时会记录到临时文件中),等待该事务提交时直接将缓存刷新到bin_log中<br>bin_log的记录格式有三种(记录执行SQL,记录更新数据,混合模式),在’记录执行SQL’的模式下主从复制不能使用RC模式</p><h3 id="存储引擎文件"><a href="#存储引擎文件" class="headerlink" title="存储引擎文件"></a>存储引擎文件</h3><p>存储引擎文件主要有’表空间文件’,重做日志文件(redo log)</p><h4 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h4><p>表空间文件指的是实际存储数据的文件,分为两种类型默认的表空间,这种表空间是共享数据存储的模式,另外一种是独自的表空间,为每一张表单独生产独立的表空间文件存放数据/索引/插入缓冲BITMAP,但是该表其余的数据还是放到默认的表空间中</p><h4 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h4><p>重做日志文件是innoDB用来保证数据完整性的关键,默认采用一个重做日志组下面有两个镜像重做日志文件的架构.<br>redo_log是在sql执行过程中不断的进行写入和复制,这里和bin_log有所差异,bin_log是在事务提交后进行的写入.<br>redo_log的记录对象是对每个页的更改的物理记录,redo_log记录的是向前的更新记录.</p><h2 id="MySQL表结构"><a href="#MySQL表结构" class="headerlink" title="MySQL表结构"></a>MySQL表结构</h2><p>MySQL的文件结构是如何数据如何在物理上的结构,MySQL对于数据在逻辑上的结构可以划分为索引组织表,InnoDO的存储结构,行记录结构,页记录结构以及视图等</p><h3 id="数据存储的方式"><a href="#数据存储的方式" class="headerlink" title="数据存储的方式"></a>数据存储的方式</h3><p>数据存储格式可以分为’堆表’/‘索引组织表’</p><ul><li>堆表指的是数据的存放是无序的,是根据空闲磁盘空间来决定存放位置;</li><li>索引组织表指的是在存放数据时是按照主键索引来进行存放的.InnoDB的B+树索引结构就是一种索引组织表的形式.</li></ul><h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>InnoDB的逻辑存储结构划分为4级,分别是表空间-段空间-区空间-页空间,页空间上存储的就是一行一行的数据了</p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB逻辑存储上最上层的操作单位,一个表空间存储了所属该表的全部数据(data,index)</p><h3 id="段空间"><a href="#段空间" class="headerlink" title="段空间"></a>段空间</h3><p>对表空间内的数据按照类型进行划分,又可以划分为数据段/索引段/回滚段等,这些不同的类型数据,被称为段空间</p><p>——逻辑-物理分割层——</p><h3 id="区空间"><a href="#区空间" class="headerlink" title="区空间"></a>区空间</h3><p>区空间是由连续的磁盘空间组成,默认区空间大小为1MB,为了保证区空间的连续性还会一次向磁盘申请多个区空间.区空间实际存储了段空间内的数据.</p><h3 id="页空间"><a href="#页空间" class="headerlink" title="页空间"></a>页空间</h3><p>页空间是InnoDB最小的磁盘管理单位,在InnoDB中每个页的大小为16KB,因此一个区可以存储64个页.页按照类型可以划分为</p><ol><li>数据页</li><li>undo页</li><li>系统页</li><li>事务数据页</li><li>插入缓冲页(BitMap/Free List)</li><li>二进制大对象页</li></ol><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>InnoDB中的数据是按照行来进行存储的,行数据的记录格式按照类型可以分为两类.Compact和Redundant两种类型.</p><ul><li><p>Redundant<br>Redundant类型是为了兼容之前版本而设计的</p></li><li><p>Compact<br>Compact格式是MySQL5.0中引入的,目的是高效的存储数据.</p></li><li><p>数据结构</p></li></ul><table><thead><tr><th>变长字段长度列表</th><th>NULL标志位</th><th>记录头信息</th><th>列数据…</th><th>事务ID</th><th>回滚指针</th></tr></thead></table><p>特别要注意’事务ID’和’回滚指针’这两项与隔离级别和事务回滚有关;<br>NULL,在行的数据结构中都不占用任何存储空间,因为在行的数据结构中有NULL标志位来处理NULL</p><ul><li>Varchar类型长度<br>Varchar类型在MySQL中的定义是最大能存储65535个字节,并且是该行所有的Varchar类型长度之和.由于一个页的大小为16KB,因此在Varchar的类型长度实际上是超过一页的大小,这样就会导致一页上不能存储一行数据.这里InnoDB采用了溢出页的方式来进行处理,page上只保留数据头信息,而溢出页上存储溢出的信息(溢出指的是数据大小溢出InnoDB设定的额定大小,而不是page页的大小)</li></ul><h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>InnoDB的数据页结构指的是页空间中数据页的结构,主要由数据系统信息和用户记录信息组成</p><ul><li>数据系统结构<br>数据系统结构主要是由文件头/页头/Infimun-Supremum Records/页目录等组成,标记了该块区域的系统信息</li><li>Infimun-Supremum Records指的是一个小于数据主键的区间起始值和终止值.这两个值会在B+树中进行存储</li><li>页目录指的是指的是标记用户数据的相对位置的结构<blockquote><p>在进行数据查找时,会先从B+树中查询到数据对应的页,将页加载到内存中后,根据页目录来对用户数据进行二分查找(重点)</p></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://my.oschina.net/xinxingegeya/blog/474895">MySQL聚簇索引&amp;聚集索引&amp;索引组织表</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL文件体系&quot;&gt;&lt;a href=&quot;#MySQL文件体系&quot; class=&quot;headerlink&quot; title=&quot;MySQL文件体系&quot;&gt;&lt;/a&gt;MySQL文件体系&lt;/h2&gt;&lt;p&gt;MySql文件体系主要分为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数文件&lt;br&gt;参数文件的定</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://agmtopy.gitee.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
