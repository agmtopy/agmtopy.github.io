<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2022-08-08T16:32:18.065Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入分布式缓存-从原理到实践</title>
    <link href="https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-08-08T15:45:00.000Z</published>
    <updated>2022-08-08T16:32:18.065Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>是《深入分布式缓存-从原理到实践》一书的一些记录</p><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><blockquote><p>cache这个词,据说来自于法语,本意是当CPU处理数据时先到cache中去寻找,如果数据在之前的操作与i就读取而被暂存其中,就不需要从主内存中去读取了.后来cache的范围有所扩展,泛指凡是位于速度相差比较大的两种硬件之间,用于协调两者数据传输差异的结构,都称为cache.</p></blockquote><p>凡是通过两种查询速度较大的方式来查询同一对象都称为cache</p><blockquote><p>缓存:存储在计算机上的一个原始数据复制集,以便用于访问   -wiki</p></blockquote><p>常见的一些缓存:</p><ul><li>CPU多级缓存</li><li>TLB(Translation lookaside buffer) -最新的虚拟内存-&gt;物理内存的转换</li></ul><p>缓存分类:</p><ul><li>按缓存位置划分<ul><li>客户端缓存</li><li>服务器端缓存</li><li>网络中的缓存</li></ul></li><li>按部署方式划分<ul><li>单体缓存</li><li>集群缓存</li><li>分布式缓存</li></ul></li></ul><h3 id="网络中的缓存"><a class="header-anchor" href="#网络中的缓存"></a>网络中的缓存</h3><ul><li>web代理缓存</li></ul><p>使用正向代理的方式将web服务器上的数据进行缓存,客户端请求后之间返回不需要重新先web服务器请求</p><ul><li>边缘缓存</li></ul><p>边缘缓存是通过反向代理的方式与用户处于同一网络,向用户提供静态内容的缓存,典型应用就是CDN缓存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;是《深入分布式缓存-从原理到实践》一书的一些记录&lt;/p&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a class=&quot;</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-操作系统结构篇</title>
    <link href="https://agmtopy.gitee.io/2022/08/04/20.%E7%AC%94%E8%AE%B0/10.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/08/04/20.%E7%AC%94%E8%AE%B0/10.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2022-08-04T01:00:34.000Z</published>
    <updated>2022-08-06T14:30:34.947Z</updated>
    
    <content type="html"><![CDATA[<h1>引言</h1><p>《现代操作系统原理与实现》是一本介绍操作系统相关的书籍,是以ARM平台进行演示的.目前在看过一遍之后,我觉得还是比较有意思的<B>操作系统结构</B>、<B>硬件结构</B>、<B>内存管理</B>、<B>进程与线程</B>、<B>进程间通信</B>、<B>同步原语</B>、<B>文件系统</B>这七个章节.<br>下面会依次对这些章节做相关介绍.</p><h2 id="操作系统结构"><a class="header-anchor" href="#操作系统结构"></a>操作系统结构</h2><p>为什么要优先介绍<B>操作系统结构</B>,是这个章节给我带来了极大的感悟：对于像操作系统这样庞大的系统,在良好的架构下可以很好的有序演进,这一点是很多业务系统所欠缺的.<br>下面将从两个方面进行介绍:<B>设计方法</B>、<B>实践</B></p><h2 id="设计方法"><a class="header-anchor" href="#设计方法"></a>设计方法</h2><p>对于操作系统的设计方法或者方法论(不太喜欢’方法论’这一表述词,因为有一种’定式’的味道,现实或代码中并没有什么是固定的)来说,主要是对复杂度进行管理的一种手段;<br>这里介绍了一种设计方法:<B>M.A.L.H</B>,即模块化(modularity)、抽象(abstraction)、分层(layering)、层级(hierarchy),我对于设计简直是认同的不能在认同了.</p><h3 id="模块化"><a class="header-anchor" href="#模块化"></a>模块化</h3><p>模块化是通过<B>‘分治法’</B>的思想,将一个复杂系统分解为一系列有明确含义/领域能相互进行交互的小模块.模块的划分一定要具有’高内聚’和’低耦合’的特性,不能过大也不能过于小.<br>现代操作系统都是模块化的,以linux内核为例,可以看到分为若干模块</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97.jpg?raw=true" alt="linux模块"></p><p>关于模块化还有一些学者的阐述:<br><img src="https://martinfowler.com/articles/microservice-trade-offs.html" alt="Microservice Trade-Offs"></p><h3 id="抽象"><a class="header-anchor" href="#抽象"></a>抽象</h3><p>抽象是在模块化的基础上,将<B>接口</B>与<B>内部实现</B>进行区分,从而使得策略与实现分离.<br>这也是程序设计中的一个重要的设计原则:<B>策略</B>与<B>机制</B>分离:<B>策略</B>表示的是&quot;要做什么&quot;,<B>机制</B>表示的是&quot;要如何做&quot;</p><p>在操作系统中有很多抽象的例子,比如<B>VFS</B>、<B>虚拟内存</B>等就对不同硬件的抽象.</p><p>良好的模块化与抽象可以很好的将一个大型系统分解为一系列能够比较好的进行交付的模块;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%8A%BD%E8%B1%A1.jpg?raw=true" alt="模块化与抽象"></p><h3 id="分层"><a class="header-anchor" href="#分层"></a>分层</h3><p>分层是通过将模块按照一定的规则进行层次划分,约束每一层内部模块之间的交付方式与跨层次模块之间的交互方式,从而使得整个系统的交付方式有序;通常的规则约束是:一个模块只能和同一层模块以及相邻的上下层模块进行交互,而不能跨模块进行交互.</p><p>分层是开始构建复杂系统架构的开始,通过确定层级后,先构建底层基础模块,然后在利用这些基础模提供的功能来构建应用服务.</p><p>在实际web项目中基本上都会根据controller/service/dao三层架构来进行划分,service层的扩展要稍微多一点,例如六边形架构、洋葱圈架构等.</p><h3 id="层次"><a class="header-anchor" href="#层次"></a>层次</h3><p>层次是模块化的另外一种表现方式,是系统对功能的抽象与组织;例如组织架构类似,在组织架构上经理岗位是负责某一部分业务的,那公司的这一部分业务就需要交给他这个岗位进行负责;这个岗位下又会在分解交给其他岗位完成一样;</p><p>层次会在完成模块化、抽象、分层后自然体现出来,它与分层概念很类似,我认为的区别在于分层关注的是交互/调用关系的维护和有序,层次是关注与功能的抽象和组织;</p><h3 id="一些碎碎念"><a class="header-anchor" href="#一些碎碎念"></a>一些碎碎念</h3><p>大多数程序员长期以来写的代码都是以实现当前需求为己任,对于代码之后的生命周期是不会去考虑的.这样的代码在过了几个月以后或者另外一位同事接手后不得不在一声声’问候’下继续做相同的事情.<br>我始终认为简单明了的代码是最好的代码,因为这样的可读性是最好的; 不用去追求’新’、‘奇’来体现技术能力,而是要去追求’正确性’、'可读性’来体现技术能力;<br>然而在实际开发中,我们往往缺少一种能够指导的方法,我认为<B>M.A.L.H</B>就是一种非常好的实现,M.A.L.H中隐含了一些程序设计的技巧或法则:单一职责原则、依赖倒置原则、接口隔离原则</p><p>个人理解总结下来:</p><p>是否实现了模块化?<br>是否实现了抽象?<br>是否能够了分层?<br>是否体现了层次?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;引言&lt;/h1&gt;
&lt;p&gt;《现代操作系统原理与实现》是一本介绍操作系统相关的书籍,是以ARM平台进行演示的.目前在看过一遍之后,我觉得还是比较有意思的&lt;B&gt;操作系统结构&lt;/B&gt;、&lt;B&gt;硬件结构&lt;/B&gt;、&lt;B&gt;内存管理&lt;/B&gt;、&lt;B&gt;进程与线程&lt;/B&gt;、&lt;B&gt;进程间通信&lt;/B&gt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>maven-shade-plugin使用中的小问题</title>
    <link href="https://agmtopy.gitee.io/2022/04/22/1.%E6%9D%82%E8%AE%B0/maven-shade-plugin%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://agmtopy.gitee.io/2022/04/22/1.%E6%9D%82%E8%AE%B0/maven-shade-plugin%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-22T15:17:08.000Z</published>
    <updated>2022-04-22T15:21:28.625Z</updated>
    
    <content type="html"><![CDATA[<h1>maven-shade-plugin使用中的小问题</h1><p>maven-shade-plugin打包导致META-INF/SERVICES中的文件丢失,导致jar在动态加载时无法启动.这个问题困扰了我一周,暂时先记录处理办法,后续完善解决步骤</p><p>主要是依据这篇文章来解决处理的<br><a href="https://cloud.tencent.com/developer/article/1622207">https://cloud.tencent.com/developer/article/1622207</a></p><ul><li>maven-shade-plugin模板</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-shade-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!-- put your configurations here --></span>                <span class="token comment">&lt;!--只包含该项目代码中用到的jar,在父项目中引入了，但在当前模块中没有用到就会被删掉--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>minimizeJar</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>minimizeJar</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!--重新定位类位置，就好像类是自己写的一样，修改别人jar包的package--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relocations</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relocation</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>com.alibaba.fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedPattern</span><span class="token punctuation">></span></span>com.gavinzh.learn.fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedPattern</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--这些类和包不会被改变--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>com.alibaba.fastjson.not.Exists<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>com.alibaba.fastjson.not.exists.*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relocation</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relocations</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                        <span class="token comment">&lt;!--创建一个你自己的标识符，位置在原有名称之后--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedArtifactAttached</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedArtifactAttached</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedClassifierName</span><span class="token punctuation">></span></span>gavinzh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedClassifierName</span><span class="token punctuation">></span></span>                        <span class="token comment">&lt;!--在打包过程中对文件做一些处理工作--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformers</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--在META-INF/MANIFEST.MF文件中添加key: value 可以设置Main方法--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span>                                    <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ManifestResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestEntries</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.gavinzh.learn.shade.Main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Build-Number</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Build-Number</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Built-By</span><span class="token punctuation">></span></span>your name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Built-By</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>X-Compile-Source-JDK</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>X-Compile-Source-JDK</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>X-Compile-Target-JDK</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>X-Compile-Target-JDK</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestEntries</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--阻止META-INF/LICENSE和META-INF/LICENSE.txt--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ApacheLicenseResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token comment">&lt;!--合并所有notice文件--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ApacheNoticeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addHeader</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addHeader</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--如果多个jar包在META-INF文件夹下含有相同的文件，那么需要将他们合并到一个文件里--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.handlers<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.schemas<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.factories<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring-form.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.tooling<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--如果多个jar包在META-INF文件夹下含有相同的xml文件，则需要聚合他们--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ComponentsXmlResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token comment">&lt;!--排除掉指定资源文件--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.DontIncludeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>.no_need<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--将项目下的文件file额外加到resource中--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.IncludeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/pom_test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>pom.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--整合spi服务中META-INF/services/文件夹的相关配置--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ServicesResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformers</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>shade<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;maven-shade-plugin使用中的小问题&lt;/h1&gt;
&lt;p&gt;maven-shade-plugin打包导致META-INF/SERVICES中的文件丢失,导致jar在动态加载时无法启动.这个问题困扰了我一周,暂时先记录处理办法,后续完善解决步骤&lt;/p&gt;
&lt;p&gt;主要是</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="markdown模板" scheme="https://agmtopy.gitee.io/tags/markdown%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源代码分析之启动原理分析</title>
    <link href="https://agmtopy.gitee.io/2022/04/12/22.springboot/SpringBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2022/04/12/22.springboot/SpringBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2022-04-12T12:46:39.000Z</published>
    <updated>2022-04-22T15:21:58.393Z</updated>
    
    <content type="html"><![CDATA[<h1>SpringBoot源代码分析之启动原理分析</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程思想-核心篇》的章节,在参考SpringBoot源代码分析而来,希望对你有所帮助</p><h2 id="准备工作"><a class="header-anchor" href="#准备工作"></a>准备工作</h2><p>参考项目为地址为:<a href="https://github.com/agmtopy/SpringBootExample">https://github.com/agmtopy/SpringBootExample</a></p><p>项目结构为:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;SpringBoot源代码分析之启动原理分析&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://agmtopy.gitee.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://agmtopy.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux的定时测量分析</title>
    <link href="https://agmtopy.gitee.io/2022/04/02/21.linux/linux%E7%9A%84%E5%AE%9A%E6%97%B6%E6%B5%8B%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2022/04/02/21.linux/linux%E7%9A%84%E5%AE%9A%E6%97%B6%E6%B5%8B%E9%87%8F%E5%88%86%E6%9E%90/</id>
    <published>2022-04-02T05:28:22.000Z</published>
    <updated>2022-04-02T10:16:07.537Z</updated>
    
    <content type="html"><![CDATA[<h1>linux的定时测量分析</h1><p>定时测量之前的文章学习中的初步印象,是由特殊的电路系统上报给操作系统的一种信号量。下面是《深入理解Linux内核》一书中的阐述和思考。</p><h2 id="定时测量"><a class="header-anchor" href="#定时测量"></a>定时测量</h2><p>操作系统中需要处理的<B>定时测量</B>主要是两种：</p><ul><li>测量当前的日期和时间</li><li>维持定时器，以便测量出某一时间间隔</li></ul><p>定时测量是通过一种基于固定的频率振荡设备和计数器设备来实现的，下面介绍一下这几个硬件设备。</p><h3 id="时钟和定时器电路"><a class="header-anchor" href="#时钟和定时器电路"></a>时钟和定时器电路</h3><ul><li>实时时钟-RTC<br>实时时钟(Renl Time Clock RTC)是一个独立于CPU和其他芯片的设备，即使当计算设备被切断电源时，它还是还能正常工作。</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/RTC.jpg?raw=true" alt="RTC产品图"></p><p>在现代的计算机结构中，RTC设备通常被集成到南桥中</p><ul><li>时间戳计数器-TSC</li></ul><p>时间戳计数器是用来接收外部传递的振荡器的时钟信号。在x86架构下是通过一条名叫<B>CLK</B>的输入总线和一个名叫<B>时间戳计时器寄存器</B>来实现的。</p><ul><li><p>可编程间隔定时器-PIT<br>PIT与RTC类似，也是一个独立于CPU和其他芯片的设备，但是它的工作方式与RTC不同。PIT是通过按照固定的频率发送一个特殊的中断信号来实现的。</p></li><li><p>CPU本地定时器</p></li></ul><p>CPU本地定时器的工作原理与PIT类似都是发送一个特殊的中断信号，但是不同点在于，CPU本地定时器是据语系统总线的时钟信号量的值来实现的。</p><ul><li>高精度事件定时器-HPET</li></ul><p>高精度事件定时器是由MS与Intel共同研发的一种新型定时器,目前应该是支持最广泛的定时器,内部主要包括8个32位或64位的独立计数器，在windows下通过设备管理器插看到</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/HPET.jpg?raw=true" alt="HPET"></p><p>在参考资料2中可以看到时钟频率对游戏帧率的影响，游戏帧率越高，时钟频率越低，这样的话，游戏的性能就会越好。这里的原理类似于显示屏幕的物理帧率对游戏性能的影响一样,可以看一下B站Up主的一个视频<a href="https://www.bilibili.com/video/BV19L411N7xw?spm_id_from=333.999.0.0">游戏帧数竟然可以影响永劫的攻击速度？！</a></p><ul><li>ACPI定时器</li></ul><p>ACPI电源管理定时器几乎存在所有的ACPI主板上，它是一个简单的计数器，每次时钟节拍到来时，寄存器就加1.</p><p>以上是一些定时器的简单介绍，主要有<B>RTC</B>、<B>HPET</B></p><h2 id="Linux计时体系结构"><a class="header-anchor" href="#Linux计时体系结构"></a>Linux计时体系结构</h2><p>linux启动后必须执行的与时间相关的操作是以下几个：</p><ul><li>更新系统启动以后经过的时间</li><li>更新当前日期和时间</li><li>确定当前进程在每一个CPU上运行的时间</li><li>更新资源使用统计数量<br>-检查每一个软件定时器的时间间隔是否达到</li></ul><p>在多处理器系统中，每一个CPU都有一个时钟，它的频率可以被设置，默认的频率是1GHz，也就是说，每秒钟的时钟节拍数是1000000。普通活动(例如:软定时器)都是由全局定时器产生的中断触发的；CPU的活动则是由本地的APIC产生的中断触发的。</p><p>(PS:APIC与ACPI的区别，ACIP是本地CPU定时器，而APIC是全局电源方面的定时器，优先级较高)</p><p>内核会提供两个最基本的计时函数:一个保持对当前时间的记录，一个计算当前秒内流逝的纳秒数</p><ul><li>计时体系的数据结构</li></ul><p>这里主要介绍一个<B>jiffies变量</B>,这个变量是用于记录系统启动后产生的节拍数，但是在X86架构下这个变量使用的是一个32位置的有符号值,因此大约只需要50天左右就会置为0，这被称为时钟回绕问题，linux提供了time_after和time_before函数来解决这个问题。解决问题的思路是通过先将32位的数据转化为64位的long类型来比较，这样做的原理是，当32位的数据转化为64位的long类型后，其符号位会被置为0，从一个有符号数变成了无符号数，在对差值与0进行比较，就可以解决时钟回绕问题。</p><p>关于这个<B>jiffies变量</B>还有一个指的注意的地方是，它在初始化时，并不是赋的0，而是负3W多的一个数字,这样做的目的是尽早的发现时钟回绕问题是否被正确的处理，这里面实际体现了一种不可靠思想，想尽量的让问题尽早的暴露出来，指的学习!</p><p>jiffies变量为什么选择的是32位而不是64位,这里主要是因为在32位系统中对64位数值的访问需要使用两个32位数值来处理，这样操作两次比直接操作32位的数值要慢一些</p><h2 id="定时测量的应用"><a class="header-anchor" href="#定时测量的应用"></a>定时测量的应用</h2><ul><li>更新日期和时间</li><li>更新系统统计数据，例如CPU统计数、系统负载等</li><li>监管内核代码，例如每次时钟中断时判断当前系统正在做什么</li><li>检查非屏蔽中断监视器,监控系统内核的运行情况</li><li>软定时器与延迟函数</li></ul><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>Linux的定时测量是通过不同的硬件来实现的，有记录当前时间的RTC、有记录系统启动时间的TSC、有记录CPU的时钟周期的APIC、有记录全局时间的电源定时器ACPI、记录高精度时间的HPET等。操作系统通过这些定时器来实现记录系统运行状态、记录当前时间、记录流逝时间等功能。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="http://manpages.ubuntu.com/manpages/xenial/man4/rtc.4.html">ubuntu RTC驱动说明书</a><br><a href="https://silicophilic.com/disabling-hpet-settings/">如何通过禁用 HPET 设置来提高游戏性能</a><br><a href="https://blogs.gnome.org/raywang/2007/11/19/acpi%E5%92%8Capic%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB/">ACPI和APIC有什么关系</a><br><a href="https://www.modb.pro/db/217433">jiffies如何避免时钟回绕问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;linux的定时测量分析&lt;/h1&gt;
&lt;p&gt;定时测量之前的文章学习中的初步印象,是由特殊的电路系统上报给操作系统的一种信号量。下面是《深入理解Linux内核》一书中的阐述和思考。&lt;/p&gt;
&lt;h2 id=&quot;定时测量&quot;&gt;&lt;a class=&quot;header-anchor&quot; href</summary>
      
    
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="https://agmtopy.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>银行会计-笔记</title>
    <link href="https://agmtopy.gitee.io/2022/03/27/1.%E6%9D%82%E8%AE%B0/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1-%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2022/03/27/1.%E6%9D%82%E8%AE%B0/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1-%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-27T07:10:10.000Z</published>
    <updated>2022-05-05T13:29:58.697Z</updated>
    
    <content type="html"><![CDATA[<h1>《银行会计》笔记</h1><p>《银行会计》一书是席总带给我看的，一直以来在对这方面的知识都比较匮乏，以下是我在阅读这本书是做的一些笔记,希望能对你有帮助,开心😋😋😋</p><h2 id="第二章-银行会计的基本核算方法"><a class="header-anchor" href="#第二章-银行会计的基本核算方法"></a>第二章:银行会计的基本核算方法</h2><h3 id="会计科目"><a class="header-anchor" href="#会计科目"></a>会计科目</h3><blockquote><p>会计科目指的是对会计对象的具体内容按照不同的性质和经济管理的要求进行分类，分类后的种种科目就是会计科目</p></blockquote><p>会计科目就是根据一些法规和自身的场景/要求，将经营过程/活动分解成的科目，通过这些科目就可以按照一定的维度，统计出经营结果，从而进行会计分析</p><h3 id="会计科目的分类"><a class="header-anchor" href="#会计科目的分类"></a>会计科目的分类</h3><blockquote><p>1.按照资产负载表进行分类</br>2. 按照会计科目所反映的经营活动进行分类(这里可以理解为按照会计科目来进行分类，因为会计科目的编码是要符号一定的经济活动的</p></blockquote><ul><li><p>按照资产负载表进行分类<br>按照这种方式主要是通过资产负载表来进行分类，这种方式的好处就是可以按照资产负载表的结构来进行分类，这种方式的缺点就是不能按照经营活动的结构来进行分类，因为经营活动的结构是不确定的，这里引申出一个概念<B>资产负载表</B></p><ul><li>资产负载表<blockquote><p>资产负债表是反应企业在<B>某一特点时间</B>的<B>财务状况</B>的报表,是企业经营活动的<B>静态</B>展示;由两个方面组成<B>资产</B>、<B>负债与股东权益</B>两个大的方面组成<br>会计科目按照资产负载表的关系进行分类就可以划分为<B>表内科目</B>、<B>表外科目</B></p></blockquote></li></ul><p>这里又引申出来两个概念<B>表内科目</B>、<B>表外科目</B></p><ul><li><p>表内科目</p><blockquote><p>表内科目指的是反映银行资金发生增减变化的会计科目，其余额会在资产负债表上体现，用于表示复式记账法的会计核算过程</p></blockquote></li><li><p>表外科目</p><blockquote><p>表外科目指的是核算业务中已发生，但是尚未涉及资金增减的事项的科目，其余额不会在负债资产表上体现，用于单式记账法的会计核算过程<br>表外科目主要用于指代不列入资产负债表内和损益表内的会计科目，主要用于金融行业内使用的一类特殊科目，这里的<B>表</B>指的是资产负债表。</p></blockquote></li></ul></li><li><p>按照经营活动进行分类</p><ul><li>资产类科目</li><li>负债类科目</li><li>资产负债共同类科目</li><li>所有者权益类科目</li><li>损益类科目<br>以下是一个银行会计科目表列子</li></ul></li><li><p>银行会计科目表</p></li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1%E7%A7%91%E7%9B%AE%E8%A1%A8.jpg?raw=true" alt=""><br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1%E7%A7%91%E7%9B%AE%E8%A1%A81.jpg?raw=true" alt="银行会计科目表"></p><p>可以看到会计科目表分为5大分类，分别对应不同的经营活动</p><h3 id="科目代号"><a class="header-anchor" href="#科目代号"></a>科目代号</h3><p>从上面的银行会计科目表中可以看到，不同的科目都有一个特定的编号，分别由两个部分组成<B>一级科目</B>、<B>二级科目</B></p><ul><li><p>一级科目<br>一级科目的编排规则是：第一位数字代表科目的资金性质，即：1-代表资产类科目；2-代表负债类科目；3-代表所有者权益类科目；4-代表资产负债类科目；5-代表损益类科目；6~9代表表外科目及补充资料；第二位数字代表业务性质；剩下两位表示顺序；</p></li><li><p>二级科目<br>二级科目是一般是由6位组成，前四位是一级科目，后两位表示顺序</p></li></ul><h3 id="记账方法"><a class="header-anchor" href="#记账方法"></a>记账方法</h3><p>记账方法指的是在核算过程中，按照那样的规则进行处理；我们需要知道的就是表内用<B>复式记账法</B>、表外用<B>单式记账法</B></p><ul><li>单式记账法<br>单式记账法指的是对每一次经营活动只会在一个科目中进行登记，即：一个科目只会记录一次，不会出现多次记账的情况，这样的记账方式优点是简单,缺点是不能反映完整的经营活动</li><li>复式记账法<br>复式记账法指的是对于每笔经营活动都需要在多个科目中进行登记，即：一个科目可以记录多次，这样的记账方式优点是可以反映完整的经营活动，缺点是记账方式复杂，不能简单地反映经营活动</li></ul><p>简单的理解就是，单式记账法只能记录一次经营活动的结果，而不是过程，复式记账法记录的是一个经营活动的过程，通过在两个以上的账户中同时描述同一笔经营活动的过程，可以反映完整的经营活动</p><p>根据复式记账法原理演化出来的<B>借贷记账法</B>是国际通用的记账法，主要包括记账主体、记账符号、记账规则、试算平衡四个方面</p><ul><li>借贷记账法</li></ul><blockquote><p>借贷记账法是根据复式记账法原理,以<B>‘借’</B>、<B>‘贷’</B>作为记账符号，以<B>有借必有贷，借贷必相等</B>作为记账规则，用以记录和反映经济业务发生而导致的会计要素增减编号过程及其结果的一种复试记账法<br>可以从上面的表述中得知，借贷记账法的的目标是描述经济活动的<B>过程</B>和<B>结果</B>这两方面。</p></blockquote><ul><li>记账主体</li></ul><blockquote><p>记账主体指的是借贷记账法进行记账时，记录的是一条条<B>会计科目</B>，这些会计科目就是借贷记账法的记账主体。</p></blockquote><ul><li>记账符号</li></ul><blockquote><p>记账符号指的是<B>借</B>、<B>贷</B>，这两个符号，表示的是科目的方向，在前面的会计科目中可以得知会计科目实际上是没有方向概念的，只是描述经济活动的过程，因此需要有方向概念，这个方向概念就是记账符号。</p></blockquote><ul><li><p>记账规则<br><B>有借必有贷,借贷必相等</B>，这个规则是根据’资产 = 负载 + 所有者权益’的会计恒等式作为理论基础发展而来，通俗的表述就是：<B>即一笔经济业务的发生，必然会在一个账户的借方和贷方登记相同的金额，以达到会计分录是借贷平衡的结果</B>。</p></li><li><p>试算平衡<br>试算平衡指的是在记账过程中如果每笔经济活动记账时都满足’记账规则’时，那么在核对<B>发生额</B>和<B>余额</B>时也应该是相等的。银行每天按照总账维度核对借方和贷方的发生额和总额。</p></li></ul><p><img src="" alt="试算平衡表"></p><p>以上是借贷记账法的组成元素，分别是记账主体、记账符号、记账规则、试算平衡四个方面。复式记账法可以较好的描述表内的资产增减过程，但是对于表外资产就不太适用，因此表外资产采用的是单式记账法，即采用收入和支出作为记账符号，业务事项发生时计入<B>收入</B>、业务事项注销或冲正时计入<B>付出</B>；余额表示尚未结算的业务事项；</p><h3 id="账务组织"><a class="header-anchor" href="#账务组织"></a>账务组织</h3><p>账务组织指的是根据会计凭证对经济业务活动进行核算，分为<B>账务明细</B>、<B>综合核算</B>两个大的方面组成，都会根据<B>账簿</B>来进行记录，账簿分为<B>明显账</B>、<B>日记账</B>、<B>总账</B>、<B>登记簿</B>四种类型</p><ul><li><p>明细账<br>明细账指的是会计账簿中反映相关业务情况的账簿</p></li><li><p>总账<br>总账指的是银行会计账簿中综合核算和监督各项经济业务的分类账簿，它是综合核算和明显核算相互核对以及统驭明显分户账的主要工具</p></li><li><p>日记账<br>日记账主要是核算现金收入和现金付出的日记账，是现金收入和现金付出的详细记录</p></li><li><p>登记簿<br>登记簿主要是用于记录表外科目的增减变化的账簿</p></li></ul><h2 id="第四章-贷款业务的核算"><a class="header-anchor" href="#第四章-贷款业务的核算"></a>第四章:贷款业务的核算</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《银行会计》笔记&lt;/h1&gt;
&lt;p&gt;《银行会计》一书是席总带给我看的，一直以来在对这方面的知识都比较匮乏，以下是我在阅读这本书是做的一些笔记,希望能对你有帮助,开心😋😋😋&lt;/p&gt;
&lt;h2 id=&quot;第二章-银行会计的基本核算方法&quot;&gt;&lt;a class=&quot;header-an</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://agmtopy.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GitLab CI/CD与GitHub Actions的介绍和使用</title>
    <link href="https://agmtopy.gitee.io/2022/03/25/1.%E6%9D%82%E8%AE%B0/GitLab_CI-CD%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://agmtopy.gitee.io/2022/03/25/1.%E6%9D%82%E8%AE%B0/GitLab_CI-CD%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-25T15:27:37.000Z</published>
    <updated>2022-03-30T13:52:12.206Z</updated>
    
    <content type="html"><![CDATA[<h1>GitLab CI/CD与GitHub Actions的介绍和使用</h1><p>本篇日志主要是用来记录<B>GitLab</B>的CI/CD与<B>GitHub Actions</B>的介绍和使用。先从操作GitLab的CI/CD开始</p><h2 id="GitLab-CI-CD"><a class="header-anchor" href="#GitLab-CI-CD"></a>GitLab CI/CD</h2><p>GitLab支持多种CI方式,本身有Ai DevOps的支持,如下所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/gitlab_ai_devops.jpg?raw=true" alt="GitLab AI DevOps"></p><p>启动Ai DevOps后gitlab会根据项目的语言使用一套预设的模板,具体可以参考<a href="https://docs.gitlab.com/ee/topics/autodevops/index.html">GitLab Ai DevOps</a></p><p>在我们的演示项目中,我们可以选择开启Ai DevOps,但是实际并不会使用,而是使用我们项目中自定义的<B>.gitlab-ci.yml</B>文件</p><p>接下来介绍,让我们开始学习如何自定义GitLab的CI/CD与gradle结合使用.</p><ul><li>前置条件:<ul><li>项目地址:<a href="https://github.com/agmtopy/testcontainers-simple">https://github.com/agmtopy/testcontainers-simple</a></li></ul></li><li>步骤:<ul><li>clone 项目到本地</li><li>修改.gitlab-ci.yml文件</li><li>上传到GitLab</li><li>执行构建</li></ul></li></ul><p>下面来详细的做一下步骤二和步骤四</p><h3 id="修改-gitlab-ci-yml文件"><a class="header-anchor" href="#修改-gitlab-ci-yml文件"></a>修改.gitlab-ci.yml文件</h3><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> docker<span class="token punctuation">:</span>dind         <span class="token comment"># Testcontainers需要docker in docker</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"--tls=false"</span><span class="token punctuation">]</span>  <span class="token comment"># 禁用tls以避免docker启动中断</span><span class="token key atrule">variables</span><span class="token punctuation">:</span>  <span class="token key atrule">DOCKER_HOST</span><span class="token punctuation">:</span> <span class="token string">"tcp://docker:2375"</span>  <span class="token key atrule">DOCKER_TLS_CERTDIR</span><span class="token punctuation">:</span> <span class="token string">""</span>  <span class="token key atrule">DOCKER_DRIVER</span><span class="token punctuation">:</span> overlay2  <span class="token key atrule">GRADLE_OPTS</span><span class="token punctuation">:</span> <span class="token string">"-Dorg.gradle.daemon=false"</span><span class="token key atrule">stages</span><span class="token punctuation">:</span>          <span class="token comment"># 作业的阶段列表及其执行顺序</span>  <span class="token punctuation">-</span> build  <span class="token punctuation">-</span> test  <span class="token punctuation">-</span> deploy<span class="token key atrule">build-job</span><span class="token punctuation">:</span>       <span class="token comment"># 此作业在构建阶段运行，构建阶段是最先执行的</span>  <span class="token key atrule">image</span><span class="token punctuation">:</span> gradle<span class="token punctuation">:</span>7.4.1<span class="token punctuation">-</span>jdk11<span class="token punctuation">-</span>alpine  <span class="token key atrule">stage</span><span class="token punctuation">:</span> build  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> echo "开始编译代码<span class="token punctuation">...</span>"    <span class="token punctuation">-</span> gradle clean compileJava    <span class="token punctuation">-</span> echo "编译代码完成<span class="token punctuation">...</span>"<span class="token key atrule">test-job</span><span class="token punctuation">:</span>        <span class="token comment"># 此作业在测试阶段运行，测试阶段在第二阶段执行的</span>  <span class="token key atrule">image</span><span class="token punctuation">:</span> gradle<span class="token punctuation">:</span>7.4.1<span class="token punctuation">-</span>jdk11<span class="token punctuation">-</span>alpine  <span class="token key atrule">stage</span><span class="token punctuation">:</span> test  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span>  echo "开始测试代码<span class="token punctuation">...</span>"    <span class="token punctuation">-</span> gradle test <span class="token punctuation">-</span><span class="token punctuation">-</span>info    <span class="token punctuation">-</span> echo "测试代码完成<span class="token punctuation">...</span>"<span class="token key atrule">deploy-job</span><span class="token punctuation">:</span>      <span class="token comment"># 此作业在部署阶段运行</span>  <span class="token key atrule">stage</span><span class="token punctuation">:</span> deploy  <span class="token comment"># 只有当之前两个阶段都成功完成时，才会执行部署的。</span>  <span class="token key atrule">script</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> echo "开始部署代码<span class="token punctuation">...</span>"    <span class="token punctuation">-</span> echo "部署代码完成.."<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面这个.gitlab-ci.yml文件中,有一个稍微特殊一点的地方在于,由于我们的代码中使用到了testcontainers,所以我们需要在.gitlab-ci.yml文件中添加一个service,这个service是用来启动testcontainers相关容器的,具体可以参考<a href="https://docs.gitlab.com/runner/install/docker.html#install-the-docker-image-and-start-the-container">安装 Docker 镜像并启动容器</a></p><p>然后我们定义了三个阶段:build,test,deploy,这三个阶段的执行顺序是:build-job,test-job,deploy-job,这样我们就可以在GitLab中按照顺序执行这三个阶段的作业了,在流水线中我们也可以看到</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%B5%81%E6%B0%B4%E7%BA%BF.jpg?raw=true" alt="流水线"></p><p>由于我们没有资源,不能进行deploy,在这个阶段实际上只是打印一下,之前的build-job和test-job阶段分别是执行:<br>- gradle clean compileJava<br>- gradle test --info</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg?raw=true" alt="执行结果"></p><p>通过在流水线中点击相关的阶段,可以看到详细的日志</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97.jpg?raw=true" alt="执行日志"></p><h2 id="GitHub-Actions"><a class="header-anchor" href="#GitHub-Actions"></a>GitHub Actions</h2><p>GitHub Actions是github推出的一套发现、创建和共享操作以执行您喜欢的任何作业（包括 CI/CD），并将操作合并到完全自定义的工作流程。</p><h3 id="创建Actions"><a class="header-anchor" href="#创建Actions"></a>创建Actions</h3><p>在Actions中,选择对应的模板进行创建</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_1.jpg?raw=true" alt="创建workflows"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_2.jpg?raw=true" alt="选择模板"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_3.jpg?raw=true" alt="模板"></p><h3 id="执行Actions"><a class="header-anchor" href="#执行Actions"></a>执行Actions</h3><p>创建完成Actions后,会自动运行.运行结果可以在workflow中查看</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_4.jpg?raw=true" alt="执行Actions"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_5.jpg?raw=true" alt="执行结果"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_5.jpg?raw=true" alt="执行日志"></p><p>注意:</p><ul><li>编译gradle项目出现’Error: Gradle script ‘/home/runner/work/testcontainers-simple/testcontainers-simple/gradlew’ is not executable.'的问题是由于我们项目中的gradlew文件不是可执行的,所以需要将其设置为可执行的,在项目中执行<B>git update-index --chmod=+x gradlew</B>即可</li></ul><h3 id="Actions配置解释"><a class="header-anchor" href="#Actions配置解释"></a>Actions配置解释</h3><ul><li>main.yml</li></ul><pre class="line-numbers language-yml文件" data-language="yml文件"><code class="language-yml文件"># This workflow uses actions that are not certified by GitHub.# They are provided by a third-party and are governed by# separate terms of service, privacy policy, and support# documentation.# This workflow will build a Java project with Gradle and cache&#x2F;restore any dependencies to improve the workflow execution time# For more information see: https:&#x2F;&#x2F;help.github.com&#x2F;actions&#x2F;language-and-framework-guides&#x2F;building-and-testing-java-with-gradlename: Java CI with Gradleon: push        # 触发事件jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions&#x2F;checkout@v2    - name: Set up JDK 11      uses: actions&#x2F;setup-java@v2      with:        java-version: &#39;11&#39;        distribution: &#39;temurin&#39;    - name: Build with Gradle      uses: gradle&#x2F;gradle-build-action@0d13054264b0bb894ded474f08ebb30921341cee      with:        arguments: build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>github的CI/CD配置就比gitlab的配置看起来要清爽很多,主要是分为三个部分:</p><ul><li><p>name<br>name主要是用来标识这个workflows的名称的</p></li><li><p>on<br>on主要是用来标识触发Actions的动作的</p></li><li><p>jobs<br>jobs又很为两个部分:</p><ul><li>runs-on<br>标识运行的基础环境</li><li>steps<br>标识运行的步骤,其中with.arguments是用来指定gradle的参数的</li></ul></li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>GitLab和GitHub的CI/CD在使用上都是比较简单的,只需要使用到专用的配置文件就可以触发,需要主要一点的是GitLab的配置文件中需要指定Docker in Docker配置,<br>而GitHub Actions使用上要比GitLab的.gitlab-ci.yml要方便,可以直接从marketplace下载已经预设好的模板,直接进行使用.配置文件中也不需要指定运行环境</p><h2 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h2><p><a href="https://about.gitlab.com/install/">gitlab install</a><br><a href="https://help.aliyun.com/document_detail/52857.html">安装和使用GitLab</a><br><a href="http://blinkfox.com/2018/11/22/ruan-jian-gong-ju/devops/gitlab-ci-jie-shao-he-shi-yong/#toc-heading-20">GitLab CI/CD 介绍和使用</a><br><a href="https://zq99299.github.io/note-combat/gitlab/cicd/">CI/CD</a><br><a href="https://docs.github.com/cn/actions/quickstart">GitHub Actions 快速开始</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;GitLab CI/CD与GitHub Actions的介绍和使用&lt;/h1&gt;
&lt;p&gt;本篇日志主要是用来记录&lt;B&gt;GitLab&lt;/B&gt;的CI/CD与&lt;B&gt;GitHub Actions&lt;/B&gt;的介绍和使用。先从操作GitLab的CI/CD开始&lt;/p&gt;
&lt;h2 id=&quot;GitL</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="gitlab" scheme="https://agmtopy.gitee.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>pulsar的简单使用</title>
    <link href="https://agmtopy.gitee.io/2022/03/19/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/50.pulsar%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://agmtopy.gitee.io/2022/03/19/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/50.pulsar%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-19T05:45:03.000Z</published>
    <updated>2022-03-30T13:52:19.889Z</updated>
    
    <content type="html"><![CDATA[<h1>pulsar的简单使用</h1><p>Apache Pulsar 是一个云原生的分布式消息传递和流媒体平台，最初由 Yahoo! 创建。现在是作为Apache软件基金会的顶级项目.<br>在pulsar这个项目中还大量使用了另外一个Apache的顶级项目<B>Bookkeeper</B>作为存储层的解决方案,在研究完成Pulsar之后也会对Bookkeeper进行研究.<br>本文用于记录本地安装Pulsar的过程,希望对你有所帮助,祝好!</p><h2 id="安装Pulsar"><a class="header-anchor" href="#安装Pulsar"></a>安装Pulsar</h2><p>根据官网介绍安装Pulsar一共有三种安装方式,分别是</p><ul><li>本地运行</li><li>docker中运行</li><li>k8s中运行</li></ul><h3 id="本地运行"><a class="header-anchor" href="#本地运行"></a>本地运行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#下载</span>$ <span class="token function">wget</span> https://archive.apache.org/dist/pulsar/pulsar-2.9.1/apache-pulsar-2.9.1-bin.tar.gz<span class="token comment">#解压</span>$ <span class="token function">tar</span> xvfz apache-pulsar-2.9.1-bin.tar.gz<span class="token comment"># 启动pulsar</span>$ <span class="token builtin class-name">cd</span> apache-pulsar-2.9.1$ bin/pulsar standalone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="docker中运行"><a class="header-anchor" href="#docker中运行"></a>docker中运行</h3><ul><li>pulsar</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -it -p <span class="token number">6650</span>:6650  -p <span class="token number">8080</span>:8080 --mount <span class="token assign-left variable">source</span><span class="token operator">=</span>pulsardata,target<span class="token operator">=</span>/pulsar/data --mount <span class="token assign-left variable">source</span><span class="token operator">=</span>pulsarconf,target<span class="token operator">=</span>/pulsar/conf apachepulsar/pulsar:2.9.1 bin/pulsar standalone -nfw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>pulsar admin</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动pulsar admin</span>docker run -it  -p <span class="token number">9527</span>:9527 -p <span class="token number">7750</span>:7750 -e <span class="token assign-left variable">SPRING_CONFIGURATION_FILE</span><span class="token operator">=</span>/pulsar-manager/pulsar-manager/application.properties apachepulsar/pulsar-manager:v0.2.0<span class="token comment"># 修改密码</span><span class="token function">curl</span>  -H <span class="token string">'X-XSRF-TOKEN: $CSRF_TOKEN'</span> -H <span class="token string">'Cookie: XSRF-TOKEN=$CSRF_TOKEN;'</span>  -H <span class="token string">"Content-Type: application/json"</span> -X PUT http://localhost:7750/pulsar-manager/users/superuser -d <span class="token string">'&#123;"name": "admin", "password": "apachepulsar", "description": "test", "email": "username@test.org"&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>pulsar admin</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/pulsar/puslarAdmin.jpg?raw=true" alt="pulsar admin"></p><h3 id="k8s中运行"><a class="header-anchor" href="#k8s中运行"></a>k8s中运行</h3><p>k8s中需要使用helm来运行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">helm install     <span class="token operator">--</span>values examples<span class="token operator">/</span>values<span class="token operator">-</span>minikube<span class="token punctuation">.</span>yaml     <span class="token operator">--</span>set initialize<span class="token operator">=</span><span class="token boolean">true</span>     <span class="token operator">--</span>namespace pulsar     pulsar<span class="token operator">-</span>mini apache<span class="token operator">/</span>pulsar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pulsar示例"><a class="header-anchor" href="#pulsar示例"></a>pulsar示例</h2><p>使用kotlin来演示</p><h3 id="普通消息功能"><a class="header-anchor" href="#普通消息功能"></a>普通消息功能</h3><ul><li>PulsarUtil</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 用于创建Pulasr使用中用到的一些工具 */</span><span class="token keyword">class</span> PulsarUtil<span class="token comment">/** * 创建pulsar客户端对象 */</span><span class="token keyword">fun</span> <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PulsarClient <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> PulsarClient<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">serviceUrl</span><span class="token punctuation">(</span><span class="token string">"pulsar://localhost:6650"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 创建Topic */</span><span class="token keyword">fun</span> <span class="token function">createProduct</span><span class="token punctuation">(</span>topic<span class="token operator">:</span> String<span class="token punctuation">,</span> client<span class="token operator">:</span> PulsarClient<span class="token punctuation">)</span><span class="token operator">:</span> Producer<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> client<span class="token punctuation">.</span><span class="token function">newProducer</span><span class="token punctuation">(</span>Schema<span class="token punctuation">.</span>STRING<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>PulsarProducer</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> PulsarProducer<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> client <span class="token operator">=</span> <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> product <span class="token operator">=</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"pulsar-topic-1"</span><span class="token punctuation">,</span> client<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        product<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"message:<span class="token interpolation variable">$i</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>PulsarConsumer</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> client <span class="token operator">=</span> <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> subscribe <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">newConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token string">"pulsar-topic-1"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">subscriptionName</span><span class="token punctuation">(</span><span class="token string">"pulsar-topic-1-sub"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">ackTimeout</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">subscriptionType</span><span class="token punctuation">(</span>SubscriptionType<span class="token punctuation">.</span>Exclusive<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> receive <span class="token operator">=</span> subscribe<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"message:"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>receive<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>        subscribe<span class="token punctuation">.</span><span class="token function">acknowledge</span><span class="token punctuation">(</span>receive<span class="token punctuation">.</span>messageId<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个例子只是使用一个普通消息来演示pulsar的消息功能,推送完成后可以看到消息被消费了.</p><h3 id="异步消息功能"><a class="header-anchor" href="#异步消息功能"></a>异步消息功能</h3><blockquote><p>异步消息分为’异步发送’和’异步接收’,异步接收应该是puslar特有的功能,虽然业务代码在使用MQ时也可以通过自定义线程池的方式来完成异步接收的效果<br>下面展示一个发送消息和异步接收消息的示例</p></blockquote><ul><li>PulsarAsyncProducer</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 异步消息 */</span><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">asyncMsg</span><span class="token punctuation">(</span>product<span class="token operator">:</span> Producer<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">":提交任务"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        product<span class="token punctuation">.</span><span class="token function">sendAsync</span><span class="token punctuation">(</span><span class="token string">"message:<span class="token interpolation variable">$i</span>|"</span> <span class="token operator">+</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAccept</span> <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Message with ID <span class="token interpolation variable">$it</span> successfully sent|"</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>执行结果</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/pulsar/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg?raw=true" alt="异步消息执行结果"></p><p>可以看到回调线程不是main,而是单独的一个线程池中的线程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;pulsar的简单使用&lt;/h1&gt;
&lt;p&gt;Apache Pulsar 是一个云原生的分布式消息传递和流媒体平台，最初由 Yahoo! 创建。现在是作为Apache软件基金会的顶级项目.&lt;br&gt;
在pulsar这个项目中还大量使用了另外一个Apache的顶级项目&lt;B&gt;Book</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="pulsar" scheme="https://agmtopy.gitee.io/tags/pulsar/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-内存部分</title>
    <link href="https://agmtopy.gitee.io/2022/03/07/20.%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E9%83%A8%E5%88%86/"/>
    <id>https://agmtopy.gitee.io/2022/03/07/20.%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E9%83%A8%E5%88%86/</id>
    <published>2022-03-07T12:42:49.000Z</published>
    <updated>2022-03-30T14:09:46.851Z</updated>
    
    <content type="html"><![CDATA[<h1>编译原理-内存部分</h1><p>这一篇主要是对后端编译器对内存布局的分析和笔记,之前的有关词法/语法方面的理论知识实在是太枯燥了,翻了又翻是在是难以理解,只能暂时放下那一部分的内容了.<br>在编译时主要将内存划分为两个部分<B>栈</B>、<B>堆</B>：<br>栈主要是作为程序的临时空间实现方法、局部变量的区域<br>堆主要是作为分配大对象的区域</p><h2 id="存储组织"><a class="header-anchor" href="#存储组织"></a>存储组织</h2><blockquote><p>存储组织指的是内存区域，字节是内存中的最小编址单元.一个字节包含8个bit.多个连续的字节作为一块内存区域，并这块区域的第一个字节作为它的地址</p></blockquote><p>这里需要注意的是向操作系统申请的一段连续的内存空间可能并不是连续的，内存地址是操作系统提供的，在底层是通过页表的形式将物理上不连续的空间组织成为逻辑上连续的一段内存地址</p><blockquote><p>数据对象的存储分配受到目标机器的寻址约束影响很大。在很多机器中，执行整数加法的指令可能要求整数必须是位数相同(对齐)的。也就是说这些对象长度必须被4整除(4字节)。编译器可能会对数据进行指针对齐操作，对于空白的空间被称为<B>‘补白’</B></p></blockquote><p>'指针对齐’其实是由于CPU决定的，当现代CPU决定以2的指数倍数进行数据读取计算时，就决定了数据-指针的位数了。'补白’的指针在进行运算时肯定是优与未进行’补白’的指针的</p><blockquote><p>生成的目标代码在编译时刻就决定了编译后的大小了，因此编译器可以将可执行目标代码放到一个静态确定的区域:<B>代码区</B></p></blockquote><p>静态区域:<br>静态区域指的是在编译后就能确定内存分配的区域，例如代码区\JVM中的常量池等</p><p>动态区域:<br>动态区域指的是只能在运行时才能填充的内存区域，例如局部变量、堆区等</p><p>关于静态分配和动态分配分别表示的是<B>编译时刻</B>、<B>运行时刻</B></p><p>动态分配主要有两种实现方式分别是</p><ol><li>栈式存储<br>一个过程局部名字在栈中分配空间,通常支持过程调用/结果返回</li><li>堆存储<br>有一些数据结构的生命周期比较长，这些数据通常被放到一个可重复存储的&quot;堆&quot;中</li></ol><blockquote><p>为了支持堆区管理，通过设计&quot;垃圾回收器&quot;来是的在运行时刻能够检测出堆区的无用的数据结构，并且自动回收</p></blockquote><p>GC的概念在很早的时候就出现了</p><h2 id="栈空间"><a class="header-anchor" href="#栈空间"></a>栈空间</h2><blockquote><p>有些语言使用过程、函数或方法作为用户自定义动作的单元，通过在运行时刻按照栈结构进行管理。在调用一个过程的时候将存放这个过程的指针入栈，计算结束时出栈。这样能带来的好处是允许同时调用多个不交叠的过程</p></blockquote><blockquote><p>为了将运行时刻的空间最大化利用,<B>堆</B>和<B>栈</B>分别被放到内存空间的两端,栈区用来存放活动记录的数据结构,这些活动记录会在函数调用过程中产生.栈区存放在内存高位端向下增长,堆区存放在低位端向上增长.</p></blockquote><h3 id="静态与动态的区别"><a class="header-anchor" href="#静态与动态的区别"></a>静态与动态的区别</h3><ul><li><p>静态指的是编译器只需要观察程序源代码就可分析出某个存储的决定,这个时期被称为<B>编译时刻</B></p></li><li><p>动态指的是需要在程序执行过程中才会对内存地址进行分配</p></li></ul><h3 id="动态存储分配"><a class="header-anchor" href="#动态存储分配"></a>动态存储分配</h3><p>动态存储分配可以有两种实现方式:<br>1. 栈式存储<br>2. 堆存储</p><h3 id="栈式存储的好处"><a class="header-anchor" href="#栈式存储的好处"></a>栈式存储的好处</h3><p>栈式存储的好处是在于方便活跃时间段内不重叠的多个过程调用时共享空间,还有一个好处是保持非局部变量的地址不变</p><h2 id="栈帧"><a class="header-anchor" href="#栈帧"></a>栈帧</h2><p>在之前的理解中把栈帧理解称为一个局部变量帧空间与栈结构的联合体,这个理解是错误的,栈帧指的就是一个活动记录,只是栈中的一个元素而已</p><h2 id="函数式语言"><a class="header-anchor" href="#函数式语言"></a>函数式语言</h2><p>函数式语言支持将一个函数作为参数传递到方法中,也支持方法中直接返回函数.java中通过类似语法糖的方式实现了部分函数式的调用过程,并不是真正的函数式调用.java不能实现函数式调用的根本原因在于java无法在运行时刻更改栈空间的非成员变量的地址,在栈空间中的非成员变量地址已经确定了的.</p><h2 id="堆管理"><a class="header-anchor" href="#堆管理"></a>堆管理</h2><p>堆是存储空间中的一部分,它被用来存储那些生命周期比较长的对象.堆必须具备两个能力:</p><ol><li>分配空间</li><li>回收空间</li></ol><p>关于堆能操作的空间也只能是在程序初始化开始后向操作系统申请的空间,对于这段空间我们的堆处理程序认为是连续的,但是在物理结构上不一定是连续的,这一部分是操作系统屏蔽的内存分配的实现细节</p><p>GC这门技术发展的真的很早,很早.也是比较底层的技术,直到现在还有源源不断的新想法出现</p><h2 id="计算机的存储结构"><a class="header-anchor" href="#计算机的存储结构"></a>计算机的存储结构</h2><p>这一段与编译没有直接关系,但是我觉得很好,推荐出来</p><p>一个处理器一般都拥有几个专属的寄存器,寄存器的内容由CPU厂商提供接口供上层软件使用.在往上可以看到由一层或多层高速缓存,做开始</p><h2 id=""><a class="header-anchor" href="#"></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;编译原理-内存部分&lt;/h1&gt;
&lt;p&gt;这一篇主要是对后端编译器对内存布局的分析和笔记,之前的有关词法/语法方面的理论知识实在是太枯燥了,翻了又翻是在是难以理解,只能暂时放下那一部分的内容了.&lt;br&gt;
在编译时主要将内存划分为两个部分&lt;B&gt;栈&lt;/B&gt;、&lt;B&gt;堆&lt;/B&gt;：&lt;br</summary>
      
    
    
    
    <category term="编译原理" scheme="https://agmtopy.gitee.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-词法语法理论</title>
    <link href="https://agmtopy.gitee.io/2022/03/05/20.%E7%AC%94%E8%AE%B0/1.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E8%AF%AD%E6%B3%95%E7%90%86%E8%AE%BA/"/>
    <id>https://agmtopy.gitee.io/2022/03/05/20.%E7%AC%94%E8%AE%B0/1.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E8%AF%AD%E6%B3%95%E7%90%86%E8%AE%BA/</id>
    <published>2022-03-05T07:01:11.908Z</published>
    <updated>2022-03-30T14:09:47.864Z</updated>
    
    <content type="html"><![CDATA[<h1>编译原理-词法语法理论</h1><p>第二章<B>创建一个简单的语法指导器</B>里面设计了很多理论知识,暂时只记录关键概念。这一章看的很困，外面阳光明媚，只能通过打字来压制一下困意😂😂😂</p><h2 id="关键概念"><a class="header-anchor" href="#关键概念"></a>关键概念</h2><ul><li><p>语法制导翻译器<br><B>语法制导翻译器</B>是用于构建语法翻译器的程序</p></li><li><p>语法的定义</p></li></ul><blockquote><p>一种用于描述程序设计语言语法的表示方法 - “上下文无关文法”,这种文法用于前端编译器</p></blockquote><ul><li>语法分析器</li></ul><p>语法分析是决定如何通过一个文法生成一个终结符号的过程。语法分析有两个过程，分别是<B>自顶向下</B>、<B>自底向上</B>两种方法，指的是语法分析对语法分析的构造顺序。</p><h2 id="词法分析器"><a class="header-anchor" href="#词法分析器"></a>词法分析器</h2><blockquote><p>词法分析是编译的第一个阶段.主要是将输入的源代码生成一个词法单元序列,每个词法单元对应一个词素</p></blockquote><p>如下图所示:<br>@TODO</p><p>词法分析器还会完成一些辅助功能例如过滤空白字符、记录源代码行号</p><h3 id="词素的识别"><a class="header-anchor" href="#词素的识别"></a>词素的识别</h3><p>源代码是由不同的字符组成的，在进行编译时首先要将输入的字符串进行拆分，拆分成为不同的词素。</p><p>对于无法识别成为词素的字符，其实可以通过变化字符来进行匹配，但是这种方案代价太高，不值得使用。我赞同这种观点，编译器的功能就是编译代码而不是尝试对代码进行修复，也是单一职责的表现</p><ul><li><p>加载源代码是否会使用完缓冲区?.<br>不会,词素只需要根据前后一两个字符就可以确定了,因此只需要数千个字节就可以完成这个工作了.</p></li><li><p>如何鉴定语言的保留字?<br>通过在初始化时将各个保留字填入符号表中,符号表会标识这些保留字不是普通的标识符,并且会指向他们说代表的词法单元去</p></li></ul><h3 id="词素识别工具"><a class="header-anchor" href="#词素识别工具"></a>词素识别工具</h3><ul><li>Lex/Yacc</li></ul><blockquote><p>Lex是Unix环境下非常著名的工具,主要功能是生成一个扫描器(Scanner)的C源码。扫描器是一种识别文本中的词汇模式的程序。 这些词汇模式（或者常规表达式）在一种特殊的句子结构中定义。一种匹配的常规表达式可能会包含相关的动作。这一动作可能还包括返回一个标记。 当 Lex 接收到文件或文本形式的输入时，它试图将文本与常规表达式进行匹配。 它一次读入一个输入字符，直到找到一个匹配的模式。 如果能够找到一个匹配的模式，Lex 就执行相关的动作（可能包括返回一个标记）。 另一方面，如果没有可以匹配的常规表达式，将会停止进一步的处理，Lex 将显示一个错误消息。</p></blockquote><p>也就是通过Lex来生成一个’正则表达式’,并进行后续操作</p><h2 id="语法分析器"><a class="header-anchor" href="#语法分析器"></a>语法分析器</h2><p>下图所示的是语法分析器在编译器中的过程<br>@TODO</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>这一章主要是关于前端编译器的两个部分’词法分析器’和’语法分析器’的一些理论知识的介绍</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://sighingnow.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/lex_yacc.html">Lex和Yacc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;编译原理-词法语法理论&lt;/h1&gt;
&lt;p&gt;第二章&lt;B&gt;创建一个简单的语法指导器&lt;/B&gt;里面设计了很多理论知识,暂时只记录关键概念。这一章看的很困，外面阳光明媚，只能通过打字来压制一下困意😂😂😂&lt;/p&gt;
&lt;h2 id=&quot;关键概念&quot;&gt;&lt;a class=&quot;header-an</summary>
      
    
    
    
    <category term="编译原理" scheme="https://agmtopy.gitee.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-引言</title>
    <link href="https://agmtopy.gitee.io/2022/03/03/20.%E7%AC%94%E8%AE%B0/0.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%BC%95%E8%A8%80-/"/>
    <id>https://agmtopy.gitee.io/2022/03/03/20.%E7%AC%94%E8%AE%B0/0.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%BC%95%E8%A8%80-/</id>
    <published>2022-03-03T13:13:20.000Z</published>
    <updated>2022-08-04T01:01:26.717Z</updated>
    
    <content type="html"><![CDATA[<h1>编译原理-引言</h1><p>大概是在开始学习编写程序的时候购入了一系列的计算机基础书籍,由于自己的原因导致很多书都只是寥寥翻开几页,就匆匆放下了.<br>近来这两年,随着年纪的增大忽然有了一个念头就是自己的程序生涯已经快要结束,但是还有那么多书未看未读,有一些惋惜和不舍.不舍的既有对知识的向往也有对年轻的奢望,惋惜的是荒废了大好年华.不如把既有的书籍看完,也是完成当初对自己的期待和结束吧.</p><p>碎碎念了很久,让我们接下来开始吧,笔记按照书籍的章节进行记录</p><h2 id="第一章"><a class="header-anchor" href="#第一章"></a>第一章</h2><blockquote><p>程序设计语言是向人以及计算机描述计算过程的记号</p></blockquote><p>这是这本书的第一句话,我觉得很好.程序/代码是由人编写给人阅读,拿给机器进行执行的,因此在编写的时候既要考虑到程序的可阅读性也要考虑到机器执行的效率.<br>但是机器是看不懂人类编写的语言,就需要一个’翻译家’将我们需要的计算过程转义后告诉计算机进行执行,这个’翻译家’就是我们的<B>编译器</B><br>研究这些编译原理,也许究其一生我们也不会使用到一次相关的知识,但是可以学习前人在处理复杂问题时候的解决思路,没有灵活的思维就只能通过经验来模仿大师的行为</p><h2 id="语言处理器"><a class="header-anchor" href="#语言处理器"></a>语言处理器</h2><p>编译器泛指语言处理器,通常由两部分组成<B>编译器</B>、<B>解释器</B></p><ol><li><p>编译器<br>编译器指的是将某一种语言翻译成为行为相同的另外一种语言(目标语言)</p></li><li><p>解释器<br>解释器指的是直接执行输入过来的语言</p><p>java语言的处理器就融合了这两个语言处理器,向通过编译器将源代码编译成为中间语言代码,在通过JVM解释执行中间语言代码</p></li></ol><ul><li>编译器结构<ol><li><p>分析部分(analysis)</p><blockquote><p>分析部分又被称为前端,指的是将源程序分解为多个组成要素,并在这些要素根据语法结构来创建出一个’中间输出’,提供给下一阶段作为输入,并且生成’符号表’</p></blockquote><p>以上是书上对前端编译器的定义,目前认为前端编译器就是执行语法规则/约束来将源代码翻译成为’中间代码’</p></li><li><p>综合部分(synthesis)</p><blockquote><p>综合部分是根据前端输入的中间代码和符号表来构造用户期望的目标代码</p></blockquote><p>对于这个的理解是从中间代码转换为目标代码的过程,例如生成目标代码为java的某A语言以及A-j的中间代码,最后才能生成java语言<br>前端编译器是与机器无关的,后端编译器是与机器相关的</p></li></ol></li></ul><h2 id="编译器的步骤"><a class="header-anchor" href="#编译器的步骤"></a>编译器的步骤</h2><p>编译器执行的步骤大致分为七个步骤,置顶向下分别是</p><ol><li>词法分析器</li><li>语法分析器</li><li>语义分析器</li><li>中间代码生成器</li><li>机器无关代码优化器</li><li>代码生成器</li><li>机器相关代码优化器</li></ol><p>下图所示:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%BC%96%E8%AF%91%E5%99%A8%E6%AD%A5%E9%AA%A4%E5%9B%BE.png?raw=true" alt="编译器步骤图"></p><p>下面就对这7个步骤进行分析</p><h3 id="1-词法分析器"><a class="header-anchor" href="#1-词法分析器"></a>1.词法分析器</h3><blockquote><p>词法分析器指的是将源代码的<B>词素(lexeme)</B>转义成为由<B>词法单元(token)</B>组成的<B>词法单元序列</B></p></blockquote><p>这里涉及到两个知识点:<br>以java代码为示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>词素(lexeme)<br>词素(lexeme)在语言领域等同与词汇,在这里指的是组成源代码的单个符号.<br>示例的源代码中的词素为’String’、‘name’、‘=’、‘&quot;’、‘hello’、‘&quot;’</p></li><li><p>词法单元<br>词法单元指的是编译器对词素的抽象承载对象,通过两部分组成&lt;token-name,attribute-value&gt;<br>token-name:语法分析步骤中使用到的抽象符号<br>attribute-value:指向符号表中关于这个词法单元的条目(可选)</p></li><li><p>符号表<br>符号表指的是用于记录源代码程序中使用到的变量名字，用于存储各种属性</p></li></ol><p>通过步骤1<B>语法分析器</B>可以将源代码转换成为<B>词法单元序列</B>，后续的操作是建立在词法单元序列的基础上的</p><h3 id="2-语法分析"><a class="header-anchor" href="#2-语法分析"></a>2.语法分析</h3><blockquote><p>编译器的第二个步骤是<B>语法分析</B>或<B>解析</B>.语法分析器使用上一步词法分析器的输出<B>词法单元序列</B>作为输入，通过使用词法单元来构建语法树结构。<br><B>语法树结构</B>是由树中的每一个内部节点表示一个<B>运算</B>组成，叶子节点表示该运算的分量 ，如下图所示中的第二个步骤，通过这个步骤将将’操作’和’分量’分离，以便下一步语义分析器使用</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%B5%84%E6%96%99/%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E7%A4%BA%E4%BE%8B.jpg?raw=true" alt="编译器工作示例"></p><h3 id="3-语义分析器"><a class="header-anchor" href="#3-语义分析器"></a>3. 语义分析器</h3><blockquote><p>语义分析器是根据<B>语法树</B>和<B>符号表</B>中的信息来检查输入的源代码是否符合语言的定义，同时收集类型信息存放到语法树和符号表中，以便在随后生成中间代码的过程中进行使用</p></blockquote><p>在语义分析的过程中主要是做两方面的事情:<br>第一: 根据语言语义和符号表对语法树中的节点进行分析语义的正确性<br>第二：进行类型检查和自动类型转换</p><h3 id="4-中间代码的生成"><a class="header-anchor" href="#4-中间代码的生成"></a>4. 中间代码的生成</h3><p>通过以上三个步骤(词法分析/语法分析/语义分析)得到正确的语法树，通过这个语法树生成需要的中间代码<br>中间代码指的是是一种易于生成并且可以与目标代码进行转换的一种语言,生成一种伪指令的代码表述</p><h3 id="5-代码优化"><a class="header-anchor" href="#5-代码优化"></a>5. 代码优化</h3><p>这一步进行对中间代码的一个与机器无关的优化，由于在上一步中生成中间代码是完全按照源代码的逻辑，因此可以按照逻辑规则进行一些优化处理，由于是对逻辑的优化因此是与机器无关的</p><h3 id="6-代码生成"><a class="header-anchor" href="#6-代码生成"></a>6. 代码生成</h3><p><B>代码生成</B>是根据上一步中优化后的中间代码作为输入，然后根据不同的计算平台来生成操作具体的寄存器/内存地址的机器代码</p><h3 id="编译器处理过程小结"><a class="header-anchor" href="#编译器处理过程小结"></a>编译器处理过程小结</h3><p>编译器处理过程的过程划分为以上6个步骤(词法/语法/语义/中间代码生成/代码优化/机器代码生成)这几个步骤，在实现时可以将这几个步骤合并成为<B>“一趟”</B></p><h2 id="程序设计语言的历史"><a class="header-anchor" href="#程序设计语言的历史"></a>程序设计语言的历史</h2><p>我很喜欢了解这种技术的发展过程，虽然这段历史离我们很遥远，但是在阅读的过程中好像在历史的长流中一样，按照时间顺序</p><ul><li><p>机器指令</p></li><li><p>汇编语言</p><ul><li>宏指令</li></ul></li><li><p>高级程序语言</p><ul><li>lisp</li><li>C/C++</li><li>JAVA</li></ul></li><li><p>特定应用程序设计语言</p><ul><li>SQL</li></ul></li><li><p>基于逻辑和约束的语言</p><ul><li>prolog</li><li>ops5</li></ul></li></ul><p>语言的发展变化也在一定程度上到了编译器的方向,编译器的演化也会影响到语言的发展，两者是相辅相成的。</p><p>编译器也会对机器指令集的发展产生影响，例如编译器更喜欢RISC(精简指令集)因为RISC上的可以做更好的指令优化</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://cs.nju.edu.cn/changxu/2_compiler/slides/Chapter_1.pdf">编译原理讲义-南京大学</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;编译原理-引言&lt;/h1&gt;
&lt;p&gt;大概是在开始学习编写程序的时候购入了一系列的计算机基础书籍,由于自己的原因导致很多书都只是寥寥翻开几页,就匆匆放下了.&lt;br&gt;
近来这两年,随着年纪的增大忽然有了一个念头就是自己的程序生涯已经快要结束,但是还有那么多书未看未读,有一些惋惜和</summary>
      
    
    
    
    <category term="编译原理" scheme="https://agmtopy.gitee.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis如何实现持久化的</title>
    <link href="https://agmtopy.gitee.io/2022/01/20/1.%E6%9D%82%E8%AE%B0/redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84/"/>
    <id>https://agmtopy.gitee.io/2022/01/20/1.%E6%9D%82%E8%AE%B0/redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84/</id>
    <published>2022-01-20T15:07:22.000Z</published>
    <updated>2022-02-03T01:31:07.503Z</updated>
    
    <content type="html"><![CDATA[<h1>redis如何实现持久化的</h1><p>redis目前实现持久化主要有两种方式,一种是通过<B>RDB文件</B>,另外一种是通过<B>AOF文件</B>.<br>redis对于持久化支持4种部署方式</p><ul><li>无持久性</li><li>RDB</li><li>AOF</li><li>RDB + AOF</li></ul><p>让就让我们来详细比较和分析以下redis底层是如何实现的RDB和AOF机制的</p><h2 id="RDB文件"><a class="header-anchor" href="#RDB文件"></a>RDB文件</h2><ul><li>RDB定义</li></ul><blockquote><p>RDB 持久性指的是在指定时间间隔后执行记录当前数据集的全部数据快照</p></blockquote><p>RDB文件就类似于MySql进行全量备份,记录某一个时间点的全部数据</p><ul><li>RDB优点</li></ul><ol><li>文件即数据,不浪费空间</li><li>异步生成文件,性能损耗最小</li><li>不需要重新执行指令,数据恢复更快</li><li>支持主从切换后的数据同步</li></ol><ul><li>RDB缺点</li></ul><ol><li>没有采用LSM日志处理,会丢失数据</li><li>对于需要持久化大量数据时,性能不如AOF增量模式</li></ol><h3 id="使用实例"><a class="header-anchor" href="#使用实例"></a>使用实例</h3><p>RDB有两种触发方式:</p><ol><li>配置文件触发</li><li>命令触发</li></ol><ul><li>配置文件触发</li></ul><p>配置文件触发为在<B>redis.conf</B>中设置</p><pre class="line-numbers language-config" data-language="config"><code class="language-config">#文件路径dir#RDB文件名称dbfilename #是否启用数据校验rdbchecksum yes#是否启用RDB文件压缩格式rdbcompression yes#bgsave异常时是否停止写入缓存stop-writes-on-bgsave-error yes#60秒内有5个值发生变化时触发生成RDB文件save 60 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>命令触发</p><ul><li>save<br>同步阻塞命令</li><li>bgsave<br>fork子进程异步生成RDB文件</li></ul></li></ul><h3 id="源码解析"><a class="header-anchor" href="#源码解析"></a>源码解析</h3><ul><li>bgsave的执行调用链</li></ul><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-22%20230847.jpg" alt="bgsave的执行链"></p><blockquote><p><B>server.main()</B> -&gt; <B>server.processCommand()</B> -&gt; <B>rdb.rdbSaveBackground()</B> -&gt; <B>rdb.redisFork()</B></p></blockquote><p>下面自底向上依次分析下这个四个方法</p><ul><li><B>rdbSave()</B></li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将数据保存在磁盘上 */</span><span class="token keyword">int</span> <span class="token function">rdbSave</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> cwd<span class="token punctuation">[</span>MAXPATHLEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Current working dir path for error messages. */</span>    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    rio rdb<span class="token punctuation">;</span>    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-%d.rdb"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>cwdp <span class="token operator">=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>cwd<span class="token punctuation">,</span>MAXPATHLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>            <span class="token string">"Failed opening the RDB file %s (in server root dir %s) "</span>            <span class="token string">"for saving: %s"</span><span class="token punctuation">,</span>            filename<span class="token punctuation">,</span>            cwdp <span class="token operator">?</span> cwdp <span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span>            <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">rioInitWithFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">startSaving</span><span class="token punctuation">(</span>RDBFLAGS_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_save_incremental_fsync<span class="token punctuation">)</span>        <span class="token function">rioSetAutoSync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>REDIS_AUTOSYNC_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span><span class="token operator">&amp;</span>error<span class="token punctuation">,</span>RDBFLAGS_NONE<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        errno <span class="token operator">=</span> error<span class="token punctuation">;</span>        <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Make sure data will not remain on the OS's output buffers */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span><span class="token function">fileno</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">//重命名文件来实现写入文件的原子性</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>cwdp <span class="token operator">=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>cwd<span class="token punctuation">,</span>MAXPATHLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>            <span class="token string">"Error moving temp DB file %s on the final "</span>            <span class="token string">"destination %s (in server root dir %s): %s"</span><span class="token punctuation">,</span>            tmpfile<span class="token punctuation">,</span>            filename<span class="token punctuation">,</span>            cwdp <span class="token operator">?</span> cwdp <span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span>            <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stopSaving</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"RDB落盘成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastsave <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>    <span class="token function">stopSaving</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>werr<span class="token operator">:</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Write error saving DB on disk: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">stopSaving</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>rdbSave()</B>完成对RDB文件的写入操作:</p><ol><li>创建一个临时文件,将内存中的数据进行写入,然后刷盘</li><li>对临时文件进行rename(👍写入文件不一定是原子,但是rename file一定是原子性的),来保证文件写入的原子性</li></ol><ul><li><B>rdbSaveBackground</B></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">rdbSaveBackground</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> childpid<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasActiveChildProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>dirty_before_bgsave <span class="token operator">=</span> server<span class="token punctuation">.</span>dirty<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastbgsave_try <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//fork子进程进行处理RDB文件,这里的fork()返回值-1表示没有创建新进程成功,0表示创建新进程成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>childpid <span class="token operator">=</span> <span class="token function">redisFork</span><span class="token punctuation">(</span>CHILD_TYPE_RDB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> retval<span class="token punctuation">;</span>        <span class="token comment">/* Child */</span>        <span class="token function">redisSetProcTitle</span><span class="token punctuation">(</span><span class="token string">"redis-rdb-bgsave"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">redisSetCpuAffinity</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>bgsave_cpulist<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"RDB文件为: %s"</span><span class="token punctuation">,</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        retval <span class="token operator">=</span> <span class="token function">rdbSave</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成rdb文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sendChildCowInfo</span><span class="token punctuation">(</span>CHILD_INFO_TYPE_RDB_COW_SIZE<span class="token punctuation">,</span> <span class="token string">"RDB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">exitFromChild</span><span class="token punctuation">(</span><span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 父进程处理 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>childpid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Can't save in background: fork: %s"</span><span class="token punctuation">,</span>                <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Background saving started by pid %ld"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> childpid<span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>rdb_save_time_start <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>rdb_child_type <span class="token operator">=</span> RDB_CHILD_TYPE_DISK<span class="token punctuation">;</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span> <span class="token comment">/* unreached */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个方法内部通过<B>redisFork()</B>创建了一个子进程来完成<B>rdbSave()</B>的调用</p><p>父进程不会阻塞而是直接打印RDB文件开始处理的消息</p><p>需要注意一点的是fork()进程的方法返回值是0-成功/-1-失败</p><p>在这一步的调用中省略<B>rdb.bgsaveCommand()</B>的调用逻辑,直接分析<B>server.c</B>中的逻辑</p><ul><li><B>server.c()</B></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> redisCommandTable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span><span class="token string">"module"</span><span class="token punctuation">,</span>moduleCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>     <span class="token string">"admin no-script"</span><span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"get"</span><span class="token punctuation">,</span>getCommand<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>     <span class="token string">"read-only fast @string"</span><span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"bgsave"</span><span class="token punctuation">,</span>bgsaveCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>     <span class="token string">"admin no-script"</span><span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">//省略其他命令</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用命令模式将所有客户端命令以及命令的处理方式放到<B>redisCommandTable</B>中进行处理,然后在和网络时间绑定就形成最开始说的调用链结构</p><ul><li>cron方式启动<br>cron方式启动的逻辑位于<B>server.serverCron()</B>中</li></ul><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>RDB文件是通过fork()子进程来处理文件,采用的是rename temp file的方式保证原子性. 父进程并不会阻塞,而是启动子进程后立即返回</p><h2 id="AOF文件"><a class="header-anchor" href="#AOF文件"></a>AOF文件</h2><p>AOF文件就类似于MySql中的binlog使用的Statement格式记录数据变化,每次只记录指令,并且超过设定的大小后会进行覆盖</p><h3 id="使用实例-v2"><a class="header-anchor" href="#使用实例-v2"></a>使用实例</h3><ul><li>配置文件</li></ul><pre class="line-numbers language-config" data-language="config"><code class="language-config">#开启redis aofappendonly yes#aof刷新机制 always:每一条都写入磁盘,everysec:每秒写入磁盘一次,no:文件系统刷新appendfsync everysec#aof文件扩容的阀值比例auto-aof-rewrite-percentage 100#aof文件重写后的初始大小auto-aof-rewrite-min-size 64mb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源码解析-v2"><a class="header-anchor" href="#源码解析-v2"></a>源码解析</h3><h3 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h3><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><h2 id="参考文章"><a class="header-anchor" href="#参考文章"></a>参考文章</h2><p><a href="https://redis.io/topics/persistence">Redis Persistence</a><br><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">Redis persistence demystified</a><br><a href="https://redis.io/topics/latency">Redis 延迟问题排查</a><br><a href="https://dl.acm.org/doi/fullHtml/10.1145/3318159">TxFS：利用文件系统崩溃一致性来提供 ACID 事务</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;redis如何实现持久化的&lt;/h1&gt;
&lt;p&gt;redis目前实现持久化主要有两种方式,一种是通过&lt;B&gt;RDB文件&lt;/B&gt;,另外一种是通过&lt;B&gt;AOF文件&lt;/B&gt;.&lt;br&gt;
redis对于持久化支持4种部署方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无持久性&lt;/li&gt;
&lt;li&gt;RDB&lt;/</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://agmtopy.gitee.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis源代码构建</title>
    <link href="https://agmtopy.gitee.io/2022/01/19/1.%E6%9D%82%E8%AE%B0/redis%E6%BA%90%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/"/>
    <id>https://agmtopy.gitee.io/2022/01/19/1.%E6%9D%82%E8%AE%B0/redis%E6%BA%90%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/</id>
    <published>2022-01-19T13:52:20.000Z</published>
    <updated>2022-01-20T15:06:15.063Z</updated>
    
    <content type="html"><![CDATA[<h1>redis源代码构建</h1><p>主要用来记录以下在WSL下编译和部署redis源码的过程</p><h2 id="环境准备"><a class="header-anchor" href="#环境准备"></a>环境准备</h2><ul><li><p>WSL<br>wsl2搭配Ubuntu 18.04使用,这一项不是必须的<br><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-19%20220306.jpg" alt="wsl"></p></li><li><p>Clion<br>JetBrains的C/C++ IDE,这一项也不是必须的</p></li><li><p>源代码<br><a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p></li></ul><h2 id="构建过程"><a class="header-anchor" href="#构建过程"></a>构建过程</h2><ul><li>按照Linux编译工具</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> update<span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span>  cmake <span class="token function">make</span> gcc g++ gdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>构建release.h</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#授权</span><span class="token function">chmod</span> +x mkreleasehdr.sh<span class="token comment">#执行make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上两个步骤就完成redis源代码的编译,接下来让我们把源代码导入CLion中进行debug</p><h2 id="调试过程"><a class="header-anchor" href="#调试过程"></a>调试过程</h2><ul><li>导入项目</li></ul><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-19%20231623.jpg" alt="导入项目"></p><ul><li>设置远程部署</li></ul><ol><li>设置远程部署工具链</li></ol><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-19%20231847.jpg" alt="工具链"></p><ol start="2"><li>设置CMake</li></ol><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-19%20231912.jpg" alt="CMake"></p><ol start="3"><li>设置MakeFile</li></ol><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-19%20232004.jpg" alt="MakeFile"></p><ul><li>设置调试器</li></ul><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-19%20232030.jpg" alt="设置调试器"></p><h2 id="debug"><a class="header-anchor" href="#debug"></a>debug</h2><ul><li>启动redis-server</li></ul><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-19%20232618.jpg" alt="启动redis-server"></p><ul><li>设置断点</li></ul><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-19%20235133.jpg" alt="设置断点"></p><p>以set为例,基本调用过程为<br><B>server.c</B> -&gt; <B>connection.c</B> -&gt; <B>t_set.c</B></p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>以上就是本地编译redis的过程,后续官网上还有编译挂载redis扩展库的过程和dockerfile的相关操作(未完待续!)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;redis源代码构建&lt;/h1&gt;
&lt;p&gt;主要用来记录以下在WSL下编译和部署redis源码的过程&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WSL&lt;b</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://agmtopy.gitee.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis底层数据结构分析</title>
    <link href="https://agmtopy.gitee.io/2022/01/05/1.%E6%9D%82%E8%AE%B0/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2022/01/05/1.%E6%9D%82%E8%AE%B0/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</id>
    <published>2022-01-05T14:51:45.000Z</published>
    <updated>2022-01-19T13:48:09.270Z</updated>
    
    <content type="html"><![CDATA[<h1>redis底层数据结构分析</h1><p>redis底层数据结构分析主要是根据《Redis5 设计与源码分析》一书的章节而来,参考对照代码版本为6.2,源代码的编译和部署可以查看上一篇文章</p><p>redis底层数据结构可以划分为</p><ul><li>简单动态字符串</li><li>跳跃表</li><li>压缩列表</li><li>字典</li><li>整数集合</li><li>quicklist</li><li>stream</li></ul><p>这七种数据类型,下面分别对这七种数据类型进行分析</p><h2 id="简单动态字符串"><a class="header-anchor" href="#简单动态字符串"></a>简单动态字符串</h2><h3 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h3><p>简单动态字符串又被称为<B>SDS</B>,几乎贯穿redis中所有的模块。redis中重新设计字符串的原因是由于C语言中的char*,不满足redis中的一些常用操作例如追加字符、<br>计数等。</p><ul><li><p>char*<br>在C语言中定义的字符串结构为:字符+字符结尾，例如&quot;hello world!/n&quot;,而/n就是字符结尾，这样的结构不满足redis所需要的快速追加和计数操作</p></li><li><p>SDS<br>SDS结构是一个可以描述字符串类型(redis内部用于区分长度)、字符串长度、字符指针的类型,下面是一个具体的SDS的定义</p></li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef char *sds;struct __attribute__ ((__packed__)) sdshdr8 &#123;    uint8_t len; &#x2F;* used *&#x2F;    uint8_t alloc; &#x2F;* excluding the header and null terminator *&#x2F;    unsigned char flags; &#x2F;* 3 lsb of type, 5 unused bits *&#x2F;    char buf[];&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到SDS的类型还是*char，但是在内部重新定义了len-占用长度、alloc-最大长度、flags-标识等。</p><p><img src="https://s2.loli.net/2022/01/17/VpmsYwhPUc9KBCq.png" alt="sds的数据结构"></p><p>在这张图中的<B>sdshdr8</B>、<B>sdshdr16</B>,flags的低三位存储的是SDS的类型，高5位没有含义，在SDS5中高5位存储的是长度。<br>实际存储数据的是<B>buf[]</B>,buf[]是一个柔性数组，柔性数组指的是数据结构和内容在内存上是连续的，这样的结构查询更快速(因为不需要额外进行指针操作)<br>使用<B><strong>attribute</strong></B>让编译器以紧凑模式进行内存分配,这样可以节省<B>flags</B>的3个字节，默认内存分配是以4个字节进行分配的</p><ul><li>小结<br>关于SDS需要记住的tags:</li></ul><ol><li>[继承] 继承于char*</li><li>[类型] 是一种动态的字符串，根据字符的长度可以分配不同的SDS类型</li><li>[组成] 由于len、alloc、flags、buf[]构成</li><li>[紧凑] 紧凑模式分配类型</li></ol><h3 id="操作"><a class="header-anchor" href="#操作"></a>操作</h3><p>SDS-动态字符串具有的操作分别有增删改查这几种，其中删除的设计比较特别。</p><ul><li>删除</li></ul><p>SDS的删除是通过<B>sdsclear</B>来实现的,直接设置len为0的方式来实现</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* Modify an sds string in-place to make it empty (zero length).* However all the existing buffer is not discarded but set as free space* so that next append operations will not require allocations up to the* number of bytes previously available. *&#x2F;void sdsclear(sds s) &#123;    sdssetlen(s, 0);    s[0] &#x3D; &#39;\0&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>增加</li></ul><p>增加机制可参考下图<br><img src="https://s2.loli.net/2022/01/06/LUTovNR2k3hyIKm.png" alt="redis_sds_扩容机制"></p><p>主要是进行两个判断</p><ol><li>判断是否需要进行扩容</li><li>判断是否需要进行类型更改</li></ol><p>默认情况下是不会使用SDS5的类型,因为Redis认为扩容是一种常见的操作,因此SDS5很大的几率会更新成为SDS8类型.</p><h2 id="跳跃列表"><a class="header-anchor" href="#跳跃列表"></a>跳跃列表</h2><h3 id="数据结构-v2"><a class="header-anchor" href="#数据结构-v2"></a>数据结构</h3><p>跳跃列表指的是通过维护一个多层的链表结构来实现快速查找的数据结构<br><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8">跳跃列表</a>的解释.<br>下面是一个跳跃列表的数据结构</p><p><img src="https://s2.loli.net/2022/01/06/uciEDA9j2THBkJx.gif" alt="跳跃列表"></p><blockquote><p>通过将有序集合的部分节点分层，由最上层开始依次向后查找，如果本层的next节点大于要查找的值或next节点为NULL，则从本节点开始，降低一层继续向后查找，依次类推，如果找到则返回节点；否则返回NULL。采用该原理查找节点，在节点数量比较多时，可以跳过一些节点，查询效率大大提升，这就是跳跃表的基本思想。</p></blockquote><p>redis中的跳跃列表主要是由两个元素进行实现<B>zskiplistNode</B>、<B>zskiplist</B>,下面来详细分析一下这两个元素的源代码</p><ul><li>zskiplistNode</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* ZSETs 所使用的特殊版本的Skiplists *&#x2F;typedef struct zskiplistNode &#123;    &#x2F;&#x2F;字符串类型ele    sds ele;    &#x2F;&#x2F;用于存储排序的分值,最底层的列表就是根据这个分值进行排序    double score;    &#x2F;&#x2F;后退指针    struct zskiplistNode *backward;    &#x2F;&#x2F;层信息描述    struct zskiplistLevel &#123;        &#x2F;&#x2F;同层中的下一个节点指针        struct zskiplistNode *forward;        &#x2F;&#x2F;同层中的跨度,用于计数        unsigned long span;    &#125; level[];&#125; zskiplistNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>zskiplist</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct zskiplist &#123;    &#x2F;&#x2F;分别指向跳跃列表的头结点指针和尾节点指针    struct zskiplistNode *header, *tail;    &#x2F;&#x2F;列表的长度    unsigned long length;    &#x2F;&#x2F;列表的高度    int level;&#125; zskiplist;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="操作-v2"><a class="header-anchor" href="#操作-v2"></a>操作</h3><ul><li>查找过程</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* 查询包含在指定范围内的第一个节点，反之返回null. *&#x2F;zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range)&#123;    zskiplistNode *x;    int i;    &#x2F;* 判断传入范围超过列表范围 *&#x2F;    if (!zslIsInRange(zsl, range))        return NULL;    x &#x3D; zsl-&gt;header;    &#x2F;&#x2F;从最高层向下查找    for (i &#x3D; zsl-&gt;level - 1; i &gt;&#x3D; 0; i--)    &#123;        &#x2F;* 在同一层内从左到右依次查找 *&#x2F;        while (x-&gt;level[i].forward &amp;&amp; !zslValueGteMin(x-&gt;level[i].forward-&gt;score, range))            x &#x3D; x-&gt;level[i].forward;    &#125;    &#x2F;* 目标节点不能是最后一个*tail节点 *&#x2F;    x &#x3D; x-&gt;level[0].forward;    serverAssert(x !&#x3D; NULL);    &#x2F;*再次检测分数限制 *&#x2F;    if (!zslValueLteMax(x-&gt;score, range))        return NULL;    return x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先从上到下，再从左到右的进行查找</p><ul><li>跳跃列表的实际应用</li></ul><p>跳跃列表主要是作为<B>zset</B>的一种底层实现,在满足以下三个条件后zset会使用<B>压缩列表-ziplist</B>作为底层实现</p><ol><li>有序集合元素数量小于128个时</li><li>元素大小不超过64字节时</li><li>集合大小操作1G时<br>如果不同时满足这三个条件时,则使用<B>skipList-跳跃列表</B>作为底层数据结构,这里需要注意的是zset底层结构转换成为skipList以后,就不会在转换成为ziplist</li></ol><ul><li>zset</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token comment">//如果当前列表长度大于128个时进行转化</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zzlLength</span><span class="token punctuation">(</span>zobj<span class="token operator">-></span>ptr<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">></span> server<span class="token punctuation">.</span>zset_max_ziplist_entries <span class="token operator">||</span> <span class="token comment">//如果当前列表格式大于64个时进行转化</span>    <span class="token function">sdslen</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span> <span class="token operator">></span> server<span class="token punctuation">.</span>zset_max_ziplist_value <span class="token operator">||</span>  <span class="token comment">//如果当前列表大小大于1G时进行转化</span>    <span class="token operator">!</span><span class="token function">ziplistSafeToAdd</span><span class="token punctuation">(</span>zobj<span class="token operator">-></span>ptr<span class="token punctuation">,</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>      <span class="token comment">//转换为skip结构</span>      <span class="token function">zsetConvert</span><span class="token punctuation">(</span>zobj<span class="token punctuation">,</span>OBJ_ENCODING_SKIPLIST<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//继续添加数据</span>      zobj<span class="token operator">-></span>ptr <span class="token operator">=</span> <span class="token function">zzlInsert</span><span class="token punctuation">(</span>zobj<span class="token operator">-></span>ptr<span class="token punctuation">,</span>ele<span class="token punctuation">,</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>newscore<span class="token punctuation">)</span> <span class="token operator">*</span>newscore <span class="token operator">=</span> score<span class="token punctuation">;</span>      <span class="token operator">*</span>out_flags <span class="token operator">|=</span> ZADD_OUT_ADDED<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="压缩列表"><a class="header-anchor" href="#压缩列表"></a>压缩列表</h2><blockquote><p>压缩列表本质上是一个字节数组,是redis为了节省内存空间而设计的紧凑性数据结构,可以包含多个元素.压缩列表可以作为有序集合(zset)、散列(hash)、列表(list)</p></blockquote><h3 id="数据结构-v3"><a class="header-anchor" href="#数据结构-v3"></a>数据结构</h3><p><img src="https://s2.loli.net/2022/01/10/79cA85aCil3IzJf.png" alt="ziplist结构"></p><ul><li>zlbytes：压缩列表的字节长度，占4个字节，因此压缩列表最多有232-1个字节</li><li>zltail：压缩列表尾元素相对于压缩列表起始地址的偏移量，占4个字节</li><li>zllen：压缩列表的元素个数，占2个字节。zllen无法存储元素个数超过65535（216-1）的压缩列表，必须遍历整个压缩列表才能获取到元素个数</li><li>entryX：压缩列表存储的元素，可以是字节数组或者整数，长度不限。entry的编码结构将在后面详细介绍</li><li>zlend：压缩列表的结尾，占1个字节，恒为0xFF</li></ul><p>以下是创建ziplist的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 创建一个空白的ziplist *&#x2F;  unsigned char *ziplistNew(void) &#123;      &#x2F;&#x2F;ZIPLIST_HEADER_SIZE &#x3D; (sizeof(uint32_t)*2+sizeof(uint16_t))  + (sizeof(uint8_t))      &#x2F;&#x2F;8个字节 + 2个字节 + 1个字节      unsigned int bytes &#x3D; ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;      &#x2F;&#x2F;分配内存,返回列表指针      unsigned char *zl &#x3D; zmalloc(bytes);      &#x2F;&#x2F;尝试将大端数据转换成小端数据      ZIPLIST_BYTES(zl) &#x3D; intrev32ifbe(bytes);      ZIPLIST_TAIL_OFFSET(zl) &#x3D; intrev32ifbe(ZIPLIST_HEADER_SIZE);      &#x2F;&#x2F;初始化列表长度      ZIPLIST_LENGTH(zl) &#x3D; 0;      &#x2F;&#x2F;设置列表尾部字符为hex_ff      zl[bytes-1] &#x3D; ZIP_END;      return zl;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是第三个步骤使用<B>intrev32ifbe()</B>尝试将大端数据转换成为小段数据;</p><p>大小端数据定义</p><blockquote><p>字节的排列方式有两个通用规则。例如，将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。<br>这里redis尽量采用小端的原因是在于<B>X86架构</B>和<B>ARM架构</B>是采用的小端模式,但是网络传输采用的是大端模式.</p></blockquote><h3 id="Entry的内部结构"><a class="header-anchor" href="#Entry的内部结构"></a>Entry的内部结构</h3><p>entry的结构体定义如下:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 我们使用这个函数来接收有关 ziplist 条目的信息。   请注意，这不是数据的实际编码方式，这是我们  被一个函数填充以便更容易操作。 *&#x2F;typedef struct zlentry &#123;    unsigned int prevrawlensize; &#x2F;* 对prevrawlen编码后的字节大小*&#x2F;    unsigned int prevrawlen;     &#x2F;* 上一个节点的长度 *&#x2F;    unsigned int lensize;        &#x2F;* 对len编码后的长度*&#x2F;    unsigned int len;            &#x2F;* 当前节点的长度 *&#x2F;    unsigned int headersize;     &#x2F;* prevrawlensize + lensize. *&#x2F;    unsigned char encoding;      &#x2F;* 当前节点所使用的编码类型:ZIP_STR_* or ZIP_INT *&#x2F;    unsigned char *p;            &#x2F;* 指向列表第一个元素的指针 *&#x2F;&#125; zlentry;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ziplist中需要注意的是’连锁更新’问题,由于ziplist的结构并不是链表结构而是连续内存结构,导致在删除上一个大节点时会导致数组整体移动的问题</p><h2 id="字典"><a class="header-anchor" href="#字典"></a>字典</h2><blockquote><p>字典又称散列表，是用来存储键值（key-value）对的一种数据结构.</p></blockquote><h3 id="数据结构-v4"><a class="header-anchor" href="#数据结构-v4"></a>数据结构</h3><p>Redis字典实现依赖的数据结构主要包含了三部分：字典、Hash表、Hash表节点。字典中嵌入了两个Hash表，Hash表中的table字段存放着Hash表节点，Hash表节点对应存储的是键值对。</p><p>结构如下:<br><img src="https://s2.loli.net/2022/01/16/sbcuXE1oLvhFzi9.jpg" alt="空Hash表结构示意"></p><ul><li>dict</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** hash结构体* 会同时使用两个hash结构体,以便实现增量扩容*&#x2F;typedef struct dictht &#123;    &#x2F;&#x2F;指针数组,用于存储键值对    dictEntry **table;    &#x2F;&#x2F;table数组的大小    unsigned long size;    &#x2F;&#x2F;掩码(size-1)    unsigned long sizemask;    &#x2F;&#x2F;已存储的元素数量    unsigned long used;&#125; dictht;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里着重介绍一下掩码(sizemask)这个字段,sizemask的计算方式为取(size-1)这样的好处是通过<br><B>hash_key&amp;sizemask = hash_key/size</B><br>位操作的性能要高于取余操作</p><ul><li>dictEntry</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct dictEntry &#123;    void *key;    union &#123;        void *val;        uint64_t u64;        int64_t s64;        double d;    &#125; v;    struct dictEntry *next;&#125; dictEntry;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dictEntry是hash的节点元素结构,需要注意的是<B>V</B>是一种联合体结构,根据使用场景使用不同类型<br>*next是用来解决hash冲突的,采用的是头插法</p><ul><li>渐进式ReHash</li></ul><ol><li>当执行插入\删除\查找\修改时都会先判断当前字典是否在进行rehash,然后尝试进行rehash后才会执行操作</li><li>线程空闲时会每次对100个节点进行rehash</li></ol><h3 id="操作-v3"><a class="header-anchor" href="#操作-v3"></a>操作</h3><ul><li>迭代操作</li></ul><p>redis中的数据迭代分为两种类型</p><ol><li>普通迭代器<br>普通迭代器只会遍历数据</li><li>安全迭代器<br>安全迭代器,在遍历过程中会删除数据</li></ol><p>这两种迭代器对迭代过程中可能会产生重复数据的处理方式不一样</p><ol><li>普通迭代器<br>普通迭代器是通过标志位来限制字典结构的变化</li><li>安全迭代器<br>安全迭代器是通过限制rehash来保证数据的准确性</li></ol><h2 id="整数集合"><a class="header-anchor" href="#整数集合"></a>整数集合</h2><p>redis中的<B>整数集合</B>是作为集合的底层数据结构,用来保存少量的数据和整数元素,下面我们来分析它的数据结构和操作</p><h3 id="数据结构-v5"><a class="header-anchor" href="#数据结构-v5"></a>数据结构</h3><ul><li>intset.h</li></ul><pre class="line-numbers language-h" data-language="h"><code class="language-h">&#x2F;*** 整数集合结构体*&#x2F;typedef struct intset &#123;    &#x2F;&#x2F;编码格式    uint32_t encoding;    &#x2F;&#x2F;数组长度    uint32_t length;    &#x2F;&#x2F;元素数组    int8_t contents[];&#125; intset;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到整数集合的结构体比较简单,只有编码格式/长度/数据,这三个部分组成.下面继续分析一下整数数组创建的过程</p><ul><li>intsetNew</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* 创建空白的intset *&#x2F;intset *intsetNew(void) &#123;    &#x2F;&#x2F;通过zmalloc分配连续内存    intset *is &#x3D; zmalloc(sizeof(intset));    &#x2F;&#x2F;设置编码    is-&gt;encoding &#x3D; intrev32ifbe(INTSET_ENC_INT16);    &#x2F;&#x2F;设置长度    is-&gt;length &#x3D; 0;    return is;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="操作-v4"><a class="header-anchor" href="#操作-v4"></a>操作</h3><p>操作主要分析添加元素(intsetAdd)和删除元素()这两个操作</p><ul><li>intsetAdd</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* 添加元素 *&#x2F;intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123;    &#x2F;&#x2F;1. 计算value的编码格式    uint8_t valenc &#x3D; _intsetValueEncoding(value);    uint32_t pos;    if (success) *success &#x3D; 1;    &#x2F;*    *判断即将添加的元素是否需要修改intset修改编码才能添加    *&#x2F;    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;        &#x2F;* 这个操作默认都是成功的 *&#x2F;        return intsetUpgradeAndAdd(is, value);    &#125; else &#123;        &#x2F;&#x2F;判断当前元素是否存在于集合中,如果有则返回失败        &#x2F;&#x2F;*pos        if (intsetSearch(is, value, &amp;pos)) &#123;            if (success) *success &#x3D; 0;            return is;        &#125;        &#x2F;&#x2F;判断当前添加元素后是否需要扩容        is &#x3D; intsetResize(is, intrev32ifbe(is-&gt;length) + 1);        &#x2F;&#x2F;pos如果在当前数组中,需要对元素进行移位操作        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is, pos, pos + 1);    &#125;    &#x2F;&#x2F;向pos的位置上插入元素value    _intsetSet(is, pos, value);    &#x2F;&#x2F;设置length    is-&gt;length &#x3D; intrev32ifbe(intrev32ifbe(is-&gt;length) + 1);    return is;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加元素是通过*pos指针来进行确定位置的,先获取可以插入的位置,在将元素插到指定的位置上,最后在进行位移操作</p><ul><li>intsetRemove</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* 删除元素 *&#x2F;intset *intsetRemove(intset *is, int64_t value, int *success) &#123;    &#x2F;&#x2F;判断元素编码    uint8_t valenc &#x3D; _intsetValueEncoding(value);    uint32_t pos;    if (success) *success &#x3D; 0;    &#x2F;&#x2F;查找元素位置    if (valenc &lt;&#x3D; intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is, value, &amp;pos)) &#123;        uint32_t len &#x3D; intrev32ifbe(is-&gt;length);        &#x2F;* We know we can delete *&#x2F;        if (success) *success &#x3D; 1;        &#x2F;*使用位移操作覆盖元素*&#x2F;        if (pos &lt; (len - 1)) intsetMoveTail(is, pos + 1, pos);        &#x2F;&#x2F;重新设置数组长度        is &#x3D; intsetResize(is, len - 1);        is-&gt;length &#x3D; intrev32ifbe(len - 1);    &#125;    return is;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先查找元素,在根据元素的位置进行移位操作.<br>从<B>intsetAdd</B>方法中可以看到整数集合中的数据是不允许重复的,是有序的数组组成.</p><h2 id="quicklist"><a class="header-anchor" href="#quicklist"></a>quicklist</h2><p>quicklist是为优化处理<B>List</B>的底层存储结构ziplist和adlist而来,关于List的定义这个描述的比较好</p><blockquote><p>链表是这样一种数据结构，其中的各对象按线性顺序排列。链表与数组的不同点在于，数组的顺序由下标决定，链表的顺序由对象中的指针决定。</p></blockquote><p>关于quicklist的定义如下</p><blockquote><p>Redis中对quciklist的注释为A doubly linked list of ziplists。quicklist是一个双向链表，链表中的每个节点是一个ziplist结构。quicklist可以看成是用双向链表将若干小型的ziplist连接到一起组成的一种数据结构。</p></blockquote><h3 id="数据结构-v6"><a class="header-anchor" href="#数据结构-v6"></a>数据结构</h3><ul><li>quicklist</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*** quickList结构体* 大小为40字节*&#x2F;typedef struct quicklist &#123;    &#x2F;&#x2F;首尾节点    quicklistNode *head;    quicklistNode *tail;    &#x2F;&#x2F;总条数    unsigned long count;    &#x2F;&#x2F;节点数量    unsigned long len;    &#x2F;&#x2F;单个节点的填充因子    int fill : QL_FILL_BITS;    &#x2F;&#x2F;不同节点的深度    unsigned int compress : QL_COMP_BITS;    unsigned int bookmark_count: QL_BM_BITS;    &#x2F;&#x2F;书签列表(用于快速查找节点使用)    quicklistBookmark bookmarks[];&#125; quicklist;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于超大型列表会采用列表尾部使用书签这种数据结构来进行快速查找</p><ul><li>quicklistBookmark</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct quicklistBookmark &#123;    quicklistNode *node;    char *name;&#125; quicklistBookmark;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以从quicklist/quicklistBookmark的结构体中看到<B>quicklistNode</B>是底层元素存储节点的结构体</p><ul><li>quicklistNode</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*** quicklistNode 是一个 32 字节的结构，用于描述一个快速列表的ziplist。* 我们使用sz(位域)将 quicklistNode 保持在 32 字节。* count: 16位，最大 65536（最大 zl 字节为 65k，因此最大计数实际上 &lt; 32k）。* encoding: 2位，RAW&#x3D;1，LZF&#x3D;2。* container: 2 位，NONE&#x3D;1，ZIPLIST&#x3D;2。* recompress: 1 位，布尔值，如果节点临时解压缩以供使用，则为 true。* attempted_compress: 1 位，布尔值，用于测试期间的验证。* extra: 10 位，免费供以后使用； 填充剩余的 32 位*&#x2F;typedef struct quicklistNode &#123;    struct quicklistNode *prev;    struct quicklistNode *next;    unsigned char *zl;    unsigned int sz;             &#x2F;* ziplist size in bytes *&#x2F;    unsigned int count : 16;     &#x2F;* count of items in ziplist *&#x2F;    unsigned int encoding : 2;   &#x2F;* RAW&#x3D;&#x3D;1 or LZF&#x3D;&#x3D;2 *&#x2F;    unsigned int container : 2;  &#x2F;* NONE&#x3D;&#x3D;1 or ZIPLIST&#x3D;&#x3D;2 *&#x2F;    unsigned int recompress : 1; &#x2F;* was this node previous compressed? *&#x2F;    unsigned int attempted_compress : 1; &#x2F;* node can&#39;t compress; too small *&#x2F;    unsigned int extra : 10; &#x2F;* more bits to steal for future usage *&#x2F;&#125; quicklistNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解析quicklistNode:</p><ol><li>结构上于ziplist不相同,采用的是列表格式记录数据</li><li>单个node最大链表数量不操作32K</li><li>encoding:LZF进行压缩编码</li></ol><p>总结:<br>redis底层数据格式分为六种</p><ul><li><p>简单动态字符串<br>简单动态字符串(SDS),逻辑上是对*char指针的扩展,结构上根据不同的长度可以分为多种类型,使用惰性删除机制</p></li><li><p>跳跃列表<br>跳跃列表(skipList)结构上zskiplistNode/zskiplist,zset在满足任意条件(元素个数超过128/元素大小大于64字节/ziplist大小超过1G)后使用skip作为底层数据结构且不会回退</p></li><li><p>压缩列表<br>压缩列表(ziplist)结构上分为*ziplist/entry,需要注意的是ziplist是连续的内存节点组成,并且entry上还有上一节点的信息</p></li><li><p>字典<br>字典(dict)结构是通过hash结构来组成,特点是采用位运算与来取余数,并且采用两个hash来实现渐进式Rehash,是通过懒处理和线程空闲时处理的方式来完成</p></li><li><p>整数集合<br>整数集合结构是连续的内存,每次添加前都要先计算编码长度和插入位置以便进行扩容</p></li><li><p>quicklist<br>quicklist是一个双向链表结构,每个节点又是ziplist组成</p></li><li><p>stream<br>省略,详见src/stream.h文件</p></li></ul><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://redis.io/topics/internals-sds">Hacking Strings</a><br><a href="http://www.itabin.com/redis-zskiplist/">zskiplist</a><br><a href="https://www.geek-share.com/detail/2714589322.html">redisd源代码的大端与小端</a><br><a href="https://cache.one/read/2884987">redis压缩列表ziplist的连锁扩容</a><br><a href="https://redisbook.readthedocs.io/en/latest/compress-datastruct/intset.html">整数集合</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;redis底层数据结构分析&lt;/h1&gt;
&lt;p&gt;redis底层数据结构分析主要是根据《Redis5 设计与源码分析》一书的章节而来,参考对照代码版本为6.2,源代码的编译和部署可以查看上一篇文章&lt;/p&gt;
&lt;p&gt;redis底层数据结构可以划分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单动</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://agmtopy.gitee.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解linux内核笔记</title>
    <link href="https://agmtopy.gitee.io/2021/12/08/21.linux/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2021/12/08/21.linux/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-08T13:25:57.000Z</published>
    <updated>2021-12-15T12:47:43.279Z</updated>
    
    <content type="html"><![CDATA[<h1>深入理解linux内核笔记</h1><h2 id="内核"><a class="header-anchor" href="#内核"></a>内核</h2><p>unix内核根据执行状态分为’用户态’和’执行态’</p><ul><li>用户与内核态的切换</li></ul><ol><li>进程调用系统调用</li><li>触发异常(exception)</li><li>响应中断</li><li>内核线程的执行(这里有一些歧义,本身就是内核态)</li></ol><ul><li>进程描述符</li></ul><p>进程描述符是用来描述当前正在运行的进程的详细信息,包括以下几个部分<br>- 程序计数器和栈指针<br>- 通用寄存器<br>- 浮点寄存器<br>- 内存管理寄存器</p><ul><li>可重入内核</li></ul><p>unix是可重入内核,意味着同时有若干个进程在执行,在抢占式内核调度系统中进程会交替执行</p><ul><li><p>僵尸进程<br>僵尸进程的产生是由父进程通过’wait4()'的系统调用等待子进程的结束的状态,</p></li><li><p>进程组与会话<br>进程组是对一种&quot;作业&quot;的抽象<br>登录会话指的是</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入理解linux内核笔记&lt;/h1&gt;
&lt;h2 id=&quot;内核&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#内核&quot;&gt;&lt;/a&gt;内核&lt;/h2&gt;
&lt;p&gt;unix内核根据执行状态分为’用户态’和’执行态’&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户与内核态的切换&lt;/li&gt;
</summary>
      
    
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="https://agmtopy.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Kubernetes之编排能力</title>
    <link href="https://agmtopy.gitee.io/2021/11/28/18.%E5%AE%B9%E5%99%A8%E5%8C%96/3.%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes%E4%B9%8B%E7%BC%96%E6%8E%92%E8%83%BD%E5%8A%9B/"/>
    <id>https://agmtopy.gitee.io/2021/11/28/18.%E5%AE%B9%E5%99%A8%E5%8C%96/3.%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes%E4%B9%8B%E7%BC%96%E6%8E%92%E8%83%BD%E5%8A%9B/</id>
    <published>2021-11-28T15:41:26.000Z</published>
    <updated>2022-02-26T06:02:30.287Z</updated>
    
    <content type="html"><![CDATA[<h1>深入剖析Kubernetes之编排能力</h1><ul><li>名词解释</li></ul><blockquote><p>编排: 引申为描述复杂计算机系统、中间件 (middleware) 和业务的自动化的安排、协调和管理。</p></blockquote><h2 id="编排能力"><a class="header-anchor" href="#编排能力"></a>编排能力</h2><ul><li><p>为什么需要编排能力?<br>在应用大规模的拆分实施微服务化以后,需要解决微服务之间的服务依赖/注册发现/资源管理等问题.</p></li><li><p>编排能力需要那一层来实现?<br>之所以需要提出这个问题是因为,目前应用的按层划分,可以在每一层都实现相同的能力,但是为什么目前主流的解决编排问题是在基础设施层解决,主要是依据责任的划分,基础能力的下沉</p></li></ul><h2 id="编排对象"><a class="header-anchor" href="#编排对象"></a>编排对象</h2><ul><li><p>资源编排<br>资源编排指的是对具体容器的NameSpace\Cgroup\网络的管理,文件系统的管理等</p></li><li><p>工作负载编排<br>工作负载编排指的是对pod生命周期的管理</p></li><li><p>服务编排<br>服务编排是应用开发人员比较熟悉的一个领域,指的是对具体的服务的服务发现/高可用的管理</p></li></ul><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/36062500">编排的艺术| K8S 中的容器编排和应用编排</a><br><a href="https://zhuanlan.zhihu.com/p/144452103">云原生时代（五）：Kubernetes与容器编排之战</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入剖析Kubernetes之编排能力&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;名词解释&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;编排: 引申为描述复杂计算机系统、中间件 (middleware) 和业务的自动化的安排、协调和管理。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="容器化" scheme="https://agmtopy.gitee.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
    <category term="Kubernetes" scheme="https://agmtopy.gitee.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Kubernetes之Pods的概念</title>
    <link href="https://agmtopy.gitee.io/2021/11/28/18.%E5%AE%B9%E5%99%A8%E5%8C%96/2.%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes%E4%B9%8BPod%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://agmtopy.gitee.io/2021/11/28/18.%E5%AE%B9%E5%99%A8%E5%8C%96/2.%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes%E4%B9%8BPod%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2021-11-28T05:40:30.000Z</published>
    <updated>2021-11-28T15:40:46.956Z</updated>
    
    <content type="html"><![CDATA[<h1>深入剖析Kubernetes之Pods的概念</h1><p>在上一篇文章中了解到kubernetes的部署在逻辑上是按照<B>Pod</B>的概念进行的,下面来详细的了解一下pod的知识</p><h2 id="基础概念"><a class="header-anchor" href="#基础概念"></a>基础概念</h2><blockquote><p>Pods是您可以在 Kubernetes 中创建和管理的最小的可部署计算单元。Pods是一组由一个或一个以上的容器组成的共享存储和网络资源，以及如何运行容器的规范。Pod 的内容始终位于同一地点并共同调度，并在共享上下文中运行。Pod 为特定于应用程序的“逻辑主机”建模：它包含一个或多个相对紧密耦合的应用程序容器。在非云环境中，在同一物理或虚拟机上执行的应用程序类似于在同一逻辑主机上执行的云应用程序。</p></blockquote><p>Pods的官网定义,这个定义传达出三个规范:</p><ol><li>Pods是Kubernetes管理执行的最小单元</li><li>Pods是容器组成,并且容器内部可以共享网络和存储</li><li>Pods是一个逻辑概念,替kubernetes完成底层操作的还是容器三剑客’Namespace’、‘Cgroup’、‘rootFs’</li></ol><h2 id="Pods组成"><a class="header-anchor" href="#Pods组成"></a>Pods组成</h2><p>Pods的组成可以参考这张图:<br><img src="https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg" alt="Pods组成"></p><p>Pods除了本身的容器’ContainerA/ContainerB’以外还有一个<B>Infra container</B>容器，这个容器的镜像很小解压后也只有100kb~200kb大小。</p><ul><li><p>Init容器<br>init容器是在用户容器启动之前-网络和数据卷初始化完成后启动<br>用于代理用户容器的网络和IO,其实就是Sidecar模式</p></li><li><p>用户容器<br>用户容器是’Web Server’也就是在YML中定义的容器</p></li></ul><h2 id="Pods功能"><a class="header-anchor" href="#Pods功能"></a>Pods功能</h2><ul><li><p>volume</p><p>volume数据卷其中有一种特殊的volume-&gt;‘Projected Volume’(投射数据卷)主要是用来向容器内部提供预先定义好的数据，可以划分为</p><ol><li>Secret</li><li>ConfigMao</li><li>DownwardApi</li><li>ServiceAccountToken</li></ol><p>这几种类型，其中Secret指的是将配置添加到kubernetes中镜像管理的数据，在通过Pods的YMAL文件的定义可以将这部分配置信息直接写入容器中，并且可以随着Kubernetes中内容的变化而变化，类似与配置中心的使用</p></li><li><p>异常恢复策略</p><p>Pods的异常恢复策略可以分为:</p><ol><li>只要容器没有运行就进行自动重启</li><li>只有在容器异常时才进行chongq</li><li>永不自动重启容器</li></ol><p>检查容器是否运行的方法有:</p><ol><li>响应外部请求，例如http请求</li><li>外部检查预设的启动后的钩子方法，例如检查文件卷宗预设的文件是否存在等</li></ol><p>实现对容器进行定期诊断的功能叫’容器探针’，由容器内部进行实现。分为三种类型</p><ol><li>ExecAction</li><li>TCPSocketAction</li><li>HTTPGetAction</li></ol><p>容器探针又分为：</p><ol><li>存活探针<br>存活探针指的是要确认一个容器是否真正的死亡的场景，例如重启时检测之前的失败容器是否已经死亡</li><li>就绪探针<br>就绪探针指的是区分应用是否准备就绪的场景</li><li>启动探针<br>启动探针指的是对于大型容器的启动比较慢的场景需要区分容器是否还在启动</li></ol></li></ul><h2 id="Pods生命周期"><a class="header-anchor" href="#Pods生命周期"></a>Pods生命周期</h2><p>Pod的阶段分为</p><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>Pending（悬决）</td><td>Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间，</td></tr><tr><td>Running（运行中）</td><td>Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。</td></tr><tr><td>Succeeded（成功）</td><td>Pod 中的所有容器都已成功终止，并且不会再重启。</td></tr><tr><td>Failed（失败）</td><td>Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。</td></tr><tr><td>Unknown（未知）</td><td>因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。</td></tr></tbody></table><h2 id="Pod的上层抽象-Service"><a class="header-anchor" href="#Pod的上层抽象-Service"></a>Pod的上层抽象:Service</h2><p>这里先简单的介绍以下Service，kubernetes中Service是将一组Pod暴露给外界的一种方式。对外提供两种访问方式</p><ol><li><p>VIP<br>通过对外提供Service的虚拟IP,然后在将请求转发到具体的Pod上。</p></li><li><p>DNS<br>- Normal Service<br>与VIP方式类似<br>- Headles Service<br>对于请求直接返回具体Pod的IP。类似于DNS直接解析出真实Pod的IP</p></li></ol><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/">pod是什么?</a><br><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase">pod的生命周期</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入剖析Kubernetes之Pods的概念&lt;/h1&gt;
&lt;p&gt;在上一篇文章中了解到kubernetes的部署在逻辑上是按照&lt;B&gt;Pod&lt;/B&gt;的概念进行的,下面来详细的了解一下pod的知识&lt;/p&gt;
&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a class=&quot;header-anchor</summary>
      
    
    
    
    <category term="容器化" scheme="https://agmtopy.gitee.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
    <category term="Kubernetes" scheme="https://agmtopy.gitee.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>大规模分布式存储系统-基础篇</title>
    <link href="https://agmtopy.gitee.io/2021/11/09/19.%E5%88%86%E5%B8%83%E5%BC%8F/0.%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2021/11/09/19.%E5%88%86%E5%B8%83%E5%BC%8F/0.%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-11-09T01:45:45.000Z</published>
    <updated>2021-11-11T05:57:59.932Z</updated>
    
    <content type="html"><![CDATA[<h1>大规模分布式存储系统-基础篇</h1><p>主要是记录阅读《大规模分布式存储系统：原理解析与架构实战》基础篇中的一些知识和理解。</p><ul><li>书评</li></ul><p><a href="https://book.douban.com/subject/25723658/">大规模分布式存储系统</a></p><p>基础篇主要是从<B>单机存储系统</B>到<B>分布式存储系统</B>的演化过程以及各自的特点进行分析</p><h2 id="单机存储系统"><a class="header-anchor" href="#单机存储系统"></a>单机存储系统</h2><p>单机存储系统最早应该是来源自关系型数据库的理论，根据数据库操作在发展出事务的概念</p><h3 id="硬件基础"><a class="header-anchor" href="#硬件基础"></a>硬件基础</h3><p>介绍CPU、IO总线、网络拓扑等知识，其中南桥/北桥的作用比较有意思</p><ul><li>南桥负责与低速设备的交互</li><li>北桥负责与高速设备的交互</li></ul><p><img src="https://i.loli.net/2021/11/09/6OIbyw3zZGTFCkc.jpg" alt="南北桥结构"></p><h3 id="存储引擎"><a class="header-anchor" href="#存储引擎"></a>存储引擎</h3><p>存储引擎是根据文件系统对存储系统提供底层的CRUD能力的引擎,根据存储引擎底层使用的算法可以大致划分为’hash存储引擎’、‘B tree存储引擎’、'LSM存储引擎’这三类</p><ul><li><p>hash存储引擎<br>hash存储引擎底层采用hash算法确定key的位置，value则代表文件的物理位置。使用这种算法的可以参考RocketMQ中的indexFile和commitLog文件之间的关系.<br>hash存储引擎不支持顺序读写</p></li><li><p>B+ tree存储引擎<br>B+ tree存储引擎具体的实现可以参考MySQL中的innodb存储引擎的设计模型，会设计出一个缓存区来对热点数据的缓存。对于缓存数据的替换策略有<B>LRU</B>、<B>LIRS</B>，其中LIRS的设计比较有趣，LIRS是为了解决LRU策略无法处理因全表扫描导致污染缓冲区的场景，底层采用多级缓冲的策略，设置晋升阈值来避免一级缓存受到污染</p></li><li><p>LSM存储引擎<br>LSM存储引擎的全称是’Log-structured merge-tree’. 将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量顺序写入磁盘中。LSM适合于写多读少的场景，通过牺牲读取性能来换写入的性能</p></li></ul><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>关于更多的存储引擎可以参考<br><a href="https://dev.to/creativcoder/what-is-a-lsm-tree-3d75">What is a LSM Tree?</a><br><a href="ttps://bbs.huaweicloud.com/blogs/detail/197482">存储引擎对比</a><br><a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf">LSM Tree 论文</a></p><h2 id="数据模型"><a class="header-anchor" href="#数据模型"></a>数据模型</h2><p>数据模型指的是存储引擎用什么格式保存数据常用的数据模型有’文件’、‘关系’、‘键值对’</p><h2 id="事务"><a class="header-anchor" href="#事务"></a>事务</h2><ul><li>事务的特性:ACID</li><li>事务的种类:读事务、写事务、混合事务</li><li>事务的实现:锁、COW、MVCC</li></ul><h2 id="故障恢复"><a class="header-anchor" href="#故障恢复"></a>故障恢复</h2><p>数据库需要实现完善的故障恢复机制，一般是采用操作日志来实现的。<br>操作日志分为</p><ul><li>回滚日志(UNDO log) 用来记录事务修改前的记录</li><li>重做日志(REDO log) 用来记录事务修改后的状态</li><li>操作日志(binlog) 用来记录对物理磁盘的操作</li></ul><h2 id="数据压缩"><a class="header-anchor" href="#数据压缩"></a>数据压缩</h2><p>数据压缩是对大量数据进行压缩以节省空间。压缩算法的核心就是查找重复数据，'列式存储技术’是把相同列的数据组织在一起</p><h3 id="压缩算法"><a class="header-anchor" href="#压缩算法"></a>压缩算法</h3><ul><li>Huffman编码</li><li>LZ系列压缩算法</li></ul><h3 id="列式存储"><a class="header-anchor" href="#列式存储"></a>列式存储</h3><pre><code>列式存储是针对于传统的行式存储的对应，针对的是OLAP的场景。按照列来存储数据就会导致列上重复的值较多，因此就需要使用压缩算法来进行压缩</code></pre><h2 id="分布式存储系统特性"><a class="header-anchor" href="#分布式存储系统特性"></a>分布式存储系统特性</h2><p>分布式存储系统底层主要依赖两个协议<B>Paxos选举协议</B>、<B>两阶段提交协议</B></p><h3 id="异常"><a class="header-anchor" href="#异常"></a>异常</h3><ul><li>宕机</li><li>网络异常<br>消息丢失、消息乱序、网络数据包异常</li></ul><blockquote><p>设计分布式系统的一个原则是:网络永远是不可靠的</p></blockquote><ul><li>磁盘故障</li></ul><h3 id="状态"><a class="header-anchor" href="#状态"></a>状态</h3><p>分布式系统中定义的系统状态有且只有<B>成功</B>、<B>失败</B>、<B>未知</B></p><h3 id="一致性"><a class="header-anchor" href="#一致性"></a>一致性</h3><p>在分布式环境中由于异常是无法避免的，因此需要冗余多份数据来保证可用性。冗余的多份副本就会存在数据一致性的问题，如何保证副本之间的一致性是关键</p><h2 id="数据分布"><a class="header-anchor" href="#数据分布"></a>数据分布</h2><p>分布式系统与单机存储系统系统最大的区别在于<B>数据分布</B>上,分布式系统可以将数据按照<B>Hash分布</B>、<B>顺序分布</B>两种方式进行划分。</p><h3 id="Hash分布"><a class="header-anchor" href="#Hash分布"></a>Hash分布</h3><p>Hash分布原理比较简单，需要注意的是扩容场景下的处理，有两种处理方法分别是</p><ul><li>元数据区<br>引入元数据区，通过元数据区来管理hash的key与value之间的关系</li><li>一致性hash算法<br>使用一致性hash算法,保证节点的平均分布</li></ul><blockquote><p>一致性hash算法如何在扩容时保证数据的平均分布?</p></blockquote><p>Hash算法不支持顺序查找</p><h3 id="顺序分布"><a class="header-anchor" href="#顺序分布"></a>顺序分布</h3><p>顺序分布指的是数据按照指定的维度顺序的写入数据，多用于分布式表格系统中</p><h2 id="复制"><a class="header-anchor" href="#复制"></a>复制</h2><p>分布式系统中数据的复制机制决定了这个分布式系统对可用性和一致性的取舍。数据的复制可以分为<B>强同步复制</B>、<B>异步复制</B>两种方向。<br>在工程实践中又可以根据这两个方向做不同的取舍，以Oracle的DataGuard复制组件为例,提供了三种不同的模式</p><ul><li>最大保护模式<br>最大保护模式也就是强同步复制模式</li><li>最大性能模式<br>最大性能模式也就是异步复制模式</li><li>最大可用模式<br>最大可用模式是默认情况下使用强同步复制模式，网络异常时使用异步复制模式</li></ul><h2 id="故障检测"><a class="header-anchor" href="#故障检测"></a>故障检测</h2><p>故障检测常用的方法有心跳、φ-accrual(累计历史故障检测器)、 Gossip故障检测.这几种方式</p><p><a href="https://iswade.github.io/database/db_internals_ch09_failure_detection/#gossip">分布式系统之故障检测</a><br><a href="https://www.serf.io/docs/internals/gossip.html">serf官网</a><br><a href="https://flogx.com/post/using-serf-to-implement-distributed-fault-detection/">使用serf实现分布式故障检测</a></p><h2 id="故障恢复-v2"><a class="header-anchor" href="#故障恢复-v2"></a>故障恢复</h2><p>故障恢复是由于分布式环境下机器或网络的故障，需要通过故障恢复的机制将服务从不可用状态恢复成可用状态。分布式系统的存储方案分为两种结构:<B>单层结构</B>、<B>双层结构</B></p><ul><li>单层结构<br>单层结构指的是服务和存储都作为一个节点，然后按照节点进行分片</li><li>多层结构<br>多层结构指的是存储系统按照服务层和存储层进行分层,在服务层只提供一个一份数据</li></ul><h2 id="分布式协议"><a class="header-anchor" href="#分布式协议"></a>分布式协议</h2><p><B>分布式协议</B>根据不同的作用域可以划分为租约\复制协议\一致性协议等.比较重要的是<B>两阶段提交协议</B>、<B>Paxos选举协议</B></p><ul><li><p>两阶段提交协议<br>两阶段提交协议指的是将分布式事务的操作划分为两个阶段,分别是<B>请求阶段</B>、<B>提交阶段</B><br>两阶段提交协议中的包括的节点有两类，分别是<B>协调者</B>和<B>参与者</B></p><p><img src="https://i.loli.net/2021/11/11/qxE9X3mhKwDJfBg.jpg" alt="两阶段提交过程.jpg"></p></li><li><p>Paxos选举协议<br>Paxos选举协议主要是用于解决多个节点之间的一致性问题。可以参考之前的一篇文章<a href="https://agmtopy.github.io/2020/06/23/1.%E6%9D%82%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7paxos%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0zab%E5%8D%8F%E8%AE%AE/">分布式中的一致性paxos算法以及其实现zab协议</a><br>采用’Quorum机制’机制来保证节点作为一个整体对外的一致性,简单的来说就是通过序列号和大多数确认机制来保证集群的一致性</p></li><li><p>Paxos与2PC混合场景<br><img src="https://i.loli.net/2021/11/11/M12yJLwtjePQfnr.jpg" alt="2PC与Paoxs的对比.jpg"></p></li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>基础篇主要是介绍单机存储系统的<B>硬件基础</B>、<B>存储引擎</B>、分布式存储系统<B>数据模型</B>、<B>分布式特性</B>、<B>故障检测/恢复</B>、<B>分布式协议</B>等</p><ul><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;大规模分布式存储系统-基础篇&lt;/h1&gt;
&lt;p&gt;主要是记录阅读《大规模分布式存储系统：原理解析与架构实战》基础篇中的一些知识和理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;书评&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="读书笔记" scheme="https://agmtopy.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Kubernetes之Kubernetes的基础概念</title>
    <link href="https://agmtopy.gitee.io/2021/11/08/18.%E5%AE%B9%E5%99%A8%E5%8C%96/1.%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes%E4%B9%8BKubernetes%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://agmtopy.gitee.io/2021/11/08/18.%E5%AE%B9%E5%99%A8%E5%8C%96/1.%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes%E4%B9%8BKubernetes%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-11-08T08:31:00.000Z</published>
    <updated>2021-11-28T05:39:51.593Z</updated>
    
    <content type="html"><![CDATA[<h1>深入剖析Kubernetes之Kubernetes的基础</h1><blockquote><p>Kubernetes是由google和RetHot主导的容器编排工具，已经称为容器编排的标准.Kubernetes源自Google内部的Borg,可以参考这篇文章</p></blockquote><p><a href="https://kubernetes.io/zh/blog/2015/04/borg-predecessor-to-kubernetes/">Borg: Kubernetes 的前身</a></p><h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><p>Kubernetes是一个对容器进行管理的框架,提供了<B>服务发现和负载均衡</B>、<B>存储编排</B>、<B>自动部署和回滚</B>、<B>自动完成装箱计算</B>、<B>自我修复</B>、<B>密钥与配置管理</B>等功能，可以参考这篇文章</p><p><a href="https://kubernetes.io/zh/docs/concepts/overview/">Kubernetes 是什么</a></p><h2 id="组件"><a class="header-anchor" href="#组件"></a>组件</h2><p><img src="https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg" alt="kubernetes组件总览"></p><p>kubernetes的组件分为<B>控制平面组件</B>、<B>Node 组件</B>、<B>插件</B></p><h3 id="控制平面组件"><a class="header-anchor" href="#控制平面组件"></a>控制平面组件</h3><p>控制平面组件是对集群做出全局决策(比如调度)，以及检测和响应集群事件的决策和处理。</p><h3 id="Node-组件"><a class="header-anchor" href="#Node-组件"></a>Node 组件</h3><p>Node节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h3 id="插件（Addons）"><a class="header-anchor" href="#插件（Addons）"></a>插件（Addons）</h3><p>插件是是对Kubernetes资源（DaemonSet、 Deployment等）实现管理的功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于kube-system命名空间。</p><h2 id="部署"><a class="header-anchor" href="#部署"></a>部署</h2><p>Kubernetes的部署工具目前有<B>kubectl</B>、<B>kind</B>、<B>minikube</B>、<B>kubeadm</B></p><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/">kubernetes的部署工具文档</a></p><h2 id="实例"><a class="header-anchor" href="#实例"></a>实例</h2><p>如何创建一个简单的kubernetes的本地环境</p><h3 id="前置准备"><a class="header-anchor" href="#前置准备"></a>前置准备</h3><ul><li><p>工具</p><ol><li>minikube</li><li>kubectl</li></ol></li><li><p>步骤</p><ol><li>安装minikube</li></ol><ul><li>检查是否支持虚拟化</li></ul><blockquote><p>grep -E --color ‘vmx|svm’ /proc/cpuinfo</p></blockquote><ul><li>安装配置 kubectl</li></ul>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y apt-transport-https<span class="token function">curl</span> -s https://packages.cloud.google.com/apt/doc/apt-key.gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -<span class="token builtin class-name">echo</span> <span class="token string">"deb https://apt.kubernetes.io/ kubernetes-xenial main"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> -a /etc/apt/sources.list.d/kubernetes.list<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>安装minikube</li></ul>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64<span class="token function">sudo</span> <span class="token function">install</span> minikube-linux-amd64 /usr/local/bin/minikube<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>启动</li></ol><ul><li>查看所有namespace下的pod</li></ul><blockquote><p>kubectl get po -A</p></blockquote><ul><li>安装仪表盘</li></ul><blockquote><p>minikube dashboard</p></blockquote><p>启动控制台后可以看到<br><img src="https://i.loli.net/2021/11/27/iYAxaecJMdFurZQ.jpg" alt="kubernetes控制台"></p></li></ul><h3 id="配置文件"><a class="header-anchor" href="#配置文件"></a>配置文件</h3><p>kubernetes不推荐使用命令行来操作容器，而是推荐使用YAML文件来进行配置</p><p>下面是一个典型的zk集群的配置文件</p><ul><li>application/zookeeper/zookeeper.yaml</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zk<span class="token punctuation">-</span>hs  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> zk<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">2888</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> server  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3888</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>election  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> zk<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zk<span class="token punctuation">-</span>cs  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> zk<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">2181</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> client  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> zk<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> policy/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PodDisruptionBudget<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zk<span class="token punctuation">-</span>pdb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> zk  <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zk<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> zk  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> zk<span class="token punctuation">-</span>hs  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">updateStrategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate  <span class="token key atrule">podManagementPolicy</span><span class="token punctuation">:</span> OrderedReady  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> zk    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">affinity</span><span class="token punctuation">:</span>        <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span>          <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>                <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>                  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"app"</span>                    <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                    <span class="token key atrule">values</span><span class="token punctuation">:</span>                    <span class="token punctuation">-</span> zk              <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> <span class="token string">"kubernetes.io/hostname"</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> kubernetes<span class="token punctuation">-</span>zookeeper        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always        <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"k8s.gcr.io/kubernetes-zookeeper:1.0-3.4.10"</span>        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"1Gi"</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"0.5"</span>        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">2181</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> client        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">2888</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> server        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">3888</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> leader<span class="token punctuation">-</span>election        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> sh        <span class="token punctuation">-</span> <span class="token punctuation">-</span>c        <span class="token punctuation">-</span> "start<span class="token punctuation">-</span>zookeeper \          <span class="token punctuation">-</span><span class="token punctuation">-</span>servers=3 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>data_dir=/var/lib/zookeeper/data \          <span class="token punctuation">-</span><span class="token punctuation">-</span>data_log_dir=/var/lib/zookeeper/data/log \          <span class="token punctuation">-</span><span class="token punctuation">-</span>conf_dir=/opt/zookeeper/conf \          <span class="token punctuation">-</span><span class="token punctuation">-</span>client_port=2181 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>election_port=3888 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>server_port=2888 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>tick_time=2000 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>init_limit=10 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>sync_limit=5 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>heap=512M \          <span class="token punctuation">-</span><span class="token punctuation">-</span>max_client_cnxns=60 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>snap_retain_count=3 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>purge_interval=12 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>max_session_timeout=40000 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>min_session_timeout=4000 \          <span class="token punctuation">-</span><span class="token punctuation">-</span>log_level=INFO"        <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">exec</span><span class="token punctuation">:</span>            <span class="token key atrule">command</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> sh            <span class="token punctuation">-</span> <span class="token punctuation">-</span>c            <span class="token punctuation">-</span> <span class="token string">"zookeeper-ready 2181"</span>          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>          <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>          <span class="token key atrule">exec</span><span class="token punctuation">:</span>            <span class="token key atrule">command</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> sh            <span class="token punctuation">-</span> <span class="token punctuation">-</span>c            <span class="token punctuation">-</span> <span class="token string">"zookeeper-ready 2181"</span>          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>          <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> datadir          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /var/lib/zookeeper      <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>        <span class="token key atrule">runAsUser</span><span class="token punctuation">:</span> <span class="token number">1000</span>        <span class="token key atrule">fsGroup</span><span class="token punctuation">:</span> <span class="token number">1000</span>  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> datadir    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span>          <span class="token key atrule">storage</span><span class="token punctuation">:</span> 10Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文件以’—'作为容器配置分割符，分别创建了4个容器从而创建一个完整的ZK集群</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">service/zk-hs createdservice/zk-cs createdpoddisruptionbudget.policy/zk-pdb createdstatefulset.apps/zk created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><ol><li>kubernetes内部是由四个组件组成</li></ol><ul><li>控制平面组件</li><li>Node节点组件</li><li>插件</li></ul><ol start="2"><li>部署工具</li></ol><ul><li>minikube</li><li>kind</li><li>kubeadm</li></ul><ol start="3"><li>配置文件<br>配置文件将容器中按照集群部署的方式根据应用维度打包形成一个配置文件,后续就可以读取这个配置文件进行启动。这里应用的概念在kubernetes中被称为pod,一个pod是由一个或多个容器组成的。</li></ol><h2 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h2><p><a href="https://kubernetes.io/zh">kubernetes中文官网</a><br><a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/">kubernetes交互文档</a><br><a href="https://minikube.sigs.k8s.io/docs/handbook/">minikube官网</a><br><a href="https://kubernetes.io/zh/docs/tutorials/stateful-application/zookeeper/">部署运行ZooKeeper集群</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入剖析Kubernetes之Kubernetes的基础&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Kubernetes是由google和RetHot主导的容器编排工具，已经称为容器编排的标准.Kubernetes源自Google内部的Borg,可以参考这篇文章&lt;/p&gt;
</summary>
      
    
    
    
    <category term="容器化" scheme="https://agmtopy.gitee.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
    <category term="Kubernetes" scheme="https://agmtopy.gitee.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>ReadWriteLock的源码分析</title>
    <link href="https://agmtopy.gitee.io/2021/11/02/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/16.ReadWriteLock%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2021/11/02/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/16.ReadWriteLock%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-11-02T08:24:34.000Z</published>
    <updated>2022-03-30T13:54:15.615Z</updated>
    
    <content type="html"><![CDATA[<h1>ReadWriteLock的源码分析</h1><p>ReadWriteLock是JUC包下的定义的读写锁的接口,定义两个接口<B>readLock()</B>、<B>writeLock()</B>分别是返回读锁和返回一个写锁。<br>ReadWriteLock默认有两个实现分别是<B>ReadWriteLockView</B>、<B>ReentrantReadWriteLock</B>。</p><p>ReentrantReadWriteLock是默认的读写锁的实现<br>ReadWriteLockView是<B>StampedLock</B>的内部类，StampedLock是JDK 1.8中对ReentrantReadWriteLock的一个增强的实现<br>下面会先分析ReentrantReadWriteLock，在对StampedLock进行分析</p><h2 id="ReentrantReadWriteLock"><a class="header-anchor" href="#ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><blockquote><p>ReentrantReadWriteLock是实现ReadWriteLock接口,对外提供read()和wirte()方法。特点主要是支持公平锁选择、可重入、锁降级的分类</p></blockquote><h3 id="用例"><a class="header-anchor" href="#用例"></a>用例</h3><p>这个用例是对ReentrantReadWriteLock提供的用例CachedData的简化版本</p><ul><li>CachedData</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> CachedData <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">lateinit</span> <span class="token keyword">var</span> <span class="token keyword">data</span><span class="token operator">:</span> String    <span class="token keyword">private</span> <span class="token keyword">var</span> cacheValid<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> lock<span class="token operator">:</span> ReentrantReadWriteLock <span class="token operator">=</span> <span class="token function">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">processCacheData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取读锁</span>        lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//获取写锁之前先要释放读锁</span>            lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">//获取写锁</span>            lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//再次检查标记,因为上一次检查标记是在获取写锁之前</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>                    <span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" set data"</span><span class="token punctuation">)</span>                    <span class="token keyword">data</span> <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    cacheValid <span class="token operator">=</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">//重新获取读锁来完成锁降级</span>                lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"打印data:"</span> <span class="token operator">+</span>  <span class="token keyword">data</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>main</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//创建线程池</span>    <span class="token keyword">val</span> poolExecutor <span class="token operator">=</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token function">SynchronousQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">//创建任务</span>    <span class="token keyword">var</span> cache<span class="token operator">:</span>CachedData <span class="token operator">=</span> <span class="token function">CachedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> barrier<span class="token operator">:</span>CyclicBarrier <span class="token operator">=</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">&#123;</span>        poolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">&#123;</span>            barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            cache<span class="token punctuation">.</span><span class="token function">processCacheData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>执行结果</li></ul><p><img src="https://i.loli.net/2021/11/12/wNerlsGfKLpEhzd.jpg" alt="执行结果"><br>可以看到两个线程对data的写锁进行竞争,但是只有一个线程成功执行set方法,另外的一个线程只能执行读锁的操作<br>从现象上来看一个<B>ReentrantReadWriteLock</B>对外提供了读锁和写锁两个功能,下面就开始对代码进行详细的分析</p><h3 id="构造函数"><a class="header-anchor" href="#构造函数"></a>构造函数</h3>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Creates a new &#123;@code ReentrantReadWriteLock&#125; with * default (nonfair) ordering properties. */</span><span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * Creates a new &#123;@code ReentrantReadWriteLock&#125; with * the given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */</span><span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    readerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReadLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    writerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WriteLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到无参的构造函数是非公平锁的策略,在构造方法中主要是创建了三个成员变量</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">&#123;</span>    <span class="token comment">//公平锁类型</span>    <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>    <span class="token comment">//内部读锁</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>ReadLock</span> readerLock<span class="token punctuation">;</span>    <span class="token comment">//内部写锁</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>WriteLock</span> writerLock<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源码解析"><a class="header-anchor" href="#源码解析"></a>源码解析</h3><h4 id="构造方法"><a class="header-anchor" href="#构造方法"></a>构造方法</h4><ul><li>获取锁的方法<br>获取读锁/写锁就是直接返回内部的读锁/写锁变量</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>WriteLock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> writerLock<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>ReadLock</span>  <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> readerLock<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到锁的类型分别是ReadLock和WriteLock,继续分析ReadLock/WriteLock</p><ul><li><p>ReadLock与WriteLock对比</p></li><li><p>ReadLock</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReadLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5992448646407690164L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">ReadLock</span><span class="token punctuation">(</span><span class="token class-name">ReentrantReadWriteLock</span> lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync <span class="token operator">=</span> lock<span class="token punctuation">.</span>sync<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryReadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>            <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireSharedNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> sync<span class="token punctuation">.</span><span class="token function">getReadLockCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>            <span class="token string">"[Read locks = "</span> <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>WriteLock</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WriteLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4992448646407690164L</span><span class="token punctuation">;</span>    <span class="token comment">//ReentrantReadWriteLock内部的AQS公平/非公平抽象类</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">WriteLock</span><span class="token punctuation">(</span><span class="token class-name">ReentrantReadWriteLock</span> lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync <span class="token operator">=</span> lock<span class="token punctuation">.</span>sync<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>            <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> o <span class="token operator">=</span> sync<span class="token punctuation">.</span><span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span>                                    <span class="token string">"[Unlocked]"</span> <span class="token operator">:</span>                                    <span class="token string">"[Locked by thread "</span> <span class="token operator">+</span> o<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//查询当前线程是否持有写锁</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//当前写锁的锁定次数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getWriteHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对比可知<B>WriteLock</B>只是比<B>ReadLock</B>多两个方法</p><ul><li>isHeldByCurrentThread()<br>查询当前线程是否持有写锁</li><li>getHoldCount()<br>当前写锁的锁定次数</li></ul><p>同时可以看到不管是<B>WriteLock</B>、<B>ReadLock</B>都是使用<B>Sync</B>来实现的功能，下面详细的分析一下<B>Sync</B>类的实现</p><ul><li><B>Sync</B></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">ThreadLocalHoldCounter</span> readHolds<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>    <span class="token comment">//构造函数</span>    <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//创建ThreadLocalHoldCounter(记录线程持有的锁数量)</span>        readHolds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalHoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置状态，调用AQS的setState()</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ensures visibility of readHolds</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码可以看出<B>Sync</B>是继承自<B>AbstractQueuedSynchronizer</B>，在构造方法中创建<B>ThreadLocalHoldCounter</B>和调用AQS的<B>setState()</B>方法</p><p>有关<B>AbstractQueuedSynchronizer</B>的内容可以参考之前写的<br><a href="../../../../../2020/05/22/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/13.AbstractQueuedSynchronizer%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">AbstractQueuedSynchronizer的源码分析</a></p><ul><li><p>ThreadLocalHoldCounter<br>ThreadLocalHoldCounter的代码如下所示</p></li><li><p>ThreadLocalHoldCounter</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalHoldCounter</span>    <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HoldCounter</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">HoldCounter</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>HoldCounter</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HoldCounter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//初始为0</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">//使用id来标识Thread而不是引用,避免引用逃逸</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> tid <span class="token operator">=</span> <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocalHoldCounter继承于ThreadLocal然后在初始化时用initialValue()方法返回一个<B>HoldCounter</B>引用<br>HoldCounter是用来记录线程中加锁的统计与线程id相关联,这里关联线程引用是比较优秀的,通过<B>LockSupport.getThreadId</B>获取一个long类型的线程标识</p><ul><li>LockSupport.getThreadId</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//U是Unsafe类型的对象</span>    <span class="token keyword">return</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> TID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><B>Sync</B>除了通过构造函数初始化上述的ThreadLocalHoldCounter对象以外,还有一些静态成员变量来完成一些例如控制允许线程重复持有锁的次数等</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHARED_SHIFT   <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHARED_UNIT    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_COUNT      <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCLUSIVE_MASK <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//省略...</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">></span> MAX_COUNT<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Reentrant acquire</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是对同一个线程持有的锁超过阈值的演示</p><p><img src="https://i.loli.net/2021/11/13/uon9IW6fcLxPRv5.jpg" alt="超过锁阈值场景"></p><h4 id="readLock"><a class="header-anchor" href="#readLock"></a>readLock()</h4><ul><li>lock</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span><span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>直接使用<B>AbstractQueuedSynchronizer</B>的<B>acquireShared()</B>获取一把共享锁,失败就阻塞</p><ul><li>AbstractQueuedSynchronizer.acquireShared</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//调用子类的tryAcquireShared()实现</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> arg<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ReentrantReadWriteLock.tryAcquireShared()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ReservedStackAccess</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*    * 例子:    * 1. 如果写锁被其他线程持有就返回失败    * 2. 因此该线程获取到写入资格,根据线程队列判断是否要进行阻塞,不需要进行阻塞时就通过CAS的方式来操作锁以及计数    * 3. 对cas失败的场景进行重试    */</span>    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取同步状态</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如果有独占线程并且独占线程不是当前线程时直接返回-1(失败)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//共享计数</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//1. 通过readerShouldBlock()判断当前是否可以操作,readerShouldBlock()主要是对公平锁和非公平锁的一个判断</span>    <span class="token comment">//2. 判断当前是否操作了最大的加锁量</span>    <span class="token comment">//3. 通过CAS进行操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> MAX_COUNT <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> SHARED_UNIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//如果是首次加锁,设置首次加锁线程和次数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>            firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//如果是首次加锁线程进行继续加锁那么次数++</span>            firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//处理holdCounter对象</span>            <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>                cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>            rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//重复处理</span>    <span class="token keyword">return</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>tryAcquireShared</B>是会执行锁的计数、初始线程的绑定等工作，并且会对执行失败进行自旋重试</p><ul><li>unlock</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<B>releaseShared</B>来完成释放锁的操作,AQS又是通过<B>tryReleaseShared</B>来完成的，下面可以看一下tryReleaseShared的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//尝试释放锁</span><span class="token annotation punctuation">@ReservedStackAccess</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如果是首次加锁线程对首次的标记进行修改</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// assert firstReaderHoldCount > 0;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReaderHoldCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            firstReaderHoldCount<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//对HoldCounter进行修改</span>        <span class="token comment">//如果不是临时holdCounter,那么获取holdCounter后在进行处理</span>        <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>            rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token function">unmatchedUnlockException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">--</span>rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//自旋</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">-</span> SHARED_UNIT<span class="token punctuation">;</span>        <span class="token comment">//CAS的方式对锁进行释放</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="writeLock"><a class="header-anchor" href="#writeLock"></a>writeLock()</h4><ul><li>lock</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>直接使用<B>AbstractQueuedSynchronizer</B>的<B>acquire()</B>获取一把独占锁,失败就阻塞</p><ul><li>unlock</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<B>release</B>来完成释放锁的操作</p><p>通过上面的代码可以看到所有的操作都是通过<B>Sync</B>这个类委托给<B>AbstractQueuedSynchronizer</B>来进行的,主要是三个功能</p><ul><li>加锁(共享/独占)</li><li>解锁(共享/独占)</li><li>计数(共享/独占)<br>然后AQS作为入口也会通过调用<B>ReentrantReadWriteLock</B>的具体的加锁/解锁/计数的进行操作。<br>读锁不进行排队，写锁会进行排队阻塞<br><B>ReentrantReadWriteLock</B>中有趣的操作是把state的高16位作为读锁标识，低16位作为写锁标识，因此也是只能加锁2^16的原因</li></ul><h2 id="StampedLock"><a class="header-anchor" href="#StampedLock"></a>StampedLock</h2><p><B>StampedLock</B>是对ReentrantReadWriteLock的迭代，在对StampedLock中优化了写锁饥饿的问题</p><h3 id="用例-v2"><a class="header-anchor" href="#用例-v2"></a>用例</h3><ul><li>StampedLockDemo</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> StampedLockDemo <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> stampedLock <span class="token operator">=</span> <span class="token function">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">fun</span> <span class="token function">writeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> stamp <span class="token operator">=</span> stampedLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">data</span> <span class="token operator">+=</span> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token number">1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            stampedLock<span class="token punctuation">.</span><span class="token function">unlockWrite</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fun</span> <span class="token function">readData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">&#123;</span>        <span class="token comment">//1.使用乐观锁</span>        <span class="token keyword">var</span> stamp <span class="token operator">=</span> stampedLock<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">var</span> curData <span class="token operator">=</span> <span class="token keyword">data</span>        <span class="token comment">//2. 写法1 双重锁保证读取到的是最新数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stampedLock<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                stamp <span class="token operator">=</span> stampedLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                curData <span class="token operator">=</span> <span class="token keyword">data</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                stampedLock<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//3. 写法2 循环</span><span class="token comment">//        while(!stampedLock.validate(stamp)) &#123;</span><span class="token comment">//            stamp = stampedLock.tryOptimisticRead();</span><span class="token comment">//            curData = this.data;</span><span class="token comment">//        &#125;</span>        <span class="token keyword">return</span> curData    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>StampedLock</B>在加锁时会返回一个戳(stamp),可以把它理解为版本号/时间戳，在后续解锁时会用到.</p><ul><li><p>提供了乐观锁和悲观锁的实现</p><ul><li>tryOptimisticRead()</li><li>tryReadLock()</li></ul></li><li><p>锁降/升级</p><ul><li>tryConvertToWriteLock()</li><li>tryConvertToReadLock()</li></ul></li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>ReadWriteLock是读写锁的接口，默认有两个实现分别是<B>ReentrantReadWriteLock</B>、<B>StampedLock</B>,分别是针对读多写少的场景和需要使用乐观锁的场景。<br>底层都采用一个标志位来进行区分读锁/写锁标识,一个是Int(32位),一个是Long(64位)，并且都继承与<B>AbstractQueuedSynchronizer</B>来进行实现的。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/zxporz/p/11642176.html">StampedLock的理解和使用</a><br><a href="https://zxs.io/article/1667">StampedLock源码分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;ReadWriteLock的源码分析&lt;/h1&gt;
&lt;p&gt;ReadWriteLock是JUC包下的定义的读写锁的接口,定义两个接口&lt;B&gt;readLock()&lt;/B&gt;、&lt;B&gt;writeLock()&lt;/B&gt;分别是返回读锁和返回一个写锁。&lt;br&gt;
ReadWriteLock默认有两</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="ReadWriteLock" scheme="https://agmtopy.gitee.io/tags/ReadWriteLock/"/>
    
  </entry>
  
</feed>
