<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2022-11-18T12:42:53.160Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程是否会影响执行效率</title>
    <link href="https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/"/>
    <id>https://agmtopy.gitee.io/2022/11/15/1.%E6%9D%82%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/</id>
    <published>2022-11-15T14:50:30.000Z</published>
    <updated>2022-11-18T12:42:53.160Z</updated>
    
    <content type="html"><![CDATA[<h1>多线程是否会影响执行效率</h1><h2 id="前提"><a class="header-anchor" href="#前提"></a>前提</h2><p>今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的</p><blockquote><p>在同一机器/操作系统上,使用n个线程处理X个任务是不是和使用n*m个线程处理X个任务效率相同?</p></blockquote><p>这样的观点是基于<B>RR-时间片轮转</B>来进行推导的;我不太认同这种观点,直觉上认为参与处理的任务过多或过少都会影响执行效率;下面先进行这两种观点的推导然后在进行实际的验证</p><h2 id="时间片轮转"><a class="header-anchor" href="#时间片轮转"></a>时间片轮转</h2><p>假设前提:</p><ol><li>操作系统对进程的调度是采用的<B>时间片轮转</B>算法来进行处理的,时间片划分的大小为1s;</li><li>每个Task需要消耗单核CPU执行0.5s</li><li>不考虑线程上下文切换耗时</li></ol><p>根据以上的前提可以得出下面这个运行图例:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%201%20%E9%A1%B5.drawio.png?raw=true" alt="2Thread执行示例"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%871-%E7%AC%AC%202%20%E9%A1%B5.drawio.png?raw=true" alt="4Thread执行示例"></p><p>从上图中可以看到无论是2Thread来进行执行还是4Thread来进行执行对于任务的执行耗时其实都是没有任何影响的,因为这其实是1000个Task与2个执行core之间的关系;</p><p>这种说法正确的前提必须是满足<B>假设前提</B>中的3点</p><h2 id="线程过多过少都会影响执行效率"><a class="header-anchor" href="#线程过多过少都会影响执行效率"></a>线程过多过少都会影响执行效率</h2><p>这种观点主要是基于《Java并发编程实战》一书中的观点:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F.jpg?raw=true" alt="推算线程池大小"></p><p>N<sub>cpu</sub> ：指的是执行机器上的物理核心数,额外注意使用容器启动的核心数<br>U<sub>cpu</sub> ：指的期望的对CPU的使用率<br>W/C ：指的是等待时间与计算时间的比例,对于计算密集型与IO密集型这个值还有所区别</p><p>例子:</p><p>N<sub>Thread</sub> = 2 * 0.8 * (1 + 10/2) = 8</p><p>如果需要N<sub>Thread</sub>持续增长时需要<B>W/C</B>比例更大,这是不可能实现的,由于w/c是由于Task决定的;<br>以上是通过反证法的方式来解释提高N<sub>Thread</sub> 并不能增加并发执行效率的原因;</p><p>实际在运用过程中还需要注意<B>Amdahl定律</B>和线程引入造成的性能开销</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/amdahl%E5%AE%9A%E5%BE%8B.jpg?raw=true" alt="Amdahl定律"></p><p>Amdahl定律就是表达并发执行线程池数并不能提高效率,而是并发度提高才能提高执行效率</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%BC%95%E5%85%A5%E7%9A%84%E5%BC%80%E9%94%80.jpg?raw=true" alt="线程引入造成的性能开销"></p><p>频繁的线程切换会引起性能损耗</p><h2 id="实例分析"><a class="header-anchor" href="#实例分析"></a>实例分析</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecutorServiceUtil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> taskNum <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">LinkedBlockingQueue</span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span>taskNum <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>            QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">8192</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]正在执行... %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> st <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">extracted</span><span class="token punctuation">(</span>latch<span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> et <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"线程数量为[%s]执行耗时[%s]ms %n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> et <span class="token operator">-</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>            QUEUE<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">extracted</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> taskNum<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>latch<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> taskId<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">;</span>        <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> latch<span class="token punctuation">,</span> <span class="token keyword">int</span> taskId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>latch <span class="token operator">=</span> latch<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>taskId <span class="token operator">=</span> taskId<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> min<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">isPrime2</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPrime2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> sqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqrt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/jvmsource/blob/master/src/main/java/com/agmtopy/source/executer/ExecutorServiceUtil.java">ExecutorServiceUtil.java</a></p><p>这是一个循环求解0~10W之间的素数的程序,下面是分别在Windows/Linux上执行的结果</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux.jpg?raw=true" alt="Linux下的执行结果"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows.jpg?raw=true" alt="Windows下的执行结果"></p><p>操作系统的线程调度策略还是会影响性能的.Linux的线程调度要稍微比Windows的优秀一点点,下面使用<B>vmstat</B>和<B>pidstat</B>分析</p><ul><li>vmstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vmstat</span> -w <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vmstat.jpg?raw=true" alt="vmstat执行结果"></p><ul><li>pidstat</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pidstat -p /PID -wtu  <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pidstat.jpg?raw=true" alt="pidstat执行结果"></p><p>主要关心<B>cswch/s</B>和<B>nvcswch/s</B>、<B>in</B>和<B>cs</B>&gt;指标，表示的是<B>线程上下文切换</B>的一个频率,在线程不断的增加以后可以看到这几个指标在快速的向上增长<br>不管是从windows还是linux的一个执行结果来看，线程的增加都会导致程序的下降,但是这种下降并不是很明显，也许是得益于现代操作系统的线程切换的一个优化吧</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>一个线程池中核心线程数与最大线程数的数量是会受到多个方面因素共同影响的，例如<B>操作系统</B>、<B>物理核心逻辑线程</B> 以及任务类型(计算密集型/IO密集型)都有关系,因此在使用线程池时对于线程池的<B>6个</B>参数一定要有思考以后在进行创建相应的线程池;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/13834692/threads-configuration-based-on-no-of-cpu-cores/13958877#13958877">Threads configuration based on no. of CPU-cores</a><br><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a><br><a href="https://research.cs.wisc.edu/multifacet/amdahl/">Amdahl’s Law in the Multicore Era</a><br><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html">Linux vmstat命令实战详解</a><br><a href="https://timzhouyes.github.io/2020/04/29/Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/">Java常见的性能问题和排查</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;多线程是否会影响执行效率&lt;/h1&gt;
&lt;h2 id=&quot;前提&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;
&lt;p&gt;今天一位同事问了一个问题感觉比较有趣,问题简化规范后是这样的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在同一机</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="多线程" scheme="https://agmtopy.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(三)</title>
    <link href="https://agmtopy.gitee.io/2022/11/14/20.%E7%AC%94%E8%AE%B0/22.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%89)/"/>
    <id>https://agmtopy.gitee.io/2022/11/14/20.%E7%AC%94%E8%AE%B0/22.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%89)/</id>
    <published>2022-11-14T15:50:10.000Z</published>
    <updated>2022-11-14T16:17:50.611Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(三)</h1><h2 id="Redis数据结构"><a class="header-anchor" href="#Redis数据结构"></a>Redis数据结构</h2><p>Redis的数据结构可以划分为下图所示:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.drawio.png?raw=true" alt="Redis的数据结构"></p><p>可以看到Redis底层采用的也是Map的方式来保存key以及value;</p><p>Redis主要的数据类型分为<B>String</B>、<B>list</B>、<B>set</B>、<B>map</B>、<B>sorted-set</B>等</p><p>下面会依次介绍这几种类型对象的底层实现原理</p><h2 id="String类型"><a class="header-anchor" href="#String类型"></a>String类型</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(三)&lt;/h1&gt;
&lt;h2 id=&quot;Redis数据结构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Redis数据结构&quot;&gt;&lt;/a&gt;Redis数据结构&lt;/h2&gt;
&lt;p&gt;Redis的数据结构可以划分为下图所示:&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TiDB数据库之简介</title>
    <link href="https://agmtopy.gitee.io/2022/11/05/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/41.TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <id>https://agmtopy.gitee.io/2022/11/05/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/41.TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%AE%80%E4%BB%8B/</id>
    <published>2022-11-05T07:30:55.000Z</published>
    <updated>2022-11-06T15:36:16.589Z</updated>
    
    <content type="html"><![CDATA[<h1>TiDB数据库之简介</h1><blockquote><p>TiDB 是 PingCAP 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processing, HTAP) 的融合型分布式数据库产品，具备水平扩容或者缩容、金融级高可用、实时 HTAP、云原生的分布式数据库、兼容 MySQL 5.7 协议和 MySQL 生态等重要特性。目标是为用户提供一站式 OLTP (Online Transactional Processing)、OLAP (Online Analytical Processing)、HTAP 解决方案。</p></blockquote><p>简单的说就是一款分布式数据库.</p><h2 id="五大特性"><a class="header-anchor" href="#五大特性"></a>五大特性</h2><ol><li><p>支持水平扩容或缩容<br>这一点在传统的RDBMS上不容易实现,传统的RDBMS通常是数据存储和计算没有进行分离的;</p></li><li><p>金融级高可用<br>采用<B> Multi-Raft 协议</B>来进行保证的</p></li><li><p>实时 HTAP<br>同时支持OLAP和OLTP处理</p></li><li><p>云原生的分布式数据库</p></li><li><p>兼容MySQL 5.7协议<br>支持MySQL协议这是一大优点</p></li></ol><h2 id="四大核心应用场景"><a class="header-anchor" href="#四大核心应用场景"></a>四大核心应用场景</h2><ol><li>对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高的金融行业属性的场景</li></ol><p>也就是适合需要高性能/高可用/高扩展性的场景</p><ol start="2"><li>对存储容量、可扩展性、并发要求较高的海量数据及高并发的 OLTP 场景</li></ol><blockquote><p>随着业务的高速发展，数据呈现爆炸性的增长，传统的单机数据库无法满足因数据爆炸性的增长对数据库的容量要求，可行方案是采用分库分表的中间件产品或者 NewSQL 数据库替代、采用高端的存储设备等，其中性价比最大的是 NewSQL 数据库，例如：TiDB。TiDB 采用计算、存储分离的架构，可对计算、存储分别进行扩容和缩容，计算最大支持 512 节点，每个节点最大支持 1000 并发，集群容量最大支持 PB 级别。</p></blockquote><ol start="3"><li><p>HTAP场景<br>一套数据库支持全部场景</p></li><li><p>OLAP场景<br>TiDB在实现上比ETL + Hadddoop简单和高效低本,并且可以直接用SQL实现分析统计功能</p></li></ol><h2 id="快速上手"><a class="header-anchor" href="#快速上手"></a>快速上手</h2><p>本次快速上手实验的环境主要是: WSL2+Ubunta</p><ol><li>下载安装脚本</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> --proto <span class="token string">'=https'</span> --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span class="token comment"># 下载完成后会展示安装脚本路径  'Shell profile:'后面的就是 $&#123;your_shell_profile&#125; 替换量</span><span class="token builtin class-name">source</span> <span class="token variable">$&#123;your_shell_profile&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_1.jpg?raw=true" alt="下载安装脚本"></p><ol start="2"><li>启动集群</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 默认TiDB、TiKV、PD 和 TiFlash 实例各一个</span>tiup playground<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_%E5%90%AF%E5%8A%A8.jpg?raw=true" alt="启动"></p><ol start="3"><li>TiDB的相关操作</li></ol><ul><li>连接TiDB</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用TiDB clinet</span>tiup client<span class="token comment"># 使用MySQL 协议</span>mysql --host <span class="token number">127.0</span>.0.1 --port <span class="token number">4000</span> -u root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_tidb%E5%8D%8F%E8%AE%AE%E7%99%BB%E9%99%86.jpg?raw=true" alt="TiDB clinet"></p><p>在使用MySQL客户端连接的时候,因为TiDB默认没有为root用户分配密码的,可以通过TiDB clint 登陆后使用<B>set password for root=‘123456’;</B>来修改密码</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_4_%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81.jpg?raw=true" alt="修改root 密码"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_5_%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.jpg?raw=true" alt="MySQL 协议连接成功"></p><ul><li>退出/清理</li></ul><ol><li><p>按下 Control+C 键停掉上述启用的 TiDB 服务。</p></li><li><p>等待服务退出操作完成后，执行以下命令：</p></li></ol><blockquote><p>tiup clean --all</p></blockquote><ul><li>管控平台/性能分析后台</li></ul><ol><li>dashboard</li></ol><p>可以看到TiDB的后台管理页面比较现代,支持各种功能包括<B>集群信息</B>、<B>慢SQL分析</B>、<B>日志查询</B>、<B>性能诊断</B>等</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_6_dashboard.jpg?raw=true" alt="dashboard"></p><h2 id="HTAP功能对比"><a class="header-anchor" href="#HTAP功能对比"></a>HTAP功能对比</h2><p>HTAOP功能就是在线分析功能,在传统的数据库使用过程中通常会伴随着这样的使用场景,下面用<B>TiFlash</B>和MySQL之间来对比</p><h3 id="准备数据"><a class="header-anchor" href="#准备数据"></a>准备数据</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用以下命令安装数据生成工具</span>tiup <span class="token function">install</span> bench<span class="token comment"># 使用以下命令生成数据</span>tiup bench tpch --sf<span class="token operator">=</span><span class="token number">1</span> prepare<span class="token operator">!</span><span class="token punctuation">[</span>准备数据<span class="token punctuation">]</span><span class="token punctuation">(</span>https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_1.jpg?raw<span class="token operator">=</span>true<span class="token punctuation">)</span><span class="token comment"># 运行以下 SQL 语句查看生成的数据量</span>SELECT CONCAT<span class="token punctuation">(</span>table_schema,<span class="token string">'.'</span>,table_name<span class="token punctuation">)</span> AS <span class="token string">'Table Name'</span>, table_rows AS <span class="token string">'Number of Rows'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">(</span>data_length/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS <span class="token string">'Data Size'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">(</span>index_length/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS <span class="token string">'Index Size'</span>, CONCAT<span class="token punctuation">(</span>ROUND<span class="token punctuation">((</span>data_length+index_length<span class="token punctuation">)</span>/<span class="token punctuation">(</span><span class="token number">1024</span>*1024*1024<span class="token punctuation">)</span>,4<span class="token punctuation">)</span>,<span class="token string">'G'</span><span class="token punctuation">)</span> AS<span class="token string">'Total'</span>FROM information_schema.TABLES WHERE table_schema LIKE <span class="token string">'test'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_2_%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B1%95%E7%A4%BA.jpg?raw=true" alt="数据行数"></p><h3 id="执行SQL"><a class="header-anchor" href="#执行SQL"></a>执行SQL</h3><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT    l_orderkey,    SUM(        l_extendedprice * (1 - l_discount)    ) AS revenue,    o_orderdate,    o_shippriorityFROM    customer,    orders,    lineitemWHERE    c_mktsegment &#x3D; &#39;BUILDING&#39;AND c_custkey &#x3D; o_custkeyAND l_orderkey &#x3D; o_orderkeyAND o_orderdate &lt; DATE &#39;1996-01-01&#39;AND l_shipdate &gt; DATE &#39;1996-02-01&#39;GROUP BY    l_orderkey,    o_orderdate,    o_shippriorityORDER BY    revenue DESC,    o_orderdatelimit 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="同步列存数据"><a class="header-anchor" href="#同步列存数据"></a>同步列存数据</h3><p>TiFlash 部署完成后并不会自动同步 TiKV 数据，你可以在 MySQL 客户端向 TiDB 发送以下 DDL 命令指定需要同步到 TiFlash 的表。指定后，TiDB 将创建对应的 TiFlash 副本。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE test.customer SET TIFLASH REPLICA 1;ALTER TABLE test.orders SET TIFLASH REPLICA 1;ALTER TABLE test.lineitem SET TIFLASH REPLICA 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="分析对比性能差异"><a class="header-anchor" href="#分析对比性能差异"></a>分析对比性能差异</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_%E4%B8%8D%E4%BD%BF%E7%94%A8TiFlash.jpg?raw=true" alt="传统关系数据引擎"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/T-TiDB/HTAP_%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_3_%E4%BD%BF%E7%94%A8TiFlash.jpg?raw=true" alt="TiFlash引擎"></p><p>可以看到TiFlash执行的耗时非常的少</p><h2 id="SQL-基本操作"><a class="header-anchor" href="#SQL-基本操作"></a>SQL 基本操作</h2><h2 id="SQL-基本操作-v2"><a class="header-anchor" href="#SQL-基本操作-v2"></a>SQL 基本操作</h2><p>TODO</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.pingcap.com/zh/tidb/dev/quick-start-with-tidb#%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4">TiDB官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;TiDB数据库之简介&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;TiDB 是 PingCAP 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processin</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="TiDB" scheme="https://agmtopy.gitee.io/tags/TiDB/"/>
    
  </entry>
  
  <entry>
    <title>git workflow的几种最佳实践方式</title>
    <link href="https://agmtopy.gitee.io/2022/10/29/1.%E6%9D%82%E8%AE%B0/git-workflow%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%B9%E5%BC%8F/"/>
    <id>https://agmtopy.gitee.io/2022/10/29/1.%E6%9D%82%E8%AE%B0/git-workflow%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%B9%E5%BC%8F/</id>
    <published>2022-10-29T02:54:10.000Z</published>
    <updated>2022-10-30T17:34:20.744Z</updated>
    
    <content type="html"><![CDATA[<h1>git workflow的几种最佳实践方式</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>现有的版本控制系统大多选择使用Git来进行管理/协作;不同的团队有会根据各自的情况选择不同的协助方式,常见的<B>git workflow</B>主要分为三种:</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow<br>常见的分支模式也可以大致划分为两种:</li><li>主干分支模式</li><li>特性分支模式</li></ul><p>下面就先介绍特性分支模式下的三种 Git WorkFlow特点与优劣;</p><h2 id="Git-flow"><a class="header-anchor" href="#Git-flow"></a>Git flow</h2><blockquote><p><B>Git flow</B>最早是由Vincent Driessen在2010年左右提出来的<B><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">《一个成功的 Git 分支模型》</a></B>一文中介绍他自己的分支管理模式;主要核心思想就是会存在两类分支:</p></blockquote><ul><li><p>长期分支:</p><ul><li><B>master</B></li><li><B>develop</B></li></ul></li><li><p>临时分支:</p><ul><li><B>hotfixs branch</B></li><li><B>release branch</B></li><li><B>feature branch</B></li></ul></li></ul><p>长期分支是一直存在的,临时分支只是会存在与一个迭代或一次hotfix的过程中,他们之间的关系如下所示:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/git_flow.png?raw=true" alt="git flow "></p><p>也可以看下面这个简化的git flow流程<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/git-flow%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png?raw=true" alt="git flow "></p><p>可以从上面两个图中看到开发者其实是站着<B>develop branch</B>一侧的,feature branch分支通常存在于本地,开发完成后执行<B>merge request(MR)</B>合并到<B>develop branch</B>(通常使用的是git merge --no–ff feature-branch的方式);同时发布分支(release branch)是从develop branch上切出来的,测试通过后mr到master中;</p><p>git flow中进行code review的判定点:</p><ul><li>尝试从私有分支合并代码到公有分支(develop, release/<em>, hotfix/</em>, master)中时</li></ul><p>例如从feature branch -&gt; develop branch,hotfixs branch -&gt; master/develop时是需要进行code review;<br>从develop -&gt; master时是不需要进行code review的;</p><h3 id="优点"><a class="header-anchor" href="#优点"></a>优点</h3><ul><li><p>严谨的合并流程<br>所有进入公共分支的代码都需要进行审核,确保代码问题;这样的合并流程适用于已有的成熟项目开发流程,可以尽量在前置协作过程中发现避免问题;</p></li><li><p>适用于开源项目(曾经)<br>各个贡献者都是在各自的repository(存储库)中工作,需要提出PR经过审核后才能提交代码到主库中</p></li></ul><h3 id="缺点"><a class="header-anchor" href="#缺点"></a>缺点</h3><ul><li><p>繁琐<br>在开发过程中,会持续维护两个长期分支<B>develop</B>和<B>master</B>,并且这两个分支的实际含义还有所重合(develop-拥有不稳定的全部代码的分支/master-拥有全部稳定代码的分支);</p></li><li><p>持续交付困难<br>所有的功能开发必须是在一个周期或多个周期内完成,造成master中的代码不是最新的,因此很难进行CD;也有基于git flow开进行CD的方案,但是有点舍本求末的感觉在里面了,CI/CD应该是在’每个人每天都致力于master上工作’的前提</p></li></ul><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>git flow的开发模式过于繁琐来保证较高的代码质量,需要去维护多个长期分支;繁琐也是相对于下面两种模式而言的;git flow的作者目前也是建议大家基于团队/项目来选择和更简单的GitHub flow;</p><h2 id="GitHub-flow"><a class="header-anchor" href="#GitHub-flow"></a>GitHub flow</h2><p>GitHub flow最早是由GitHub的技术经理scott chacon提出来的<a href="http://scottchacon.com/2011/08/31/github-flow.html">GitHub Flow</a>,是基于Github内部使用Git工作的一种流程;</p><blockquote><p>GitHub flow主要有以下几个特征:<br>- master branch中的代码是在任何时候都是可以进行部署的<br>- 功能分支名称需要用描述功能特性来进行命名的<br>- 即时将本地代码push/pull到服务器上<br>- 使用PR来进行协作(反馈/帮助/合并)<br>- 完成master合并后立即部署</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/github%20flow.jpg?raw=true" alt="github flow"></p><p>这是一个简易的GitHub flow的流程,可以看到所有去请求在进行审核之后都会被合并到Master分支中;<br>在实践中GitHub flow是一个一直向前的流程,对于master分支几乎不会进行回滚操作(通过新的提交抵消错误需要进行回滚的合并)</p><h3 id="优点-v2"><a class="header-anchor" href="#优点-v2"></a>优点</h3><ul><li><p>分支模型简单<br>这个分支模型简单是相对于Git flow来说的,只用维护一个长期分支<B>master</B>,利于后续的CI/CD</p></li><li><p>PR<br>这个是GitHub flow的一个创新,PR不止是合并代码而是一种协作方式,可以进行评论/审查/帮助,这个是跨地域进行大规模协作的基础,改变了以前通过邮件的方式;</p></li><li><p>可以最大限度减少未发布代码的数量<br>master branch 在合并代码后就会进入持续交付阶段,这样会最大限度的降低未发布代码的数量</p></li></ul><h3 id="缺点-v2"><a class="header-anchor" href="#缺点-v2"></a>缺点</h3><ul><li><p>无法应对版本的延迟发布<br>在实际开发工作中,持续交付不一定能实现,毕竟大多数技术开发还是以业务为导向的;</p></li><li><p>无法处理多版本交付<br>开发环境/测试环境/预发环境甚至生产多版本部署的场景</p></li></ul><h3 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h3><p>GitHub flow在简化Git flow的基础上支持开源软件的开发模式,但是自身也有一些问题.</p><h2 id="GitLab-flow"><a class="header-anchor" href="#GitLab-flow"></a>GitLab flow</h2><p>GitLab flow是由极狐公司提出在<B><a href="https://docs.gitlab.cn/jh/topics/gitlab_flow.html">GitLab Flow介绍</a></B>一文实践的分支管理方式;</p><p>GitLab flow的设计遵寻两个原则:</p><ul><li>单一主分支</li></ul><blockquote><p>单一主分支原则与GitHub Flow所保留的Master分支一致</p></blockquote><ul><li>上游优先</li></ul><blockquote><p>上游优先原则指的是只存在一个主分支master,它是所有其他分支的<B>上游</B>.只有上游分支采纳的代码变化,才能应用到其他分支。对于<B>持续发布</B>的项目，它建议在master分支以外，再建立不同的环境分支。比如,<B>开发环境</B>的分支是master,<B>预发环境</B>的分支是pre-* ,<B>生产环境</B>的分支是pro-*;</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%201.png?raw=true" alt="上游优先流程"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%202.png?raw=true" alt="生产分支的切出"></p><p>从上述的流程中可以看到GitLab flow在分支上选择是多分支的管理方式,但是是一种基于<B>上游优先</B>策略下的多分支管理方式,并不是像Git flow那样同时维护多个长期分支,对于后续的发布分支流程,GitLab采用的也是从Master branch中切分支或者打tag的方式:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/GitLab%20flow%203.jpg?raw=true" alt="GitLab 发布分支"></p><p>在GitLab的实践中,通常<B>Master branch</B>都是受保护的,这样大部分开发者不能对其进行直接修改;<br>其中在他们的实践中也认可践行(PR/MR)的协助方式,分支的命名也是采用的功能命名的方式,合并后立即删除,以便其他人重新开始这个功能的议题;issues是工作的开始,MR是工作的结束;</p><h3 id="优点-v3"><a class="header-anchor" href="#优点-v3"></a>优点</h3><ul><li><p>支持多版本部署<br>支持pre-* /pro-*的多分支部署方式</p></li><li><p>可以支持延迟发布<br>开发分支和发布分支可以并行</p></li></ul><h2 id="小结-v3"><a class="header-anchor" href="#小结-v3"></a>小结</h2><p>由于GitLab flow出现的时间比git flow/gitlab flow都要晚一些,因此吸收了这两种风格的特点(支持多分支/PR模式);<br>大多数开发模式都是让代码审查通过后直接进入Master branch,因为这样可以尽早的解决冲突;</p><p>以上三种代码分支的管理方式都是基于<B>功能开发</B>(先有需求驱动的开发模式),并不是GitLab flow就一定比Git flow要更好,只有更适合的,下面介绍三种简单的区分方式仅供参考:</p><ul><li>工作中会使用到多个版本 -&gt; Git flow</li></ul><blockquote><p>如果代码库在工作中有多个版本(即典型的软件产品,如操作系统、Office 软件包、自定义应用程序等);可以使用git-flow,主要原因是在开发下一个版本的同时,需要在生产中持续支持以前的版本,并且有一个较长的迭代周期;</p></blockquote><ul><li>工作中只会使用到一个版本 -&gt; GitHub flow</li></ul><blockquote><p>如果代码库始终只有一个生产版本（即网站、Web 服务等），可以使用 github flow。主要原因是您不需要为开发人员复杂的事情。一旦开发人员完成一项功能或完成错误修复，它就会立即升级为生产版本。</p></blockquote><ul><li>生产中的单一版本但非常复杂的软件 -&gt; Gitlab-flow</li></ul><blockquote><p>在商业大型软件或者是以提供服务的项目上，在生产中可能需要在您的分支和主分支之间来回部署,并且在不同版本都需要进行CI/CD。推荐就使用Gitlab-flow</p></blockquote><h2 id="基于主干的开发模式"><a class="header-anchor" href="#基于主干的开发模式"></a>基于主干的开发模式</h2><p>在基于主干的开发模式中,所有开发人员都在一个开放的分支上进行工作。一般是使用master分支.他们直接向Master提交代码并运行;开发人员会创建短暂的功能分支。一旦他们分支上的代码编译并通过所有测试，他们就会直接将其合并到master. 确保开发是真正连续的，并防止开发人员创建难以解决的合并冲突;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9D%82%E8%AE%B0/git_flow/%E5%9F%BA%E4%BA%8E%E4%B8%BB%E5%B9%B2%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png?raw=true" alt="基于主干开发流程"></p><p>可以看到<B>基于主干的开发流程</B>非常的简单,任何人都可以直接向Master branch 合并代码,能够做到快速交付/迭代;缺点是没有人来进行功能性code review,只能进行完整的源代码检查(这是一种灾难😰);</p><p>基于主干的开发模式适用于:<B>项目开始的早期</B>、<B>拥有的都是老手</B>(😖)或者是<B>基础架构强/持续集成工具集成度高/TDD和自动化测试覆盖完善场景</B>下;</p><p>其实还有其他的开发模式例如<B>集中式</B>、<B>Forking</B>等工作流程,有兴趣的可以了解一下;</p><h2 id="使用Git的几个约定"><a class="header-anchor" href="#使用Git的几个约定"></a>使用Git的几个约定</h2><p>在使用Git过程中,其实每个团队的风格不同,都有一些比较好的值得借鉴的地方,以下可能是我自己的一个使用习惯</p><ol><li><p><B>使用rebase -i整理需要提交的commit</B><br>每次大功能向master/develop等公开分支提交时,会首先将同一需求的多个commit压缩合并成为一个有具体含义的commit后在发起PR;这样做的原因是基于我认为提交的MR应该是一个完整的功能/补丁/操作的log,可以让之后进行阅读的人知道这一行代码是为那个需求/修复而写的,而不应该是一个需求中的一个小点添加的;第二点是便于回滚/Cherry-pick,一个commit的操作要比多个commit的操作更简单;</p></li><li><p><B>基于最新的共享分支进行MR</B><br>这一点是基于Code review来说的,基于过时的分支合并到共享分支中是会夹杂大量代码差异,不利于code review的进行;对于rebase的使用,坚持一个原则<B>私有分支操作使用rebase,共享分支操作使用merge</B></p></li><li><p><B>使用stash</B><br>暂存区配合分支切换可以较好的完成,工作区的分支切换/代码存储合并的动作</p></li></ol><h2 id="问题"><a class="header-anchor" href="#问题"></a>问题</h2><ul><li><p>Code Review如何让每一个人参与其中?</p></li><li><p>CI耗时过程问题以及是否需要进行CI?</p></li></ul><blockquote><p>需要,非常需要;gradle cache;</p></blockquote><ul><li>代码文件冲突/合并的问题?</li></ul><blockquote><p>产生的原因是与长期分支脱节、需求划分的不合理、没有及时的协作解决冲突等等</p></blockquote><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://docs.gitlab.cn/jh/topics/gitlab_flow.html">GitLab Flow 介绍</a><br><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a><br><a href="https://nvie.com/posts/a-successful-git-branching-model/">一个成功的Git分支模式</a><br><a href="http://dockone.io/article/2350">gitLab Flow的11条建议</a><br><a href="https://www.atlassian.com/git/tutorials/comparing-workflows">atlassian Bitbucket</a><br><a href="https://about.gitlab.com/topics/version-control/what-is-git-workflow/">what-is-git-workflow</a><br><a href="https://www.toptal.com/software/trunk-based-development-git-flow">trunk based developmentgit flow</a><br><a href="https://medium.com/burdaforward/state-of-ci-cd-and-the-dreaded-git-flow-fce92d04fb07">State of CI/CD and the omnipresent git flow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;git workflow的几种最佳实践方式&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;现有的版本控制系统大多选择使用Git来进行管理/协作;不同的团队有会根据各自的情况选择不同的</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://agmtopy.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库系统原理</title>
    <link href="https://agmtopy.gitee.io/2022/09/27/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/31.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>https://agmtopy.gitee.io/2022/09/27/11.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/31.%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2022-09-27T15:11:06.000Z</published>
    <updated>2022-11-05T07:31:16.606Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式数据库系统原理</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><blockquote><p>为什么需要分布式?</p></blockquote><ul><li><B>处理逻辑</B></li><li><B>功能</B></li><li><B>数据</B></li><li><B>控制</B></li></ul><p>对于这个的理解应该是:</p><ul><li>处理逻辑:对应应用实例或者算法之类的,单点无法满足某些需求(AP)</li><li>功能:对于功能的分布式划分主要是体现在微服务的拆分上,不同的功能拆分成为不同的服务</li><li>数据:对于数据的拆分主要是单点数据服务无法满足要求的情况下,进行拆库拆表</li><li>控制:<font color="#dddd00">这个暂时不能理解?控制是否为程序或者算法的同义楠?</font></li></ul><blockquote><p>什么是分布式数据库?<br>物理上分布不同地方,通过计算机网络逻辑上相互关联的数据库</p></blockquote><h3 id="主要的问题"><a class="header-anchor" href="#主要的问题"></a>主要的问题</h3><ul><li>数据如何选择分片?</li><li>分布式事务的实现?</li><li>性能问题?</li></ul><p>如下图:</p><p><img src="https://raw.githubusercontent.com/agmtopy/noteBook/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.jpg" alt="分布式数据问题之间的联系"></p><h3 id="集中式数据库模型与分布式数据库模型"><a class="header-anchor" href="#集中式数据库模型与分布式数据库模型"></a>集中式数据库模型与分布式数据库模型</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E9%9B%86%E4%B8%AD%E5%BC%8FDBMS%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.jpg?raw=true" alt="集中式DBMS分层架构"></p><p>可以看到集中式数据库就是一个标准的应用分层,以MySql为例</p><p>界面: 提供不同语音的MySql Drive<br>控制: 连接校验<br>编译: sql解析<br>执行: innodb存储引擎处理<br>数据访问:MySql内核处理<br>一致性: 各种Lock和log</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpg?raw=true" alt="分布式数据库结构"></p><p>可以看到分布式数据库系统需要从三个不同的方面进行考虑:<B>物理分布</B>&lt;B&gt;异构性</B>&lt;B&gt;自治性</B></p><ul><li>物理分布:指的是组成分布式系统的服务可以在物理上隔离,可以不需要在通一台硬件机器上运行</li><li>异构性:指的是各个服务允许使用各自的协议来提供服务,这一点在工业级的分布式数据库上应该没有实现,还是遵守相同协议来降低软件复杂度</li><li>自洽性:各个服务本身就可以单独对外提供服务,不用依赖其他系统,这一点常用的分布式系统较为不同</li></ul><h3 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h3><ul><li>DBMS</li></ul><blockquote><p>DBMS-关系数据库的概念是一组结构化的数据,它是出于我们对现实世界建模的映射,一个关系数据库是以表格形式表达数据的数据库.</p></blockquote><h2 id="分布式数据库设计"><a class="header-anchor" href="#分布式数据库设计"></a>分布式数据库设计</h2><p>有两种分布式数据库的设计方法:<B>自顶向下的方法</B>和<B>自底向上的方法</B>,这也是软件领域设计的两种通用设计方法,例如我们在设计系统的时候基于底层功能实现还是上层战略定位来进行的往往会得到不同的演进路线;</p><ul><li>自顶向下:指的是在设计的时候就考虑不同的实例去支持局部的全局概念模型</li><li>自底向上:指的是将多个数据库中的信息集成为一个紧密相连的多数据库系统,常用于<B>数据仓库/数据湖</B></li></ul><h3 id="分布设计的研究问题"><a class="header-anchor" href="#分布设计的研究问题"></a>分布设计的研究问题</h3><ul><li>如何得到正确的分片结果?<br>首先,数据分片有两种维度来进行,一种是垂直分片按照业务领域进行划分,一种是水平进行分片按照特定规则来进行划分;我们会重点研究采用水平模式的设计方案.</li></ul><p>专业的分布式数据库的数据划分好复杂,会去考虑数据的分片是按照某些条件来进行的,既要保证数据的分片又要保证数据的’亲和性’;一大段一大段的高阶函数~😳😳😳</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式数据库系统原理&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要分布式?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;B&gt;处理逻辑</summary>
      
    
    
    
    <category term="数据库" scheme="https://agmtopy.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-内存管理篇</title>
    <link href="https://agmtopy.gitee.io/2022/09/24/20.%E7%AC%94%E8%AE%B0/12.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/09/24/20.%E7%AC%94%E8%AE%B0/12.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/</id>
    <published>2022-09-24T09:09:44.000Z</published>
    <updated>2022-09-25T14:22:14.661Z</updated>
    
    <content type="html"><![CDATA[<h1>现代操作系统原理与实现-内存管理篇</h1><p>一晃而过距离上一篇<B>硬件结构</B>已经过去了一个月有余了.最近一直在整理<B>Notion</B>上的笔记,把《深入理解Java虚拟机》的相关笔记也在notion上写和整理去了,对《现代操作系统原理与实现》的笔记也耽搁了许久;这本书应该是本年度最佳书籍了,会争取在今年把第一遍阅读的相关笔记完成,时间过的真的很快,跑题感慨了一下,下面继续有关内存部分的整理和理解吧!</p><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>在上一章中了解到物理内存是组成操作系统的重要部分,这一章节就是介绍操作系统是如何管理和使用内存的;</p><h3 id="内存管理"><a class="header-anchor" href="#内存管理"></a>内存管理</h3><p>内存管理主要是对物理内存的管理,在早期程序是直接分配在物理内存上运行的,那个时候操作系统都不存在,这样分配会产生几个问题例如程序直接操作物理内存无法做到隔离/分配内存空间的碎片化/无法处理超过物理容量限制的分配</p><p>针对这个些问题,提出了<B>虚拟内存</B>的概念,大概是在1956年的一位德国物理学家提出的,感觉这个时间过了好久了啊,但是在翻阅资料查这些的时候发现计算机的发明居然还没有80年,太不可思议了</p><p><img src="http://www.isolves.com/d/file/p/2020/03-17/bbd1470ef6879e2f6e4847b7444fde35.jpg" alt="虚拟内存技术发展时间线"></p><h4 id="虚拟内存"><a class="header-anchor" href="#虚拟内存"></a>虚拟内存</h4><blockquote><p>虚拟内存作为物理内存和应用程序之间的一个抽象层;应用程序不在直接运行在物理内存之上,而是运行在虚拟内存之上;应用程序在运行时只知道虚拟内存地址,cpu或者硬件负责将虚拟地址转换为物理地址,操作系统负责设置虚拟地址与物理地址之间的映射;每个应用程序只能看到属于自己的虚拟内存地址,并且看到的虚拟内存地址是同一的、连续的;</p></blockquote><ul><li>虚拟内存的结构<br>下面是一张有关CPU如何将虚拟地址转换为物理地址的图:</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/x-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/CPU%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%A4%BA%E6%84%8F%E5%9B%BE.drawio.png?raw=true" alt="CPU虚拟地址翻译示意图"></p><p>可以看到操作系统向CPU发生虚拟地址访问请求后,传给MMU在通过TLB转换后,将物理地址发送给操作总线,从而访问到物理内存地址;</p><p>现代操作系统都是通过分页的形式采用页表来实现的,<B>TLB</B>缓存了虚拟页号到物理页号之间的映射关系,TLB的设计非常简单就是做映射,但是却十分的高效,因为在内存数据的访问遵守<B>时空局部性原理</B></p><ul><li>虚拟内存中的换页</li></ul><p>在前面说到物理内存无法自动处理分配超过实际容量限制的场景.而虚拟内存可以做到,就是通过换页机制来实现的,具体流程如下:</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/143273007">操作系统之内存管理</a><br><a href="https://ewikizh.top/wiki/Virtual_memory#cite_note-10">虚拟内存</a><br><a href="https://www.isolves.com/it/rj/jy/2020-03-17/14226.html">虚拟内存技术的前世今生</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;现代操作系统原理与实现-内存管理篇&lt;/h1&gt;
&lt;p&gt;一晃而过距离上一篇&lt;B&gt;硬件结构&lt;/B&gt;已经过去了一个月有余了.最近一直在整理&lt;B&gt;Notion&lt;/B&gt;上的笔记,把《深入理解Java虚拟机》的相关笔记也在notion上写和整理去了,对《现代操作系统原理与实现》的笔记也</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-硬件结构篇</title>
    <link href="https://agmtopy.gitee.io/2022/08/14/20.%E7%AC%94%E8%AE%B0/11.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/08/14/20.%E7%AC%94%E8%AE%B0/11.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2022-08-14T06:39:04.000Z</published>
    <updated>2022-09-24T09:10:19.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>操作系统是建立在硬件结构基础上的软件实现,这一章节我们来介绍计算机的硬件结构.</p><h2 id="CPU与指令集架构"><a class="header-anchor" href="#CPU与指令集架构"></a>CPU与指令集架构</h2><blockquote><p>指令集架构是cpu与软件之间的桥梁,包括指令集\特权级\寄存器\执行模式\安全扩展\性能加速等等</p></blockquote><h3 id="指令集"><a class="header-anchor" href="#指令集"></a>指令集</h3><p>指令集包括<B>精简指令集(RISC)</B>和<B>复杂指令集(CISC)</B>两种.</p><ul><li><p>精简指令集<br>指的是没有寄存器的指令集,通过指令来模拟寄存器的操作,常见的安卓和苹果的A系/M系芯片都是使用的这种指令集</p></li><li><p>复杂指令集<br>指的是有寄存器的指令集,通过使用寄存器来执行指令,常见的Intel的X86芯片都是使用的这种指令集</p></li></ul><p>目前在生产中并没有严格隔离指令集,CISC也在集成RISC的相关指令</p><p>常用的指令类型分为4种:</p><ul><li>数据搬移指令(mov等)</li><li>寄存器计算指令(add/sub等)</li><li>内存读写指令(ldr-加载/str-读写等)</li><li>调整指令(b)</li><li>过程调用指令(bl/ret)</li><li>特权指令(mrs/msr)</li></ul><h2 id="特权级"><a class="header-anchor" href="#特权级"></a>特权级</h2><p>指的是指令运行的级别,分别是El0,El1,El2,El3</p><ul><li><p>El0<br>指的是最低特权级,应用程序通常运行在这一级别上,也可以称为<B>用户态</B></p></li><li><p>EL1<br>操作系统通常运行在这一级别上,也称为<B>内核态</B></p></li><li><p>El2<br>指的是次高特权级,操作系统通常运行在这一级别上,也称为<B>高级内核态</B>,通常虚拟机监控器需要运行在这一状态</p></li><li><p>El3<br>负责普通世界与安全世界的切换,安全世界是<B>AArch64</B>提出来的一个管理硬件交互的级别,EL3在级别上是最高的,因为可以直接操作硬件</p></li></ul><blockquote><p>EL0 &lt; EL1 &lt; EL3 &lt; EL3</p></blockquote><p>程序在运行过程中大量的发生EL0 &lt;=&gt; EL1转换,其实就是用户进程与内核进程在不断的进行切换的过程;这里需要注意一点的是<B>中断</B>是运行在EL1级别上的</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2.jpg?raw=true" alt="中断切换"></p><h2 id="寄存器"><a class="header-anchor" href="#寄存器"></a>寄存器</h2><p>寄存器是指令集中的一种数据结构,用于存储数据,比如寄存器中存储的是指令的地址,寄存器中存储的是指令的参数等等.它们是cpu的基本架构组成部分,参与指令的执行和计算过程.现代CPU往往会使用大量专用的寄存器来做专业的事情,比如帧指针寄存器,连接寄存器等</p><h2 id="物理内存与CPU缓存"><a class="header-anchor" href="#物理内存与CPU缓存"></a>物理内存与CPU缓存</h2><ul><li>物理缓存</li></ul><blockquote><p>CPU在执行的过程中,可以通过访存指令不断的向物理内存中读写数据;CPU使用物理内存的方式很简单:通过<B>总线</B>向物理内存发生一个读写请求,其中包括目标地址,物理内存在接收到请求后,会根据请求的类型进行读写操作,并返回相应的结果</p></blockquote><p>通过以上的描述可以得知CPU在进行执行时都是通过总线与内存进行交互\cpu从内存中取值后会放到私有的区域(CPU缓存)中,其实这样的设计也加大了应用人员开发出健壮/正确的并发代码难度,在编写并发相关代码时一定要仔细</p><ul><li>CPU缓存</li></ul><blockquote><p>CPU缓存是一个私有的区域,用于存储CPU执行过程中的数据;由若干个<B>缓存行</B>组成.每个缓存行包含:一个<B>有序位标识</B>标识数据是否有效和一个<B>标记地址</B>用于标记其对应的物理地址;</p></blockquote><blockquote><p>CPU以缓存行(常见的是64bit大小)为单位把物理内存读取到缓存中,也就是说如果只需要一个bit的数据,但是还是需要把该字节对应的缓存行数据全部读取到缓存中,写入反之亦然也是每次需要写出64bit大小的数据</p></blockquote><p>对于CPU缓存行最熟悉的一个作用是<B>禁止指令重排</B>,在java中我们知道valitate的一个作用是可见性,就是根据基于缓存行的<B>缓存一致性协议-MESI协议</B>来实现的</p><p>volatile的另外一个作用是可以解决编译器层面的可见性与重排序问题。而内存屏障则解决了硬件层面的可见性与重排序问题</p><h2 id="设备与中端"><a class="header-anchor" href="#设备与中端"></a>设备与中端</h2><p>常见的设备指的是输入与输出设备,常见的内存映射输入输出设备,常见的中断设备,比如硬盘,光驱,键盘,鼠标等</p><p><B>中断</B>机制是提供设备主动通知CPU的能力.设备通过向CPU发送中断来打断CPU的执行.</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>本章主要介绍<B>精简指令集</B>&lt;B&gt;特权级</B>&lt;B&gt;寄存器</B>&lt;B&gt;内存与缓存</B>等硬件基本结构<br>多核CPU缓存的设计遵守<B>缓存一致性协议</B>这个是valotail可见性的基础</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/MrLiuZF/p/15054855.html">CPU缓存</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;操作系统是建立在硬件结构基础上的软件实现,这一章节我们来介绍计算机的硬件结构.&lt;/p&gt;
&lt;h2 id=&quot;CPU与指令集架构&quot;&gt;&lt;a class=&quot;head</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(一)</title>
    <link href="https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/20.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%B8%80)/</id>
    <published>2022-08-08T15:45:00.000Z</published>
    <updated>2022-11-14T15:51:04.370Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(一)</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>是《深入分布式缓存-从原理到实践》一书的一些记录</p><h2 id="理论基础"><a class="header-anchor" href="#理论基础"></a>理论基础</h2><blockquote><p>cache这个词,据说来自于法语,本意是当CPU处理数据时先到cache中去寻找,如果数据在之前的操作与i就读取而被暂存其中,就不需要从主内存中去读取了.后来cache的范围有所扩展,泛指凡是位于速度相差比较大的两种硬件之间,用于协调两者数据传输差异的结构,都称为cache.</p></blockquote><p>凡是通过两种查询速度较大的方式来查询同一对象都称为cache</p><blockquote><p>缓存:存储在计算机上的一个原始数据复制集,以便用于访问   -wiki</p></blockquote><p>常见的一些缓存:</p><ul><li>CPU多级缓存</li><li>TLB(Translation lookaside buffer) -最新的虚拟内存-&gt;物理内存的转换</li></ul><p>缓存分类:</p><ul><li>按缓存位置划分<ul><li>客户端缓存</li><li>服务器端缓存</li><li>网络中的缓存</li></ul></li><li>按部署方式划分<ul><li>单体缓存</li><li>集群缓存</li><li>分布式缓存</li></ul></li></ul><h3 id="网络中的缓存"><a class="header-anchor" href="#网络中的缓存"></a>网络中的缓存</h3><ul><li>web代理缓存</li></ul><p>使用正向代理的方式将web服务器上的数据进行缓存,客户端请求后之间返回不需要重新先web服务器请求</p><ul><li>边缘缓存</li></ul><p>边缘缓存是通过反向代理的方式与用户处于同一网络,向用户提供静态内容的缓存,典型应用就是CDN缓存</p><h3 id="缓存算法"><a class="header-anchor" href="#缓存算法"></a>缓存算法</h3><p>LRU:最近最少使用算法<br>LFU:最少使用算法(会统计一段时间内每个缓存的访问次数)<br>SIZE:缓存大小算法(按照缓存的大小进行算法)</p><h2 id="分布式系统理论"><a class="header-anchor" href="#分布式系统理论"></a>分布式系统理论</h2><ul><li>并向与并发</li></ul><blockquote><p>并发指的是两个事情或多个事情在同一个时间段内间隔发生;并行指的是两个事情或多个事情在同一个时刻同时发生;</p></blockquote><ul><li>CAP</li></ul><blockquote><p>CAP理论提出一致性\可用性\分区容错性的取舍问题</p></blockquote><p>一致性©:指的是在同一时刻访问所有节点得到的数据相同<br>可用性(U):指的是在同一时刻访问所有节点得到的数据都可用<br>分区容错性§:指的是节点一定会发生故障,但是不会影响整个系统的正常运行</p><h3 id="分布式系统设计策略"><a class="header-anchor" href="#分布式系统设计策略"></a>分布式系统设计策略</h3><p>分布式系统设计策略指的是对于设计分布式系统常见的几个问题的处理策略:</p><ul><li>如何检测你还活着?</li><li>如何保障高可用?</li><li>容错机制的设计?</li><li>重试机制?</li><li>负载均衡?</li></ul><p>下面详细对每一个问题进行解答:</p><h4 id="如何检测你还活着"><a class="header-anchor" href="#如何检测你还活着"></a>如何检测你还活着?</h4><p>在分布式系统中如何检测当前节点是否存活?<br>在大多数分布式中间件中都是通过<B>心跳检测</B>的机制来检测当前节点是否存活的,例如在zk的client与server之间的心跳检测保持连接\redis哨兵架构中的哨兵与master/slave之间的心跳检测</p><p><B>φ-accrual 故障检测器</B>是通过滑动窗口的时间算法来统计结果</p><p><B>Gossip分发</B>(流言算法)通过消息的传递确定节点是否应该停止服务的算法</p><p>小结:<br>存活检测有两个方法:一个是从通信链路入手检测目标节点的网络是否异常\一种是通过检测当前状态是否符合预期状态来检测目标节点是否存活</p><h4 id="如何保障高可用"><a class="header-anchor" href="#如何保障高可用"></a>如何保障高可用?</h4><p>在分布式系统中保障高可用的核心就是数据备份,通过多个节点的备份来在任何节点故障的情况下提供服务<br>按照提供服务的节点时机可以分为<B>主备(Master/Slave)</B>&lt;B&gt;互备(Failover)</B>&lt;B&gt;集群(Cluster)</B>这三种方式</p><ul><li><p>主备(Master/Slave)模式<br>主备模式多用于要求严格提供C(一致性)\A(可用性)的场景中,MySQL的主备模式\Redis的哨兵模式</p></li><li><p>互备(Failover)模式<br>互备模式指的是各个节点提供的数据和服务是相同的,常见的RocketMQ的注册中心NameServer就是多个节点提供相同的服务</p></li><li><p>集群(Cluster)模式<br>集群模式指的是服务在多个节点运行,不同的节点运行不同的任务,比如Redis的集群模式;集群模式与主备模式/互备模式的区别在于集群模式是仅对服务进行高可用的设计,另外两种设计既有对服务和数据的双重含义</p></li></ul><h4 id="容错机制的设计"><a class="header-anchor" href="#容错机制的设计"></a>容错机制的设计</h4><p>容错机制指的是在系统设计中需要对一些异常场景的兼容,例如在Raft的一些实现中就会对CommitId进行CRC32的容错机制校验</p><h4 id="重试机制"><a class="header-anchor" href="#重试机制"></a>重试机制</h4><p>重试机制指的是系统调用失败后,由于无法确定是否网络异常,或者是否是系统调用的问题,可以重试一定次数,如果重试次数超过限制,则抛出异常;这种设计是基于网络异常和系统异常的区别的基础上来进行设计的,在一般认为中网络异常是频繁且持续的,因此可以重试机制下,重试一定次数<br>重试机制又会引出接口幂等的场景,因此在分布式系统设计中,接口一定要提供幂等</p><h4 id="负载均衡"><a class="header-anchor" href="#负载均衡"></a>负载均衡</h4><p>负载均衡类似于集群模式通过一个总的调度器来对任务进行分配,常用的负载均衡方案Nginx,LB</p><h3 id="分布式系统的几个通用问题"><a class="header-anchor" href="#分布式系统的几个通用问题"></a>分布式系统的几个通用问题</h3><ul><li>全局id的生成</li><li>hash取模分配</li><li>路由表</li><li>一致性hash算法</li><li>数据拆分</li><li>分布式锁的解决方案</li><li>分布式事务的解决方案</li></ul><h4 id="全局Id的生成方案"><a class="header-anchor" href="#全局Id的生成方案"></a>全局Id的生成方案</h4><p>分布式Id的产生是基于数据服务大都采用集群的模式提供服务,在这种模式下不同的节点如果产生的id不进行相互协调的话会造成id的冲突,因此需要一个全局的id生成方案来保证id的唯一性</p><p>有两种实现思路:</p><ul><li>基于节点执行不同规则的id生成</li><li>基于全局协调器的id生成</li></ul><p>下面分别来介绍一下这两种不同的方案</p><ul><li>基于节点执行不同规则的id生成</li></ul><p>是通过值得数据节点的id生成规则来实现的,例如对id设置初始值和步长,然后每个节点都会计算出自己的id,这样就可以保证id的唯一性</p><ul><li><p>基于全局协调器的id生成<br>基于全局协调器的id生成方案实现比较多,例如通过一张id表的方式来进行实现\通过分布式id生成器的号段模式来实现\通过分布式id生成器的雪花算法来实现</p></li><li><p>snowflake的id生成方案</p></li></ul><p>64bit = 41bit(时间戳) + 10bit(节点id) + 12bit(自增id)<br>时间戳精确到毫秒<br>12位自增id每个节点最多产生4096个id</p><h4 id="hash取模-路由表-一致性hash算法"><a class="header-anchor" href="#hash取模-路由表-一致性hash算法"></a>hash取模\路由表\一致性hash算法</h4><p>hash取模\路由表\一致性hash算法都是为了解决数据或服务的一个寻址过程,例如对于一个数据库来说,如果数据库有多个节点,那么对于某个数据来说,可以通过hash取模的方式来寻址到对应的节点,这样就可以保证数据的一致性</p><p>hash取模是指的是对数据进行hash取模,然后根据模的值来寻址到对应的节点,这样就可以保证数据的分片性</p><p>路由表是通过预设的路由表来寻址到对应的节点,这样就也可以保证数据的分片性;路由表还有一个优点是对于有序增加的场景下可以通过递增预设的路由表数据来寻址到对应的节点,还不影响之前的数据,但是这样有一个路由表单点问题,需要做好数据的备份和failover</p><h4 id="数据拆分"><a class="header-anchor" href="#数据拆分"></a>数据拆分</h4><p>数据的拆分主要指的是将数据分片到不同的节点上,这样就可以保证数据的一致性;前面已经介绍数据拆分的原理;<br>常用的数据拆分方案是mycat/shardingsphere等</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>这一章节主要给我们介绍<B>分布式系统设计策略</B>&lt;B&gt;分布式系统的几个通用问题</B>的解决方案</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(一)&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;是《深入分布式缓存-从原理到实践》一书的一些记录&lt;/p&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a clas</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入分布式缓存-从原理到实践(二)</title>
    <link href="https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/21.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%BA%8C)/"/>
    <id>https://agmtopy.gitee.io/2022/08/08/20.%E7%AC%94%E8%AE%B0/21.%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5(%E4%BA%8C)/</id>
    <published>2022-08-08T15:45:00.000Z</published>
    <updated>2022-11-14T15:51:02.990Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分布式缓存-从原理到实践(二)</h1><h2 id="规划定义"><a class="header-anchor" href="#规划定义"></a>规划定义</h2><h3 id="JSR"><a class="header-anchor" href="#JSR"></a>JSR</h3><blockquote><p>JSR是java Specification Requests的缩写,是java定义的一种对java对象临时在内存中进行缓存的方法,包括对象的创建\访问\失效\一致性等</p></blockquote><h3 id="缓存常用方法"><a class="header-anchor" href="#缓存常用方法"></a>缓存常用方法</h3><table><thead><tr><th>接口</th><th>说明</th><th>Ehcache</th><th>Guava</th></tr></thead><tbody><tr><td>put()</td><td>添加缓存</td><td>✔</td><td>✔</td></tr><tr><td>putIfAbsent()</td><td>如果key不存在则添加缓存</td><td>✔</td><td>✔</td></tr><tr><td>replace()</td><td>如果key存在则替换缓存</td><td>✔</td><td>✔</td></tr><tr><td>get()</td><td>获取缓存</td><td>✔</td><td>✔</td></tr><tr><td>getAll()</td><td>获取所有缓存</td><td>✔</td><td>✔</td></tr><tr><td>getAllPresent(key)</td><td>存在key在进行加载</td><td>❌</td><td>✔</td></tr><tr><td>putAll(entries)</td><td>添加所有缓存</td><td>✔</td><td>✔</td></tr><tr><td>keySet()</td><td>获取所有key</td><td>❌</td><td>❌</td></tr><tr><td>remove()</td><td>移除缓存</td><td>✔</td><td>✔</td></tr><tr><td>clear()</td><td>清空缓存</td><td>✔</td><td>✔</td></tr></tbody></table><p>可以看到常见的缓存操作就三类:<B>添加</B>&lt;B&gt;获取</B>&lt;B&gt;移除</B></p><p>下面介绍两类缓存的实现方式:<B>本地缓存</B>和<B>分布式缓存</B></p><h2 id="本地缓存"><a class="header-anchor" href="#本地缓存"></a>本地缓存</h2><h3 id="Ehcache"><a class="header-anchor" href="#Ehcache"></a>Ehcache</h3><p>暂且将Ehcache划分到本地缓存中,因为在使用中大多数场景下还是将Ehcache作为本地缓存来进行使用</p><p>Ehcache2的核心淘汰策略逻辑如下:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ehcache_AbstractPolicy_selectedBasedOnPolicy.jpg?raw=true" alt="selectedBasedOnPolicy"></p><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/AbstractPolicy.java#L77">AbstractPolicy.selectedBasedOnPolicy</a></p><ul><li>compare</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Compares the desirableness for eviction of two elements * * @param element1 the element to compare against * @param element2 the element to compare * @return true if the second element is preferable for eviction to the first element * under ths policy */</span><span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<B>compare()</B>方法是核心的比较方法,下层有<B>LRUPolicy</B>&lt;B&gt;LFUPolicy</B>&lt;B&gt;FIFOPolicy</B>底层实现</p><ul><li>LruPolicy</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较最后访问时间</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getLastAccessTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getLastAccessTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/LruPolicy.java#L52">LruPolicy.compare</a></p><ul><li>LFU</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较访问次数</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getHitCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getHitCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/LfuPolicy.java#L52">LfuPolicy.compare</a></p><ul><li>FIFO</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">// 最近最少使用算法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Element</span> element1<span class="token punctuation">,</span> <span class="token class-name">Element</span> element2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较创建和更新时间</span>    <span class="token keyword">return</span> element2<span class="token punctuation">.</span><span class="token function">getLatestOfCreationAndUpdateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> element1<span class="token punctuation">.</span><span class="token function">getLatestOfCreationAndUpdateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/ehcache/ehcache2/blob/12f580426154277bd7079bb71e85ae3615eae36f/ehcache-core/src/main/java/net/sf/ehcache/store/FifoPolicy.java#L52">FIFOPolicy.compare</a></p><h3 id="Guava-Cache"><a class="header-anchor" href="#Guava-Cache"></a>Guava Cache</h3><p>Guava Cache是Google对java集合的一种封装来实现缓存功能;</p><p>Guava Cache 提供缓存的失效时间和定时更新功能,下面介绍Guava Cache定时更新方法</p><ul><li>scheduleRefresh()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">V</span> <span class="token function">scheduleRefresh</span><span class="token punctuation">(</span>    <span class="token class-name">ReferenceEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> entry<span class="token punctuation">,</span>    <span class="token class-name">K</span> key<span class="token punctuation">,</span>    <span class="token keyword">int</span> hash<span class="token punctuation">,</span>    <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span>    <span class="token keyword">long</span> now<span class="token punctuation">,</span>    <span class="token class-name">CacheLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> loader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">refreshes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//map.refreshes()判断是否存在过期时间</span>      <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> entry<span class="token punctuation">.</span><span class="token function">getWriteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> map<span class="token punctuation">.</span>refreshNanos<span class="token punctuation">)</span><span class="token comment">//判断是否已经过期</span>      <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>entry<span class="token punctuation">.</span><span class="token function">getValueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断是否当前正在加载新值</span>    <span class="token class-name">V</span> newValue <span class="token operator">=</span> <span class="token function">refresh</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> loader<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新加载数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> newValue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>scheduleRefresh()方法是在get()方法中调用的<br><a href="https://github.com/google/guava/blob/c111c0150225739b3f5914d1739cd22fb692bce7/guava/src/com/google/common/cache/LocalCache.java#L2324">LocalCache.scheduleRefresh</a></p><h3 id="Caffine"><a class="header-anchor" href="#Caffine"></a>Caffine</h3><h2 id="二级缓存"><a class="header-anchor" href="#二级缓存"></a>二级缓存</h2><p>在使用集中式或者数据库热点配置数据时,我们往往将这些数据放到应用进程空间中中,这样可以提高缓存的命中率;可以用Echache/Guava作为二级缓存来进行使用<br>下面介绍两种常用的设计方案:</p><ul><li>定时轮询</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/reids%E6%95%B0%E6%8D%AE%E5%AE%9A%E6%97%B6%E8%BD%AE%E8%AF%A2%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88.drawio.png?raw=true" alt="定时轮询"></p><ul><li>消息通知</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/drawio/s-%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E7%8E%B0/reids%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88.drawio.png?raw=true" alt="消息通知"></p><p>消息通知的方案可以保证准实时下的推送,但是会带来一定的开销,比如消息通知的推送频率是每秒一次,那么每秒钟的消息会被推送到缓存中,这样会带来一定的开销,通过这样的消耗来保证实时性;还需要注意一点的是应用的重启后一定要消费最新的消息或从redis中获取最新的数据</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://github.com/hazelcast/hazelcast">https://github.com/hazelcast/hazelcast</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分布式缓存-从原理到实践(二)&lt;/h1&gt;
&lt;h2 id=&quot;规划定义&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#规划定义&quot;&gt;&lt;/a&gt;规划定义&lt;/h2&gt;
&lt;h3 id=&quot;JSR&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JS</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>现代操作系统原理与实现-操作系统结构篇</title>
    <link href="https://agmtopy.gitee.io/2022/08/04/20.%E7%AC%94%E8%AE%B0/10.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://agmtopy.gitee.io/2022/08/04/20.%E7%AC%94%E8%AE%B0/10.%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2022-08-04T01:00:34.000Z</published>
    <updated>2022-08-14T06:40:46.371Z</updated>
    
    <content type="html"><![CDATA[<h1>引言</h1><p>《现代操作系统原理与实现》是一本介绍操作系统相关的书籍,是以ARM平台进行演示的.目前在看过一遍之后,我觉得还是比较有意思的<B>操作系统结构</B>、<B>硬件结构</B>、<B>内存管理</B>、<B>进程与线程</B>、<B>进程间通信</B>、<B>同步原语</B>、<B>文件系统</B>这七个章节.<br>下面会依次对这些章节做相关介绍.</p><h2 id="操作系统结构"><a class="header-anchor" href="#操作系统结构"></a>操作系统结构</h2><p>为什么要优先介绍<B>操作系统结构</B>,是这个章节给我带来了极大的感悟：对于像操作系统这样庞大的系统,在良好的架构下可以很好的有序演进,这一点是很多业务系统所欠缺的.<br>下面将从两个方面进行介绍:<B>设计方法</B>、<B>实践</B></p><h2 id="设计方法"><a class="header-anchor" href="#设计方法"></a>设计方法</h2><p>对于操作系统的设计方法或者方法论(不太喜欢’方法论’这一表述词,因为有一种’定式’的味道,现实或代码中并没有什么是固定的)来说,主要是对复杂度进行管理的一种手段;<br>这里介绍了一种设计方法:<B>M.A.L.H</B>,即模块化(modularity)、抽象(abstraction)、分层(layering)、层级(hierarchy),我对于设计简直是认同的不能在认同了.</p><h3 id="模块化"><a class="header-anchor" href="#模块化"></a>模块化</h3><p>模块化是通过<B>‘分治法’</B>的思想,将一个复杂系统分解为一系列有明确含义/领域能相互进行交互的小模块.模块的划分一定要具有’高内聚’和’低耦合’的特性,不能过大也不能过于小.<br>现代操作系统都是模块化的,以linux内核为例,可以看到分为若干模块</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97.jpg?raw=true" alt="linux模块"></p><p>关于模块化还有一些学者的阐述:<br><img src="https://martinfowler.com/articles/microservice-trade-offs.html" alt="Microservice Trade-Offs"></p><h3 id="抽象"><a class="header-anchor" href="#抽象"></a>抽象</h3><p>抽象是在模块化的基础上,将<B>接口</B>与<B>内部实现</B>进行区分,从而使得策略与实现分离.<br>这也是程序设计中的一个重要的设计原则:<B>策略</B>与<B>机制</B>分离:<B>策略</B>表示的是&quot;要做什么&quot;,<B>机制</B>表示的是&quot;要如何做&quot;</p><p>在操作系统中有很多抽象的例子,比如<B>VFS</B>、<B>虚拟内存</B>等就对不同硬件的抽象.</p><p>良好的模块化与抽象可以很好的将一个大型系统分解为一系列能够比较好的进行交付的模块;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%8A%BD%E8%B1%A1.jpg?raw=true" alt="模块化与抽象"></p><h3 id="分层"><a class="header-anchor" href="#分层"></a>分层</h3><p>分层是通过将模块按照一定的规则进行层次划分,约束每一层内部模块之间的交付方式与跨层次模块之间的交互方式,从而使得整个系统的交付方式有序;通常的规则约束是:一个模块只能和同一层模块以及相邻的上下层模块进行交互,而不能跨模块进行交互.</p><p>分层是开始构建复杂系统架构的开始,通过确定层级后,先构建底层基础模块,然后在利用这些基础模提供的功能来构建应用服务.</p><p>在实际web项目中基本上都会根据controller/service/dao三层架构来进行划分,service层的扩展要稍微多一点,例如六边形架构、洋葱圈架构等.</p><h3 id="层次"><a class="header-anchor" href="#层次"></a>层次</h3><p>层次是模块化的另外一种表现方式,是系统对功能的抽象与组织;例如组织架构类似,在组织架构上经理岗位是负责某一部分业务的,那公司的这一部分业务就需要交给他这个岗位进行负责;这个岗位下又会在分解交给其他岗位完成一样;</p><p>层次会在完成模块化、抽象、分层后自然体现出来,它与分层概念很类似,我认为的区别在于分层关注的是交互/调用关系的维护和有序,层次是关注与功能的抽象和组织;</p><h3 id="一些碎碎念"><a class="header-anchor" href="#一些碎碎念"></a>一些碎碎念</h3><p>大多数程序员长期以来写的代码都是以实现当前需求为己任,对于代码之后的生命周期是不会去考虑的.这样的代码在过了几个月以后或者另外一位同事接手后不得不在一声声’问候’下继续做相同的事情.<br>我始终认为简单明了的代码是最好的代码,因为这样的可读性是最好的; 不用去追求’新’、‘奇’来体现技术能力,而是要去追求’正确性’、'可读性’来体现技术能力;<br>然而在实际开发中,我们往往缺少一种能够指导的方法,我认为<B>M.A.L.H</B>就是一种非常好的实现,M.A.L.H中隐含了一些程序设计的技巧或法则:单一职责原则、依赖倒置原则、接口隔离原则</p><p>个人理解总结下来:</p><p>是否<B>能够</B>模块化?<br>是否<B>需要</B>抽象?<br>是否<B>能够</B>分层?<br>是否<B>体现</B>层次?</p><p>这些表现是层层递进的一个过程.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;引言&lt;/h1&gt;
&lt;p&gt;《现代操作系统原理与实现》是一本介绍操作系统相关的书籍,是以ARM平台进行演示的.目前在看过一遍之后,我觉得还是比较有意思的&lt;B&gt;操作系统结构&lt;/B&gt;、&lt;B&gt;硬件结构&lt;/B&gt;、&lt;B&gt;内存管理&lt;/B&gt;、&lt;B&gt;进程与线程&lt;/B&gt;、&lt;B&gt;进程间通信&lt;/B&gt;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://agmtopy.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>maven-shade-plugin使用中的小问题</title>
    <link href="https://agmtopy.gitee.io/2022/04/22/1.%E6%9D%82%E8%AE%B0/maven-shade-plugin%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://agmtopy.gitee.io/2022/04/22/1.%E6%9D%82%E8%AE%B0/maven-shade-plugin%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-22T15:17:08.000Z</published>
    <updated>2022-04-22T15:21:28.625Z</updated>
    
    <content type="html"><![CDATA[<h1>maven-shade-plugin使用中的小问题</h1><p>maven-shade-plugin打包导致META-INF/SERVICES中的文件丢失,导致jar在动态加载时无法启动.这个问题困扰了我一周,暂时先记录处理办法,后续完善解决步骤</p><p>主要是依据这篇文章来解决处理的<br><a href="https://cloud.tencent.com/developer/article/1622207">https://cloud.tencent.com/developer/article/1622207</a></p><ul><li>maven-shade-plugin模板</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-shade-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!-- put your configurations here --></span>                <span class="token comment">&lt;!--只包含该项目代码中用到的jar,在父项目中引入了，但在当前模块中没有用到就会被删掉--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>minimizeJar</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>minimizeJar</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!--重新定位类位置，就好像类是自己写的一样，修改别人jar包的package--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relocations</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relocation</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>com.alibaba.fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedPattern</span><span class="token punctuation">></span></span>com.gavinzh.learn.fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedPattern</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--这些类和包不会被改变--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>com.alibaba.fastjson.not.Exists<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>com.alibaba.fastjson.not.exists.*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relocation</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relocations</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                        <span class="token comment">&lt;!--创建一个你自己的标识符，位置在原有名称之后--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedArtifactAttached</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedArtifactAttached</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shadedClassifierName</span><span class="token punctuation">></span></span>gavinzh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shadedClassifierName</span><span class="token punctuation">></span></span>                        <span class="token comment">&lt;!--在打包过程中对文件做一些处理工作--></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformers</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--在META-INF/MANIFEST.MF文件中添加key: value 可以设置Main方法--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span>                                    <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ManifestResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestEntries</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.gavinzh.learn.shade.Main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Build-Number</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Build-Number</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Built-By</span><span class="token punctuation">></span></span>your name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Built-By</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>X-Compile-Source-JDK</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>X-Compile-Source-JDK</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>X-Compile-Target-JDK</span><span class="token punctuation">></span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>X-Compile-Target-JDK</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestEntries</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--阻止META-INF/LICENSE和META-INF/LICENSE.txt--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ApacheLicenseResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token comment">&lt;!--合并所有notice文件--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ApacheNoticeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addHeader</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addHeader</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--如果多个jar包在META-INF文件夹下含有相同的文件，那么需要将他们合并到一个文件里--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.handlers<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.schemas<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.factories<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring-form.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.AppendingTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/spring.tooling<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--如果多个jar包在META-INF文件夹下含有相同的xml文件，则需要聚合他们--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ComponentsXmlResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token comment">&lt;!--排除掉指定资源文件--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.DontIncludeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>.no_need<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--将项目下的文件file额外加到resource中--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.IncludeResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>META-INF/pom_test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>pom.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformer</span><span class="token punctuation">></span></span>                            <span class="token comment">&lt;!--整合spi服务中META-INF/services/文件夹的相关配置--></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transformer</span> <span class="token attr-name">implementation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.maven.plugins.shade.resource.ServicesResourceTransformer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transformers</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>shade<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;maven-shade-plugin使用中的小问题&lt;/h1&gt;
&lt;p&gt;maven-shade-plugin打包导致META-INF/SERVICES中的文件丢失,导致jar在动态加载时无法启动.这个问题困扰了我一周,暂时先记录处理办法,后续完善解决步骤&lt;/p&gt;
&lt;p&gt;主要是</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="markdown模板" scheme="https://agmtopy.gitee.io/tags/markdown%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源代码分析之启动原理分析</title>
    <link href="https://agmtopy.gitee.io/2022/04/12/22.springboot/1.SpringBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2022/04/12/22.springboot/1.SpringBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2022-04-12T12:46:39.000Z</published>
    <updated>2022-09-24T09:06:04.430Z</updated>
    
    <content type="html"><![CDATA[<h1>SpringBoot源代码分析之启动原理分析</h1><h2 id="引言"><a class="header-anchor" href="#引言"></a>引言</h2><p>这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程思想-核心篇》的章节,在参考SpringBoot源代码分析而来,希望对你有所帮助</p><h2 id="准备工作"><a class="header-anchor" href="#准备工作"></a>准备工作</h2><p>参考项目为地址为:<a href="https://github.com/agmtopy/SpringBootExample">https://github.com/agmtopy/SpringBootExample</a></p><h2 id="启动类概览"><a class="header-anchor" href="#启动类概览"></a>启动类概览</h2><p>在项目中,启动类为<code>SpringDemoApplication</code>,这个类应该是一切的开始,下面我们就来根据这个<B>run</B>方法来进行分析</p><ul><li>SpringDemoApplication</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringDemoApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringDemoApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>执行链路</li></ul><p>可以看到执行链路为:</p><p>这里有一个小细节,在没有提前初始化SpringApplication()时是不能使用arthas进行插入代码,显示错误为图一</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/S-springboot%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/Arthas_SpringApplicationRun1.jpg?raw=true" alt="图1"></p><p>查看相关类信息也没有看到类加载</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/S-springboot%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/Arthas_SpringApplicationRun2.jpg?raw=true" alt="图2"></p><p>经过分析可以知道这时候<B>SpringApplication</B>类还没有加载</p><h2 id="SpringApplication-run"><a class="header-anchor" href="#SpringApplication-run"></a>SpringApplication.run()</h2><ul><li>run()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">      <span class="token comment">//1. 构造方法  </span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> primarySources<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span class="token comment">//2. 构造方法</span>   <span class="token keyword">public</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">ResourceLoader</span> resourceLoader<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//1. 初始化ResourceLoader</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">=</span> resourceLoader<span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">,</span> <span class="token string">"PrimarySources must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>primarySources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType <span class="token operator">=</span> <span class="token class-name">WebApplicationType</span><span class="token punctuation">.</span><span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>bootstrapRegistryInitializers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">BootstrapRegistryInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token punctuation">)</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass <span class="token operator">=</span> <span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>run()方法最后是执行<B>SpringApplication</B>的初始化方法:</p><p><img src="" alt="图3"></p><ul><li>run()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 运行Spring应用程序，创建并刷新新的容器 */</span><span class="token keyword">public</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//1. 执行需要在初始化开始时执行的钩子方法</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">preRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 获取初始化时间</span><span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3.初始化BootStrapContext(引导上下文)</span><span class="token class-name">DefaultBootstrapContext</span> bootstrapContext <span class="token operator">=</span> <span class="token function">createBootstrapContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ConfigurableApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//4. 配置head头属性</span><span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 获取运行中的执行监听器</span><span class="token class-name">SpringApplicationRunListeners</span> listeners <span class="token operator">=</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6. 启动监听器</span>listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token comment">//7. 初始化应用程序参数</span><span class="token class-name">ApplicationArguments</span> applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8. 准备运行环境</span><span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span> bootstrapContext<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//9. 设置需要忽略的bean</span><span class="token function">configureIgnoreBeanInfo</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10. 打印Banner信息</span><span class="token class-name">Banner</span> printedBanner <span class="token operator">=</span> <span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//11. 创建ApplicationContext</span>context <span class="token operator">=</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//12. 设置应用程序启动器(用于收集启动过程中的一些信息)</span>context<span class="token punctuation">.</span><span class="token function">setApplicationStartup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//13. 准备启动ApplicationContext</span><span class="token function">prepareContext</span><span class="token punctuation">(</span>bootstrapContext<span class="token punctuation">,</span> context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//14. 判断是否需要重新刷新容器</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//15. 后置刷新容器方法</span><span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//16. 记录时间</span><span class="token class-name">Duration</span> timeTakenToStartup <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofNanos</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>timeTakenToStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//17. 设置监听时间</span>listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> timeTakenToStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//18. 执行Runner方法</span><span class="token function">callRunners</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Duration</span> timeTakenToReady <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofNanos</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>listeners<span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> timeTakenToReady<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//19. 执行后置Hook后置方法</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">postRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> context<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到run方法的执行过程分为几个阶段:</p><ul><li><p><B>前置准备阶段</B></p><ul><li>执行前置钩子方法(步骤一)</li><li>初始化引导上下文(步骤二\步骤三\步骤四)</li><li>设置启动监听器 (步骤五\步骤六)</li></ul></li><li><p><B>启动容器阶段</B></p><ul><li>初始化应用参数(步骤七\八\九\十)</li><li>创建容器(步骤十一\十二\十三)</li></ul></li><li><p><B>刷新容器阶段</B></p><ul><li>刷新容器(步骤十四)</li><li>创建容器(步骤十五)</li></ul></li><li><p><B>执行后置方法阶段</B></p><ul><li>执行Runner(步骤十八)</li><li>执行hook(步骤十九)</li></ul></li></ul><h2 id="前置准备阶段"><a class="header-anchor" href="#前置准备阶段"></a>前置准备阶段</h2><p><B>前置准备阶段</B>主要是设置一些容器上下文和钩子函数,下面详细分析一下这几个功能的实现</p><h3 id="执行前置钩子方法"><a class="header-anchor" href="#执行前置钩子方法"></a>执行前置钩子方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置钩子方法</span><span class="token class-name">SpringApplicationHooks</span><span class="token punctuation">.</span><span class="token function">hooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">preRun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个方法是在针对于AOT的启动过程中提供的钩子方法,最早应用于<B>v3.0.0-M4</B>版本中,<a href="https://github.com/spring-projects/spring-boot/commit/9cd17f8a14eab8007c372c045a6b9295a3a56126?diff=unified">commit</a></p><p>下面来继续分析<B>SpringApplicationHooks</B>的执行流程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SpringApplicationHooks</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Hooks</span><span class="token punctuation">></span></span> hooks <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token class-name">Hooks</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">withHook</span><span class="token punctuation">(</span><span class="token class-name">Hook</span> hook<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> action<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//....</span><span class="token punctuation">&#125;</span><span class="token comment">//钩子接口</span><span class="token keyword">interface</span> <span class="token class-name">Hook</span> <span class="token punctuation">&#123;</span><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">preRun</span><span class="token punctuation">(</span><span class="token class-name">SpringApplication</span> application<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">postRun</span><span class="token punctuation">(</span><span class="token class-name">SpringApplication</span> application<span class="token punctuation">,</span> <span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">preRefresh</span><span class="token punctuation">(</span><span class="token class-name">SpringApplication</span> application<span class="token punctuation">,</span> <span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>SpringApplicationHooks</B>主要是由两个部分组成:</p><ul><li>本身的线程变量属性<B>hooks</B>和设置方法<B>withHook</B></li><li><B>hook</B>接口定义的方法:<B>preRun():开始执行</B>、<B>postRun():run()方法执行完成后执行</B>、<B>preRefresh():指定刷新前执行</B></li></ul><p>目前hook有两个实现类,在SpringApplicationHooks中默认实现的<B>hooks</B>以及在AOT模块中的实现类<B>AotProcessorHook</B></p><p>下面对<B>Hook</B>的方法的调用过程进行分析</p><ul><li>preRun</li></ul><p><img src="" alt="preRun调用过程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;SpringBoot源代码分析之启动原理分析&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;p&gt;这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://agmtopy.gitee.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="https://agmtopy.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux的定时测量分析</title>
    <link href="https://agmtopy.gitee.io/2022/04/02/21.linux/linux%E7%9A%84%E5%AE%9A%E6%97%B6%E6%B5%8B%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2022/04/02/21.linux/linux%E7%9A%84%E5%AE%9A%E6%97%B6%E6%B5%8B%E9%87%8F%E5%88%86%E6%9E%90/</id>
    <published>2022-04-02T05:28:22.000Z</published>
    <updated>2022-04-02T10:16:07.537Z</updated>
    
    <content type="html"><![CDATA[<h1>linux的定时测量分析</h1><p>定时测量之前的文章学习中的初步印象,是由特殊的电路系统上报给操作系统的一种信号量。下面是《深入理解Linux内核》一书中的阐述和思考。</p><h2 id="定时测量"><a class="header-anchor" href="#定时测量"></a>定时测量</h2><p>操作系统中需要处理的<B>定时测量</B>主要是两种：</p><ul><li>测量当前的日期和时间</li><li>维持定时器，以便测量出某一时间间隔</li></ul><p>定时测量是通过一种基于固定的频率振荡设备和计数器设备来实现的，下面介绍一下这几个硬件设备。</p><h3 id="时钟和定时器电路"><a class="header-anchor" href="#时钟和定时器电路"></a>时钟和定时器电路</h3><ul><li>实时时钟-RTC<br>实时时钟(Renl Time Clock RTC)是一个独立于CPU和其他芯片的设备，即使当计算设备被切断电源时，它还是还能正常工作。</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/RTC.jpg?raw=true" alt="RTC产品图"></p><p>在现代的计算机结构中，RTC设备通常被集成到南桥中</p><ul><li>时间戳计数器-TSC</li></ul><p>时间戳计数器是用来接收外部传递的振荡器的时钟信号。在x86架构下是通过一条名叫<B>CLK</B>的输入总线和一个名叫<B>时间戳计时器寄存器</B>来实现的。</p><ul><li><p>可编程间隔定时器-PIT<br>PIT与RTC类似，也是一个独立于CPU和其他芯片的设备，但是它的工作方式与RTC不同。PIT是通过按照固定的频率发送一个特殊的中断信号来实现的。</p></li><li><p>CPU本地定时器</p></li></ul><p>CPU本地定时器的工作原理与PIT类似都是发送一个特殊的中断信号，但是不同点在于，CPU本地定时器是据语系统总线的时钟信号量的值来实现的。</p><ul><li>高精度事件定时器-HPET</li></ul><p>高精度事件定时器是由MS与Intel共同研发的一种新型定时器,目前应该是支持最广泛的定时器,内部主要包括8个32位或64位的独立计数器，在windows下通过设备管理器插看到</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/HPET.jpg?raw=true" alt="HPET"></p><p>在参考资料2中可以看到时钟频率对游戏帧率的影响，游戏帧率越高，时钟频率越低，这样的话，游戏的性能就会越好。这里的原理类似于显示屏幕的物理帧率对游戏性能的影响一样,可以看一下B站Up主的一个视频<a href="https://www.bilibili.com/video/BV19L411N7xw?spm_id_from=333.999.0.0">游戏帧数竟然可以影响永劫的攻击速度？！</a></p><ul><li>ACPI定时器</li></ul><p>ACPI电源管理定时器几乎存在所有的ACPI主板上，它是一个简单的计数器，每次时钟节拍到来时，寄存器就加1.</p><p>以上是一些定时器的简单介绍，主要有<B>RTC</B>、<B>HPET</B></p><h2 id="Linux计时体系结构"><a class="header-anchor" href="#Linux计时体系结构"></a>Linux计时体系结构</h2><p>linux启动后必须执行的与时间相关的操作是以下几个：</p><ul><li>更新系统启动以后经过的时间</li><li>更新当前日期和时间</li><li>确定当前进程在每一个CPU上运行的时间</li><li>更新资源使用统计数量<br>-检查每一个软件定时器的时间间隔是否达到</li></ul><p>在多处理器系统中，每一个CPU都有一个时钟，它的频率可以被设置，默认的频率是1GHz，也就是说，每秒钟的时钟节拍数是1000000。普通活动(例如:软定时器)都是由全局定时器产生的中断触发的；CPU的活动则是由本地的APIC产生的中断触发的。</p><p>(PS:APIC与ACPI的区别，ACIP是本地CPU定时器，而APIC是全局电源方面的定时器，优先级较高)</p><p>内核会提供两个最基本的计时函数:一个保持对当前时间的记录，一个计算当前秒内流逝的纳秒数</p><ul><li>计时体系的数据结构</li></ul><p>这里主要介绍一个<B>jiffies变量</B>,这个变量是用于记录系统启动后产生的节拍数，但是在X86架构下这个变量使用的是一个32位置的有符号值,因此大约只需要50天左右就会置为0，这被称为时钟回绕问题，linux提供了time_after和time_before函数来解决这个问题。解决问题的思路是通过先将32位的数据转化为64位的long类型来比较，这样做的原理是，当32位的数据转化为64位的long类型后，其符号位会被置为0，从一个有符号数变成了无符号数，在对差值与0进行比较，就可以解决时钟回绕问题。</p><p>关于这个<B>jiffies变量</B>还有一个指的注意的地方是，它在初始化时，并不是赋的0，而是负3W多的一个数字,这样做的目的是尽早的发现时钟回绕问题是否被正确的处理，这里面实际体现了一种不可靠思想，想尽量的让问题尽早的暴露出来，指的学习!</p><p>jiffies变量为什么选择的是32位而不是64位,这里主要是因为在32位系统中对64位数值的访问需要使用两个32位数值来处理，这样操作两次比直接操作32位的数值要慢一些</p><h2 id="定时测量的应用"><a class="header-anchor" href="#定时测量的应用"></a>定时测量的应用</h2><ul><li>更新日期和时间</li><li>更新系统统计数据，例如CPU统计数、系统负载等</li><li>监管内核代码，例如每次时钟中断时判断当前系统正在做什么</li><li>检查非屏蔽中断监视器,监控系统内核的运行情况</li><li>软定时器与延迟函数</li></ul><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>Linux的定时测量是通过不同的硬件来实现的，有记录当前时间的RTC、有记录系统启动时间的TSC、有记录CPU的时钟周期的APIC、有记录全局时间的电源定时器ACPI、记录高精度时间的HPET等。操作系统通过这些定时器来实现记录系统运行状态、记录当前时间、记录流逝时间等功能。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="http://manpages.ubuntu.com/manpages/xenial/man4/rtc.4.html">ubuntu RTC驱动说明书</a><br><a href="https://silicophilic.com/disabling-hpet-settings/">如何通过禁用 HPET 设置来提高游戏性能</a><br><a href="https://blogs.gnome.org/raywang/2007/11/19/acpi%E5%92%8Capic%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB/">ACPI和APIC有什么关系</a><br><a href="https://www.modb.pro/db/217433">jiffies如何避免时钟回绕问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;linux的定时测量分析&lt;/h1&gt;
&lt;p&gt;定时测量之前的文章学习中的初步印象,是由特殊的电路系统上报给操作系统的一种信号量。下面是《深入理解Linux内核》一书中的阐述和思考。&lt;/p&gt;
&lt;h2 id=&quot;定时测量&quot;&gt;&lt;a class=&quot;header-anchor&quot; href</summary>
      
    
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="https://agmtopy.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>银行会计-笔记</title>
    <link href="https://agmtopy.gitee.io/2022/03/27/1.%E6%9D%82%E8%AE%B0/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1-%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2022/03/27/1.%E6%9D%82%E8%AE%B0/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1-%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-27T07:10:10.000Z</published>
    <updated>2022-05-05T13:29:58.697Z</updated>
    
    <content type="html"><![CDATA[<h1>《银行会计》笔记</h1><p>《银行会计》一书是席总带给我看的，一直以来在对这方面的知识都比较匮乏，以下是我在阅读这本书是做的一些笔记,希望能对你有帮助,开心😋😋😋</p><h2 id="第二章-银行会计的基本核算方法"><a class="header-anchor" href="#第二章-银行会计的基本核算方法"></a>第二章:银行会计的基本核算方法</h2><h3 id="会计科目"><a class="header-anchor" href="#会计科目"></a>会计科目</h3><blockquote><p>会计科目指的是对会计对象的具体内容按照不同的性质和经济管理的要求进行分类，分类后的种种科目就是会计科目</p></blockquote><p>会计科目就是根据一些法规和自身的场景/要求，将经营过程/活动分解成的科目，通过这些科目就可以按照一定的维度，统计出经营结果，从而进行会计分析</p><h3 id="会计科目的分类"><a class="header-anchor" href="#会计科目的分类"></a>会计科目的分类</h3><blockquote><p>1.按照资产负载表进行分类</br>2. 按照会计科目所反映的经营活动进行分类(这里可以理解为按照会计科目来进行分类，因为会计科目的编码是要符号一定的经济活动的</p></blockquote><ul><li><p>按照资产负载表进行分类<br>按照这种方式主要是通过资产负载表来进行分类，这种方式的好处就是可以按照资产负载表的结构来进行分类，这种方式的缺点就是不能按照经营活动的结构来进行分类，因为经营活动的结构是不确定的，这里引申出一个概念<B>资产负载表</B></p><ul><li>资产负载表<blockquote><p>资产负债表是反应企业在<B>某一特点时间</B>的<B>财务状况</B>的报表,是企业经营活动的<B>静态</B>展示;由两个方面组成<B>资产</B>、<B>负债与股东权益</B>两个大的方面组成<br>会计科目按照资产负载表的关系进行分类就可以划分为<B>表内科目</B>、<B>表外科目</B></p></blockquote></li></ul><p>这里又引申出来两个概念<B>表内科目</B>、<B>表外科目</B></p><ul><li><p>表内科目</p><blockquote><p>表内科目指的是反映银行资金发生增减变化的会计科目，其余额会在资产负债表上体现，用于表示复式记账法的会计核算过程</p></blockquote></li><li><p>表外科目</p><blockquote><p>表外科目指的是核算业务中已发生，但是尚未涉及资金增减的事项的科目，其余额不会在负债资产表上体现，用于单式记账法的会计核算过程<br>表外科目主要用于指代不列入资产负债表内和损益表内的会计科目，主要用于金融行业内使用的一类特殊科目，这里的<B>表</B>指的是资产负债表。</p></blockquote></li></ul></li><li><p>按照经营活动进行分类</p><ul><li>资产类科目</li><li>负债类科目</li><li>资产负债共同类科目</li><li>所有者权益类科目</li><li>损益类科目<br>以下是一个银行会计科目表列子</li></ul></li><li><p>银行会计科目表</p></li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1%E7%A7%91%E7%9B%AE%E8%A1%A8.jpg?raw=true" alt=""><br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E9%93%B6%E8%A1%8C%E4%BC%9A%E8%AE%A1%E7%A7%91%E7%9B%AE%E8%A1%A81.jpg?raw=true" alt="银行会计科目表"></p><p>可以看到会计科目表分为5大分类，分别对应不同的经营活动</p><h3 id="科目代号"><a class="header-anchor" href="#科目代号"></a>科目代号</h3><p>从上面的银行会计科目表中可以看到，不同的科目都有一个特定的编号，分别由两个部分组成<B>一级科目</B>、<B>二级科目</B></p><ul><li><p>一级科目<br>一级科目的编排规则是：第一位数字代表科目的资金性质，即：1-代表资产类科目；2-代表负债类科目；3-代表所有者权益类科目；4-代表资产负债类科目；5-代表损益类科目；6~9代表表外科目及补充资料；第二位数字代表业务性质；剩下两位表示顺序；</p></li><li><p>二级科目<br>二级科目是一般是由6位组成，前四位是一级科目，后两位表示顺序</p></li></ul><h3 id="记账方法"><a class="header-anchor" href="#记账方法"></a>记账方法</h3><p>记账方法指的是在核算过程中，按照那样的规则进行处理；我们需要知道的就是表内用<B>复式记账法</B>、表外用<B>单式记账法</B></p><ul><li>单式记账法<br>单式记账法指的是对每一次经营活动只会在一个科目中进行登记，即：一个科目只会记录一次，不会出现多次记账的情况，这样的记账方式优点是简单,缺点是不能反映完整的经营活动</li><li>复式记账法<br>复式记账法指的是对于每笔经营活动都需要在多个科目中进行登记，即：一个科目可以记录多次，这样的记账方式优点是可以反映完整的经营活动，缺点是记账方式复杂，不能简单地反映经营活动</li></ul><p>简单的理解就是，单式记账法只能记录一次经营活动的结果，而不是过程，复式记账法记录的是一个经营活动的过程，通过在两个以上的账户中同时描述同一笔经营活动的过程，可以反映完整的经营活动</p><p>根据复式记账法原理演化出来的<B>借贷记账法</B>是国际通用的记账法，主要包括记账主体、记账符号、记账规则、试算平衡四个方面</p><ul><li>借贷记账法</li></ul><blockquote><p>借贷记账法是根据复式记账法原理,以<B>‘借’</B>、<B>‘贷’</B>作为记账符号，以<B>有借必有贷，借贷必相等</B>作为记账规则，用以记录和反映经济业务发生而导致的会计要素增减编号过程及其结果的一种复试记账法<br>可以从上面的表述中得知，借贷记账法的的目标是描述经济活动的<B>过程</B>和<B>结果</B>这两方面。</p></blockquote><ul><li>记账主体</li></ul><blockquote><p>记账主体指的是借贷记账法进行记账时，记录的是一条条<B>会计科目</B>，这些会计科目就是借贷记账法的记账主体。</p></blockquote><ul><li>记账符号</li></ul><blockquote><p>记账符号指的是<B>借</B>、<B>贷</B>，这两个符号，表示的是科目的方向，在前面的会计科目中可以得知会计科目实际上是没有方向概念的，只是描述经济活动的过程，因此需要有方向概念，这个方向概念就是记账符号。</p></blockquote><ul><li><p>记账规则<br><B>有借必有贷,借贷必相等</B>，这个规则是根据’资产 = 负载 + 所有者权益’的会计恒等式作为理论基础发展而来，通俗的表述就是：<B>即一笔经济业务的发生，必然会在一个账户的借方和贷方登记相同的金额，以达到会计分录是借贷平衡的结果</B>。</p></li><li><p>试算平衡<br>试算平衡指的是在记账过程中如果每笔经济活动记账时都满足’记账规则’时，那么在核对<B>发生额</B>和<B>余额</B>时也应该是相等的。银行每天按照总账维度核对借方和贷方的发生额和总额。</p></li></ul><p><img src="" alt="试算平衡表"></p><p>以上是借贷记账法的组成元素，分别是记账主体、记账符号、记账规则、试算平衡四个方面。复式记账法可以较好的描述表内的资产增减过程，但是对于表外资产就不太适用，因此表外资产采用的是单式记账法，即采用收入和支出作为记账符号，业务事项发生时计入<B>收入</B>、业务事项注销或冲正时计入<B>付出</B>；余额表示尚未结算的业务事项；</p><h3 id="账务组织"><a class="header-anchor" href="#账务组织"></a>账务组织</h3><p>账务组织指的是根据会计凭证对经济业务活动进行核算，分为<B>账务明细</B>、<B>综合核算</B>两个大的方面组成，都会根据<B>账簿</B>来进行记录，账簿分为<B>明显账</B>、<B>日记账</B>、<B>总账</B>、<B>登记簿</B>四种类型</p><ul><li><p>明细账<br>明细账指的是会计账簿中反映相关业务情况的账簿</p></li><li><p>总账<br>总账指的是银行会计账簿中综合核算和监督各项经济业务的分类账簿，它是综合核算和明显核算相互核对以及统驭明显分户账的主要工具</p></li><li><p>日记账<br>日记账主要是核算现金收入和现金付出的日记账，是现金收入和现金付出的详细记录</p></li><li><p>登记簿<br>登记簿主要是用于记录表外科目的增减变化的账簿</p></li></ul><h2 id="第四章-贷款业务的核算"><a class="header-anchor" href="#第四章-贷款业务的核算"></a>第四章:贷款业务的核算</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;《银行会计》笔记&lt;/h1&gt;
&lt;p&gt;《银行会计》一书是席总带给我看的，一直以来在对这方面的知识都比较匮乏，以下是我在阅读这本书是做的一些笔记,希望能对你有帮助,开心😋😋😋&lt;/p&gt;
&lt;h2 id=&quot;第二章-银行会计的基本核算方法&quot;&gt;&lt;a class=&quot;header-an</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://agmtopy.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GitLab CI/CD与GitHub Actions的介绍和使用</title>
    <link href="https://agmtopy.gitee.io/2022/03/25/1.%E6%9D%82%E8%AE%B0/GitLab_CI-CD%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://agmtopy.gitee.io/2022/03/25/1.%E6%9D%82%E8%AE%B0/GitLab_CI-CD%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-25T15:27:37.000Z</published>
    <updated>2022-10-29T02:56:50.100Z</updated>
    
    <content type="html"><![CDATA[<h1>GitLab CI/CD与GitHub Actions的介绍和使用</h1><p>本篇日志主要是用来记录<B>GitLab</B>的CI/CD与<B>GitHub Actions</B>的介绍和使用。先从操作GitLab的CI/CD开始</p><h2 id="GitLab-CI-CD"><a class="header-anchor" href="#GitLab-CI-CD"></a>GitLab CI/CD</h2><p>GitLab支持多种CI方式,本身有Ai DevOps的支持,如下所示</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/gitlab_ai_devops.jpg?raw=true" alt="GitLab AI DevOps"></p><p>启动Ai DevOps后gitlab会根据项目的语言使用一套预设的模板,具体可以参考<a href="https://docs.gitlab.com/ee/topics/autodevops/index.html">GitLab Ai DevOps</a></p><p>在我们的演示项目中,我们可以选择开启Ai DevOps,但是实际并不会使用,而是使用我们项目中自定义的<B>.gitlab-ci.yml</B>文件</p><p>接下来介绍,让我们开始学习如何自定义GitLab的CI/CD与gradle结合使用.</p><ul><li>前置条件:<ul><li>项目地址:<a href="https://github.com/agmtopy/testcontainers-simple">https://github.com/agmtopy/testcontainers-simple</a></li></ul></li><li>步骤:<ul><li>clone 项目到本地</li><li>修改.gitlab-ci.yml文件</li><li>上传到GitLab</li><li>执行构建</li></ul></li></ul><p>下面来详细的做一下步骤二和步骤四</p><h3 id="修改-gitlab-ci-yml文件"><a class="header-anchor" href="#修改-gitlab-ci-yml文件"></a>修改.gitlab-ci.yml文件</h3><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">services:  - name: docker:dind         # Testcontainers需要docker in docker    command: [&quot;--tls&#x3D;false&quot;]  # 禁用tls以避免docker启动中断variables:  DOCKER_HOST: &quot;tcp:&#x2F;&#x2F;docker:2375&quot;  DOCKER_TLS_CERTDIR: &quot;&quot;  DOCKER_DRIVER: overlay2  GRADLE_OPTS: &quot;-Dorg.gradle.daemon&#x3D;false&quot;stages:          # 作业的阶段列表及其执行顺序  - build  - test  - deploybuild-job:       # 此作业在构建阶段运行，构建阶段是最先执行的  image: gradle:7.4.1-jdk11-alpine  stage: build  script:    - echo &quot;开始编译代码...&quot;    - gradle clean compileJava    - echo &quot;编译代码完成...&quot;test-job:        # 此作业在测试阶段运行，测试阶段在第二阶段执行的  image: gradle:7.4.1-jdk11-alpine  stage: test  script:    -  echo &quot;开始测试代码...&quot;    - gradle test --info    - echo &quot;测试代码完成...&quot;deploy-job:      # 此作业在部署阶段运行  stage: deploy  # 只有当之前两个阶段都成功完成时，才会执行部署的。  script:    - echo &quot;开始部署代码...&quot;    - echo &quot;部署代码完成..&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面这个.gitlab-ci.yml文件中,有一个稍微特殊一点的地方在于,由于我们的代码中使用到了testcontainers,所以我们需要在.gitlab-ci.yml文件中添加一个service,这个service是用来启动testcontainers相关容器的,具体可以参考<a href="https://docs.gitlab.com/runner/install/docker.html#install-the-docker-image-and-start-the-container">安装 Docker 镜像并启动容器</a></p><p>然后我们定义了三个阶段:build,test,deploy,这三个阶段的执行顺序是:build-job,test-job,deploy-job,这样我们就可以在GitLab中按照顺序执行这三个阶段的作业了,在流水线中我们也可以看到</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%B5%81%E6%B0%B4%E7%BA%BF.jpg?raw=true" alt="流水线"></p><p>由于我们没有资源,不能进行deploy,在这个阶段实际上只是打印一下,之前的build-job和test-job阶段分别是执行:<br>- gradle clean compileJava<br>- gradle test --info</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg?raw=true" alt="执行结果"></p><p>通过在流水线中点击相关的阶段,可以看到详细的日志</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97.jpg?raw=true" alt="执行日志"></p><h2 id="GitHub-Actions"><a class="header-anchor" href="#GitHub-Actions"></a>GitHub Actions</h2><p>GitHub Actions是github推出的一套发现、创建和共享操作以执行您喜欢的任何作业（包括 CI/CD），并将操作合并到完全自定义的工作流程。</p><h3 id="创建Actions"><a class="header-anchor" href="#创建Actions"></a>创建Actions</h3><p>在Actions中,选择对应的模板进行创建</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_1.jpg?raw=true" alt="创建workflows"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_2.jpg?raw=true" alt="选择模板"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_3.jpg?raw=true" alt="模板"></p><h3 id="执行Actions"><a class="header-anchor" href="#执行Actions"></a>执行Actions</h3><p>创建完成Actions后,会自动运行.运行结果可以在workflow中查看</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_4.jpg?raw=true" alt="执行Actions"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_5.jpg?raw=true" alt="执行结果"></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/GitHub_Actions_5.jpg?raw=true" alt="执行日志"></p><p>注意:</p><ul><li>编译gradle项目出现’Error: Gradle script ‘/home/runner/work/testcontainers-simple/testcontainers-simple/gradlew’ is not executable.'的问题是由于我们项目中的gradlew文件不是可执行的,所以需要将其设置为可执行的,在项目中执行<B>git update-index --chmod=+x gradlew</B>即可</li></ul><h3 id="Actions配置解释"><a class="header-anchor" href="#Actions配置解释"></a>Actions配置解释</h3><ul><li>main.yml</li></ul><pre class="line-numbers language-yml文件" data-language="yml文件"><code class="language-yml文件"># This workflow uses actions that are not certified by GitHub.# They are provided by a third-party and are governed by# separate terms of service, privacy policy, and support# documentation.# This workflow will build a Java project with Gradle and cache&#x2F;restore any dependencies to improve the workflow execution time# For more information see: https:&#x2F;&#x2F;help.github.com&#x2F;actions&#x2F;language-and-framework-guides&#x2F;building-and-testing-java-with-gradlename: Java CI with Gradleon: push        # 触发事件jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions&#x2F;checkout@v2    - name: Set up JDK 11      uses: actions&#x2F;setup-java@v2      with:        java-version: &#39;11&#39;        distribution: &#39;temurin&#39;    - name: Build with Gradle      uses: gradle&#x2F;gradle-build-action@0d13054264b0bb894ded474f08ebb30921341cee      with:        arguments: build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>github的CI/CD配置就比gitlab的配置看起来要清爽很多,主要是分为三个部分:</p><ul><li><p>name<br>name主要是用来标识这个workflows的名称的</p></li><li><p>on<br>on主要是用来标识触发Actions的动作的</p></li><li><p>jobs<br>jobs又很为两个部分:</p><ul><li>runs-on<br>标识运行的基础环境</li><li>steps<br>标识运行的步骤,其中with.arguments是用来指定gradle的参数的</li></ul></li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>GitLab和GitHub的CI/CD在使用上都是比较简单的,只需要使用到专用的配置文件就可以触发,需要主要一点的是GitLab的配置文件中需要指定Docker in Docker配置,<br>而GitHub Actions使用上要比GitLab的.gitlab-ci.yml要方便,可以直接从marketplace下载已经预设好的模板,直接进行使用.配置文件中也不需要指定运行环境</p><h2 id="参考文档"><a class="header-anchor" href="#参考文档"></a>参考文档</h2><p><a href="https://about.gitlab.com/install/">gitlab install</a><br><a href="https://help.aliyun.com/document_detail/52857.html">安装和使用GitLab</a><br><a href="http://blinkfox.com/2018/11/22/ruan-jian-gong-ju/devops/gitlab-ci-jie-shao-he-shi-yong/#toc-heading-20">GitLab CI/CD 介绍和使用</a><br><a href="https://zq99299.github.io/note-combat/gitlab/cicd/">CI/CD</a><br><a href="https://docs.github.com/cn/actions/quickstart">GitHub Actions 快速开始</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;GitLab CI/CD与GitHub Actions的介绍和使用&lt;/h1&gt;
&lt;p&gt;本篇日志主要是用来记录&lt;B&gt;GitLab&lt;/B&gt;的CI/CD与&lt;B&gt;GitHub Actions&lt;/B&gt;的介绍和使用。先从操作GitLab的CI/CD开始&lt;/p&gt;
&lt;h2 id=&quot;GitL</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://agmtopy.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>pulsar的简单使用</title>
    <link href="https://agmtopy.gitee.io/2022/03/19/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/50.pulsar%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://agmtopy.gitee.io/2022/03/19/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/50.pulsar%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-19T05:45:03.000Z</published>
    <updated>2022-03-30T13:52:19.889Z</updated>
    
    <content type="html"><![CDATA[<h1>pulsar的简单使用</h1><p>Apache Pulsar 是一个云原生的分布式消息传递和流媒体平台，最初由 Yahoo! 创建。现在是作为Apache软件基金会的顶级项目.<br>在pulsar这个项目中还大量使用了另外一个Apache的顶级项目<B>Bookkeeper</B>作为存储层的解决方案,在研究完成Pulsar之后也会对Bookkeeper进行研究.<br>本文用于记录本地安装Pulsar的过程,希望对你有所帮助,祝好!</p><h2 id="安装Pulsar"><a class="header-anchor" href="#安装Pulsar"></a>安装Pulsar</h2><p>根据官网介绍安装Pulsar一共有三种安装方式,分别是</p><ul><li>本地运行</li><li>docker中运行</li><li>k8s中运行</li></ul><h3 id="本地运行"><a class="header-anchor" href="#本地运行"></a>本地运行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#下载</span>$ <span class="token function">wget</span> https://archive.apache.org/dist/pulsar/pulsar-2.9.1/apache-pulsar-2.9.1-bin.tar.gz<span class="token comment">#解压</span>$ <span class="token function">tar</span> xvfz apache-pulsar-2.9.1-bin.tar.gz<span class="token comment"># 启动pulsar</span>$ <span class="token builtin class-name">cd</span> apache-pulsar-2.9.1$ bin/pulsar standalone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="docker中运行"><a class="header-anchor" href="#docker中运行"></a>docker中运行</h3><ul><li>pulsar</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -it -p <span class="token number">6650</span>:6650  -p <span class="token number">8080</span>:8080 --mount <span class="token assign-left variable">source</span><span class="token operator">=</span>pulsardata,target<span class="token operator">=</span>/pulsar/data --mount <span class="token assign-left variable">source</span><span class="token operator">=</span>pulsarconf,target<span class="token operator">=</span>/pulsar/conf apachepulsar/pulsar:2.9.1 bin/pulsar standalone -nfw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>pulsar admin</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动pulsar admin</span>docker run -it  -p <span class="token number">9527</span>:9527 -p <span class="token number">7750</span>:7750 -e <span class="token assign-left variable">SPRING_CONFIGURATION_FILE</span><span class="token operator">=</span>/pulsar-manager/pulsar-manager/application.properties apachepulsar/pulsar-manager:v0.2.0<span class="token comment"># 修改密码</span><span class="token function">curl</span>  -H <span class="token string">'X-XSRF-TOKEN: $CSRF_TOKEN'</span> -H <span class="token string">'Cookie: XSRF-TOKEN=$CSRF_TOKEN;'</span>  -H <span class="token string">"Content-Type: application/json"</span> -X PUT http://localhost:7750/pulsar-manager/users/superuser -d <span class="token string">'&#123;"name": "admin", "password": "apachepulsar", "description": "test", "email": "username@test.org"&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>pulsar admin</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/pulsar/puslarAdmin.jpg?raw=true" alt="pulsar admin"></p><h3 id="k8s中运行"><a class="header-anchor" href="#k8s中运行"></a>k8s中运行</h3><p>k8s中需要使用helm来运行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">helm install     <span class="token operator">--</span>values examples<span class="token operator">/</span>values<span class="token operator">-</span>minikube<span class="token punctuation">.</span>yaml     <span class="token operator">--</span>set initialize<span class="token operator">=</span><span class="token boolean">true</span>     <span class="token operator">--</span>namespace pulsar     pulsar<span class="token operator">-</span>mini apache<span class="token operator">/</span>pulsar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pulsar示例"><a class="header-anchor" href="#pulsar示例"></a>pulsar示例</h2><p>使用kotlin来演示</p><h3 id="普通消息功能"><a class="header-anchor" href="#普通消息功能"></a>普通消息功能</h3><ul><li>PulsarUtil</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 用于创建Pulasr使用中用到的一些工具 */</span><span class="token keyword">class</span> PulsarUtil<span class="token comment">/** * 创建pulsar客户端对象 */</span><span class="token keyword">fun</span> <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PulsarClient <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> PulsarClient<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">serviceUrl</span><span class="token punctuation">(</span><span class="token string">"pulsar://localhost:6650"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 创建Topic */</span><span class="token keyword">fun</span> <span class="token function">createProduct</span><span class="token punctuation">(</span>topic<span class="token operator">:</span> String<span class="token punctuation">,</span> client<span class="token operator">:</span> PulsarClient<span class="token punctuation">)</span><span class="token operator">:</span> Producer<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> client<span class="token punctuation">.</span><span class="token function">newProducer</span><span class="token punctuation">(</span>Schema<span class="token punctuation">.</span>STRING<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>PulsarProducer</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">class</span> PulsarProducer<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> client <span class="token operator">=</span> <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> product <span class="token operator">=</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"pulsar-topic-1"</span><span class="token punctuation">,</span> client<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        product<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"message:<span class="token interpolation variable">$i</span>"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>PulsarConsumer</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> client <span class="token operator">=</span> <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> subscribe <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">newConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token string">"pulsar-topic-1"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">subscriptionName</span><span class="token punctuation">(</span><span class="token string">"pulsar-topic-1-sub"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">ackTimeout</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">subscriptionType</span><span class="token punctuation">(</span>SubscriptionType<span class="token punctuation">.</span>Exclusive<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> receive <span class="token operator">=</span> subscribe<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"message:"</span> <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>receive<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>        subscribe<span class="token punctuation">.</span><span class="token function">acknowledge</span><span class="token punctuation">(</span>receive<span class="token punctuation">.</span>messageId<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个例子只是使用一个普通消息来演示pulsar的消息功能,推送完成后可以看到消息被消费了.</p><h3 id="异步消息功能"><a class="header-anchor" href="#异步消息功能"></a>异步消息功能</h3><blockquote><p>异步消息分为’异步发送’和’异步接收’,异步接收应该是puslar特有的功能,虽然业务代码在使用MQ时也可以通过自定义线程池的方式来完成异步接收的效果<br>下面展示一个发送消息和异步接收消息的示例</p></blockquote><ul><li>PulsarAsyncProducer</li></ul><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 异步消息 */</span><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">asyncMsg</span><span class="token punctuation">(</span>product<span class="token operator">:</span> Producer<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">":提交任务"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        product<span class="token punctuation">.</span><span class="token function">sendAsync</span><span class="token punctuation">(</span><span class="token string">"message:<span class="token interpolation variable">$i</span>|"</span> <span class="token operator">+</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAccept</span> <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Message with ID <span class="token interpolation variable">$it</span> successfully sent|"</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>执行结果</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/pulsar/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg?raw=true" alt="异步消息执行结果"></p><p>可以看到回调线程不是main,而是单独的一个线程池中的线程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;pulsar的简单使用&lt;/h1&gt;
&lt;p&gt;Apache Pulsar 是一个云原生的分布式消息传递和流媒体平台，最初由 Yahoo! 创建。现在是作为Apache软件基金会的顶级项目.&lt;br&gt;
在pulsar这个项目中还大量使用了另外一个Apache的顶级项目&lt;B&gt;Book</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="pulsar" scheme="https://agmtopy.gitee.io/tags/pulsar/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-内存部分</title>
    <link href="https://agmtopy.gitee.io/2022/03/07/20.%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E9%83%A8%E5%88%86/"/>
    <id>https://agmtopy.gitee.io/2022/03/07/20.%E7%AC%94%E8%AE%B0/2.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E9%83%A8%E5%88%86/</id>
    <published>2022-03-07T12:42:49.000Z</published>
    <updated>2022-03-30T14:09:46.851Z</updated>
    
    <content type="html"><![CDATA[<h1>编译原理-内存部分</h1><p>这一篇主要是对后端编译器对内存布局的分析和笔记,之前的有关词法/语法方面的理论知识实在是太枯燥了,翻了又翻是在是难以理解,只能暂时放下那一部分的内容了.<br>在编译时主要将内存划分为两个部分<B>栈</B>、<B>堆</B>：<br>栈主要是作为程序的临时空间实现方法、局部变量的区域<br>堆主要是作为分配大对象的区域</p><h2 id="存储组织"><a class="header-anchor" href="#存储组织"></a>存储组织</h2><blockquote><p>存储组织指的是内存区域，字节是内存中的最小编址单元.一个字节包含8个bit.多个连续的字节作为一块内存区域，并这块区域的第一个字节作为它的地址</p></blockquote><p>这里需要注意的是向操作系统申请的一段连续的内存空间可能并不是连续的，内存地址是操作系统提供的，在底层是通过页表的形式将物理上不连续的空间组织成为逻辑上连续的一段内存地址</p><blockquote><p>数据对象的存储分配受到目标机器的寻址约束影响很大。在很多机器中，执行整数加法的指令可能要求整数必须是位数相同(对齐)的。也就是说这些对象长度必须被4整除(4字节)。编译器可能会对数据进行指针对齐操作，对于空白的空间被称为<B>‘补白’</B></p></blockquote><p>'指针对齐’其实是由于CPU决定的，当现代CPU决定以2的指数倍数进行数据读取计算时，就决定了数据-指针的位数了。'补白’的指针在进行运算时肯定是优与未进行’补白’的指针的</p><blockquote><p>生成的目标代码在编译时刻就决定了编译后的大小了，因此编译器可以将可执行目标代码放到一个静态确定的区域:<B>代码区</B></p></blockquote><p>静态区域:<br>静态区域指的是在编译后就能确定内存分配的区域，例如代码区\JVM中的常量池等</p><p>动态区域:<br>动态区域指的是只能在运行时才能填充的内存区域，例如局部变量、堆区等</p><p>关于静态分配和动态分配分别表示的是<B>编译时刻</B>、<B>运行时刻</B></p><p>动态分配主要有两种实现方式分别是</p><ol><li>栈式存储<br>一个过程局部名字在栈中分配空间,通常支持过程调用/结果返回</li><li>堆存储<br>有一些数据结构的生命周期比较长，这些数据通常被放到一个可重复存储的&quot;堆&quot;中</li></ol><blockquote><p>为了支持堆区管理，通过设计&quot;垃圾回收器&quot;来是的在运行时刻能够检测出堆区的无用的数据结构，并且自动回收</p></blockquote><p>GC的概念在很早的时候就出现了</p><h2 id="栈空间"><a class="header-anchor" href="#栈空间"></a>栈空间</h2><blockquote><p>有些语言使用过程、函数或方法作为用户自定义动作的单元，通过在运行时刻按照栈结构进行管理。在调用一个过程的时候将存放这个过程的指针入栈，计算结束时出栈。这样能带来的好处是允许同时调用多个不交叠的过程</p></blockquote><blockquote><p>为了将运行时刻的空间最大化利用,<B>堆</B>和<B>栈</B>分别被放到内存空间的两端,栈区用来存放活动记录的数据结构,这些活动记录会在函数调用过程中产生.栈区存放在内存高位端向下增长,堆区存放在低位端向上增长.</p></blockquote><h3 id="静态与动态的区别"><a class="header-anchor" href="#静态与动态的区别"></a>静态与动态的区别</h3><ul><li><p>静态指的是编译器只需要观察程序源代码就可分析出某个存储的决定,这个时期被称为<B>编译时刻</B></p></li><li><p>动态指的是需要在程序执行过程中才会对内存地址进行分配</p></li></ul><h3 id="动态存储分配"><a class="header-anchor" href="#动态存储分配"></a>动态存储分配</h3><p>动态存储分配可以有两种实现方式:<br>1. 栈式存储<br>2. 堆存储</p><h3 id="栈式存储的好处"><a class="header-anchor" href="#栈式存储的好处"></a>栈式存储的好处</h3><p>栈式存储的好处是在于方便活跃时间段内不重叠的多个过程调用时共享空间,还有一个好处是保持非局部变量的地址不变</p><h2 id="栈帧"><a class="header-anchor" href="#栈帧"></a>栈帧</h2><p>在之前的理解中把栈帧理解称为一个局部变量帧空间与栈结构的联合体,这个理解是错误的,栈帧指的就是一个活动记录,只是栈中的一个元素而已</p><h2 id="函数式语言"><a class="header-anchor" href="#函数式语言"></a>函数式语言</h2><p>函数式语言支持将一个函数作为参数传递到方法中,也支持方法中直接返回函数.java中通过类似语法糖的方式实现了部分函数式的调用过程,并不是真正的函数式调用.java不能实现函数式调用的根本原因在于java无法在运行时刻更改栈空间的非成员变量的地址,在栈空间中的非成员变量地址已经确定了的.</p><h2 id="堆管理"><a class="header-anchor" href="#堆管理"></a>堆管理</h2><p>堆是存储空间中的一部分,它被用来存储那些生命周期比较长的对象.堆必须具备两个能力:</p><ol><li>分配空间</li><li>回收空间</li></ol><p>关于堆能操作的空间也只能是在程序初始化开始后向操作系统申请的空间,对于这段空间我们的堆处理程序认为是连续的,但是在物理结构上不一定是连续的,这一部分是操作系统屏蔽的内存分配的实现细节</p><p>GC这门技术发展的真的很早,很早.也是比较底层的技术,直到现在还有源源不断的新想法出现</p><h2 id="计算机的存储结构"><a class="header-anchor" href="#计算机的存储结构"></a>计算机的存储结构</h2><p>这一段与编译没有直接关系,但是我觉得很好,推荐出来</p><p>一个处理器一般都拥有几个专属的寄存器,寄存器的内容由CPU厂商提供接口供上层软件使用.在往上可以看到由一层或多层高速缓存,做开始</p><h2 id=""><a class="header-anchor" href="#"></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;编译原理-内存部分&lt;/h1&gt;
&lt;p&gt;这一篇主要是对后端编译器对内存布局的分析和笔记,之前的有关词法/语法方面的理论知识实在是太枯燥了,翻了又翻是在是难以理解,只能暂时放下那一部分的内容了.&lt;br&gt;
在编译时主要将内存划分为两个部分&lt;B&gt;栈&lt;/B&gt;、&lt;B&gt;堆&lt;/B&gt;：&lt;br</summary>
      
    
    
    
    <category term="编译原理" scheme="https://agmtopy.gitee.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-词法语法理论</title>
    <link href="https://agmtopy.gitee.io/2022/03/05/20.%E7%AC%94%E8%AE%B0/1.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E8%AF%AD%E6%B3%95%E7%90%86%E8%AE%BA/"/>
    <id>https://agmtopy.gitee.io/2022/03/05/20.%E7%AC%94%E8%AE%B0/1.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E8%AF%AD%E6%B3%95%E7%90%86%E8%AE%BA/</id>
    <published>2022-03-05T07:01:11.908Z</published>
    <updated>2022-03-30T14:09:47.864Z</updated>
    
    <content type="html"><![CDATA[<h1>编译原理-词法语法理论</h1><p>第二章<B>创建一个简单的语法指导器</B>里面设计了很多理论知识,暂时只记录关键概念。这一章看的很困，外面阳光明媚，只能通过打字来压制一下困意😂😂😂</p><h2 id="关键概念"><a class="header-anchor" href="#关键概念"></a>关键概念</h2><ul><li><p>语法制导翻译器<br><B>语法制导翻译器</B>是用于构建语法翻译器的程序</p></li><li><p>语法的定义</p></li></ul><blockquote><p>一种用于描述程序设计语言语法的表示方法 - “上下文无关文法”,这种文法用于前端编译器</p></blockquote><ul><li>语法分析器</li></ul><p>语法分析是决定如何通过一个文法生成一个终结符号的过程。语法分析有两个过程，分别是<B>自顶向下</B>、<B>自底向上</B>两种方法，指的是语法分析对语法分析的构造顺序。</p><h2 id="词法分析器"><a class="header-anchor" href="#词法分析器"></a>词法分析器</h2><blockquote><p>词法分析是编译的第一个阶段.主要是将输入的源代码生成一个词法单元序列,每个词法单元对应一个词素</p></blockquote><p>如下图所示:<br>@TODO</p><p>词法分析器还会完成一些辅助功能例如过滤空白字符、记录源代码行号</p><h3 id="词素的识别"><a class="header-anchor" href="#词素的识别"></a>词素的识别</h3><p>源代码是由不同的字符组成的，在进行编译时首先要将输入的字符串进行拆分，拆分成为不同的词素。</p><p>对于无法识别成为词素的字符，其实可以通过变化字符来进行匹配，但是这种方案代价太高，不值得使用。我赞同这种观点，编译器的功能就是编译代码而不是尝试对代码进行修复，也是单一职责的表现</p><ul><li><p>加载源代码是否会使用完缓冲区?.<br>不会,词素只需要根据前后一两个字符就可以确定了,因此只需要数千个字节就可以完成这个工作了.</p></li><li><p>如何鉴定语言的保留字?<br>通过在初始化时将各个保留字填入符号表中,符号表会标识这些保留字不是普通的标识符,并且会指向他们说代表的词法单元去</p></li></ul><h3 id="词素识别工具"><a class="header-anchor" href="#词素识别工具"></a>词素识别工具</h3><ul><li>Lex/Yacc</li></ul><blockquote><p>Lex是Unix环境下非常著名的工具,主要功能是生成一个扫描器(Scanner)的C源码。扫描器是一种识别文本中的词汇模式的程序。 这些词汇模式（或者常规表达式）在一种特殊的句子结构中定义。一种匹配的常规表达式可能会包含相关的动作。这一动作可能还包括返回一个标记。 当 Lex 接收到文件或文本形式的输入时，它试图将文本与常规表达式进行匹配。 它一次读入一个输入字符，直到找到一个匹配的模式。 如果能够找到一个匹配的模式，Lex 就执行相关的动作（可能包括返回一个标记）。 另一方面，如果没有可以匹配的常规表达式，将会停止进一步的处理，Lex 将显示一个错误消息。</p></blockquote><p>也就是通过Lex来生成一个’正则表达式’,并进行后续操作</p><h2 id="语法分析器"><a class="header-anchor" href="#语法分析器"></a>语法分析器</h2><p>下图所示的是语法分析器在编译器中的过程<br>@TODO</p><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>这一章主要是关于前端编译器的两个部分’词法分析器’和’语法分析器’的一些理论知识的介绍</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://sighingnow.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/lex_yacc.html">Lex和Yacc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;编译原理-词法语法理论&lt;/h1&gt;
&lt;p&gt;第二章&lt;B&gt;创建一个简单的语法指导器&lt;/B&gt;里面设计了很多理论知识,暂时只记录关键概念。这一章看的很困，外面阳光明媚，只能通过打字来压制一下困意😂😂😂&lt;/p&gt;
&lt;h2 id=&quot;关键概念&quot;&gt;&lt;a class=&quot;header-an</summary>
      
    
    
    
    <category term="编译原理" scheme="https://agmtopy.gitee.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-引言</title>
    <link href="https://agmtopy.gitee.io/2022/03/03/20.%E7%AC%94%E8%AE%B0/0.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%BC%95%E8%A8%80-/"/>
    <id>https://agmtopy.gitee.io/2022/03/03/20.%E7%AC%94%E8%AE%B0/0.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%BC%95%E8%A8%80-/</id>
    <published>2022-03-03T13:13:20.000Z</published>
    <updated>2022-08-04T01:01:26.717Z</updated>
    
    <content type="html"><![CDATA[<h1>编译原理-引言</h1><p>大概是在开始学习编写程序的时候购入了一系列的计算机基础书籍,由于自己的原因导致很多书都只是寥寥翻开几页,就匆匆放下了.<br>近来这两年,随着年纪的增大忽然有了一个念头就是自己的程序生涯已经快要结束,但是还有那么多书未看未读,有一些惋惜和不舍.不舍的既有对知识的向往也有对年轻的奢望,惋惜的是荒废了大好年华.不如把既有的书籍看完,也是完成当初对自己的期待和结束吧.</p><p>碎碎念了很久,让我们接下来开始吧,笔记按照书籍的章节进行记录</p><h2 id="第一章"><a class="header-anchor" href="#第一章"></a>第一章</h2><blockquote><p>程序设计语言是向人以及计算机描述计算过程的记号</p></blockquote><p>这是这本书的第一句话,我觉得很好.程序/代码是由人编写给人阅读,拿给机器进行执行的,因此在编写的时候既要考虑到程序的可阅读性也要考虑到机器执行的效率.<br>但是机器是看不懂人类编写的语言,就需要一个’翻译家’将我们需要的计算过程转义后告诉计算机进行执行,这个’翻译家’就是我们的<B>编译器</B><br>研究这些编译原理,也许究其一生我们也不会使用到一次相关的知识,但是可以学习前人在处理复杂问题时候的解决思路,没有灵活的思维就只能通过经验来模仿大师的行为</p><h2 id="语言处理器"><a class="header-anchor" href="#语言处理器"></a>语言处理器</h2><p>编译器泛指语言处理器,通常由两部分组成<B>编译器</B>、<B>解释器</B></p><ol><li><p>编译器<br>编译器指的是将某一种语言翻译成为行为相同的另外一种语言(目标语言)</p></li><li><p>解释器<br>解释器指的是直接执行输入过来的语言</p><p>java语言的处理器就融合了这两个语言处理器,向通过编译器将源代码编译成为中间语言代码,在通过JVM解释执行中间语言代码</p></li></ol><ul><li>编译器结构<ol><li><p>分析部分(analysis)</p><blockquote><p>分析部分又被称为前端,指的是将源程序分解为多个组成要素,并在这些要素根据语法结构来创建出一个’中间输出’,提供给下一阶段作为输入,并且生成’符号表’</p></blockquote><p>以上是书上对前端编译器的定义,目前认为前端编译器就是执行语法规则/约束来将源代码翻译成为’中间代码’</p></li><li><p>综合部分(synthesis)</p><blockquote><p>综合部分是根据前端输入的中间代码和符号表来构造用户期望的目标代码</p></blockquote><p>对于这个的理解是从中间代码转换为目标代码的过程,例如生成目标代码为java的某A语言以及A-j的中间代码,最后才能生成java语言<br>前端编译器是与机器无关的,后端编译器是与机器相关的</p></li></ol></li></ul><h2 id="编译器的步骤"><a class="header-anchor" href="#编译器的步骤"></a>编译器的步骤</h2><p>编译器执行的步骤大致分为七个步骤,置顶向下分别是</p><ol><li>词法分析器</li><li>语法分析器</li><li>语义分析器</li><li>中间代码生成器</li><li>机器无关代码优化器</li><li>代码生成器</li><li>机器相关代码优化器</li></ol><p>下图所示:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E7%BC%96%E8%AF%91%E5%99%A8%E6%AD%A5%E9%AA%A4%E5%9B%BE.png?raw=true" alt="编译器步骤图"></p><p>下面就对这7个步骤进行分析</p><h3 id="1-词法分析器"><a class="header-anchor" href="#1-词法分析器"></a>1.词法分析器</h3><blockquote><p>词法分析器指的是将源代码的<B>词素(lexeme)</B>转义成为由<B>词法单元(token)</B>组成的<B>词法单元序列</B></p></blockquote><p>这里涉及到两个知识点:<br>以java代码为示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>词素(lexeme)<br>词素(lexeme)在语言领域等同与词汇,在这里指的是组成源代码的单个符号.<br>示例的源代码中的词素为’String’、‘name’、‘=’、‘&quot;’、‘hello’、‘&quot;’</p></li><li><p>词法单元<br>词法单元指的是编译器对词素的抽象承载对象,通过两部分组成&lt;token-name,attribute-value&gt;<br>token-name:语法分析步骤中使用到的抽象符号<br>attribute-value:指向符号表中关于这个词法单元的条目(可选)</p></li><li><p>符号表<br>符号表指的是用于记录源代码程序中使用到的变量名字，用于存储各种属性</p></li></ol><p>通过步骤1<B>语法分析器</B>可以将源代码转换成为<B>词法单元序列</B>，后续的操作是建立在词法单元序列的基础上的</p><h3 id="2-语法分析"><a class="header-anchor" href="#2-语法分析"></a>2.语法分析</h3><blockquote><p>编译器的第二个步骤是<B>语法分析</B>或<B>解析</B>.语法分析器使用上一步词法分析器的输出<B>词法单元序列</B>作为输入，通过使用词法单元来构建语法树结构。<br><B>语法树结构</B>是由树中的每一个内部节点表示一个<B>运算</B>组成，叶子节点表示该运算的分量 ，如下图所示中的第二个步骤，通过这个步骤将将’操作’和’分量’分离，以便下一步语义分析器使用</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%B5%84%E6%96%99/%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E7%A4%BA%E4%BE%8B.jpg?raw=true" alt="编译器工作示例"></p><h3 id="3-语义分析器"><a class="header-anchor" href="#3-语义分析器"></a>3. 语义分析器</h3><blockquote><p>语义分析器是根据<B>语法树</B>和<B>符号表</B>中的信息来检查输入的源代码是否符合语言的定义，同时收集类型信息存放到语法树和符号表中，以便在随后生成中间代码的过程中进行使用</p></blockquote><p>在语义分析的过程中主要是做两方面的事情:<br>第一: 根据语言语义和符号表对语法树中的节点进行分析语义的正确性<br>第二：进行类型检查和自动类型转换</p><h3 id="4-中间代码的生成"><a class="header-anchor" href="#4-中间代码的生成"></a>4. 中间代码的生成</h3><p>通过以上三个步骤(词法分析/语法分析/语义分析)得到正确的语法树，通过这个语法树生成需要的中间代码<br>中间代码指的是是一种易于生成并且可以与目标代码进行转换的一种语言,生成一种伪指令的代码表述</p><h3 id="5-代码优化"><a class="header-anchor" href="#5-代码优化"></a>5. 代码优化</h3><p>这一步进行对中间代码的一个与机器无关的优化，由于在上一步中生成中间代码是完全按照源代码的逻辑，因此可以按照逻辑规则进行一些优化处理，由于是对逻辑的优化因此是与机器无关的</p><h3 id="6-代码生成"><a class="header-anchor" href="#6-代码生成"></a>6. 代码生成</h3><p><B>代码生成</B>是根据上一步中优化后的中间代码作为输入，然后根据不同的计算平台来生成操作具体的寄存器/内存地址的机器代码</p><h3 id="编译器处理过程小结"><a class="header-anchor" href="#编译器处理过程小结"></a>编译器处理过程小结</h3><p>编译器处理过程的过程划分为以上6个步骤(词法/语法/语义/中间代码生成/代码优化/机器代码生成)这几个步骤，在实现时可以将这几个步骤合并成为<B>“一趟”</B></p><h2 id="程序设计语言的历史"><a class="header-anchor" href="#程序设计语言的历史"></a>程序设计语言的历史</h2><p>我很喜欢了解这种技术的发展过程，虽然这段历史离我们很遥远，但是在阅读的过程中好像在历史的长流中一样，按照时间顺序</p><ul><li><p>机器指令</p></li><li><p>汇编语言</p><ul><li>宏指令</li></ul></li><li><p>高级程序语言</p><ul><li>lisp</li><li>C/C++</li><li>JAVA</li></ul></li><li><p>特定应用程序设计语言</p><ul><li>SQL</li></ul></li><li><p>基于逻辑和约束的语言</p><ul><li>prolog</li><li>ops5</li></ul></li></ul><p>语言的发展变化也在一定程度上到了编译器的方向,编译器的演化也会影响到语言的发展，两者是相辅相成的。</p><p>编译器也会对机器指令集的发展产生影响，例如编译器更喜欢RISC(精简指令集)因为RISC上的可以做更好的指令优化</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://cs.nju.edu.cn/changxu/2_compiler/slides/Chapter_1.pdf">编译原理讲义-南京大学</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;编译原理-引言&lt;/h1&gt;
&lt;p&gt;大概是在开始学习编写程序的时候购入了一系列的计算机基础书籍,由于自己的原因导致很多书都只是寥寥翻开几页,就匆匆放下了.&lt;br&gt;
近来这两年,随着年纪的增大忽然有了一个念头就是自己的程序生涯已经快要结束,但是还有那么多书未看未读,有一些惋惜和</summary>
      
    
    
    
    <category term="编译原理" scheme="https://agmtopy.gitee.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis如何实现持久化的</title>
    <link href="https://agmtopy.gitee.io/2022/01/20/1.%E6%9D%82%E8%AE%B0/redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84/"/>
    <id>https://agmtopy.gitee.io/2022/01/20/1.%E6%9D%82%E8%AE%B0/redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84/</id>
    <published>2022-01-20T15:07:22.000Z</published>
    <updated>2022-02-03T01:31:07.503Z</updated>
    
    <content type="html"><![CDATA[<h1>redis如何实现持久化的</h1><p>redis目前实现持久化主要有两种方式,一种是通过<B>RDB文件</B>,另外一种是通过<B>AOF文件</B>.<br>redis对于持久化支持4种部署方式</p><ul><li>无持久性</li><li>RDB</li><li>AOF</li><li>RDB + AOF</li></ul><p>让就让我们来详细比较和分析以下redis底层是如何实现的RDB和AOF机制的</p><h2 id="RDB文件"><a class="header-anchor" href="#RDB文件"></a>RDB文件</h2><ul><li>RDB定义</li></ul><blockquote><p>RDB 持久性指的是在指定时间间隔后执行记录当前数据集的全部数据快照</p></blockquote><p>RDB文件就类似于MySql进行全量备份,记录某一个时间点的全部数据</p><ul><li>RDB优点</li></ul><ol><li>文件即数据,不浪费空间</li><li>异步生成文件,性能损耗最小</li><li>不需要重新执行指令,数据恢复更快</li><li>支持主从切换后的数据同步</li></ol><ul><li>RDB缺点</li></ul><ol><li>没有采用LSM日志处理,会丢失数据</li><li>对于需要持久化大量数据时,性能不如AOF增量模式</li></ol><h3 id="使用实例"><a class="header-anchor" href="#使用实例"></a>使用实例</h3><p>RDB有两种触发方式:</p><ol><li>配置文件触发</li><li>命令触发</li></ol><ul><li>配置文件触发</li></ul><p>配置文件触发为在<B>redis.conf</B>中设置</p><pre class="line-numbers language-config" data-language="config"><code class="language-config">#文件路径dir#RDB文件名称dbfilename #是否启用数据校验rdbchecksum yes#是否启用RDB文件压缩格式rdbcompression yes#bgsave异常时是否停止写入缓存stop-writes-on-bgsave-error yes#60秒内有5个值发生变化时触发生成RDB文件save 60 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>命令触发</p><ul><li>save<br>同步阻塞命令</li><li>bgsave<br>fork子进程异步生成RDB文件</li></ul></li></ul><h3 id="源码解析"><a class="header-anchor" href="#源码解析"></a>源码解析</h3><ul><li>bgsave的执行调用链</li></ul><p><img src="https://hexo-1254947285.cos.ap-chengdu.myqcloud.com/hexo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-22%20230847.jpg" alt="bgsave的执行链"></p><blockquote><p><B>server.main()</B> -&gt; <B>server.processCommand()</B> -&gt; <B>rdb.rdbSaveBackground()</B> -&gt; <B>rdb.redisFork()</B></p></blockquote><p>下面自底向上依次分析下这个四个方法</p><ul><li><B>rdbSave()</B></li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将数据保存在磁盘上 */</span><span class="token keyword">int</span> <span class="token function">rdbSave</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> tmpfile<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> cwd<span class="token punctuation">[</span>MAXPATHLEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* Current working dir path for error messages. */</span>    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    rio rdb<span class="token punctuation">;</span>    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token string">"temp-%d.rdb"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>cwdp <span class="token operator">=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>cwd<span class="token punctuation">,</span>MAXPATHLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>            <span class="token string">"Failed opening the RDB file %s (in server root dir %s) "</span>            <span class="token string">"for saving: %s"</span><span class="token punctuation">,</span>            filename<span class="token punctuation">,</span>            cwdp <span class="token operator">?</span> cwdp <span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span>            <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">rioInitWithFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">startSaving</span><span class="token punctuation">(</span>RDBFLAGS_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>rdb_save_incremental_fsync<span class="token punctuation">)</span>        <span class="token function">rioSetAutoSync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>REDIS_AUTOSYNC_BYTES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbSaveRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span><span class="token operator">&amp;</span>error<span class="token punctuation">,</span>RDBFLAGS_NONE<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        errno <span class="token operator">=</span> error<span class="token punctuation">;</span>        <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Make sure data will not remain on the OS's output buffers */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fsync</span><span class="token punctuation">(</span><span class="token function">fileno</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">goto</span> werr<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">//重命名文件来实现写入文件的原子性</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rename</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">,</span>filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>cwdp <span class="token operator">=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>cwd<span class="token punctuation">,</span>MAXPATHLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>            <span class="token string">"Error moving temp DB file %s on the final "</span>            <span class="token string">"destination %s (in server root dir %s): %s"</span><span class="token punctuation">,</span>            tmpfile<span class="token punctuation">,</span>            filename<span class="token punctuation">,</span>            cwdp <span class="token operator">?</span> cwdp <span class="token operator">:</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span>            <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stopSaving</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"RDB落盘成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastsave <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">=</span> C_OK<span class="token punctuation">;</span>    <span class="token function">stopSaving</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>werr<span class="token operator">:</span>    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Write error saving DB on disk: %s"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>tmpfile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">stopSaving</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><B>rdbSave()</B>完成对RDB文件的写入操作:</p><ol><li>创建一个临时文件,将内存中的数据进行写入,然后刷盘</li><li>对临时文件进行rename(👍写入文件不一定是原子,但是rename file一定是原子性的),来保证文件写入的原子性</li></ol><ul><li><B>rdbSaveBackground</B></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">rdbSaveBackground</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> rdbSaveInfo <span class="token operator">*</span>rsi<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> childpid<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasActiveChildProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>dirty_before_bgsave <span class="token operator">=</span> server<span class="token punctuation">.</span>dirty<span class="token punctuation">;</span>    server<span class="token punctuation">.</span>lastbgsave_try <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//fork子进程进行处理RDB文件,这里的fork()返回值-1表示没有创建新进程成功,0表示创建新进程成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>childpid <span class="token operator">=</span> <span class="token function">redisFork</span><span class="token punctuation">(</span>CHILD_TYPE_RDB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> retval<span class="token punctuation">;</span>        <span class="token comment">/* Child */</span>        <span class="token function">redisSetProcTitle</span><span class="token punctuation">(</span><span class="token string">"redis-rdb-bgsave"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">redisSetCpuAffinity</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>bgsave_cpulist<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"RDB文件为: %s"</span><span class="token punctuation">,</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        retval <span class="token operator">=</span> <span class="token function">rdbSave</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span>rsi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成rdb文件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">sendChildCowInfo</span><span class="token punctuation">(</span>CHILD_INFO_TYPE_RDB_COW_SIZE<span class="token punctuation">,</span> <span class="token string">"RDB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">exitFromChild</span><span class="token punctuation">(</span><span class="token punctuation">(</span>retval <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 父进程处理 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>childpid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            server<span class="token punctuation">.</span>lastbgsave_status <span class="token operator">=</span> C_ERR<span class="token punctuation">;</span>            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Can't save in background: fork: %s"</span><span class="token punctuation">,</span>                <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Background saving started by pid %ld"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> childpid<span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>rdb_save_time_start <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        server<span class="token punctuation">.</span>rdb_child_type <span class="token operator">=</span> RDB_CHILD_TYPE_DISK<span class="token punctuation">;</span>        <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span> <span class="token comment">/* unreached */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个方法内部通过<B>redisFork()</B>创建了一个子进程来完成<B>rdbSave()</B>的调用</p><p>父进程不会阻塞而是直接打印RDB文件开始处理的消息</p><p>需要注意一点的是fork()进程的方法返回值是0-成功/-1-失败</p><p>在这一步的调用中省略<B>rdb.bgsaveCommand()</B>的调用逻辑,直接分析<B>server.c</B>中的逻辑</p><ul><li><B>server.c()</B></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> redisCommandTable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span><span class="token string">"module"</span><span class="token punctuation">,</span>moduleCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>     <span class="token string">"admin no-script"</span><span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"get"</span><span class="token punctuation">,</span>getCommand<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>     <span class="token string">"read-only fast @string"</span><span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"bgsave"</span><span class="token punctuation">,</span>bgsaveCommand<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>     <span class="token string">"admin no-script"</span><span class="token punctuation">,</span>     <span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">//省略其他命令</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用命令模式将所有客户端命令以及命令的处理方式放到<B>redisCommandTable</B>中进行处理,然后在和网络时间绑定就形成最开始说的调用链结构</p><ul><li>cron方式启动<br>cron方式启动的逻辑位于<B>server.serverCron()</B>中</li></ul><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>RDB文件是通过fork()子进程来处理文件,采用的是rename temp file的方式保证原子性. 父进程并不会阻塞,而是启动子进程后立即返回</p><h2 id="AOF文件"><a class="header-anchor" href="#AOF文件"></a>AOF文件</h2><p>AOF文件就类似于MySql中的binlog使用的Statement格式记录数据变化,每次只记录指令,并且超过设定的大小后会进行覆盖</p><h3 id="使用实例-v2"><a class="header-anchor" href="#使用实例-v2"></a>使用实例</h3><ul><li>配置文件</li></ul><pre class="line-numbers language-config" data-language="config"><code class="language-config">#开启redis aofappendonly yes#aof刷新机制 always:每一条都写入磁盘,everysec:每秒写入磁盘一次,no:文件系统刷新appendfsync everysec#aof文件扩容的阀值比例auto-aof-rewrite-percentage 100#aof文件重写后的初始大小auto-aof-rewrite-min-size 64mb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源码解析-v2"><a class="header-anchor" href="#源码解析-v2"></a>源码解析</h3><h3 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h3><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><h2 id="参考文章"><a class="header-anchor" href="#参考文章"></a>参考文章</h2><p><a href="https://redis.io/topics/persistence">Redis Persistence</a><br><a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">Redis persistence demystified</a><br><a href="https://redis.io/topics/latency">Redis 延迟问题排查</a><br><a href="https://dl.acm.org/doi/fullHtml/10.1145/3318159">TxFS：利用文件系统崩溃一致性来提供 ACID 事务</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;redis如何实现持久化的&lt;/h1&gt;
&lt;p&gt;redis目前实现持久化主要有两种方式,一种是通过&lt;B&gt;RDB文件&lt;/B&gt;,另外一种是通过&lt;B&gt;AOF文件&lt;/B&gt;.&lt;br&gt;
redis对于持久化支持4种部署方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无持久性&lt;/li&gt;
&lt;li&gt;RDB&lt;/</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://agmtopy.gitee.io/tags/redis/"/>
    
  </entry>
  
</feed>
