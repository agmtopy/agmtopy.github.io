<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>agmtopy博客</title>
  
  <subtitle>agmtopy</subtitle>
  <link href="https://agmtopy.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://agmtopy.gitee.io/"/>
  <updated>2025-11-21T16:21:10.658Z</updated>
  <id>https://agmtopy.gitee.io/</id>
  
  <author>
    <name>agmtopy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Disruptor源码分析之RingBuffer</title>
    <link href="https://agmtopy.gitee.io/2025/11/13/26.%E9%AB%98%E6%80%A7%E8%83%BD/03.Disruptor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BRingBuffer/"/>
    <id>https://agmtopy.gitee.io/2025/11/13/26.%E9%AB%98%E6%80%A7%E8%83%BD/03.Disruptor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BRingBuffer/</id>
    <published>2025-11-13T13:10:00.000Z</published>
    <updated>2025-11-21T16:21:10.658Z</updated>
    
    <content type="html"><![CDATA[<h1>Disruptor源码分析之RingBuffer</h1><p>RingBuffer是Disruptor的核心组件之一,它是一个高效的环形缓冲区,用于在生产者和消费者之间传递事件对象,RingBuffer通过预分配内存和无锁设计实现了高性能的数据传输,本文将深入分析RingBuffer的源码实现,包括其继承结构、属性、初始化过程以及读写逻辑。</p><h2 id="RingBuffer类"><a class="header-anchor" href="#RingBuffer类"></a>RingBuffer类</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/RingBuffer_%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%9B%BE.png?raw=true" alt="RingBuffer继承图"></p><p>可用看到RingBuffer继承实现<B>RingBufferPad</B>、<B>Cursored</B>、<B>Sequenced</B>,其中RingBufferPad是对RingBuffer自身结构的描述,Sequenced和Cursored接口定义RingBuffer的行为;</p><h3 id="RingBufferPad-核心抽象"><a class="header-anchor" href="#RingBufferPad-核心抽象"></a>RingBufferPad:核心抽象</h3><p>可以看到RingBuffer继承自RingBufferPad,其中RingBufferPad的作用是进行缓存行填充,防止伪共享,RingBufferPad对于缓存行填充的实现有前后两个版本,第一个版本是使用Long类型的字段进行填充,第二个版本是使用byte数组进行填充,具体代码如下:<br><a href="https://github.com/LMAX-Exchange/disruptor/commit/bd5d7d8dd6271d1b9086b96323fbd8fca51e33b1">Commit bd5d7d8</a></p><p>为什么要从Long类型改为byte数组呢?<br>因为Long类型的字段在JDK15之后由于内存布局调整,导致Long类型的继承布局结构可能会被优化,导致缓存行填充失效,而byte数组可以确保填充字段不会被优化掉,从而保证缓存行填充的效果,因此在使用padding trick技巧时需要关注不同JDK版本对继承字段的优化;</p><h3 id="Cursored-序列接口"><a class="header-anchor" href="#Cursored-序列接口"></a>Cursored:序列接口</h3><p>Cursored用于声明当前&quot;当前最大序列号&quot;的抽象接口,当RingBuffer继承Cursored时,需要实现getCursor()方法,用于获取当前最大序列号;</p><h3 id="Sequenced-基本操作接口"><a class="header-anchor" href="#Sequenced-基本操作接口"></a>Sequenced:基本操作接口</h3><p>Sequenced是RingBuffer的核心父类,它定义了RingBuffer的基本操作接口,包括获取容量、发布事件、检查是否有可用事件等方法,定义了其他类如何与RingBuffer进行交互的方式;</p><h2 id="RingBuffer的属性"><a class="header-anchor" href="#RingBuffer的属性"></a>RingBuffer的属性</h2><p>RingBuffer的核心属性都是放到<B>RingBufferFields</B>中的分别是:</p><ol><li><B>indexMask</B>:用于计算核心环形缓冲区的索引的掩码,大小为RingBuffer长度减1,计算索引方式为:index = num &amp; indexMask,等效与num % bufferSize,通过位运算可以提高计算效率;<br>例如,RingBuffer的长度为4,则indexMask = 4 - 1 = 3(二进制为0011),当num=6(二进制为0110)时,index = 0011 &amp; 0110 = 0010 = 2,所以索引为2;</li><li><B>entries</B>:核心环形缓冲区,用于存储事件对象的数组,有界数组;</li><li><B>sequencer</B>:生产者序列号对象,用于管理生产者的序列<br>sequencer是Disruptor的<B>核心调度器</B>,它其实是继承Cursored(状态管理)和Sequenced(基本操作)两个接口的抽象类,它定义了生产者如何发布事件,以及如何与消费者进行协调,其中它有两个实现类:<ul><li>SingleProducerSequencer:单生产者实现,适用于只有一个生产者的场景,它通过简单的自旋锁来实现线程间的协调,性能较高;</li><li>MultiProducerSequencer:多生产者实现,适用于有多个生产者的场景,它使用CAS操作来实现线程间的协调,从而避免锁的使用,性能稍低于单生产者实现;</li></ul></li><li><B>bufferSize</B>:环形缓冲区的大小,必须是2的幂次方;</li></ol><ul><li><a href="https://github.com/LMAX-Exchange/disruptor/blob/17a619e9412951ec8762affbe08d10d7bca92c1a/src/main/java/com/lmax/disruptor/RingBuffer.java#L34">RingBufferFields</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">RingBufferFields</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">RingBufferPad</span><span class="token punctuation">&#123;</span>    <span class="token comment">//数组前后空闲填充数量,防止伪共享</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">BUFFER_PAD</span> <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>    <span class="token comment">//索引掩码</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> indexMask<span class="token punctuation">;</span>    <span class="token comment">//有界事件数组</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> entries<span class="token punctuation">;</span>    <span class="token comment">//数组大小</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> bufferSize<span class="token punctuation">;</span>    <span class="token comment">//控制器</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Sequencer</span> sequencer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="RingBuffer初始化过程"><a class="header-anchor" href="#RingBuffer初始化过程"></a>RingBuffer初始化过程</h2><p>RingBuffer初始化主要是通过Disruptor类来完成的,Disruptor.create()方法会创建RingBuffer对象,具体代码如下:</p><p><a href="https://github.com/LMAX-Exchange/disruptor/blob/95c705f60c1833b07f1fed6e08a08d7bee7f0971/src/main/java/com/lmax/disruptor/dsl/Disruptor.java#L92">Disruptor.create</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Disruptor</span><span class="token punctuation">(</span>        <span class="token keyword">final</span> <span class="token class-name">EventFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> eventFactory<span class="token punctuation">,</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> ringBufferSize<span class="token punctuation">,</span>        <span class="token keyword">final</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>        <span class="token keyword">final</span> <span class="token class-name">ProducerType</span> producerType<span class="token punctuation">,</span>        <span class="token keyword">final</span> <span class="token class-name">WaitStrategy</span> waitStrategy<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>        <span class="token class-name">RingBuffer</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>producerType<span class="token punctuation">,</span> eventFactory<span class="token punctuation">,</span> ringBufferSize<span class="token punctuation">,</span> waitStrategy<span class="token punctuation">)</span><span class="token punctuation">,</span>        threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/LMAX-Exchange/disruptor/blob/17a619e9412951ec8762affbe08d10d7bca92c1a/src/main/java/com/lmax/disruptor/RingBuffer.java#L201">RingBuffer.create()</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">create</span><span class="token punctuation">(</span>        <span class="token keyword">final</span> <span class="token class-name">ProducerType</span> producerType<span class="token punctuation">,</span>        <span class="token keyword">final</span> <span class="token class-name">EventFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> eventFactory<span class="token punctuation">,</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> bufferSize<span class="token punctuation">,</span>        <span class="token keyword">final</span> <span class="token class-name">WaitStrategy</span> waitStrategy<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Sequencer</span> sequencer<span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>producerType<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token constant">SINGLE</span><span class="token operator">:</span>            <span class="token comment">//单生产者模式</span>            sequencer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleProducerSequencer</span><span class="token punctuation">(</span>bufferSize<span class="token punctuation">,</span> waitStrategy<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token constant">MULTI</span><span class="token operator">:</span>            <span class="token comment">//多生产者模式</span>            sequencer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MultiProducerSequencer</span><span class="token punctuation">(</span>bufferSize<span class="token punctuation">,</span> waitStrategy<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unknown producer type: "</span> <span class="token operator">+</span> producerType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>sequencer<span class="token punctuation">,</span> eventFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到buffersize会被用于创建Sequencer对象,然后传递给RingBuffer的构造方法,在RingBuffer的构造方法中,会使用Sequencer对象中的buffersize属性来创建entries数组,具体代码如下:</p><ul><li><a href="https://github.com/LMAX-Exchange/disruptor/blob/17a619e9412951ec8762affbe08d10d7bca92c1a/src/main/java/com/lmax/disruptor/RingBuffer.java#L43">RingBufferFields#RingBufferFields</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">RingBufferFields</span><span class="token punctuation">(</span>        <span class="token keyword">final</span> <span class="token class-name">EventFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> eventFactory<span class="token punctuation">,</span>        <span class="token keyword">final</span> <span class="token class-name">Sequencer</span> sequencer<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sequencer <span class="token operator">=</span> sequencer<span class="token punctuation">;</span>        <span class="token comment">//使用sequencer中的BufferSize作为数组长度</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bufferSize <span class="token operator">=</span> sequencer<span class="token punctuation">.</span><span class="token function">getBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bufferSize <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"bufferSize must not be less than 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">bitCount</span><span class="token punctuation">(</span>bufferSize<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"bufferSize must be a power of 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>indexMask <span class="token operator">=</span> bufferSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//创建事件数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>entries <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>bufferSize <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token constant">BUFFER_PAD</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">fill</span><span class="token punctuation">(</span>eventFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在创建entries数组时,可以看到使用bufferSize加上了2倍的BUFFER_PAD,其中<B>BUFFER_PAD</B>是为了进行缓存行填充,防止伪共享;然后就进行了fill操作,用于初始化entries数组,具体代码如下:</p><ul><li><a href="https://github.com/LMAX-Exchange/disruptor/blob/17a619e9412951ec8762affbe08d10d7bca92c1a/src/main/java/com/lmax/disruptor/RingBuffer.java#L43">RingBufferFields#fill</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">EventFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> eventFactory<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bufferSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//对数组进行填充,可以看到前BUFFER_PAD和后BUFFER_PAD的位置没有进行填充</span>        entries<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token constant">BUFFER_PAD</span><span class="token punctuation">]</span> <span class="token operator">=</span> eventFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对空数组进行填充使用EventFactory创建事件对象,eventFactory是用户自定义的,用于创建事件对象的工厂接口,用户可以实现自己的EventFactory来创建不同类型的事件对象;</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>RingBuffer的初始化主要是通过Disruptor类来完成的,在创建RingBuffer时会根据生产者类型(单生产者或者多生产者)创建不同的Sequencer对象,然后传递给RingBuffer的构造方法,在构造方法中会使用Sequencer中的bufferSize来创建entries数组,并使用EventFactory进行初始化填充,同时还会在数组中使用空的位置防止伪共享;</p><h2 id="RingBuffer的读写逻辑"><a class="header-anchor" href="#RingBuffer的读写逻辑"></a>RingBuffer的读写逻辑</h2><p>RingBuffer的读写逻辑是整个Disruptor的关键,主要是通过Sequencer来实现的,生产者通过Sequencer来发布事件,消费者通过Sequencer来获取可用事件;</p><h3 id="写入流程"><a class="header-anchor" href="#写入流程"></a>写入流程</h3><p>生产者写入事件的流程主要包括以下几个步骤:</p><ol><li>获取下一个可用的序列号:生产者通过调用sequencer.next()</li><li>通过第一步获取的序列号获取事件对象:生产者通过ringBuffer.get(sequence)获取对应的事件对象;</li><li>填充事件对象:生产者对获取到的事件对象进行填充;</li><li>发布事件:生产者通过sequencer.publish(sequence)将事件发布出去;</li></ol><p>可以参考:<a href="https://github.com/agmtopy/Disruptor/blob/631de39d356887a175d9ffdb1aadaa7a8cb49354/src/main/java/performance/basis/Disruptor1P1C.java#L29">Disruptor1P1C</a></p><p>根据这个流程依次进行分析:</p><ul><li>获取下一个可用序号的</li></ul><p>Sequencer#next方法是实现Sequenced接口的next方法,有两种不同的实现,分别是SingleProducerSequencer和MultiProducerSequencer,先对SingleProducerSequencer进行分析:</p><p><a href="https://github.com/agmtopy/disruptor-source/blob/0950b4d69396e90c2c0643a51d99c2fb9cfab703/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java#L134">SingleProducerSequencer#next</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//判断线程和生产者是否是最开始的匹配关系,首次获取nextSeq时,会将两者之间存到Map中</span>     <span class="token keyword">assert</span> <span class="token function">sameThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"Accessed by two threads - use ProducerType.MULTI!"</span><span class="token punctuation">;</span>     <span class="token comment">//检测是否超过有效索引长度</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">></span> bufferSize<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"n must be > 0 and &lt; bufferSize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token comment">//this.nextValue作为上一次写入索引</span>     <span class="token keyword">long</span> nextValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nextValue<span class="token punctuation">;</span>     <span class="token comment">//关注点1:下一次索引+n</span>     <span class="token keyword">long</span> nextSequence <span class="token operator">=</span> nextValue <span class="token operator">+</span> n<span class="token punctuation">;</span>     <span class="token comment">//关注点2:wrapPoint:理论上的最晚可以消费的索引地址</span>     <span class="token keyword">long</span> wrapPoint <span class="token operator">=</span> nextSequence <span class="token operator">-</span> bufferSize<span class="token punctuation">;</span>     <span class="token comment">//获取缓存下来的最小消费者序号</span>     <span class="token keyword">long</span> cachedGatingSequence <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cachedValue<span class="token punctuation">;</span>     <span class="token comment">//关注点3:判断nextIndex是否超过当前最小的消费者序号</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>wrapPoint <span class="token operator">></span> cachedGatingSequence <span class="token operator">||</span> cachedGatingSequence <span class="token operator">></span> nextValue<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         <span class="token comment">//重新设置内存屏障</span>         cursor<span class="token punctuation">.</span><span class="token function">setVolatile</span><span class="token punctuation">(</span>nextValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// StoreLoad fence</span>         <span class="token comment">//设置局部变量用于暂存最慢的消费索引</span>         <span class="token keyword">long</span> minSequence<span class="token punctuation">;</span>         <span class="token comment">//关注点4:循环等待,生产者等待最慢的消费者消费出空闲的位置</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>wrapPoint <span class="token operator">></span> <span class="token punctuation">(</span>minSequence <span class="token operator">=</span> <span class="token class-name">Util</span><span class="token punctuation">.</span><span class="token function">getMinimumSequence</span><span class="token punctuation">(</span>gatingSequences<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>             <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TODO: Use waitStrategy to spin?</span>         <span class="token punctuation">&#125;</span>         <span class="token comment">//重新设置位置</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>cachedValue <span class="token operator">=</span> minSequence<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>nextValue <span class="token operator">=</span> nextSequence<span class="token punctuation">;</span>     <span class="token keyword">return</span> nextSequence<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中的四个关注点参考这个图:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/RingBuffer_next%E8%8E%B7%E5%8F%96%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.png?raw=true" alt="获取下一个位置"></p><p>在获取下一个可用位置时,由于是单线程写入,因此在校验过是单线程写入后,后续主要做的事情就是在保证有空闲位置时,直接返回下一个可用位置,如果没有空闲位置,则通过循环等待的方式等待消费者消费出空闲位置;</p><p>ps:循环等待是通过<B>LockSupport.parkNanos(1L);</B>这种方式实现的;</p><ul><li><p>MultiProducerSequencer#next<br>@TODO 待补充</p></li><li><p>获取对应的事件对象</p></li></ul><p>获取事件对象是通过RingBuffer#get方法实现的,具体代码如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> sequence<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">elementAt</span><span class="token punctuation">(</span>sequence<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">E</span> <span class="token function">elementAt</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> sequence<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//先加数组前BUFFER_PAD位插入的空白,在进行位运算返回事件</span>    <span class="token keyword">return</span> entries<span class="token punctuation">[</span><span class="token constant">BUFFER_PAD</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sequence <span class="token operator">&amp;</span> indexMask<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取事件很简单,直接获取entries数组中对应位置的事件对象即可,需要注意的是由于entries数组前后有BUFFER_PAD个空白位置,因此在获取时需要加上BUFFER_PAD;</p><p>获取完成事件后,对事件进行填充,这个过程是用户自行实现的,填充完成后,需要发布事件通知消费者;</p><ul><li>发布事件</li></ul><p>RingBuffer的pushlish方法是调用Sequencer的publish方法实现的,具体代码如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publish</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> sequence<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sequencer<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>sequence<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Sequencer#publish<br>Sequencer的publish方法同样有两个实现,分别是SingleProducerSequencer和MultiProducerSequencer,先对SingleProducerSequencer进行分析:</p></li><li><p><a href="https://github.com/agmtopy/disruptor-source/blob/a617447ce5091233d96d5fbd318ae52e49a51d9f/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java#L235">SingleProducerSequencer#publish(long)</a></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publish</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> sequence<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//设置最大序列号</span>    cursor<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sequence<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//通知消费者等待策略唤醒</span>    waitStrategy<span class="token punctuation">.</span><span class="token function">signalAllWhenBlocking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cursor.set(sequence)的作用是发布当前事件的序列号,类似于声明该事件已处理完成,消费者可以开始消费该事件,cursor对象是Sequence的一个实例对象,cursor.set(sequence)方法会将cursor的值设置为传入的sequence值,表示当前已发布的最大序列号;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Sequence</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> initialValue<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//写屏障,保证写操作不会被指令重排序</span>    <span class="token class-name">VarHandle</span><span class="token punctuation">.</span><span class="token function">releaseFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> initialValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用waitStrategy.signalAllWhenBlocking()方法通知等待策略唤醒消费者线程,从而让消费者开始消费事件;</p><p>signalAllWhenBlocking方法不同的消费者有不同的实现,例如BusySpinWaitStrategy从不释放CPU,也不存在唤醒<br><a href="https://github.com/agmtopy/disruptor-source/blob/1384012154411b4c4e2081cd594d03f12616c417/src/main/java/com/lmax/disruptor/BusySpinWaitStrategy.java#L43">com.lmax.disruptor.BusySpinWaitStrategy#signalAllWhenBlocking</a></p><p>BlockingWaitStrategy使用信号量mutex来控制释放CPU时,对于signalAllWhenBlocking需要进行notifyAll操作</p><p><a href="https://github.com/agmtopy/disruptor-source/blob/1384012154411b4c4e2081cd594d03f12616c417/src/main/java/com/lmax/disruptor/BlockingWaitStrategy.java#L55">com.lmax.disruptor.BlockingWaitStrategy#signalAllWhenBlocking</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">signalAllWhenBlocking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mutex<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读取流程"><a class="header-anchor" href="#读取流程"></a>读取流程</h3><p>先从消费者如何注册开始分析,消费者注册分为两种注册方式分别是<B>handleEventsWith()</B>注册广播消息处理器和<B>handleEventsWithWorkerPool</B>注册事件消费组的方式;</p><ul><li><p>广播模式<br>广播模式指的是消息会被每一个注册的消费器处理一次,需要继承<B>EventHandler</B>接口,实现<B>onEvent</B>方法;</p></li><li><p>事件消费组模式<br>事件消费模式指的是消息会被事件消费组中的某一个消费者处理一次,需要实现<B>WorkHandler</B>接口,实现<B>onEvent</B>方法;<br>ps:WorkerPool的方式在Disruptor中已被废弃,建议使用EventHandler的方式;</p></li></ul><p>下面基于disruptor4.0版本对EventHandler进行分析;</p><ol><li>注册流程<br>Disruptor#handleEventsWith()  -&gt;  <a href="https://github.com/agmtopy/disruptor-source/blob/ff615c140fcd068c1d7296ce7f1a76cfd70e0588/src/main/java/com/lmax/disruptor/dsl/Disruptor.java#L506">createEventProcessors()</a></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">EventHandlerGroup</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">createEventProcessors</span><span class="token punctuation">(</span>            <span class="token keyword">final</span> <span class="token class-name">Sequence</span><span class="token punctuation">[</span><span class="token punctuation">]</span> barrierSequences<span class="token punctuation">,</span>            <span class="token keyword">final</span> <span class="token class-name">EventHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> eventHandlers<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">checkNotStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//每个消费者一个Sequence</span>        <span class="token keyword">final</span> <span class="token class-name">Sequence</span><span class="token punctuation">[</span><span class="token punctuation">]</span> processorSequences <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sequence</span><span class="token punctuation">[</span>eventHandlers<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">SequenceBarrier</span> barrier <span class="token operator">=</span> ringBuffer<span class="token punctuation">.</span><span class="token function">newBarrier</span><span class="token punctuation">(</span>barrierSequences<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//依次处理EventHandler</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> eventHandlersLength <span class="token operator">=</span> eventHandlers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> eventHandlersLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//取出EventHandler包装成BatchEventProcessor</span>            <span class="token keyword">final</span> <span class="token class-name">EventHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> eventHandler <span class="token operator">=</span> eventHandlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token class-name">BatchEventProcessor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> batchEventProcessor <span class="token operator">=</span>                    <span class="token keyword">new</span> <span class="token class-name">BatchEventProcessorBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>ringBuffer<span class="token punctuation">,</span> barrier<span class="token punctuation">,</span> eventHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//设置异常处理器</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>exceptionHandler <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                batchEventProcessor<span class="token punctuation">.</span><span class="token function">setExceptionHandler</span><span class="token punctuation">(</span>exceptionHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//核心关键点1:用consumerRepository来存储EventProcessor</span>            consumerRepository<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>batchEventProcessor<span class="token punctuation">,</span> eventHandler<span class="token punctuation">,</span> barrier<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//对序列数组进行初始化</span>            processorSequences<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> batchEventProcessor<span class="token punctuation">.</span><span class="token function">getSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//核心关键点2:更新消费者门闩,防止生产者将未消费位置覆盖</span>        <span class="token function">updateGatingSequencesForNextInChain</span><span class="token punctuation">(</span>barrierSequences<span class="token punctuation">,</span> processorSequences<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">EventHandlerGroup</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> consumerRepository<span class="token punctuation">,</span> processorSequences<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法中有两个地方值得注意,第一个地方是在于<B>consumerRepository</B>,用于保存消费者对象的容器,内部是通过Map的方式进行实现的</p><ul><li>ConsumerRepository</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConsumerRepository</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EventHandlerIdentity</span><span class="token punctuation">,</span> <span class="token class-name">EventProcessorInfo</span><span class="token punctuation">></span></span> eventProcessorInfoByEventHandler <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">IdentityHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Sequence</span><span class="token punctuation">,</span> <span class="token class-name">ConsumerInfo</span><span class="token punctuation">></span></span> eventProcessorInfoBySequence <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">IdentityHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ConsumerInfo</span><span class="token punctuation">></span></span> consumerInfos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//省略......</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS:IdentityHashMap中的key是比较对象引用地址</p><p>第二个关键点是<B>updateGatingSequencesForNextInChain</B>方法,这个方法的作用是在于防止生产者提前将未消费的事件覆盖掉;</p><ul><li><a href="https://github.com/agmtopy/disruptor-source/blob/ff615c140fcd068c1d7296ce7f1a76cfd70e0588/src/main/java/com/lmax/disruptor/dsl/Disruptor.java#L573">Disruptor#updateGatingSequencesForNextInChain</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">updateGatingSequencesForNextInChain</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Sequence</span><span class="token punctuation">[</span><span class="token punctuation">]</span> barrierSequences<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Sequence</span><span class="token punctuation">[</span><span class="token punctuation">]</span> processorSequences<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//消费者处理序列长度大于0时,才进行处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>processorSequences<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 把新的消费者序列 (B) 加入 RingBuffer 的监控名单</span>        ringBuffer<span class="token punctuation">.</span><span class="token function">addGatingSequences</span><span class="token punctuation">(</span>processorSequences<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2. 把旧的屏障序列 (A) 从监控名单移除</span>        <span class="token comment">// 因为 B 依赖 A，所以 B 肯定比 A 慢，RingBuffer 只要盯着 B 就够了</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Sequence</span> barrierSequence <span class="token operator">:</span> barrierSequences<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ringBuffer<span class="token punctuation">.</span><span class="token function">removeGatingSequence</span><span class="token punctuation">(</span>barrierSequence<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 3. 同时也告诉这个消费者组，下次如果再有人接在 B 后面（比如 .then(C)），</span>        <span class="token comment">// B 就变成了由于旧的序列，需要被移除</span>        consumerRepository<span class="token punctuation">.</span><span class="token function">unMarkEventProcessorsAsEndOfChain</span><span class="token punctuation">(</span>barrierSequences<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为disruptor支持消费者之间相互依赖进行消费,因此对于有相互依赖关系的两个消费者,例如A消费者完成在then B消费者这种场景,只需要判断B消费者是否完成消费即可,如果B完成表示A肯定完成,因此只需要监控B消费者的Sequences即可;</p><p>第三步设置处理链结束的方法是<a href="https://github.com/agmtopy/disruptor-source/blob/aa7c19701dae05d138911ee350a1b52cbca9613a/src/main/java/com/lmax/disruptor/dsl/EventProcessorInfo.java#L87">EventProcessorInfo#markAsUsedInBarrier</a><br>将endOfChain设置未false即可;</p><ol start="2"><li>启动消费者流程</li></ol><p>disruptor的启动方法是[Disruptor#start],这个方法会调用<a href="https://github.com/agmtopy/disruptor-source/blob/5eb647d1603c39f7f670cd718ef3e73b673c6488/src/main/java/com/lmax/disruptor/dsl/ConsumerRepository.java#L60">ConsumerRepository#startAll</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startAll</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    consumerInfos<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>c <span class="token operator">-></span> c<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>threadFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/agmtopy/disruptor-source/blob/aa7c19701dae05d138911ee350a1b52cbca9613a/src/main/java/com/lmax/disruptor/dsl/EventProcessorInfo.java#L66">EventProcessorInfo#start</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//通过线程工厂创建一个指定好任务的线程</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread <span class="token operator">=</span> threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>eventprocessor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> thread<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Failed to create thread to run: "</span> <span class="token operator">+</span> eventprocessor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//立即启动线程执行任务</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这一个步骤又和注册consumerhandler关联到一起了,注册时将eventHandler包装成BatchEventProcessor,ConsumerInfo启动后会执行BatchEventProcessor子类的<B>run</B>方法,下面以<B>BatchEventProcessor</B>来进行分析:<br>BatchEventProcessor.run()方法主要做的事为:清除屏障标识、开始循环处理事件</p><ul><li><a href="https://github.com/agmtopy/disruptor-source/blob/d9fefddb24f28a8e8dfd5464029d6c01f4c1e9f2/src/main/java/com/lmax/disruptor/BatchEventProcessor.java#L149">com.lmax.disruptor.BatchEventProcessor#processEvents</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>       <span class="token class-name">T</span> event <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>       <span class="token comment">//设置需要处理的下一个序列号</span>       <span class="token keyword">long</span> nextSequence <span class="token operator">=</span> sequence<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1L</span><span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>       <span class="token punctuation">&#123;</span>           <span class="token keyword">final</span> <span class="token keyword">long</span> startOfBatchSequence <span class="token operator">=</span> nextSequence<span class="token punctuation">;</span>           <span class="token comment">//外层try-catch处理系统异常</span>           <span class="token keyword">try</span>           <span class="token punctuation">&#123;</span>               <span class="token comment">//内层try-catch处理可重试异常</span>               <span class="token keyword">try</span>               <span class="token punctuation">&#123;</span>                   <span class="token comment">//关键点1:检测是否可以进行消费:是否有可消费的消息,是否前置消费处理器已处理完成</span>                   <span class="token comment">//返回的最大的可消费位置</span>                   <span class="token keyword">final</span> <span class="token keyword">long</span> availableSequence <span class="token operator">=</span> sequenceBarrier<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span>nextSequence<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//设置单次消费的最大限制</span>                   <span class="token keyword">final</span> <span class="token keyword">long</span> endOfBatchSequence <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nextSequence <span class="token operator">+</span> batchLimitOffset<span class="token punctuation">,</span> availableSequence<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//判断是否有消费,有消费时通知消费事件</span>                   <span class="token keyword">if</span> <span class="token punctuation">(</span>nextSequence <span class="token operator">&lt;=</span> endOfBatchSequence<span class="token punctuation">)</span>                   <span class="token punctuation">&#123;</span>                       <span class="token comment">//通知开始处理</span>                       eventHandler<span class="token punctuation">.</span><span class="token function">onBatchStart</span><span class="token punctuation">(</span>endOfBatchSequence <span class="token operator">-</span> nextSequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> availableSequence <span class="token operator">-</span> nextSequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span>                   <span class="token comment">//循环开始处理</span>                   <span class="token keyword">while</span> <span class="token punctuation">(</span>nextSequence <span class="token operator">&lt;=</span> endOfBatchSequence<span class="token punctuation">)</span>                   <span class="token punctuation">&#123;</span>                       <span class="token comment">//关键点2:从RingBuffer数组中获取元素</span>                       event <span class="token operator">=</span> dataProvider<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nextSequence<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//通知事件</span>                       eventHandler<span class="token punctuation">.</span><span class="token function">onEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> nextSequence<span class="token punctuation">,</span> nextSequence <span class="token operator">==</span> endOfBatchSequence<span class="token punctuation">)</span><span class="token punctuation">;</span>                       nextSequence<span class="token operator">++</span><span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span>                   retriesAttempted <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                   <span class="token comment">//设置本次读取的终止位置</span>                   sequence<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>endOfBatchSequence<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>               <span class="token comment">//省略...</span>           <span class="token punctuation">&#125;</span>           <span class="token comment">//省略...</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法有两个重要的关键点,分别是关键点1负责检测是否可以进行消费和关键点2从RingBuffer数组中获取元素进行消费的动作<br>关键点1<B>sequenceBarrier.waitFor</B>方法的作用是在于使用传入的等待策略来等待可消费的消息;<br>关键点2<B>dataProvider.get(nextSequence)</B>方法的作用是去取RingBuffer中的event数组中的数据,然后在将event传递到eventHandler.onEvent方法中</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/mjunz/p/18896162">Disruptor—3.核心源码实现分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Disruptor源码分析之RingBuffer&lt;/h1&gt;
&lt;p&gt;RingBuffer是Disruptor的核心组件之一,它是一个高效的环形缓冲区,用于在生产者和消费者之间传递事件对象,RingBuffer通过预分配内存和无锁设计实现了高性能的数据传输,本文将深入分析Ri</summary>
      
    
    
    
    <category term="高性能" scheme="https://agmtopy.gitee.io/categories/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="disruptor" scheme="https://agmtopy.gitee.io/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor之理论基础</title>
    <link href="https://agmtopy.gitee.io/2025/11/09/26.%E9%AB%98%E6%80%A7%E8%83%BD/02.Disruptor%E4%B9%8B%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2025/11/09/26.%E9%AB%98%E6%80%A7%E8%83%BD/02.Disruptor%E4%B9%8B%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90/</id>
    <published>2025-11-09T07:03:34.000Z</published>
    <updated>2025-11-11T17:05:58.289Z</updated>
    
    <content type="html"><![CDATA[<h1>Disruptor之理论基础</h1><p>disruptor的设计理念主要围绕以下几个核心思想:<strong>无锁设计</strong>,<strong>缓存行填充</strong>,<strong>序列号机制</strong>,<strong>事件驱动</strong>,<strong>高吞吐量</strong>;</p><h2 id="传统队列的一些问题"><a class="header-anchor" href="#传统队列的一些问题"></a>传统队列的一些问题</h2><ul><li>锁性能瓶颈<br>锁提供了一种互斥机制,通过锁可以保证数据安全性,但是锁的使用会带来性能瓶颈,根据Disruptor官网的说法使用锁的成本如下</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/Disruptor%E5%AE%98%E7%BD%91%E5%AF%B9%E4%BA%8E%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%86%E6%9E%90.png?raw=true" alt="性能分析"><br>可以看到性能如下:无锁 &gt; valatile &gt; CAS &gt; lock,其中可以看到即使是CAS的性能也远远大于lock的方式,这是因为CAS不需要切换到内核态,而lock需要频繁的切换到内核态,这会带来很大的性能开销;</p><p>这里有一个知识点,对于互斥锁或者信号量发生竞争时,都会使用<B>内核仲裁</B>来决定锁的归属,从用户态切换到内核态会涉及到切换上线文,上线文切换会发生<B>缓存行失效</B>,这两个开销加起来会导致锁的性能大幅下降;</p><p>紧接着就引出第二点,缓存行失效的问题;</p><ul><li>缓存行</li></ul><p>缓存行指的是现代的CPU为了提高内存访问效率,在加载内存时是通过加载一个缓存行,通常缓存行的大小为64字节;<br>在CPU进行线程切换时,因为不同的线程可能会访问不同的内存地址,当线程切换时,CPU需要重新加载新的缓存行,这会导致之前的缓存行失效,从而带来性能下降,这也就是<B>缓存行失效问题</B>;<br>同一个缓存行中可能同时放着两个不同的对象,当线程修改某一个对象时,会导致整个缓存行失效,让CPU重新对整个缓存行进行加载,从而影响另一个对象的访问性能,这就是<B>缓存行伪共享问题</B>,可以通过增大数组元素中的间隔来解决;</p><h2 id="Disruptor的设计理念"><a class="header-anchor" href="#Disruptor的设计理念"></a>Disruptor的设计理念</h2><ul><li>环形数据结构<br>Disruptor使用环形缓冲区(RingBuffer)作为数据存储结构,在初始化时预先分配内存,通过使用环形缓冲区可以避免频繁的内存分配和垃圾回收,从而提高性能,其中环形缓冲区只是逻辑上采用的,实际上是通过数组实现的,如图第二部分所示,当发布到第17个事件时,实际上是覆盖了第1个事件的位置;<br>采用连续内存的数组存储数据的好处是相邻的数据会被加载到相同的CPU cache中,所以访问遍历的速度会很快,而传统的链表结构会导致数据分散在内存中,从而影响缓存命中率;</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/Disruptor%E5%AE%98%E7%BD%91_RingBuffer.png?raw=true" alt="RingBuffer结构"></p><ul><li><p>无锁设计<br>Disruptor通过使用无锁设计来避免锁竞争带来的性能瓶颈,它使用了CAS操作和自旋锁等技术来实现线程间的协调,从而避免了锁的使用;</p></li><li><p>序列号机制<br>Disruptor通过序列号机制来实现生产者和消费者之间的协调,每个事件都有一个唯一的序列号,生产者在发布事件时会递增序列号,消费者在消费事件时也会递增序列号,通过比较序列号来判断事件是否已经被消费;</p></li><li><p>缓存行处理<br>Disruptor通过缓存行填充技术来避免缓存行伪共享问题,它在数据结构中添加填充字段,确保不同的对象不会共享同一个缓存行,从而提高缓存命中率;</p></li><li><p>事件驱动模型<br>Disruptor采用事件驱动模型,生产者发布事件后,消费者会被通知进行消费,这种模型可以减少轮询等待的开销,提高系统的响应速度;</p></li></ul><h2 id="Disruptor的实现"><a class="header-anchor" href="#Disruptor的实现"></a>Disruptor的实现</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/Disruptor%E5%AE%98%E7%BD%91_%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9B%BE.png?raw=true" alt="Disruptor核心类图"></p><h3 id="核心数据结构-RingBuffer"><a class="header-anchor" href="#核心数据结构-RingBuffer"></a>核心数据结构:RingBuffer</h3><p>RingBuffer是由数组\事件\缓冲区大小\生产者序列号(Sequencer)\消费者序列号(Sequences)组成,各自功能如下:</p><ul><li>数组:一个用于存储事件对象且大小固定的数组</li><li>事件:RingBuffer中存储的数据单元,在RingBuffer初始化时通过事件工厂预创建</li><li>缓冲区大小:RingBuffer的大小,必须是2的N次方,以便于通过位运算进行索引计算</li><li>生产者序列号(Sequencer):用于跟踪生产者发布事件的位置</li><li>消费者序列号(Sequences):用于跟踪消费者消费事件的位置</li></ul><h3 id="等待策略"><a class="header-anchor" href="#等待策略"></a>等待策略</h3><p>等待策略分为消费等待策略和生产等待策略,主要用于控制生产者和消费者在等待事件时的行为</p><ul><li><p>生产等待策略(ClaimStrategy)<br>确保多个生产者在并发写入时，能够安全、无冲突地获取到独占的 RingBuffer 序列号,有两种策略:</p></li><li><p>单生产者策略(SingleThreadedClaimStrategy):适用于单个生产者的</p></li><li><p>多生产者策略(MultiThreadedClaimStrategy):适用于多个生产者的</p></li><li><p>消费者等待策略(WaitStrategy)<br>优化消费者等待新事件时的 CPU 使用效率和延迟之间的权衡,有以下几种策略:</p></li></ul><table><thead><tr><th>类型</th><th>策略名称</th><th>核心机制</th><th>延迟 (Latency)</th><th>CPU 占用</th><th>适用场景</th></tr></thead><tbody><tr><td>I. 极限性能型</td><td>1. BusySpinWaitStrategy</td><td>纯自旋空循环，不放弃 CPU。</td><td>最低 (Low)</td><td>极高 (Max)</td><td>对延迟有毫秒级甚至纳秒级的苛刻要求，且生产者持续高产，不计 CPU 消耗。</td></tr><tr><td>II. 平衡优化型</td><td>2. YieldingWaitStrategy</td><td>短暂自旋后，调用 Thread.yield() 放弃时间片。</td><td>低 (Low)</td><td>中等 (Medium)</td><td>延迟敏感但希望适度节省 CPU 的场景，是最常用的平衡策略。</td></tr><tr><td></td><td>3. SleepingWaitStrategy</td><td>自旋后，周期性地调用 Thread.sleep(1)，让出 CPU 并休眠。</td><td>中等 (Moderate)</td><td>低 (Low)</td><td>适用于延迟要求不高，但需要更彻底节省 CPU 的多生产者场景。</td></tr><tr><td>III. 资源友好型</td><td>4. BlockingWaitStrategy</td><td>使用 Java 锁和条件变量阻塞线程，被生产者唤醒。</td><td>中高 (Moderate/High)</td><td>最低 (Min)</td><td>对延迟不敏感，追求最低 CPU 占用的场景，如日志或监控系统。</td></tr><tr><td></td><td>5. LiteBlockingWaitStrategy</td><td>使用 LockSupport.parkNanos 进行轻量级阻塞。</td><td>中高 (Moderate/High)</td><td>最低 (Min)</td><td>类似于 Blocking，但试图减少与操作系统锁的交互开销，略微更高效。</td></tr><tr><td>IV. 高级自适应型</td><td>6. PhasedBackoffWaitStrategy</td><td>三阶段混合：忙等 -&gt; Yield -&gt; 阻塞/定时阻塞。</td><td>自适应</td><td>自适应</td><td>生产者吞吐量极不稳定的场景。高负载时低延迟，空闲时低 CPU。</td></tr><tr><td></td><td>7. TimeoutBlockingWaitStrategy</td><td>阻塞等待，但设有超时时间。</td><td>中高 (Moderate/High)</td><td>最低 (Min)</td><td>需定期处理逻辑（如心跳、超时检查）的消费者，不希望永远阻塞。</td></tr><tr><td></td><td>8. LiteTimeoutBlockingWaitStrategy</td><td>轻量阻塞等待，设有超时时间。</td><td>中高 (Moderate/High)</td><td>最低 (Min)</td><td>LiteBlocking 的超时版本，结合了轻量阻塞和周期性唤醒的需求。</td></tr></tbody></table><h3 id="写入逻辑"><a class="header-anchor" href="#写入逻辑"></a>写入逻辑</h3><h4 id="单生产者写入流程"><a class="header-anchor" href="#单生产者写入流程"></a>单生产者写入流程</h4><p>步骤 1: 申请下一个订单流水号 (Claim)<br>Disruptor 单生产者：唯一的生产者直接操作自己的序列号,进行一次原子递增操作<br>步骤 2: 检查RingBuffer是否已满<br>通过比较下一个序列号和消费者的最小序列号加上缓冲区大小来判断RingBuffer是否已满,如果已满则需要等待消费者消费;<br>步骤 3: 替换事件<br>将数据写入该位置的事件对象中;<br>步骤 4: 发布事件<br>通过更新生产者序列号来发布事件,通知消费者有新事件可以消费;</p><h4 id="多生产者写入流程"><a class="header-anchor" href="#多生产者写入流程"></a>多生产者写入流程</h4><p>步骤 1: 抢夺下一个订单流水号 (Claim with CAS)<br>所有生产者同时尝试读取当前的最高序列号（例如 9），并尝试使用 CAS (Compare-and-Swap) 将其原子性地更新到 10。更新成功的生产者获得了序列号 10，可以10的位置进行写入；更新失败的生产者需要重新读取最新的最高序列号并重试。<br>步骤 2: 检查RingBuffer是否已满<br>与单生产者类似,通过比较下一个序列号和消费者的最小序列号加上缓冲区大小来判断RingBuffer是否已满,如果已满则需要等待消费者消费;<br>步骤 3: 替换事件<br>将数据写入该位置的事件对象中;<br>步骤 4: 按序发布事件 (Gated Publish)<br>多生产者需要确保事件按序发布,即使生产者抢到了序列号10,也不能直接发布,而是需要等待序列号9被发布后才能发布序列号10,通过这种方式确保事件的顺序性;</p><p>简单来说就是:<B>多生产者模式下通过CAS的方式竞争下一个下入位置,更新成功的生产者向持有的那个位置进行写入,同时发布事件时必须顺序的进行发布</B></p><h3 id="消费逻辑"><a class="header-anchor" href="#消费逻辑"></a>消费逻辑</h3><h4 id="单个消费者消费流程"><a class="header-anchor" href="#单个消费者消费流程"></a>单个消费者消费流程</h4><p>步骤 1: 检测是否有新数据<br>通过比较消费者的序列号和生产者的序列号来判断是否有新数据可供消费;<br>步骤 2: 决策是消费还是等待<br>如果有新数据则继续消费,否则根据等待策略进行等待;<br>步骤 3: 批量获取待消费事件范围<br>为了提高效率,消费者可以批量获取一段范围内的事件进行消费;<br>步骤 4: 处理事件<br>消费者对获取到的事件进行处理;</p><h4 id="多个消费者消费流程"><a class="header-anchor" href="#多个消费者消费流程"></a>多个消费者消费流程</h4><p>多个消费者的处理流程比较复杂,因为消息处理策略可以分为广播消息和事件消息两种,并且在消费上也可以分为独立消费和协同消费两种模式,所以多消费者的处理流程需要根据具体的场景来设计;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html">Disruptor官网</a><br><a href="https://qin.news/disruptor/">Disruptor 高性能队列原理浅析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Disruptor之理论基础&lt;/h1&gt;
&lt;p&gt;disruptor的设计理念主要围绕以下几个核心思想:&lt;strong&gt;无锁设计&lt;/strong&gt;,&lt;strong&gt;缓存行填充&lt;/strong&gt;,&lt;strong&gt;序列号机制&lt;/strong&gt;,&lt;strong&gt;事件驱动&lt;/stro</summary>
      
    
    
    
    <category term="高性能" scheme="https://agmtopy.gitee.io/categories/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="disruptor" scheme="https://agmtopy.gitee.io/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor之基础入门</title>
    <link href="https://agmtopy.gitee.io/2025/11/07/26.%E9%AB%98%E6%80%A7%E8%83%BD/01.Disruptor%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://agmtopy.gitee.io/2025/11/07/26.%E9%AB%98%E6%80%A7%E8%83%BD/01.Disruptor%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2025-11-06T16:04:18.000Z</published>
    <updated>2025-11-09T05:50:12.322Z</updated>
    
    <content type="html"><![CDATA[<h1>Disruptor之基础入门</h1><h2 id="什么是Disruptor"><a class="header-anchor" href="#什么是Disruptor"></a>什么是Disruptor</h2><p>Disruptor是一个高性能的并发编程框架，旨在提供低延迟和高吞吐量的数据处理能力。它由LMAX交易所开发，最初用于金融交易系统，但其设计理念和实现方式使其适用于各种需要高性能数据处理的场景;<br>核心的设计理念是认为<B>队列是一种糟糕的抽象，因为它暗示了数据必须在不同上下文之间被复制排队进行处理,LMAX Disruptor哲学核心是通过共享内存、序列同步，而不是通过消息排队，来实现线程间通信。</B></p><p>由于Disruptor只是一个队列,对于事件的处理并不会有性能上的提高,它提高的是使用传统队列时的性能损耗,传统的队列会因为锁竞争、缓存行失效等问题导致性能下降,而Disruptor通过无锁设计和缓存行填充等技术来减少这些问题,从而实现高性能的事件传递。</p><h2 id="Disruptor的使用"><a class="header-anchor" href="#Disruptor的使用"></a>Disruptor的使用</h2><h3 id="基础使用"><a class="header-anchor" href="#基础使用"></a>基础使用</h3><ul><li>单个生产者,单个消费者模式</li></ul><p><a href="https://github.com/agmtopy/Disruptor/blob/master/src/main/java/performance/basis/Disruptor1P1C.java">Disruptor1P1C</a><br>使用Disruptor步骤如下<br><B>第一步</B>是创建一个Disruptor实例,需要指定4个参数分别是:</p><ol><li>事件工厂,用于RingBuffer<B>预创建</B>事件实例对象使用</li><li>消费者线程工厂,用于创建消费者线程,这一点设计可以参考下一篇文章有详细的分析 @TODO</li><li>环形缓冲区大小,必须是2的N次方,用于设置RingBuffer的大小</li><li>生产者类型(单个生产者或多个生产者)</li><li>等待策略(BlockingWaitStrategy、SleepingWaitStrategy、YieldingWaitStrategy、BusySpinWaitStrategy),用于设置<B>消费者等待</B>事件的策略;<br><B>第二步</B>是注册消费者<br><B>第三步</B>是生产者填充RingBuffer并发布事件</li></ol><ul><li>单个消费者,多个生产者-广播模式</li></ul><p><a href="https://github.com/agmtopy/Disruptor/blob/master/src/main/java/performance/basis/Disruptor1P2C.java">Disruptor1P2C</a></p><p>通过handleEventsWith方法注册多个消费者,消息会被多个消费者消费<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B_1p2c.png?raw=true" alt="事件消费模型_1p2c"></p><ul><li>单个消费者,单个消费组-事件模式<br>事件只会被同一个消费组中的某一个hadnler消费,不同消费组之间是并行消费的,消费组之间是完全隔离的互不影响</li></ul><p><a href="https://github.com/agmtopy/Disruptor/blob/master/src/main/java/performance/basis/Disruptor1P1G.java">Disruptor1P1G</a></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B_1p1g.png?raw=true" alt="事件消费模型_1p1g"></p><ul><li>单个消费者,多个消费组-事件模式<br>事件只会被同一个消费组中的某一个hadnler消费,不同消费组之间是并行消费的,消费组之间是完全隔离的互不影响</li></ul><p><a href="https://github.com/agmtopy/Disruptor/blob/master/src/main/java/performance/basis/Disruptor1P2G.java">Disruptor1P2G</a></p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B_1p2g.png?raw=true" alt="事件消费模型_1p2g"></p><ul><li>单个消费者,多个消费组串行-事件模式<br><a href="https://github.com/agmtopy/Disruptor/blob/master/src/main/java/performance/basis/Disruptor1P2G.java">Disruptor1P1GThan1G</a></li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/d-disruptor/%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B_%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F.png?raw=true" alt="其他事件消费模型"></p><p>小结:通过实现<B>EventHandler</B>接口的处理方法是处理<B>广播</B>模式,通过<B>WorkHandler</B>接口的处理方法是处理<B>事件</B>模式;<br>对事件的处理方法可以使用handleEventsWithWorkerPool方法注册多个消费组,消费者之间可以通过<B>then</B>方法串行处理,通过<B>after</B>方法配合<B>handleEventsWith</B>来指定消费组之间的依赖关系,实现链式\菱形\六边形等消费模式;</p><h2 id="适用场景"><a class="header-anchor" href="#适用场景"></a>适用场景</h2><p>Disruptor解决的问题是队列在高并发场景下由于锁竞争、缓存行失效等问题导致的性能瓶颈,因此对于性能瓶颈在事件处理上的场景,Disruptor并不能带来性能提升,反而会因为其复杂性带来额外的开销;<br>以下是一些适合使用Disruptor的场景:</p><ol><li>高频交易系统:需要处理大量的交易请求,对延迟和吞吐量有极高的要求;</li></ol><p><a href="https://github.com/agmtopy/Disruptor/blob/master/src/main/java/performance/MatchingTransactions/ExchangeLauncher.java">ExchangeLauncher</a></p><p>这个是一个简单的撮合引擎示例,使用Disruptor实现高性能的订单撮合交易,我们重点关注ExchangeLauncher对disruptord分组使用,ResultsHandler对事件的处理操作;</p><ol start="2"><li><p>日志操作:Log4j2使用Disruptor实现异步日志记录,提高日志写入性能;</p><ul><li><p>2.1 创建Disruptor实例<br><a href="https://github.com/apache/logging-log4j2/blob/1cfcda9b4ccd4e6a0b6b6c3839e68a96fd6b87ed/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerDisruptor.java#L138">AsyncLoggerDisruptor.disruptor</a></p></li><li><p>2.2 消费者Handler<br><a href="https://github.com/apache/logging-log4j2/blob/1cfcda9b4ccd4e6a0b6b6c3839e68a96fd6b87ed/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerDisruptor.java#L53">AsyncLoggerDisruptor.createEventHandler()</a></p></li><li><p>2.3 生产者发布日志事件<br>[AsyncLogger.handleRingBufferFull()](<a href="https://github.com/apache/logging-log4j2/blob/dc6c53ab7bb195f3878d3ee92cd0ff20634326f1/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java#L277">https://github.com/apache/logging-log4j2/blob/dc6c53ab7bb195f3878d3ee92cd0ff20634326f1/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java#L277</a>;</p></li></ul></li><li><p>Axon Framework:使用Disruptor实现事件处理和命令处理;</p><ul><li>3.1 创建Disruptor实例<br><a href="https://github.com/AxonFramework/AxonFramework/blob/4.5.0/axon-disruptor/src/main/java/org/axonframework/disruptor/DisruptorEventBus.java#L244">DisruptorEventBus.createDisruptor()</a></li><li>3.2 消费者Handler<br><a href="https://github.com/AxonFramework/AxonFramework/blob/4.5.0/axon-disruptor/src/main/java/org/axonframework/disruptor/DisruptorEventBus.java#L266">EventProcessorHandler</a></li><li>3.3 生产者发布事件<br><a href="https://github.com/AxonFramework/AxonFramework/blob/4.5.0/axon-disruptor/src/main/java/org/axonframework/disruptor/DisruptorEventBus.java#L304">EventProcessorHandler.doDispatch()</a></li></ul></li></ol><h2 id="相关项目"><a class="header-anchor" href="#相关项目"></a>相关项目</h2><ul><li><a href="https://github.com/apache/logging-log4j2">logging-log4j2</a></li><li><a href="https://github.com/AxonFramework">AxonFramework</a></li></ul><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><ol><li><a href="https://lmax-exchange.github.io/disruptor/disruptor.html?utm_source=chatgpt.com">Throughput Performance Testing</a></li><li><a href="https://martinfowler.com/articles/lmax.html">The LMAX Architecture</a></li><li><a href="https://mp.weixin.qq.com/s/kmuG5azJnqjKRYlkiVHWqQ">Disruptor在撮合引擎的实践｜得物技术</a></li><li><a href="https://tech.meituan.com/2016/11/18/disruptor.html">高性能队列——Disruptor</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Disruptor之基础入门&lt;/h1&gt;
&lt;h2 id=&quot;什么是Disruptor&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是Disruptor&quot;&gt;&lt;/a&gt;什么是Disruptor&lt;/h2&gt;
&lt;p&gt;Disruptor是一个高性能的并发编程框架，</summary>
      
    
    
    
    <category term="高性能" scheme="https://agmtopy.gitee.io/categories/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="disruptor" scheme="https://agmtopy.gitee.io/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>深入理解分布式事务-原理与实践-分布式事务原理</title>
    <link href="https://agmtopy.gitee.io/2025/08/31/19.%E5%88%86%E5%B8%83%E5%BC%8F/2.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://agmtopy.gitee.io/2025/08/31/19.%E5%88%86%E5%B8%83%E5%BC%8F/2.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/</id>
    <published>2025-08-31T15:48:30.000Z</published>
    <updated>2025-09-01T17:13:53.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入理解分布式事务-原理与实践-分布式事务原理"><a class="header-anchor" href="#深入理解分布式事务-原理与实践-分布式事务原理"></a>深入理解分布式事务-原理与实践-分布式事务原理</h2><p>在上一章中已经介绍了分布式事务的基础知识了,这一章将会介绍主要的几种分布式事务的原理,包括<B>XA强一致性分布式事务原理</B>、<B>TCC分布式事务原理</B>、<B>可靠消息型分布式事务原理</B>、<B>最大努力通知型分布式事务原理</B></p><h3 id="XA强一致性分布式事务原理"><a class="header-anchor" href="#XA强一致性分布式事务原理"></a>XA强一致性分布式事务原理</h3><p>X/Open组织定于的分布式事务标准规划被称为<B>X/Open DTP模型</B>,定义了事务处理的规划和API,具体的实现由各个厂商进行负责实现;</p><ul><li><p>DTP模型<br>主要定义了3个组件,分别是<B>应用程序</B>、<B>资源管理器</B>、<B>事务管理器</B><br>应用程序:定义事务边界<br>资源管理器:提供访问资源的方式<br>事务管理器:分配事务ID、监控事务的执行进度、负责事务的提交和回滚</p></li><li><p>xa规范</p></li></ul><ol><li>xa_start:负责开启或恢复一个分支事务</li><li>xa_end:负责暂停或终止一个分支事务</li><li>xa_prepare:负责对一个分支事务进行预提交操作</li><li>xa_commit:负责提交一个分支事务</li><li>xa_rollback:负责回滚一个分支事务</li><li>xa_recover:负责在系统崩溃后,恢复未完成的分支事务</li></ol><ul><li>xa事务的缺陷</li></ul><ol><li>同步阻塞<br>MySQl需要配合串行化的事务隔离级别来使用XA事务,这会导致性能下降。</li><li>单点故障<br>XA事务的协调者是事务管理器,如果事务管理器出现故障,资源管理器会一直等待,不会主动释放资源;</li><li>数据不一致<br>在二阶段过程中,如果协调者向一部分资源管理器发送了提交请求,而另一部分资源管理器由于故障未能收到提交请求,就会导致数据不一致。</li></ol><h3 id="TCC分布式事务原理"><a class="header-anchor" href="#TCC分布式事务原理"></a>TCC分布式事务原理</h3><blockquote><p>TCC分布式事务最核心的思想就是在应用层将一个完整的事务拆分成三个阶段: Try、Confirm、Cancel。在某种程度上讲,TCC是一种资源,实现了Try-Confirm-Cancel三个操作接口,本质上还是两阶段提交的变种。</p></blockquote><p>TCC分布式事务属于<B>最终一致性下的补偿性事务</B><br>使用TCC时需要注意:</p><ol><li>幂等性<br>Confirm 和 Cancel 阶段可能会因为网络超时等原因被重试。因此，这两个方法必须是幂等的，即无论被调用多少次，结果都必须一致。开发者需要自行实现幂等性检查，例如通过一个唯一的事务 ID。</li><li>空回滚（Empty Rollback）<br>如果一个服务的 Try 阶段因为网络问题失败了，但 Cancel 阶段的请求却成功到达了，那么就会发生“空回滚”。Cancel 方法被调用时，Try 方法实际上没有执行，Cancel 必须能够识别这种情况并安全地退出，不执行任何回滚操作。</li></ol><p>为每一个全局事务生成一个唯一的事务ID，并在 Try 阶段执行时，将这个事务ID和一些状态信息记录下来。在 Cancel 阶段执行时，首先检查这个唯一的事务ID对应的记录是否存在。<br>如果记录存在：说明 Try 阶段已经成功执行过，此时可以安全地执行 Cancel 逻辑。<br>如果记录不存在：说明 Try 阶段没有成功执行（可能是因为网络延迟或请求失败），此时可以判断为空回滚，Cancel 方法应该直接返回，不执行任何业务回滚操作。<br>简单来说，就是通过一个事务日志或状态记录来判断 Try 阶段是否成功执行，避免 Cancel 方法在不恰当的时机被调用。</p><ol start="3"><li>防悬挂<br>悬挂问题的本质是：Try 阶段的资源被锁定后，Confirm 或 Cancel 阶段的请求永远没有到达，导致资源一直被占用。<br>设置一个超时时间，来自动清理那些长时间没有得到 Confirm 或 Cancel 最终指令的 Try 事务。</li></ol><h3 id="可靠消息最终一致性分布式事务原理"><a class="header-anchor" href="#可靠消息最终一致性分布式事务原理"></a>可靠消息最终一致性分布式事务原理</h3><p>可靠消息最终一致性分布式事务是一种依赖消息中间件完成资源管理器之间相互协作的最终一致性解决方案;</p><p>基本流程如下：</p><ol><li>业务服务 A 在执行某个操作时，首先将操作消息发送到消息队列中，并立即返回成功响应。</li><li>消息队列将消息异步投递到业务服务 B，业务服务 B 接收到消息后执行相应的操作。</li><li>业务服务 B 在处理完消息后，将处理结果（成功或失败）发送回消息队列。</li><li>消息队列根据处理结果，通知业务服务 A 进行相应的补偿操作。</li></ol><p>这种方式的优点在于：</p><ul><li>解耦：业务服务 A 和 B 之间通过消息队列进行通信，降低了耦合度。</li><li>异步：业务服务 A 不需要等待业务服务 B 的处理结果，可以提高系统的吞吐量。</li><li>最终一致性：通过消息的可靠投递和补偿机制，可以保证系统的最终一致性。</li></ul><p>在实现可靠消息最终一致性分布式事务时，需要注意以下几点：</p><ol><li>消息的可靠投递：确保消息能够被可靠地投递到消息队列中，并且能够被业务服务 B 正确处理。</li><li>消息的幂等性：业务服务 B 在处理消息时，需要确保操作的幂等性，以避免重复处理导致的数据不一致。</li><li>补偿机制：在业务服务 B 处理失败时，需要能够及时触发补偿操作，以保证系统的最终一致性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深入理解分布式事务-原理与实践-分布式事务原理&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#深入理解分布式事务-原理与实践-分布式事务原理&quot;&gt;&lt;/a&gt;深入理解分布式事务-原理与实践-分布式事务原理&lt;/h2&gt;
&lt;p&gt;在上一章中已经介绍了分布式事</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="读书笔记" scheme="https://agmtopy.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture常用方法总结</title>
    <link href="https://agmtopy.gitee.io/2025/07/18/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/17.CompletableFuture%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://agmtopy.gitee.io/2025/07/18/2.%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/17.CompletableFuture%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-17T16:06:48.000Z</published>
    <updated>2025-07-18T17:17:17.074Z</updated>
    
    <content type="html"><![CDATA[<h1>CompletableFuture常用方法总结</h1><p>下文对CompletableFuture类中的常用方法进行了总结,以备不时之需;</p><h2 id="创建方法"><a class="header-anchor" href="#创建方法"></a>创建方法</h2><h3 id="示例"><a class="header-anchor" href="#示例"></a>示例</h3><ol><li>supplyAsync()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token label symbol">@supplyAsync</span> FutureTask<span class="token punctuation">.</span><span class="token function">printlnWithString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>runAsync()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">    <span class="token keyword">fun</span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> future <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">runAsync</span> <span class="token punctuation">&#123;</span><span class="token comment">//            return@runAsync printlnWithString()</span>            FutureTask<span class="token punctuation">.</span><span class="token function">printlnWithVoid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//返回结果为null</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>completedFuture()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token comment">/** * 返回设定值,不会启用线程池去提交任务 */</span><span class="token keyword">fun</span> <span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token label symbol">@completedFuture</span> FutureTask<span class="token punctuation">.</span><span class="token function">printlnWithString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//返回结果为null</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点"><a class="header-anchor" href="#特点"></a>特点:</h3><table><thead><tr><th>方法名</th><th>描述</th><th>是否返回结果</th><th>返回异常</th><th>同组方法</th></tr></thead><tbody><tr><td>supplyAsync</td><td>supplyAsync提交任务</td><td>返回结果</td><td>抛出ExecutionException</td><td>supplyAsync(Runnable runnable, Executor executor)</td></tr><tr><td>runAsync</td><td>runAsync提交任务</td><td>无返回结果</td><td>抛出ExecutionException</td><td>runAsync(Runnable runnable, Executor executor)</td></tr><tr><td>completedFuture</td><td>设置默认返回值</td><td>返回结果</td><td>不会抛出异常</td><td>无</td></tr></tbody></table><h3 id="指定线程执行"><a class="header-anchor" href="#指定线程执行"></a>指定线程执行</h3><p><B>supplyAsync</B><br><B>runAsync</B></p><h2 id="链式调用"><a class="header-anchor" href="#链式调用"></a>链式调用</h2><h3 id="示例-v2"><a class="header-anchor" href="#示例-v2"></a>示例</h3><ol><li>thenApply()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenApply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">//将fn的结果传递到consumer_future函数中</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">thenApply</span> <span class="token punctuation">&#123;</span> fn_result <span class="token operator">-></span> FutureTask<span class="token punctuation">.</span><span class="token function">consumer_future</span><span class="token punctuation">(</span>fn_result<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>thenAccept()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenAccept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">thenAccept</span> <span class="token punctuation">&#123;</span> fn_result <span class="token operator">-></span> FutureTask<span class="token punctuation">.</span><span class="token function">consumer_future</span><span class="token punctuation">(</span>fn_result<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>thenRun()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">thenRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn_result:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>thenCompose()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenCompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">thenCompose</span> <span class="token punctuation">&#123;</span> fn_result <span class="token operator">-></span> FutureTask<span class="token punctuation">.</span><span class="token function">consumer_future</span><span class="token punctuation">(</span>fn_result<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>exceptionally()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">exceptionally</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">exceptionally</span> <span class="token punctuation">&#123;</span> ex <span class="token operator">-></span>        <span class="token keyword">var</span> threadName <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,异常堆栈为:"</span></span> <span class="token operator">+</span> ex<span class="token punctuation">.</span>message<span class="token punctuation">)</span>        <span class="token string-literal singleline"><span class="token string">"返回错误信息"</span></span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>whenComplete()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">    <span class="token keyword">fun</span> <span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//        val fn = FutureTask.create_future_exception()</span>        <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">whenComplete</span> <span class="token punctuation">&#123;</span> fn_result<span class="token punctuation">,</span> ex <span class="token operator">-></span>            <span class="token keyword">var</span> threadName <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,fn执行成功,返回结果为:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn_result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,fn执行失败,异常堆栈为:"</span></span> <span class="token operator">+</span> ex<span class="token punctuation">.</span>message<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>handle()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">val</span> fn <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//        val fn = FutureTask.create_future_exception()</span>        <span class="token keyword">val</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">handle</span> <span class="token punctuation">&#123;</span> fn_result<span class="token punctuation">,</span> ex <span class="token operator">-></span>            <span class="token keyword">var</span> threadName <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,fn执行成功,返回结果为:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn_result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"thread_name:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">threadName</span></span><span class="token string">,fn执行失败,异常堆栈为:"</span></span> <span class="token operator">+</span> ex<span class="token punctuation">.</span>message<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span><span class="token label symbol">@handle</span> <span class="token string-literal singleline"><span class="token string">"handle执行完成"</span></span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">val</span> fn2Result <span class="token operator">=</span> fn2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"fn2Result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">fn2Result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点-v2"><a class="header-anchor" href="#特点-v2"></a>特点:</h3><table><thead><tr><th>方法名</th><th>描述</th><th>是否返回结果</th><th>返回异常</th><th>同组方法</th></tr></thead><tbody><tr><td>thenApply</td><td>fn2处理fn1的处理结果,适用于结果转换</td><td>返回结果</td><td>抛出ExecutionException</td><td>thenApplyAsync(Function action, Executor executor)</td></tr><tr><td>thenAccept</td><td>fn2处理fn1的处理结果</td><td>无返回结果</td><td>抛出ExecutionException</td><td>thenAcceptAsync(Function action, Executor executor)</td></tr><tr><td>thenRun</td><td>fn执行完成后执行Runnable,不关心fn的返回值</td><td>抛出ExecutionException</td><td>thenRunAsync(Runnable action,Executor executor)</td><td></td></tr><tr><td>thenCompose</td><td>fn执whenComplete</td><td>返回fn同类型的返回值</td><td>抛出ExecutionException</td><td>thenComposeAsync(Function action, Executor executor)</td></tr><tr><td>exceptionally</td><td>用于处理fn的异常</td><td>有返回值</td><td>抛出ExecutionException</td><td>thenComposeAsync(Function action, Executor executor)</td></tr><tr><td>whenComplete</td><td>处理fn返回的结果或者执行异常</td><td>有返回值</td><td>抛出ExecutionException</td><td>whenComplete(Function action, Executor executor)</td></tr><tr><td>handle()</td><td>处理fn返回的结果或者执行异常</td><td>无返回值</td><td>抛出ExecutionException</td><td>handleAsync(Function action, Executor executor)</td></tr></tbody></table><p>需要注意的是<B>thenApply</B>和<B>thenCompose</B>的区别:</p><ol><li>thenApply返回的是<B>CompletableFuture</B>对象,thenCompose的返回值与fn原有的返回值</li></ol><h2 id="组合"><a class="header-anchor" href="#组合"></a>组合</h2><h3 id="示例-v3"><a class="header-anchor" href="#示例-v3"></a>示例</h3><ol><li>allOf()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">allOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> allFuture <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>        FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">val</span> result <span class="token operator">=</span> allFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>thenCombine()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenCombine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenCombine</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r1<span class="token punctuation">,</span> r2 <span class="token operator">-></span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"BiFunction threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>        <span class="token string-literal singleline"><span class="token string">"fn1的result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r1</span></span><span class="token string">,fn2的result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r2</span></span><span class="token string">,"</span></span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> combineResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">combineResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>thenAcceptBoth()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">thenAcceptBoth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAcceptBoth</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r1<span class="token punctuation">,</span> r2 <span class="token operator">-></span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"BiFunction threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string-literal singleline"><span class="token string">",fn1的result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r1</span></span><span class="token string">,fn2的result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r2</span></span><span class="token string">,"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>runAfterBoth()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">runAfterBoth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">runAfterBoth</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Runnable threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>applyToEither()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">applyToEither</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">applyToEither</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r1 <span class="token operator">-></span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Runnable threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string-literal singleline"><span class="token string">",fn1或fn2执行结果为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r1</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>        r1    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>acceptEither()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">acceptEither</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acceptEither</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> r1 <span class="token operator">-></span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Runnable threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string-literal singleline"><span class="token string">",fn1或fn2执行结果为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">r1</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>runAfterEither()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">runAfterEither</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> combine <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">runAfterEither</span><span class="token punctuation">(</span>FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Runnable threadName:"</span></span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> thenAcceptBothResult <span class="token operator">=</span> combine<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"main thread result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">thenAcceptBothResult</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点-v3"><a class="header-anchor" href="#特点-v3"></a>特点:</h3><table><thead><tr><th>方法名</th><th>描述</th><th>是否返回结果</th><th>同组方法</th></tr></thead><tbody><tr><td>allOf</td><td>组合多个Future</td><td>无结果</td><td>anyOf:入参为可变数组或数组</td></tr><tr><td>thenCombine</td><td>将fn1的结果和fn2的结果传递到BiFunction中</td><td>有返回值为BiFunction</td><td>thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn,Executor executor)</td></tr><tr><td>thenAcceptBoth</td><td>fn1的结果和fn2的结果传递到BiFunction中</td><td>无返回值</td><td>thenAcceptBothAsync</td></tr><tr><td>runAfterBoth</td><td>fn1执行完成后执行fn2,然后执行Runnable执行线程默认为fn2的执行线程</td><td>无返回值</td><td>runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action)</td></tr><tr><td>applyToEither</td><td>将fn1的结果和fn2的结果,二者任一一个结果传递到Function中</td><td>有返回值为BiFunction</td><td>applyToEitherAsync(CompletionStage&lt;? extends U&gt; other,Function&lt;? super T, U&gt; fn,Executor executor)</td></tr><tr><td>acceptEither</td><td>fn1或fn2执行完成,执行fn3</td><td>无返回值</td><td>acceptEitherAsync</td></tr><tr><td>runAfterEither</td><td>fn1或fn2执行完成,执行fn3</td><td>无返回值</td><td>runAfterEitherAsync</td></tr></tbody></table><p>需要注意的是<B>thenCombine</B>和<B>applyToEither</B>的区别:</p><ol><li>thenCombine是两个fn都完成后才执行fn3,applyToEither是任一一个fn完成后就执行fn3</li></ol><h2 id="获取结果"><a class="header-anchor" href="#获取结果"></a>获取结果</h2><h3 id="示例-v4"><a class="header-anchor" href="#示例-v4"></a>示例</h3><ol><li>get()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> result0 <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> future_exception <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> result1 <span class="token operator">=</span> future_exception<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>join()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> list <span class="token operator">=</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"1"</span></span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">&#123;</span> item <span class="token operator">-></span>        <span class="token keyword">val</span> result0 <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"result0:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result0</span></span><span class="token string">,item:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">item</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">val</span> future1 <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    future1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>getNow()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"defaultValue"</span></span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"create_future_time3s result:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">result</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">val</span> future1 <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    future1<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"exception"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>isDone()</li></ol><pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">val</span> future <span class="token operator">=</span> FutureTask<span class="token punctuation">.</span><span class="token function">create_future_time3s</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> done <span class="token operator">=</span> future<span class="token punctuation">.</span>isDone    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"future是否完成:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">done</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点-v4"><a class="header-anchor" href="#特点-v4"></a>特点:</h3><table><thead><tr><th>方法名</th><th>描述</th><th>是否支持lambda调用</th></tr></thead><tbody><tr><td>get</td><td>阻塞的方式获取结果</td><td>不支持lambda方式进行调用</td></tr><tr><td>join</td><td>阻塞的方式获取结果</td><td>支持lambda方式进行调用</td></tr><tr><td>getNow</td><td>立即尝试获取结果,如果future未完成就返回默认值,非阻塞的方式</td><td>不支持lambda方式进行调用</td></tr><tr><td>isDone</td><td>判断是否执行完成</td><td>支持lambda方式进行调用</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CompletableFuture常用方法总结&lt;/h1&gt;
&lt;p&gt;下文对CompletableFuture类中的常用方法进行了总结,以备不时之需;&lt;/p&gt;
&lt;h2 id=&quot;创建方法&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#创建方法&quot;&gt;&lt;/a&gt;创建方</summary>
      
    
    
    
    <category term="并发" scheme="https://agmtopy.gitee.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="CompletableFuture" scheme="https://agmtopy.gitee.io/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar发送消息分析</title>
    <link href="https://agmtopy.gitee.io/2025/07/08/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/51.Pulsar%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%86%E6%9E%90/"/>
    <id>https://agmtopy.gitee.io/2025/07/08/7.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86/51.Pulsar%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%86%E6%9E%90/</id>
    <published>2025-07-08T13:45:54.000Z</published>
    <updated>2025-07-17T16:05:47.590Z</updated>
    
    <content type="html"><![CDATA[<h1>Pulsar发送消息分析</h1><p>Pulsar提供的多种发送消息的模式,分别是:send(msg)-同步消息,sendAsync(msg)-异步消息;</p><h2 id="简单示例"><a class="header-anchor" href="#简单示例"></a>简单示例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SampleProducer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PulsarClient</span> client <span class="token operator">=</span> <span class="token class-name">PulsarClient</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serviceUrl</span><span class="token punctuation">(</span><span class="token string">"pulsar://localhost:6650"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Producer</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> producer <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">newProducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token string">"persistent://my-tenant/my-ns/my-topic"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token class-name">String</span> msg <span class="token operator">=</span>  <span class="token string">"my-message: "</span><span class="token operator">+</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">ISO_LOCAL_DATE_TIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">sendAsync</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="源码分析"><a class="header-anchor" href="#源码分析"></a>源码分析</h2><h3 id="send"><a class="header-anchor" href="#send"></a>send()</h3><p>Producer是生产者的顶级接口,这个接口中定义了三类方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 发送消息API</span>    <span class="token class-name">MessageId</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">T</span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span><span class="token punctuation">;</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageId</span><span class="token punctuation">></span></span> <span class="token function">sendAsync</span><span class="token punctuation">(</span><span class="token class-name">T</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取信息</span>    <span class="token class-name">String</span> <span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">getProducerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ProducerStats</span> <span class="token function">getStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 管理生产者</span>    <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><B>MessageBuilder</B>是重要的抽象,先mark一下,后面会讲到;</li></ul><p><B>producer</B>的实现类是ProducerImpl.java</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/P-pulsar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ProducerImpl.png?raw=true" alt="ProducerImpl继承关系"></p><p>从图中可以看到,ProducerImpl.java继承于<B>ProducerBase</B>,其中send()方法是使用ProducerBase中的实现;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">MessageId</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">T</span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">newMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中ewMessage().value(message)对应的类是<B>TypedMessageBuilderImpl</B>,其中send()方法如下:</p><ul><li>TypedMessageBuilderImpl.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">MessageId</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">PulsarClientException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// enqueue the message to the buffer</span>        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageId</span><span class="token punctuation">></span></span> sendFuture <span class="token operator">=</span> <span class="token function">sendAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sendFuture<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// the send request wasn't completed yet (e.g. not failing at enqueuing), then attempt to triggerFlush</span>            <span class="token comment">// it out</span>            producer<span class="token punctuation">.</span><span class="token function">triggerFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sendFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token class-name">PulsarClientException</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>send()方法底层是通过sendAsyn()方法将消息暂存到缓冲区,然后通过<B>triggerFlush()</B>发送消息;</p><ul><li>TypedMessageBuilderImpl.java</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageId</span><span class="token punctuation">></span></span> <span class="token function">sendAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> message <span class="token operator">=</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageId</span><span class="token punctuation">></span></span> sendFuture<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>txn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sendFuture <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">internalSendWithTxnAsync</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> txn<span class="token punctuation">)</span><span class="token punctuation">;</span>        txn<span class="token punctuation">.</span><span class="token function">registerSendOp</span><span class="token punctuation">(</span>sendFuture<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        sendFuture <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">internalSendAsync</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sendFuture<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中,txn是处理事务消息的分支,internalSendAsync为内部异步发送方法</p><p>ProducerImpl.internalSendAsync() -&gt; ProducerImpl.sendAsync() -&gt; ProducerImpl.serializeAndSendMessage()</p><p>其中在sendAsync()中,设置了单个消息的最大长度为5Mb,其中最重要的方法在<B>synchronized(this)</B>的保护之下;</p><ul><li>ProducerImpl</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">serializeAndSendMessage</span><span class="token punctuation">(</span><span class="token class-name">MessageImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> msg<span class="token punctuation">,</span>                                         <span class="token class-name">ByteBuf</span> payload<span class="token punctuation">,</span>                                         <span class="token keyword">long</span> sequenceId<span class="token punctuation">,</span>                                         <span class="token class-name">String</span> uuid<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> chunkId<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> totalChunks<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> readStartIndex<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> chunkMaxSizeInBytes<span class="token punctuation">,</span>                                         <span class="token class-name">ByteBuf</span> compressedPayload<span class="token punctuation">,</span>                                         <span class="token keyword">boolean</span> compressed<span class="token punctuation">,</span>                                         <span class="token keyword">int</span> compressedPayloadSize<span class="token punctuation">,</span>                                         <span class="token class-name">SendCallback</span> callback<span class="token punctuation">,</span>                                         <span class="token class-name">ChunkedMessageCtx</span> chunkedMessageCtx<span class="token punctuation">,</span>                                         <span class="token class-name">MessageId</span> messageId<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//省略batch数据块的内容....</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//将消息添加到缓存中</span>        <span class="token keyword">boolean</span> isBatchFull <span class="token operator">=</span> batchMessageContainer<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        lastSendFuture <span class="token operator">=</span> callback<span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置netty批量延迟发起访问</span>        <span class="token function">triggerSendIfFullOrScheduleFlush</span><span class="token punctuation">(</span>isBatchFull<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        payload<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    isLastSequenceIdPotentialDuplicated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在完成插入缓存后,紧接着执行的是<B>producer.triggerFlush()</B></p><ul><li>ProducerImpl</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">triggerFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBatchMessagingEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//对ProducerImpl对象进行加锁</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">ProducerImpl</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">batchMessageAndSend</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ProducerImpl</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">batchMessageAndSend</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> shouldScheduleNextBatchFlush<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>batchMessageContainer<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断是否有消息,此处的消息是在batchMessageContainer.add(msg, callback)中暂存的</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            lastBatchSendNanoTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OpSendMsg</span><span class="token punctuation">></span></span> opSendMsgs<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>batchMessageContainer<span class="token punctuation">.</span><span class="token function">isMultiBatches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                opSendMsgs <span class="token operator">=</span> batchMessageContainer<span class="token punctuation">.</span><span class="token function">createOpSendMsgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                opSendMsgs <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>batchMessageContainer<span class="token punctuation">.</span><span class="token function">createOpSendMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            batchMessageContainer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">OpSendMsg</span> opSendMsg <span class="token operator">:</span> opSendMsgs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//正式开始发送消息</span>                <span class="token function">processOpSendMsg</span><span class="token punctuation">(</span>opSendMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ProducerImpl</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//核心方法</span>cnx<span class="token punctuation">.</span><span class="token function">ctx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">WriteInEventLoopCallback</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> cnx<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码的作用是将消息发送操作提交到 Netty 的事件循环线程（EventLoop）中异步执行,详细步骤:</p><ol><li>cnx.ctx().channel().eventLoop()<br>cnx 是一个与 Pulsar Broker 建立的连接对象。<br>ctx() 返回的是 Netty 的上下文（ChannelHandlerContext），用于网络 I/O 操作。<br>channel() 获取底层的 Netty Channel，表示当前的网络连接。<br>eventLoop() 获取该 Channel 绑定的 Netty EventLoop 线程。<br>Netty 使用 EventLoop 来处理所有 I/O 操作，确保对 Channel 的操作是线程安全的。</li><li>execute(…)<br>将一个任务（Runnable）提交给 Netty 的 EventLoop 线程去执行。这样可以保证所有的网络操作都在同一个线程中串行化执行，避免并发问题。</li><li>WriteInEventLoopCallback.create(…)<br>创建了一个实现了 Runnable 接口的任务对象 WriteInEventLoopCallback。该任务封装了消息发送的具体逻辑：<br>调用 cnx.ctx().writeAndFlush(cmd, cnx.ctx().voidPromise()) 发送消息。</li></ol><p>通过调用WriteInEventLoopCallback.run()方法进行发送消息</p><ul><li>WriteInEventLoopCallback</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"[&#123;&#125;] [&#123;&#125;] Sending message cnx &#123;&#125;, sequenceId &#123;&#125;"</span><span class="token punctuation">,</span> producer<span class="token punctuation">.</span>topic<span class="token punctuation">,</span> producer<span class="token punctuation">.</span>producerName<span class="token punctuation">,</span> cnx<span class="token punctuation">,</span>                sequenceId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        cnx<span class="token punctuation">.</span><span class="token function">ctx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> cnx<span class="token punctuation">.</span><span class="token function">ctx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        op<span class="token punctuation">.</span><span class="token function">updateSentTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中cmd是一个<B>ByteBufPair</B>对象,message是存储在对象中的;</p><p>通过Netty的writeAndFlush方法将消息刷新到channel中最后请求到Broker服务;</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><ul><li>时序图</li></ul><h2 id="注意事项"><a class="header-anchor" href="#注意事项"></a>注意事项</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># docker启动Pulsar Standalone模式</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-p</span> <span class="token number">6650</span>:6650 <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">--mount</span> <span class="token assign-left variable">source</span><span class="token operator">=</span>pulsardata,target<span class="token operator">=</span>/pulsar/data <span class="token parameter variable">--mount</span> <span class="token assign-left variable">source</span><span class="token operator">=</span>pulsarconf,target<span class="token operator">=</span>/pulsar/conf apachepulsar/pulsar:4.0.5 bin/pulsar standalone<span class="token comment"># docker容器内创建tenant</span>bin/pulsar-admin tenants create my-tenant<span class="token comment"># docker容器内创建namespace</span>bin/pulsar-admin namespaces create my-tenant/my-ns<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Pulsar发送消息分析&lt;/h1&gt;
&lt;p&gt;Pulsar提供的多种发送消息的模式,分别是:send(msg)-同步消息,sendAsync(msg)-异步消息;&lt;/p&gt;
&lt;h2 id=&quot;简单示例&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简单示例&quot;&gt;</summary>
      
    
    
    
    <category term="消息队列" scheme="https://agmtopy.gitee.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="pulsar" scheme="https://agmtopy.gitee.io/tags/pulsar/"/>
    
  </entry>
  
  <entry>
    <title>Java的隐藏利器:鲜为人知却极具价值的工具与库</title>
    <link href="https://agmtopy.gitee.io/2025/06/22/1.%E6%9D%82%E8%AE%B0/Java%E7%9A%84%E9%9A%90%E8%97%8F%E5%88%A9%E5%99%A8-%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E5%8D%B4%E6%9E%81%E5%85%B7%E4%BB%B7%E5%80%BC%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%BA%93/"/>
    <id>https://agmtopy.gitee.io/2025/06/22/1.%E6%9D%82%E8%AE%B0/Java%E7%9A%84%E9%9A%90%E8%97%8F%E5%88%A9%E5%99%A8-%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E5%8D%B4%E6%9E%81%E5%85%B7%E4%BB%B7%E5%80%BC%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%BA%93/</id>
    <published>2025-06-22T07:38:30.000Z</published>
    <updated>2025-08-21T16:48:57.136Z</updated>
    
    <content type="html"><![CDATA[<h1>Java的隐藏利器:鲜为人知却极具价值的工具与库</h1><p>源自:<a href="https://www.youtube.com/watch?v=bOEPqLyazAk">https://www.youtube.com/watch?v=bOEPqLyazAk</a>,<br>以下是视频内容的总结和扩展,github地址:<a href="https://github.com/johanjanssen/JavaHiddenGems">https://github.com/johanjanssen/JavaHiddenGems</a></p><p>分为五个部分:架构、测试、实现、安全、构建</p><h2 id="架构"><a class="header-anchor" href="#架构"></a>架构</h2><h3 id="Arun"><a class="header-anchor" href="#Arun"></a>Arun</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java的隐藏利器:鲜为人知却极具价值的工具与库&lt;/h1&gt;
&lt;p&gt;源自:&lt;a href=&quot;https://www.youtube.com/watch?v=bOEPqLyazAk&quot;&gt;https://www.youtube.com/watch?v=bOEPqLyazAk&lt;/a</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入理解分布式事务-原理与实践-分布式事务基础</title>
    <link href="https://agmtopy.gitee.io/2025/06/21/19.%E5%88%86%E5%B8%83%E5%BC%8F/1.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E4%B8%80/"/>
    <id>https://agmtopy.gitee.io/2025/06/21/19.%E5%88%86%E5%B8%83%E5%BC%8F/1.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E4%B8%80/</id>
    <published>2025-06-20T16:03:27.000Z</published>
    <updated>2025-08-22T01:20:41.984Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式事务基础</h1><h2 id="事务的基本概念"><a class="header-anchor" href="#事务的基本概念"></a>事务的基本概念</h2><h3 id="ACID"><a class="header-anchor" href="#ACID"></a>ACID</h3><ol><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ol><h3 id="事务的类型"><a class="header-anchor" href="#事务的类型"></a>事务的类型</h3><ul><li><p>扁平事务<br>事务操作中最常见、最简单的事务,无法单独提交整个事务中的部分事务,只能把整个事务全部提交或者回滚;</p></li><li><p>带有保存点的扁平事务<br>内部带有保存点的事务,可以将当前事务回滚到此位置;</p></li><li><p>链式事务<br>链式事务是在带有保存点的扁平事务的基础上,自动将当前事务的上下文隐式的传递给下一事务,也就是说一个事务的提交操作和下一个事务的开始操作合并在一起是具备原子性的;</p></li><li><p>嵌套事务<br>嵌套事务指的是有多个事务处于嵌套状态,共同完成一项任务的处理,整个任务具备原子性;嵌套事务最外层有一个顶层事务,只有当顶层事务完成后才会整体提交;</p></li><li><p>分布式事务基础<br>分布式事务指的是事务的参与者、事务所在的服务器、涉及的资源服务器以及事务管理器分别位于不同的分布式系统下的一个整体事务;</p></li></ul><h3 id="本地事务"><a class="header-anchor" href="#本地事务"></a>本地事务</h3><p>本地事务通常是由关系型数据库本身的事务特性来进行实现的,优缺点:</p><p>优点:</p><ol><li>严格支持ACID特性</li><li>事务可靠,关系型数据的事务是经过严格论证的</li><li>本地事务执行效率高</li><li>事务是由DBMS完成</li><li>不涉及网络通信</li></ol><p>缺点:</p><ol><li>不具备分布式事务的处理能力</li><li>一次事务处理过程只能连接一个支持事务的数据库,即不能用于多个事务性数据库;</li></ol><h3 id="MySql事务基础"><a class="header-anchor" href="#MySql事务基础"></a>MySql事务基础</h3><ul><li>并发带来的问题</li></ul><ol><li>更新丢失<br><B>丢失更新</B>本质上是<B>写操作冲突</B>,解决的方法是让每个事务按照一定的顺序进行写操作;</li><li>脏读<br><B>脏读</B>本质上是<B>读写操作冲突</B>,解决的方法是先写后读,写完之后才能读取;</li><li>不可重复读<br><B>不可重复读</B>本质上是<B>读写操作冲突</B>,解决的方法是先读后写,读完之后才能进行写入操作;</li><li>幻读<br><B>幻读</B>本质上是<B>读写操作冲突</B>,解决的方法是先读后写,读完之后才能进行写入操作;</li></ol><blockquote><p><B>不可重复读</B>和<B>幻读</B>的区别在于,不可重复读关注的是对字段的更新或删除操作,幻读的重点是在于插入操作;</p></blockquote><ul><li>MySQL事务隔离级别</li></ul><ol><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行化</li></ol><p>MySQL的默认事务隔离级别是<B>可重复读</B>,MySQL用MVCC机制保证的在克重复读级别下不会出现<B>脏读</B>&lt;B&gt;不可重复读</B>&lt;B&gt;幻读</B>,其中幻读是通过<B>间隙锁</B>来解决的;</p><ul><li>MySQL中锁的分类</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB.png?raw=true" alt="MySQL中锁的分类"></p><p>读锁和写锁是互斥的,读锁和读锁不互斥,写锁和写锁是互斥的;<br>避免死锁的几种方式:</p><ol><li>尽量让 数据表中的数据检索都通过索引的方式来完成,避免无效索引导致行锁升级为表锁;</li><li>合理设计索引,尽量缩小锁的范围;</li><li>尽量减少查询条件的范围,尽量避免间隙锁或缩小间隙锁的范围;</li><li>尽量控制事务的大小,减少一次事务锁定的资源数量,缩短锁定资源的时间;</li><li>如果一条SQL语句涉及事务加锁操作,则尽量将其放到最后,从而减少锁定资源的时间;</li></ol><ul><li>InnoDB的MVCC的原理</li></ul><p>通过在数据行上定义两个字段:分别是<B>创建行版本号</B>&lt;B&gt;删除行版本号</B>,这两个版本号只标识该行的创建和该行的删除动作的时序;</p><ol><li>查询操作</li></ol><blockquote><p>InnoDB存储引擎只会查询版本号小于或者等于当前查询事务版本号的数据行,这样做的目的是在于只能查询到当前事务开始时那一刻的数据,或者当前事务修改的数据行,并且会判断删除版本号是否大于当前事务ID;</p></blockquote><ol start="2"><li>插入操作</li></ol><blockquote><p>在插入数据时根据当前事务的版本号来维护数据行上的创建版本号,插入操作不维护删除版本号</p></blockquote><ol start="3"><li>更新操作</li></ol><blockquote><p>更新操作是在数据行上将上一条数据的删除版本号更新为当前更新操作的事务版本号,然后重新复制出一条新的数据行,其中创建版本号为当前更新事务的版本号;</p></blockquote><ol start="4"><li>删除操作</li></ol><blockquote><p>删除操作是更新最新的数据行上的DB_DELETED(删除行版本号)</p></blockquote><h2 id="MySQL事务的实现原理"><a class="header-anchor" href="#MySQL事务的实现原理"></a>MySQL事务的实现原理</h2><blockquote><p>MySQL的事务实现是由于锁\MVCC\Redo Log\Undo Log共同来完成的,其中事务的隔离性是通过锁和MVCC机制,原子性和持久性是通过Redo Log,一致性是通过Undo Log来实现的;</p></blockquote><h3 id="Redo-Log"><a class="header-anchor" href="#Redo-Log"></a>Redo Log</h3><p><B>Redo Log</B>向前,记录的是InnoDB执行的动作的日志,也被称为重做日志,用于故障恢复和保证事务的原子性和持久性;<br>Redo Log的日志记录格式是物理日志,记录的是磁盘上数据进行的修改操作;</p><p>其中对于Redo Log写入文件的刷盘时机有以下几种规则:</p><ol><li>由inboodb_flush_log_at_trx_commit配置决定:设置为0或者2时每秒去刷盘,区别在于是否需要通过Log Buffer,设置为1时是每次事务提交时进行刷盘</li><li>每秒刷新一次</li><li>Log Buffer内存使用超过一半时</li><li>当事务中存在checkpoint(检测点),checkpoint机制去刷新脏页</li></ol><h3 id="Undo-Log"><a class="header-anchor" href="#Undo-Log"></a>Undo Log</h3><p><B>Undo Log</B>是用于回滚事务和实现MVCC机制的,采用的是和操作相反的逻辑格式记录日志;<br>Undo Log的回滚段分 为insert undo log和update undo log;<br>insert undo log指的是事务对插入新记录产生的Undo log,只作用于事务回滚时需要,在事务提交后即可丢弃;<br>update undo log指的是事务对记录进行删除和更新操作时产生的Undo log日志,作用于事务回滚以及一致性读,只有当所有的事务id大于该版本时才能进行删除;</p><h3 id="Bin-Log"><a class="header-anchor" href="#Bin-Log"></a>Bin Log</h3><p>Bin log是MySQL用于主从复制和故障恢复的日志格式,其中记录格式分为<B>Row格式</B>&lt;B&gt;Statement格式</B>&lt;B&gt;Mixed模式</B>;</p><p>Row格式:保存的是对数据的修改<br>Statement格式:保存的是执行SQL<br>Mixed格式:默认是Statement,对于无法使用Statemnt格式的采用Row格式</p><p>MySQL事务在提交的时候会记录事务日志和二进制日志,是先记录二进制日志在写入事务日志;<br>两者配合完成了事务的一致性,采用的二阶段提交流程如下所示:</p><ol><li>Prepare阶段<br>a. BinLog Buffer<br>b. RedoLog Buffer -&gt; RedoLog file(prepare标识)</li><li>Commit 阶段<br>a. BinLog Buffer  -&gt; BinLog file<br>b. RedoLog file(prepare标识) -&gt; RedoLog file(commit标识)</li></ol><h3 id="MySQL事务流程"><a class="header-anchor" href="#MySQL事务流程"></a>MySQL事务流程</h3><ul><li>MySQL事务执行流程</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/MySQL%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png?raw=true" alt="MySQL事务执行流程"></p><p>在这个流程中,第4个步骤是记录Undo Log对应的Redo Log到内存缓冲区,因为Undo Log的操作也需要Redo Log进行记录</p><ul><li>MySQL事务恢复流程</li></ul><ol><li>在事务执行到第8步时,MySQL崩溃或者宕机,会优先使用Redo Log恢复数据,然后使用Undo Log回滚数据;</li><li>如果执行到第8步之后,MySQL崩溃或宕机,会使用Redo Log恢复数据;</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/MySQL%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B.png?raw=true" alt="MySQL事务恢复流程"></p><p>大体上可以划分为两个阶段:提交事务和回滚事务,其中提交事务是提交Redo Log已经标记为成功的事务,回滚事务是回滚Redo Log中未提交的事务,同时需要配合bin log完成写入;</p><h3 id="MySQL中的XA事务"><a class="header-anchor" href="#MySQL中的XA事务"></a>MySQL中的XA事务</h3><p>XA分布式事务的全称是 eXtended Architecture Transaction,XA事务支持不同的数据库实例共同完成分布式事务;<br>XA事务的本质是一种基于<B>两阶段提交</B>的分布式事务,在使用XA分布式事务时,需要将InnoDB存储引擎的事务隔离级别设置为串行化;</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/XA%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png?raw=true" alt="XA事务模型"></p><h4 id="参与者"><a class="header-anchor" href="#参与者"></a>参与者:</h4><ol><li><p>事务管理器<br>主要对参与全局事务的各个分支事务进行协调,并对资源管理器进行通信;通常是一个单独的应用服务器或者中间件,例如JTA;</p></li><li><p>资源管理器<br>资源管理器通常是数据库实例</p></li><li><p>应用程序<br>主要用来发起全局事务和分支事务的操作</p></li></ol><h4 id="XA事务的执行流程"><a class="header-anchor" href="#XA事务的执行流程"></a>XA事务的执行流程</h4><p>XA事务是一个两阶段提交的分布式事务,大体的流程分为<B>Prepare阶段</B>和<B>Commit阶段</B></p><ul><li>Prepare阶段</li></ul><ol><li>事务管理器™开启一个全局事务,该全局事务具有一个唯一的全局事务ID(XID)</li><li>事务管理器™通知各个资源管理器(RM)开启一个各自的新事务</li><li>资源管理器(RM)开始执行各自的事务分支,只写入不进行提交,处于<B>事务已开启-未提交状态</B>,注意这一步是锁定住资源的</li><li>资源管理器(RM)向事务管理器™上报Prepare阶段的执行结果</li></ol><ul><li>Commit阶段</li></ul><ol><li>事务管理器™收集所有资源管理器(RM)的Prepare阶段的结果,超时会认为是失败</li><li>事务管理器™收集所有资源管理器(RM)的结果,确认Commit阶段下发的命令是Commit还是Rollback</li><li>资源管理器(RM)根据事务管理器™的结果完成Commit或者Rollback</li><li>资源管理器(RM)向事务管理器™上报第二个步骤的执行结果</li></ol><h4 id="XA事务超时的处理策略"><a class="header-anchor" href="#XA事务超时的处理策略"></a>XA事务超时的处理策略</h4><ul><li>Prepare阶段</li></ul><ol><li>TM超时回滚机制</li><li>TM超时下发全局回滚</li><li>RM自行回滚</li></ol><ul><li>Commit阶段</li></ul><ol><li>TM重试机制</li><li>RM的幂等性保证</li><li>回滚补偿</li></ol><h4 id="XA事务的性能问题"><a class="header-anchor" href="#XA事务的性能问题"></a>XA事务的性能问题</h4><ol><li>阻塞性(Blocking)<br>在准备阶段（Prepare）,资源管理器（RM）需要开始锁定资源</li><li>网络开销<br>2PC 协议需要进行多次网络通信</li><li>复杂性和单点问题<br>TM\RM\APP等多个组件带来的复杂性,TM会带来单点问题</li></ol><h4 id="XA事务的优点"><a class="header-anchor" href="#XA事务的优点"></a>XA事务的优点</h4><ol><li>强一致性的分布式事务解决方案</li></ol><h2 id="Spring事务的实现原理"><a class="header-anchor" href="#Spring事务的实现原理"></a>Spring事务的实现原理</h2><h3 id="Spring事务原理"><a class="header-anchor" href="#Spring事务原理"></a>Spring事务原理</h3><p>Spring实现事务的原理是<B>关闭自动提交</B>;</p><h3 id="Spring事务的三大接口"><a class="header-anchor" href="#Spring事务的三大接口"></a>Spring事务的三大接口</h3><blockquote><p>Spring支持事务管理功能,最核心的就是Spring事务的三大接口:<B>PlatformTransactionManager</B>、<B>TransactionDefinition</B>、<B>TransactionStatus</B></p></blockquote><ul><li><p>PlatformTransactionManager<br>Spring不是直接管理事务,而是定义提供多种事务管理器,通过这些事务管理器将事务管理的职责委托给Hibernate\MyBatis\JPA等持久化框架;<br>PlatformTransactionManager就是定义事务操作的基本方法类,为Spring提供了一个统一的事务管理接口,类似于桥接的设计模式;<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/Spring_PlatformTransactionManager_%E7%B1%BB%E5%9B%BE.png?raw=true" alt="Spring_PlatformTransactionManager_类图"></p></li><li><p>TransactionDefinition<br>TransactionDefinition接口主要用来定义与事务相关的方法,表示事务属性的常量信息</p></li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/Spring_TransactionDefinition_%E7%B1%BB%E5%9B%BE.png?raw=true" alt="Spring_TransactionDefinition_类图"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionDefinition</span> <span class="token punctuation">&#123;</span><span class="token comment">/** * 支持当前事务,如果当前没有事务就创建一个新事务 */</span><span class="token keyword">int</span> <span class="token constant">PROPAGATION_REQUIRED</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">/** * 如果当前存在事务,即加入该事务;如果当前不存在事务,即以非事务的方式运行 */</span><span class="token keyword">int</span> <span class="token constant">PROPAGATION_SUPPORTS</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/** * 如果当前存在事务,即加入该事务;如果当前不存在事务,立即抛出异常 */</span><span class="token keyword">int</span> <span class="token constant">PROPAGATION_MANDATORY</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">/** * 创建一个新事务运行,如果当前存在事务,挂起当前已存在的事务 */</span><span class="token keyword">int</span> <span class="token constant">PROPAGATION_REQUIRES_NEW</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">/** * 以非事务的方式运行,如果当前存在事务,挂起当前已存在的事务 */</span><span class="token keyword">int</span> <span class="token constant">PROPAGATION_NOT_SUPPORTED</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">/** * 以非事务的方式运行,如果当前存在事务,立即抛出异常 */</span><span class="token keyword">int</span> <span class="token constant">PROPAGATION_NEVER</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">/** * 如果当前存在事务，则创建一个嵌套事务；如果当前没有事务，则创建一个新的事务 */</span><span class="token keyword">int</span> <span class="token constant">PROPAGATION_NESTED</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">/** * 使用后端数据库默认的隔离级别 */</span><span class="token keyword">int</span> <span class="token constant">ISOLATION_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//后续还有事务隔离级别\传播行为\超时时间等定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>TransactionStatus<br>TransactionStatus接口主要用来存储事务的执行状态,定义了一组方法,用来读取事务的状态信息;</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/Spring_TransactionStatus_%E7%B1%BB%E5%9B%BE.png?raw=true" alt="Spring_TransactionStatus_类图"></p><h3 id="Spring事务隔离级别"><a class="header-anchor" href="#Spring事务隔离级别"></a>Spring事务隔离级别</h3><p>Spring中事务存在五种隔离级别:<B>ISOLATION_DEFAULT</B>、<B>ISOLATION_READ_UNCOMMITTED</B>、<B>ISOLATION_READ_COMMITTED</B>、<B>ISOLATION_REPEATABLE_READ</B>、<B>ISOLATION_SERIALIZABLE</B></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>并发性能</th><th>数据一致性</th></tr></thead><tbody><tr><td><code>ISOLATION_READ_UNCOMMITTED</code></td><td>是</td><td>是</td><td>是</td><td>最高</td><td>最差</td></tr><tr><td><code>ISOLATION_READ_COMMITTED</code></td><td>否</td><td>是</td><td>是</td><td>较高</td><td>较差</td></tr><tr><td><code>ISOLATION_REPEATABLE_READ</code></td><td>否</td><td>否</td><td>是</td><td>较低</td><td>较好</td></tr><tr><td><code>ISOLATION_SERIALIZABLE</code></td><td>否</td><td>否</td><td>否</td><td>最低</td><td>最好</td></tr></tbody></table><p>这里需要注意的是Spring 事务隔离级别和数据库事务隔离级别是协同工作的。 Spring 负责发起隔离级别请求，而数据库负责实现。 最终起作用的是数据库的隔离级别。 因此，了解数据库的隔离级别支持和默认设置非常重要。 通过显式配置 Spring 的隔离级别并在不同的数据库环境下进行测试，可以确保事务隔离的正确性。</p><p>Spring的事务管理器会使用JDBC驱动请求设置数据库的隔离级别,但是是需要数据库支持才可以,如果数据库忽略设置隔离级别,对于Spring事务管理器来说也无可奈何;</p><h3 id="Spring事务传播机制"><a class="header-anchor" href="#Spring事务传播机制"></a>Spring事务传播机制</h3><table><thead><tr><th>类别</th><th>事务传播机制类型</th><th>描述</th></tr></thead><tbody><tr><td>支持当前事务的传播机制</td><td>REQUIRED</td><td>尝试加入现有事务或创建新的事务</td></tr><tr><td>_</td><td>SUPPORTS</td><td>尝试加入现有事务或以非事务的方式执行</td></tr><tr><td>_</td><td>MANDATORY</td><td>尝试加入现有事务,失败则抛出异常</td></tr><tr><td>不支持当前事务的传播机制</td><td>REQUIRES_NEW</td><td>创建新的事务，挂起现有事务</td></tr><tr><td>_</td><td>NOT_SUPPORTED</td><td>挂起现有事务后以非事务的方式执行</td></tr><tr><td>_</td><td>NEVER</td><td>抛出异常</td></tr><tr><td>嵌套事务</td><td>NESTED</td><td>创建嵌套事务（保存点），加入现有事务。外部事务回滚，内部事务也会回滚</td></tr></tbody></table><p>最常用的事务传播机制:</p><ol><li>REQUIRED<br>默认事务传播机制,适用于大部分场景</li><li>NOT_SUPPORTED<br>非事务执行的场景,适用于允许以非事务执行的场景</li><li>REQUIRED_NEW<br>适用于需要以事务方式保证持久化但是又不需要被外层事务所影响的场景,例如记录操作日志,即使主业务流程失败,也需要记录本次操作的场景</li></ol><h3 id="Spring事务失效的场景"><a class="header-anchor" href="#Spring事务失效的场景"></a>Spring事务失效的场景</h3><ol><li><p>方法没有被public修饰<br>由于Spring是通过AOP的方式织入的开启事务和提交事务的,因此方式是非public的时无法代理</p></li><li><p>同一个类中直接调用<br>直接调用,不经过AOP,无法开启事务;</p></li><li><p>使用不支持事务的传播机制<br>例如NOT_SUPPORTED这种不开启事务的机制</p></li><li><p>错误的catch异常/标注错误的异常类型<br>由于事务的回滚需要依赖方法抛出异常,如果吃掉异常,那么就不会回滚事务,这时需要判断是否符合业务逻辑;<br>Spring中默认回滚的异常为<B>RuntimeException</B>,如果抛出其他异常时,需要使用rollbackFor进行标识</p></li></ol><h2 id="分布式事务的基本概念"><a class="header-anchor" href="#分布式事务的基本概念"></a>分布式事务的基本概念</h2><ul><li>架构目标和架构原则</li></ul><ol><li>N+1设计</li><li>回滚设计</li><li>禁用设计</li><li>监控设计</li><li>设计多活数据中心</li><li>使用成熟的技术</li><li>异步设计</li><li>无状态系统</li><li>水平扩展而非垂直升级</li><li>设计时至少要有两步前瞻性</li><li>非核心则购买</li><li>使用商品化硬件</li><li>小构建\小发布\快速试错</li><li>故障隔离</li><li>自动化</li></ol><p>《The Art of Scalability》一书的观点很赞👍,这本书需要看;</p><h3 id="分布式事务场景"><a class="header-anchor" href="#分布式事务场景"></a>分布式事务场景</h3><ol><li>跨JVM进程</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80_%E8%B7%A8JVM%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF.png?raw=true" alt="分布式事务基础_跨JVM调用场景"></p><ol start="2"><li><p>同一应用调用多个数据库实例场景<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80_%E8%B7%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF.png?raw=true" alt="分布式事务基础_跨数据库调用场景"></p></li><li><p>多个应用调用同一个数据库实例场景<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80_%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%90%8C%E4%B8%80%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%BA%E6%99%AF.png?raw=true" alt="分布式事务基础_多个服务调用同一数据库场景"></p></li></ol><h3 id="数据一致性"><a class="header-anchor" href="#数据一致性"></a>数据一致性</h3><p>数据一致性问题,包括数据多副本\调用超时\缓存与数据库不一致\多个缓存节点内数据不一致等问题;<br>常用的解决方案有:ACID特性\CAP理论\Base理论\DTP理论\2PC(两阶段提交)\3PC(三阶段提交)\TCC模型\可靠消息最终一致性模型\最大努力通知模型等;</p><h2 id="分布式事务的理论基础"><a class="header-anchor" href="#分布式事务的理论基础"></a>分布式事务的理论基础</h2><h3 id="CAP理论"><a class="header-anchor" href="#CAP理论"></a>CAP理论</h3><p>CAP指的是Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）,这三个分布式系统中最重要的三个需求;<br>由于三者最多只能满足两点,因此有AP\CP\CA,这三种模式:</p><ol><li>AP模式<br>指的是追求系统的可用性和分区容忍性,由于分区容忍性在现实场景中很难避免,因此现在一致性还是可用性,是一种架构上的选择;Base理论就是基于AP模式的衍生</li><li>CP模式<br>强一致性,代表系统有ZK<br><a href="http://3.AC">3.AC</a><br>放弃分区容忍性,架构回滚为单体应用架构</li></ol><h3 id="Base理论"><a class="header-anchor" href="#Base理论"></a>Base理论</h3><p>Base理论是AP模式的扩展,由于CAP中的一致性指的是强一致性,是在任何时间读取任意节点的数据都必须是一致,而Base理论中的一致性指的是允许在某一段时间内数据不一致,但是最终都非达到一致;</p><h2 id="分布式事务的解决方案"><a class="header-anchor" href="#分布式事务的解决方案"></a>分布式事务的解决方案</h2><h3 id="强一致性的分布式事务解决方案"><a class="header-anchor" href="#强一致性的分布式事务解决方案"></a>强一致性的分布式事务解决方案</h3><p>强一致性的分布式事务解决方案主要有<B>DTP模型</B>、<B>2PC模型</B>、<B>3PC模型</B>,要求在任意时刻查询参与全局事务的各个节点的数据都是一致的;</p><ul><li>优缺点<br>优点如下:</li></ul><ol><li>数据一致性比较高</li><li>在任意时刻都能够查询到最新写入的数据</li></ol><p>缺点如下:</p><ol><li>存在性能问题,在分布式事务未完全提交和回滚之前,应用程序查询不到最新的数据</li><li>实现复杂</li><li>牺牲了可用性</li><li>不适合高并发的场景</li></ol><h3 id="DTP模型"><a class="header-anchor" href="#DTP模型"></a>DTP模型</h3><p>DTP模型是由X/Open组织定义的一套分布式事务标准,这套标准主要定义实现分布式事务的规范和API,具体的实现交给相应的厂商来进行实现,类似JDBC驱动,由不同的数据库厂商进行实现;常见的实现有MySQL的XA模式、</p><ul><li>DTP模型定义的重要概念</li></ul><ol><li>事务:一个事务就是一个完整的工作单元,应具备特性</li><li>全局事务:由事务管理器管理的事务,能够一次性操作多个资源管理器</li><li>分支事务:每个资源管理器中独立的事务</li><li>控制线程:执行全局事务的线程,这个线程用于协调关联应用程序\事务管理器\资源管理器等,又被称为事务上下文环境</li></ol><ul><li>DTP模型的四大组件</li></ul><table><thead><tr><th>组件</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td><strong>AP</strong></td><td>Application Program</td><td>事务发起者，调用事务服务</td></tr><tr><td><strong>TM</strong></td><td>Transaction Manager</td><td>控制事务的全局一致性（如开启、提交、回滚事务）</td></tr><tr><td><strong>RM</strong></td><td>Resource Manager</td><td>资源管理器，如数据库、消息中间件等，执行具体的事务操作</td></tr><tr><td><strong>CM</strong></td><td>Communication Resource Manager</td><td>通信管理器，负责不同节点间的通信（有时合并在 RM 或 TM 中）</td></tr></tbody></table><ul><li>DTP模型示意图</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88_DTP%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true" alt="DTP模型示意图"></p><p>这个模型可以被划分为两个阶段:</p><ol><li><p>Prepare阶段<br>这个阶段包括步骤(1,2,3,4,5,6,7,8),其中步骤3\5开始进行RM分支事务,只会修改数据但是不会提交事务,同时记录Redo Log和Undo Log,后续步骤7和步骤8指的是更新数据和记录日志的操作以及<B>锁定资源</B>;</p></li><li><p>Commit阶段<br>步骤9和步骤10是RM接收到TM的命令后开始通过Redo Log刷盘或者Undo Log回滚,并释放资源;</p></li></ol><p>从上述步骤中可以看到DTP模型中的强一致性是通过长时间锁定资源来进行实现的,实际生产中可能会产生问题;</p><h3 id="2PC模型"><a class="header-anchor" href="#2PC模型"></a>2PC模型</h3><p>2PC模型指的是<B>两阶段提交协议</B>,P-Prepare阶段、C-Commit阶段;其中XA模型是2PC模型的一个具体实现;</p><ul><li>2PC模型存在的问题</li></ul><ol><li>同步阻塞问题:在事务执行过程中,所有参与事务的节点都会对其占用的公共资源进行加锁,导致其他访问该公共资源的进程或者线程阻塞;</li><li>单点故障问题:事务管理器™发生故障时,资源管理器(RM)会一直阻塞</li><li>数据不一致问题:在Commit阶段,如果TM发送的指令丢失,会导致资源管理器中的数据库可能与其他RM中的数据不一致</li><li>在Commit阶段,如果TM发送完成Commit信息后宕机,然后RM宕机,导致无法确认事务是否已提交,RM有可能提交也有可能不提交;</li></ol><h3 id="3PC模型"><a class="header-anchor" href="#3PC模型"></a>3PC模型</h3><blockquote><p>3PC模型指的是三阶段提交模型,是为了解决2PC模型中的一些问题也提出来的,主要是将2PC模型中的Prepare阶段划分为<B>CanCommit阶段</B>、<B>PreCommit阶段</B>、<B>Commit阶段</B>;3PC 引入了超时机制和预提交阶段，从而降低了阻塞发生的概率;</p></blockquote><ul><li>CanCommit阶段<br>准备阶段是事务管理器向所有参与者发送CanCommit请求,询问它们是否可以执行提交操作;</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/3PC%E6%A8%A1%E5%9E%8B_CanCommit%E9%98%B6%E6%AE%B5.png?raw=true" alt="3PC_CanCommit阶段"></p><blockquote><p>3PC 模型中 CanCommit 阶段的主要目的是在更早的阶段让参与者 (Participants，即资源管理器) 有机会拒绝事务，从而避免后续阶段可能发生的阻塞和资源浪费;</p></blockquote><ol><li><p>降低阻塞的可能性<br>3PC 模型引入了 CanCommit 阶段，允许参与者在收到 Prepare 命令之前，先检查自身的状态，判断是否能够提交事务。 如果参与者发现无法提交，则可以直接拒绝事务，从而避免了后续 Prepare 和 Commit 阶段的资源浪费和可能的阻塞</p></li><li><p>提前发现问题，减少资源占用<br>CanCommit 阶段发现问题，参与者可以拒绝事务，从而释放占用的资源，避免后续阶段的资源浪费;</p></li><li><p>提高系统的响应速度<br>通过在早期阶段过滤掉无法提交的事务，可以减少后续阶段的处理量，从而提高系统的整体响应速度。<br>如果协调者在 CanCommit 阶段收到多个参与者的 No 响应，它可以立即中止事务，避免后续不必要的处理。</p></li><li><p>作为协调者和参与者之间的一次心跳检测</p></li></ol><p><B>执行失败处理机制</B></p><blockquote><p>在CanCommit阶段有RM执行失败,在这个阶段中TM会向参与全局事务的资源管理器(RM)发送CanCommit请求,如果不能执行完成事务,则会向事务管理器响应No状态,TM收到NO响应,就中断全局事务的继续执行;</p></blockquote><ul><li>PreCommit阶段</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/3PC%E6%A8%A1%E5%9E%8B_PreCommit%E9%98%B6%E6%AE%B5.png?raw=true" alt="3PC_PreCommit阶段"></p><blockquote><p>3PC 模型中 PreCommit 阶段的主要目的是让资源管理器开始执行事务操作,同时将Undo Log和Redo Log信息写入事务日志中,并向事务管理器™发送执行的ACK状态,<B>此时不会提交事务</B></p></blockquote><p><B>执行失败处理机制</B></p><blockquote><p>TM收到RM返回的中断后会向每个RM发送abort(中断)请求,RM在这个阶段如果收到abort请求或者超时等参加都会中断分支事务的执行;</p></blockquote><ul><li>doCommit阶段</li></ul><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/3PC%E6%A8%A1%E5%9E%8B_doCommit%E9%98%B6%E6%AE%B5.png?raw=true" alt="3PC_doCommit阶段"></p><h2 id="最终一致性分布式事务解决方案"><a class="header-anchor" href="#最终一致性分布式事务解决方案"></a>最终一致性分布式事务解决方案</h2><p>强一致性分布式事务解决方案要求参与事务的各个节点的数据时刻都要保持一致,因此通过资源管理器锁定的方式来保证,这样会带来性能上的问题;而最终一致性分布式事务不要求参与事务的各个节点数据要时刻保持一致,通过允许数据有中间态,只要一段时间后,数据能够达到最终一致性即可;</p><p>典型方案:</p><ol><li>TCC模型</li><li>可靠消息最终一致性模型</li><li>最大努力通知型解决方案</li></ol><p>优点:</p><ol><li>性能高</li><li>具备可用性</li><li>适合高并发场景</li></ol><p>缺点:</p><ol><li>数据会存在一定时间范围内的不一致</li><li>不适合事务要求比较高的场景</li></ol><h3 id="TCC模型"><a class="header-anchor" href="#TCC模型"></a>TCC模型</h3><p>TCC模型本质上是一种应用层实现2PC协议的一种方式,CanCommit阶段在TCC模型中是<B>Try阶段</B>,doCommit阶段在TCC模型中是<B>Commit阶段</B>、<B>Cancel阶段</B>;</p><ul><li>TCC的执行流程</li></ul><ol><li><p>Try阶段<br>在这个阶段,不会执行任何业务逻辑,仅对业务进行检查,确保能够进行下一步操作;</p></li><li><p>Commit阶段<br>全局事务管理器开始负责对各个资源管理器下发Commit提交命令</p></li><li><p>Cancel阶段<br>在业务执行异常或者出现错误的情况下,需要回滚事务的操作,执行分支事务的取消操作,并且释放Try阶段预留的资源;</p></li></ol><ul><li>TCC模型的优缺点</li></ul><p>优点:</p><ol><li>TCC是在应用层控制事务,对于事务的控制又更小的粒度</li><li>Confim阶段和Cancel阶段的方法具备幂等性,通过重试机制保证分布式事务执行完成后的数据一致性</li><li>TCC由于是应用层协议,天然支持横向扩展,避免了XA模型的单点问题</li></ol><p>缺点:</p><ol><li>TCC嵌入到业务代码中,每个资源服务器的分支事务都需要被拆分成Try\Commit\Cancel等三个方法;</li></ol><ul><li>TCC需要注意的问题</li></ul><ol><li><p>空回滚问题<br>指的是由于网络或者其他原因导致RM的Try请求为接收到,而接收到Cancel请求,Cancel在未Try的基础上错误的回滚业务数据;<br>解决空悬挂问题的关键是在于在执行Cancel请求时需要先判断是否已执行Try请求,常用的方法有通过流水表的形式进行判断;</p></li><li><p>悬挂问题<br>指的是只进行Try,但是由于超时或者时序问题(try-延迟,cancel,try-到达)在业务数据终态后重新执行try请求了,由于TM未感知到该次Try,因此不会进行释放,常用的解决方案有:<B>Try阶段不锁资源</B>、<B>Try阶段通过业务数据判断是否能够进行</B></p></li></ol><h3 id="可靠消息最终一致性解决方案"><a class="header-anchor" href="#可靠消息最终一致性解决方案"></a>可靠消息最终一致性解决方案</h3><p>可靠消息最终一致性分布式事务解决方案指的是事务的发起方执行完成本地事务之后,发出一条消息,事务的参与方订阅该消息,本质上是通过消息系统完成事务的流转;</p><blockquote><p>事务消息发送分为两个阶段。第一阶段会发送一个半事务消息，半事务消息是指暂不能投递的消息，生产者已经成功地将消息发送到了 Broker，但是Broker 未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，如果发送成功则执行本地事务，并根据本地事务执行成功与否，向 Broker 半事务消息状态（commit或者rollback），半事务消息只有 commit 状态才会真正向下游投递。如果由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，Broker 端会通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit或是Rollback）。这样最终保证了本地事务执行成功，下游就能收到消息，本地事务执行失败，下游就收不到消息。总而保证了上下游数据的一致性。</p></blockquote><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/f-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/RocketMQ%E9%95%BF%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png?raw=true" alt="RocketMQ事务消息的详细交互流程"></p><h3 id="最大努力通知型解决方案"><a class="header-anchor" href="#最大努力通知型解决方案"></a>最大努力通知型解决方案</h3><p>适用场景:适用于对最终一致性时间敏感度较低的场景,并且事务被动方的处理结果不会影响到事务主动方,典型的适用场景是支付平台异步通知商户支付结果;</p><p>这种方案类似于接口交互来实现事务的一致性;</p><p>最大努力通知型解决方案需要实现的功能是<B>可查询操作</B>和<B>幂等操作</B></p><p>简单来说就是通过<B>幂等</B>、<B>重试</B>、<B>查询</B>来实现,适用于和三方接口进行交互时使用;</p><ul><li>最大努力通知型解决方案和可靠消息最终一致性的区别</li></ul><ol><li><p>设计不同<br>a. 可靠消息最终一致性解决方案是需要事务发起方保证将消息发送成功<br>b. 最大努力通知型解决方案只是要求尽最大努力将消息通知给业务被动发起方,不一定保证业务方能够接收到消息;</p></li><li><p>业务场景不同<br>a. 可靠消息最终一致性解决方案可以看成异步方式达到事务的最终一致性,时效性上更高<br>b. 最大努力通知型解决方案不保证达到最终一致性的时效,这取决于事务接收方</p></li><li><p>解决的问题不同<br>a. 可靠消息最终一致性解决方案是一个遵循同一个事务机制的出发点,有TM\RM等角色;<br>b. 最大努力通知型解决方案是按照系统与系统直接完成事务一致性进行出发的;</p></li></ol><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>本文作为了解事务以及分布式事务的基础理论,主要有:</p><ol><li>MySQl实现事务的原理:关键字:<B>Redo Log</B>、<B>Undo Log</B>、<B>Bin Log</B>、<B>XA事务</B></li><li>Spring的事务管理:关键字:<B>PlatformTransactionManager</B>、<B>TransactionDefinition</B>、<B>TransactionStatus</B>、<B>事务的隔离级别</B>、<B>事务的传播机制</B>、<B>事务的失效场景</B></li><li>分布式事务的理论基础:关键字:<B>CAP</B>、<B>Base理论</B>、<B>强一致性的分布式事务解决方案</B>、<B>最终一致性分布式事务解决方案</B>、<B>2PC</B>、<B>3PC</B>、<B>TCC</B>、<B>可靠消息最终一致性解决方案</B>、<B>最大努力通知型解决方案<br></B></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;分布式事务基础&lt;/h1&gt;
&lt;h2 id=&quot;事务的基本概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#事务的基本概念&quot;&gt;&lt;/a&gt;事务的基本概念&lt;/h2&gt;
&lt;h3 id=&quot;ACID&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#AC</summary>
      
    
    
    
    <category term="分布式" scheme="https://agmtopy.gitee.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="读书笔记" scheme="https://agmtopy.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计的实践</title>
    <link href="https://agmtopy.gitee.io/2025/06/10/24.%E6%9E%B6%E6%9E%84/2.1DDD%E5%AE%9E%E8%B7%B5/"/>
    <id>https://agmtopy.gitee.io/2025/06/10/24.%E6%9E%B6%E6%9E%84/2.1DDD%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-06-10T14:36:09.000Z</published>
    <updated>2025-06-22T07:38:07.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>领域驱动设计断断续续看过几本书,但是都没有系统性的学习完成过,因此这篇文章从三个阶段来完成的记录一下,分别是<B>基础概念</B>、<B>核心知识</B>、<B>高级扩展</B>;</p><h2 id="基础概念"><a class="header-anchor" href="#基础概念"></a>基础概念</h2><h3 id="领域驱动设计的开发流程"><a class="header-anchor" href="#领域驱动设计的开发流程"></a>领域驱动设计的开发流程</h3><p><img src="" alt="领域驱动设计的开发流程"></p><p>模型的建立：获取行为需求 -&gt; 领域建模。<br>模型的实现：架构设计 -&gt; 数据库设计 -&gt; 代码实现。<br>DDD 的基本开发过程：获取行为需求 -&gt; 领域建模 -&gt; 架构设计 -&gt; 数据库设计 -&gt; 代码实现</p><h3 id="获取行为需求"><a class="header-anchor" href="#获取行为需求"></a>获取行为需求</h3><p>获取行为需求指的是，我们首先要分析系统具有哪些功能，这些功能由什么人操作，会产生什么效果。这个过程传统上叫做“捕获行为需求”<br>常用的获取行为需求的方式有两种，第一种是用例(use case),第二种是事件风暴</p><p>2.1 事件风暴<br>!()[]<br>事件风暴在实践过程中会遇到来回返工的情况，出现这两种情况一般是两个原因,第一个原因会议偏离主题、第二个原因会议无结论记录,因此在事件风暴这个环节,可以落地的方法是由一个人负责,完成梳理之后进行评审的方式;</p><p>事件风暴过程中需要注意的点:</p><ol><li>对于领域事件的命名，采用完成时+被动语态，例如添加完成订单,在事件风暴中的动作是’订单已添加’、签订好合同,在事件风暴中的动作是’合同已签订’;</li><li>在DDD的命名中,如果有约定俗成的业务术语,优先使用业务术语;</li><li>不要把技术事件当作领域事件,例如事务提交、缓存已命中等;</li><li>查询功能不算领域事件;</li></ol><p>可以使用https://boardmix.cn/来做事件风暴</p><p>2.2 识别命令</p><blockquote><p>命令(command)，就是引发领域事件的操作，我们可以通过分析领域事件得到。除了识别出命令本身以外，我们通常还要识别出谁执行的命令，以及为了执行命令我们要查询出什么数据;</p></blockquote><p>!(命令图列)[]</p><p>2.3. 识别领域名词</p><blockquote><p>领域名词，是从领域事件、命令、执行者、查询数据里找到的名词性概念。例如，对于签订合同这个命令而言，受到影响的名词性概念是“合同”；</p></blockquote><ul><li>注意实现</li></ul><ol><li>在事件风暴里只列出主要的、足以用于表达和交流领域知识的步骤</li><li>事件风暴的粒度原则上宜粗不宜细,有一个大体的轮廓即可</li></ol><p>小结:事件风暴就是先确定要做什么事情(<B>领域事件</B>),然后由于什么动作出发(<B>命令</B>),然后找到动作由谁(<B>执行者</B>)进行触发，最后早到出发这个动作需要查询什么数据(<B>查询数据</B>)的过程:</p><h3 id="领域建模"><a class="header-anchor" href="#领域建模"></a>领域建模</h3><p>目的:</p><ul><li>将业务知识可视化，准确、深刻地反映为领域知识，并且在业务和技术人员之间达成一致；</li><li>指导系统的设计和编码，也就是说，领域模型应该能够比较容易地转化成数据库模式和代码实现;</li></ul><p>!(模型之间的联系)[]</p><p>领域对象表示的是领域事件的作用端，也就是<B>领域名词</B>，例如提交订单这个领域事件对应的领域对象就是订单;</p><p>领域对象由三部分组成:</p><ol><li>领域对象</li><li>领域对象之间的关系</li><li>领域对象的关键属性</li></ol><ul><li>领域对象又可以划分为:实体、值对象<br>实体对应到代码中就是类对象,实体与实体之间的关系就是类图,类有关键属性;</li></ul><p>建立完成领域模型后,需要完善<B>业务规则</B>、<B>建立词汇表</B></p><ul><li>模型驱动设计</li></ul><ol><li>领域模型要和业务需求保持一致</li><li>系统实现要和领域模型保持一致</li></ol><p>领域模型是堆业务进行模拟和提炼,形成浓缩的知识</p><ul><li>统一语言</li></ul><blockquote><p>统一语言包含了两个层面的含义：一是业务和技术人员之间的语言是统一的，二是开发团队内部各角色之间的语言是统一的。最终结果就是每一行代码都能对应到统一语言，从而与业务保持一致</p></blockquote><h3 id="架构设计"><a class="header-anchor" href="#架构设计"></a>架构设计</h3><h4 id="分层架构"><a class="header-anchor" href="#分层架构"></a>分层架构</h4><p>分层架构的核心思想就是将代码分成若干层,每一层负责不同的关注点;将不稳定的部分依赖与稳定的部分,常用的分层架构有六边形架构,外层依赖内层，但是内层不能依赖外层;<br>实践上就是采用分模块和分package的方式进行分层</p><h3 id="数据库设计"><a class="header-anchor" href="#数据库设计"></a>数据库设计</h3><p>在传统的软件开发过程中,对于数据库的设计是采用的’主观理解法’俗称拍脑袋法进行设计的，在了解到需求后,通过思考需求得到数据库模型,在根据数据库模型进行实现,这种方式设计的数据库模型很难精确的反映业务领域模型;<br>采用DDD的方式通过模块到实体,在到数据库模型的方式进行设计的方法，得到的数据库模型更贴近业务领域模型;</p><h3 id="代码实现"><a class="header-anchor" href="#代码实现"></a>代码实现</h3><p>在对象的定义上有两种模式:面向过程的方式和面向对象的方式，面向过程的方式就是常说的贫血模型,面向对象的方式就是充血模型或者说是富领域模式;在实践过程中并不是面向过程模式就要比面向对象模式低级,在实际研发过程中两者的关系如下所示:</p><p><img src="" alt="面向过程与面向对象之间的关系"></p><blockquote><p>面向对象和面向过程之间有一个广阔的&quot;灰色地带&quot;,这里面的变化非常多,难以穷尽,这两个极端都不是我们要追求的,我们需要做的是找到其中的一个平衡点;</p></blockquote><p>原则:</p><ol><li>依赖层问题</li><li>依赖倒置原则</li></ol><h4 id="提供领域对象的封装性"><a class="header-anchor" href="#提供领域对象的封装性"></a>提供领域对象的封装性</h4><ol><li>限制getter和setter的数量</li><li>用有业务含义的接口替代简单的setter和getter</li></ol><h4 id="编程风格"><a class="header-anchor" href="#编程风格"></a>编程风格</h4><ol><li>领域对象不能访问数据库</li><li>领域服务只能读数据库,领域服务需要读数据库。而写库的功能通常可以由应用服务来做，从而减轻领域层的负担</li><li>应用服务可以读写数据库</li><li>用ID表示对象之间的关联</li><li>领域对象有自己的领域服务</li></ol><h4 id="小结"><a class="header-anchor" href="#小结"></a>小结</h4><p>捕获行为需求和事件风暴的关系如下图所示,通过事件风暴的形式捕获到系统的行为需求,从而形成<B>统一语言</B>和<B>模型驱动设计</B></p><p><img src="" alt="事件风暴的关系"></p><p>执行者查询读数据，然后发出命令。命令触发领域事件。<br>可以从命令、领域事件、执行者、读数据中识别出领域名词。</p><p><img src="" alt="模型的建立"></p><p>这张图是领域驱动设计的精华,最核心的是<B>领域模型</B>,领域模型上面衍生出<B>领域对象</B>,下面衍生出<B>业务规则</B>;</p><h2 id="业务规则"><a class="header-anchor" href="#业务规则"></a>业务规则</h2><h3 id="聚合"><a class="header-anchor" href="#聚合"></a>聚合</h3><p>聚合指的是实体与实体之间的一种关系,这种关系有两种特点:第一具有整体和部分的关系,第二具有不变规则,而且这种不变规则的并发的时候可能被破坏;<br>这种关系中心的实体被称为<B>聚合根</B>,聚合根需要有一个全局唯一标识;\</p><p>聚合的作用是为一组具有整体部分关系的对象维护不变规则;</p><blockquote><p>减号(-)表示这是一个私有(private)属性、加号(+)表示公有(public)权限、井号(#)表示保护(protected)权限、波浪号(~)表示包级私有(package private)权限</p></blockquote><p><img src="" alt="领域模型"></p><p><img src="" alt="实现模型"></p><p>实现对象关联的方法分为两种,一种是<B>对象关联</B>、一种是<B>ID关联</B>,使用对象关联切换的成本较高,比较倾向与使用ID进行关联;<br>1<br>对<B>聚合对象</B>进行持久化的时候,是针对整个聚合下的多个对象进行的持久化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Repository</span><span class="token punctuation">.</span>java<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token class-name">Emp</span> emp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 持久化聚合对象</span>    empRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>emp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 插入skill对象</span>    emp<span class="token punctuation">.</span><span class="token function">getSkills</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>skill <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        skill<span class="token punctuation">.</span><span class="token function">setEmpId</span><span class="token punctuation">(</span>emp<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置关联的ID</span>        skillRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>skill<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//插入work对象</span>    emp<span class="token punctuation">.</span><span class="token function">getWorks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>work <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        work<span class="token punctuation">.</span><span class="token function">setEmpId</span><span class="token punctuation">(</span>emp<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置关联的ID</span>        workRepository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Repository表示的是对整个聚合进行持久化操作,而DAO表示的是对单个对象进行持久化操作,因此在DDD中Repository是对聚合的操作,而DAO是对单个对象的操作;</p><p>对于不变规则的实现,有两个需要注意的点:</p><ol><li>如果规则的验证不需要访问数据库,那么首先应该考虑在领域对象里实现,而不是在领域服务里实现;</li><li>对于聚合根的内部对象,对于它们的验证必须是从整个聚合层面才能进行验证的,无法单独进行验证;</li></ol><p>聚合在达到一定规模之后也要进行拆分,避免一个大的聚合导致的性能问题;</p><h4 id="用事务保证固定规则"><a class="header-anchor" href="#用事务保证固定规则"></a>用事务保证固定规则</h4><p>由于数据库事务无法完成避免并发修改聚合根的问题,会存在数据库事务的粒度与业务需求不匹配、丢失更新的问题,因此需要使用乐观锁的方式来保证聚合根的并发修改问题;</p><p>乐观锁的实现方式:</p><ol><li>在聚合根中添加版本号字段</li><li>在更新聚合根时,使用版本号进行校验</li><li>如果版本号不匹配,则说明有其他事务已经修改了聚合根,需要重新加载聚合根并进行处理</li></ol><p>悲观锁的实现方式:</p><ol><li>在聚合根中添加锁字段</li><li>在更新聚合根时,使用锁字段进行校验</li><li>如果锁字段被其他事务占用,则等待或抛出异常<br>类似于独占锁的方式,悲观锁会导致性能问题,因此在DDD中不推荐使用悲观锁的方式;</li></ol><p>没有关联对象的聚合根,被称为单实体聚合,现在我们面向对象的项目对于PO的定义就是单实体聚合;</p><h3 id="泛化"><a class="header-anchor" href="#泛化"></a>泛化</h3><p>泛化是指在领域模型中,将具有相同属性和行为的对象抽象为一个父类,从而减少代码的重复和复杂度;<br>泛化的实现方式是通过继承的方式,将相同的属性和行为;</p><blockquote><p>直接“借用”系统中已经存在的机制，在短期内虽然达到了目的，但长期来看会导致概念混乱，这种做法是很多开发团队常见的错误。而错误的根源，就在于我们没有掌握一种优雅的方法，来处理不同概念的共性和个性;</p></blockquote><p>可以泛化,不代表必须进行泛化,有三个原则:<br>第一:如果只有特征值不相同,那么用特征值为对象进行分类即可,不必要进行泛化;<br>第二:如果特性种类不同,那么很可能需要进行泛化<br>第三:如果在<B>业务规则</B>、<B>操作接口</B>、<B>操作实现</B>上有共性和个性的化,优先考虑在实现上</p><h3 id="限界上下文"><a class="header-anchor" href="#限界上下文"></a>限界上下文</h3><blockquote><p>限界上下文确实和划分模块、划分子系统一样，是一种分而治之的手段，可以起到分离关注点的作用。但限界上下文增加了一个要点，就是，它的目的还在于维护概念一致性。这里的概念一致性,不在是全局一致性,而是局部一致性;</p></blockquote><p>限界上下文的划分是和组织结构相关的,由于全局一致性已经超过了团队的认知负载了,所有限界上下文不在追求全局一致性;</p><h2 id="如何践行领域驱动设计"><a class="header-anchor" href="#如何践行领域驱动设计"></a>如何践行领域驱动设计</h2><p>实施DDD的项目要满足以下几个关键因素:有价值\有痛点\有意愿\有时间;</p><ul><li><p>有价值，是指站在企业的角度，这个系统对达成企业的战略目标有较大的意义；或者从业务角度，这个系统能够为公司带来比较大的收益。包括 DDD 在内的任何技术改进过程，都需要一定的成本。只有应用到价值较大系统，才能带来足够的回报</p></li><li><p>有痛点，指的是公司管理层或者开发团队确实遇到了难以解决的困难，需求寻求方法学的帮助。如果目前的开发方法挺顺利的，没有感受到明显的问题，只是“为了引入而引入 DDD”，那么往往会动力不足;</p></li><li><p>有意愿，指的是开发团队确实愿意学习新技能。其中，项目经理、开发组长、技术骨干等角色往往起着决定性的作用;</p></li><li><p>有时间，也很重要。引入任何新技术，总会有些成本。包括学习成本、试错成本等等。关键是看产出是否大于成本;</p></li></ul><p>实施DDD的场景有三种实际场景:</p><ol><li>新的项目</li><li>改造现有项目</li><li>改进现有的研发流程</li></ol><h3 id="新的项目"><a class="header-anchor" href="#新的项目"></a>新的项目</h3><blockquote><p>领导希望保证质量，降低风险，觉得需要方法学的支持，因此要引入 DDD</p></blockquote><p>在新的项目中引入DDD要避免的是<B>瀑布型思维</B>,避免在一开始就想要把模型建立的完美;</p><h3 id="改造现有项目"><a class="header-anchor" href="#改造现有项目"></a>改造现有项目</h3><p>改造现有项目主要分为四个步骤:反推领域模型 -&gt; 建立目标领域模型  -&gt; 设计演进路线  -&gt; 迭代实施,在这个过程中,一定不要陷入第一个步骤和第二个步骤中,在这两个步骤中只会有模型产出,没有实际落地的代码,也看不到任何实际的效果,会导致人们失去耐心,最终DDD无疾而终;</p><p>建议的做法是，首先选择系统中一个相对独立的小模块，然后按照前面的 4 步，尽快落地到代码并上线，建立最小闭环。通过这个过程，初步掌握 DDD 落地技能并取得实际效果。<br>同时，这么做也能培养人才，积累经验，建立必要的开发流程。完成之后，再选择下一个切片，逐步扩大范围，并深化 DDD 的技能。</p><h3 id="改进现有的研发流程"><a class="header-anchor" href="#改进现有的研发流程"></a>改进现有的研发流程</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;领域驱动设计断断续续看过几本书,但是都没有系统性的学习完成过,因此这篇文章从三个阶段来完成的记录一下,分别是&lt;B&gt;基础概念&lt;/B&gt;、&lt;B&gt;核心知识&lt;/B&gt;</summary>
      
    
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="领域驱动设计" scheme="https://agmtopy.gitee.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java性能权威指南一Java性能调优工具箱</title>
    <link href="https://agmtopy.gitee.io/2025/05/26/12.JVM/31.java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E4%B8%80)/"/>
    <id>https://agmtopy.gitee.io/2025/05/26/12.JVM/31.java%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E4%B8%80)/</id>
    <published>2025-05-26T14:47:22.000Z</published>
    <updated>2025-07-08T16:25:18.944Z</updated>
    
    <content type="html"><![CDATA[<h1>java性能权威指南一Java性能调优工具箱</h1><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>说来惭愧这本书是HeapDump社区,大概是23年的礼品吧,也是目前最后一本收到的技术书籍,以下是对这本书的学习笔记;</p><p>说到Java性能优化,有两个绕不开的前置条件:</p><ol><li><p>关于对’不要过早优化’论点的误区<br>在这个一点上,个人理解是不要过早投入精力进行极致优化,例如0.99s的响应时间,投入大量精力优化到0.49s,投入和产出不成正比;<br>'过早优化’这个词语是高德纳最早提出来的,但是完整的原话是&quot;我们不应该把大量的时间耗费在哪些小的性能改进上,过早优化是所有噩梦的根源&quot;,这不是我们编写复杂、混乱、晦涩代码的借口；</p></li><li><p>性能测试的方法<br>性能测试有几个原则:</p></li></ol><ul><li>测试真实应用</li><li>理解批处理流逝时间、吞吐量和响应时间<br>这个指的是Java应用通常都会使用JIT-即时编译技术，因此需要运行一段时间后才能测试出真实的性能水平</li><li>同统计方法论应对性能变化<br>就算是计算机科学这一严谨的学科,在测试过程中也会出现毛刺现象,因此我们评估应用的性能指标一定是要基于统计学来进行分析;</li></ul><p>简单介绍过前置条件后,下面进入主菜<B>Java性能调优工具箱</B>一节;</p><h2 id="性能调优工具"><a class="header-anchor" href="#性能调优工具"></a>性能调优工具</h2><h3 id="操作系统的工具和分析"><a class="header-anchor" href="#操作系统的工具和分析"></a>操作系统的工具和分析</h3><ul><li>CPU使用率<br>性能调优的目的是<B>提高单位时间内CPU的使用率<B><br>常用的命令是有:</li></ul><ol><li>vmstat [选项] [延迟时间] [次数]</li></ol><ul><li>磁盘使用率<br>目前来说磁盘读写相比CPU还是太慢太慢了,I/O阻塞是导致大部分程序性能无法提高的原因;<br>常用的命令有:</li></ul><ol><li>isstat -xm 5<br>输出CPU使用情况、磁盘I/O统计信息，关键指标:<B>%util-磁盘使用率</B>、<B>w_await-磁盘写入时间(毫秒)</B>、<B>%iowait-等待I/O的时间占比</B>、<B>wMB/s-磁盘每秒写入大小</B></li></ol><ul><li>网络使用率<br>网络使用率类似磁盘使用率，常用的命令有:</li></ul><ol><li>netstat:netstat -a 显示所有活动的网络连接、netstat -l 显示所有正在监听的端口,新版本的Linux中使用命令<B>ss</B>进行替代;</li><li>nicstat 5:<B>%Util - 网络端口使用率</B>、<B>rKB/s 读取速度 </B>、<B>wKB/s  写入速度</B></li></ol><h3 id="JAVA监控工具"><a class="header-anchor" href="#JAVA监控工具"></a>JAVA监控工具</h3><h4 id="JDK自带工具"><a class="header-anchor" href="#JDK自带工具"></a>JDK自带工具</h4><ul><li><p>jcmd<br>用于打印VM的信息,</p></li><li><p>jconsole<br>最早的JVM图形化性能监控工具</p></li><li><p>jhat<br>读取memory dump文件</p></li><li><p>jinfo<br>查看JVM的系统属性</p></li><li><p>jstack<br>转储Java进程的堆栈信息</p></li><li><p>jstat<br>提供GC和类装载活动的信息</p></li><li><p>jvisualvm<br>监控和分析JVM性能的工具</p></li></ul><p>重点的命令有:</p><ol><li><p>内存转储 (Heap Dump)<br>jmap -dump:format=b,file=heapdump.hprof <pid><br>jcmd <pid> GC.heap_dump <PATH>/heapdump.hprof</p></li><li><p>线程转储 (Thread Dump)<br>jstack <pid> &gt; threaddump.txt<br>jcmd <pid> Thread.print &gt; threaddump.txt</p></li></ol><h3 id="性能分析工具"><a class="header-anchor" href="#性能分析工具"></a>性能分析工具</h3><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://bbs.huaweicloud.com/blogs/395995">为什么说过早优化是万恶之源</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;java性能权威指南一Java性能调优工具箱&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;说来惭愧这本书是HeapDump社区,大概是23年的礼品吧,也是目前最后一本收到的技术书籍</summary>
      
    
    
    
    <category term="性能" scheme="https://agmtopy.gitee.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="笔记" scheme="https://agmtopy.gitee.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>系统的稳定性建设</title>
    <link href="https://agmtopy.gitee.io/2025/05/13/1.%E6%9D%82%E8%AE%B0/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/"/>
    <id>https://agmtopy.gitee.io/2025/05/13/1.%E6%9D%82%E8%AE%B0/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/</id>
    <published>2025-05-13T14:55:55.000Z</published>
    <updated>2025-05-26T00:14:47.074Z</updated>
    
    <content type="html"><![CDATA[<h1>系统的稳定性建设</h1><p>系统的稳定性建设在工作中虽然已经做了很多相关的工作,但是没有形成系统性的思考,因此通过这篇文章记录一下相关的方法论;</p><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>软件系统由于自身的特点,具备横向扩展的复制能力和交付后持续迭代的特点,使得软件系统需要在不断的迭代中努力去维持系统的稳定性,不然就会导致将大量的研发资源投入到灭火中,而不是在业务的创新上,不是技术是深入上;<br>软件系统的稳定性建设就是<B>保证系统在不断迭代中,能够保持稳定态,并且在发生故障时能够快速恢复到正常状态的能力</B>;</p><h2 id="如何衡量系统的稳定性"><a class="header-anchor" href="#如何衡量系统的稳定性"></a>如何衡量系统的稳定性?</h2><p>在对传统系统进行稳定性判断时常用的指标是通过服务的可用时长占比,例如Uptime:999.99%,即一年中有5.26分钟的不可用时间,但是在金融系统中,由于业务的特点单纯的可用时长占比已经不能完全反映系统的稳定性了,因此需要引入数据的正确性来衡量系统的稳定性;</p><p><B>业务指标偏离度</B>用于表示将实际业务数据与预期值或历史值进行比较，衡量业务指标的偏离程度。如果系统不稳定，导致数据获取或处理错误，那么业务指标偏离度可能会出现异常波动。对于金融类的系统,通常的做法是按照交易维度来进行统计的,<B>错误的数据笔数/总的交易笔数/天或月或季</B>,这样就能够很好的反映出系统的稳定性;</p><h2 id="影响系统稳定性的因素有哪些"><a class="header-anchor" href="#影响系统稳定性的因素有哪些"></a>影响系统稳定性的因素有哪些?</h2><ul><li>现状<br>在现在的系统中,出现系统不稳定性的原因主要有一下几个方面:硬件系统导致的服务不可用、业务配置错误、代码BUG、外围服务导致等;</li></ul><ol><li>硬件系统导致的不可用场景:云服务厂商提供的MySQL不稳定、网络原因等</li><li>业务配置错误:产品参数开关配置错误</li><li>代码BUG:NPE、计算金额错误</li><li>外围服务导致:上游服务不按约定传参导致、下游服务不可用影响业务的正常开展</li></ol><p>通过上面场景的分析,可以总结为下面这个图:</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE.png?raw=true" alt="系统稳定性建设"></p><p>影响系统的稳定性主要可以分为两个大类:<B>自然因素</B>、<B>人为因素</B>;<br>自然因素是不能避免的原因,只能从发现、解决的环节来尽可能的降低影响;<br>人为因素是可以通过<B>流程</B>、<B>规范</B>、<B>工具</B>来避免的,我们在提高系统的稳定性上也是着重优化人为因素这一点;</p><h3 id="自然因素"><a class="header-anchor" href="#自然因素"></a>自然因素</h3><ol><li>硬件原因<br>硬件原因导致的服务不可用可以分为:</li></ol><ul><li>服务器硬件不可用:断电、磁盘损坏、路由器不可用等等</li><li>网络故障:网络超时、丢包、中断等</li></ul><ol start="2"><li>三方服务原因<br>这里的三方服务指的是,非同一公司内部提供的服务导致不可用,通常可以分为:</li></ol><ul><li>云服务厂商提供的服务不可用,例如存储服务、MySQL服务等</li><li>开源框架的BUG</li></ul><p>自然原因导致的系统稳定性下降,可以从两个方面进行思考:</p><ol><li>通过冗余硬件的方式来降低风险,例如RAID技术和UPS等硬件设备;</li><li>通过事后监控的形式,尽早的发现问题,从而解决问题,控制影响范围;</li></ol><h3 id="人为因素"><a class="header-anchor" href="#人为因素"></a>人为因素</h3><p>人为可以控制的因素可以划分为几个大的环节:需求评审阶段 -&gt; 研发阶段 -&gt; 测试阶段 -&gt; 上线阶段 -&gt; 故障处理</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E9%9C%80%E6%B1%82%E4%BA%A4%E4%BB%98%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?raw=true" alt="需求交付生命周期"></p><p>下面从这个几个环节分析是什么原因导致稳定性降低</p><h4 id="需求评审环节"><a class="header-anchor" href="#需求评审环节"></a>需求评审环节</h4><p>需求评审环节指的不是对一个需求或者一个功能集(模块)的片面思考,更多是是需要从行业-公司-业务条线上的思考,没有一成不变的业务,需要运营、产品、研发一起想清楚、想透彻,然后提出合理的业务诉求,以及有预见性的业务建设;<br>在这个阶段有三个可以值得思考和把控的点:</p><ol><li><p>团队的定位<br>先抓住团队的立身之本,分析这个行业或者公司在的核心业务是什么?这个团队能为这个核心业务贡献什么?<br>例如电商系统的核心部门是广告业务、金融系统的核心部门是风险或者资金部门,核心业务拥有最大的资源倾斜;<br>但是核心业务在不同的时期是会发生变化的,好的职业路径肯定是不断在在核心业务条线上游走,但是很难做到;</p></li><li><p>没有长远的需求规划能力<br>在实际工作中,遇到很多产品经理只是需求方的一个传话筒,这一类产品往往对行业没有一个整体的意识,只能做到被业务方牵着鼻子走,设计的方案往往也是短视的,导致的结果就是设计的产品方案是定制化的,没有横向的复制扩展能力,以及纵向业务扩展能力;</p></li></ol><blockquote><p><B>横向的复制能力</B>指的解决的是行业内通用的痛点,通过一次方案能适用多个使用方的能力;<br><B>纵向的扩展能力</B>指的是能对抽象出业务能力,对未来业务的变化有预见性的设计;</p></blockquote><p><B>业务理解</B>是对系统稳定性影响最大的一个因素,软件系统是现实需求的直观反馈,业务架构决定了技术架构;<br>如果产研团队对业务理解的不深刻不透彻,只能着眼于未来一年甚至几个月的短期需求和利益,想到哪里就做到哪里,那么技术层面上就无法做好提前的布局和设计,变更、堆砌、重复就会接踵而来;<br>万丈高楼平地起,业务需求的理解才是软件系统的地基,地基不稳定,后续在通过各种手段方法措施来进行治理都只能治标不治本;</p><ol start="3"><li>业务需求的把控<br>从业务需求层面考虑稳定型,主要从两个方面做起:一是<B>业务需求的过滤</B>,过滤出真正有价值的需求,二是<B>需求模型的简化</B>;<br>对于需求价值的判断可以采用需求价值判断决策漏斗来进行分析:</li></ol><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E9%9C%80%E6%B1%82%E4%BB%B7%E5%80%BC%E8%BF%87%E6%BB%A4%E6%BC%8F%E6%96%97%E5%9B%BE.drawio.png?raw=true" alt="需求价值判断决策漏斗"></p><p>对于业务价值的判断,尤其是做创新型业务时,产品或者业务的想法很多,这能体现创新的源动力,但是作为实现这些想法的技术人员,要能从纷繁复杂的需求中找到最核心的需求,必须要<B>对需求方的原始需求进行合理性的质疑</B>,砍掉没有核心价值的伪需求,来精简业务模型,将有限的研发资源投入真正有业务价值的地方;</p><p>业务模型的简化会带来业务复杂度的简化,从而提高系统稳定性;</p><blockquote><p>小结:<B>对业务理解的认知,是建立全局稳定性思考的前提条件,对需求的去伪存真化繁为简决定了一个系统的复杂度,做稳定性建设必须要考虑这一环节</B></p></blockquote><h4 id="设计阶段"><a class="header-anchor" href="#设计阶段"></a>设计阶段</h4><p>研发阶段、测试阶段、上线阶段、故障处理阶段,这几个阶段都是需要投入研发资源去进行关注的,下面依次来分析一下会导致稳定性下降的原因;</p><p>在设计阶段中主要的产出物是<B>技术方案</B>,表示研发阶段的开始,在这个环节中需要把控好<B>技术设计方案</B>的质量,从而尽量在早期进行调整;</p><p>在进行详细方案评审前,一定一定要让整个团队清楚,评审的目的是<B>团队帮助你来检查方案,而不是挑战你的方案,不是来找茬的</B>,有谦虚、平和的心态才能有开发、友善的建议;</p><ul><li><p>业务上<br>在实际工作中,处理业务需求的技术方案设计遇到两类人,一类是只关心这个需求是作什么,如何才能把这个需求实现,另外一类是了解这个需求是做什么,并且知道为什么要做这个需求,并且在这个需求上进行扩展;<br>第一类人,做100个需求和做10个需求的效果是一样的,没有主动思考的能力,这一类人的技术方案需要在设计评审时引导他进行思考,但是引导还是需要分人分场合进行的,工作态度严肃坚定的人和自由散漫的人提出一个相同的意见,最后得到的反馈也是不一样的;<br>第二类人,能够做到主动思考,但是在主动思考过程中需要注意的是不要陷入过度设计中去,工程化实际上是围绕这效率\质量这两个点来进行的,适当才是当前最好的设计,这部分过渡设计可能更多的出现在技术上;</p></li><li><p>技术上<br>一个不好的技术方案,经常会出现问题的几个地方:</p></li></ul><table><thead><tr><th>序号</th><th>场景</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>限流</td><td>限流是服务提供者基于自身考虑提供的保护自身的能力,常见的算法有计数器算法、滑动窗口算法、令牌桶算法等，实现的框架有Resilience4j、Sentinel</td></tr><tr><td>2</td><td>熔断降级</td><td>熔断是防止我们的系统被下游系统拖垮，实现的框架有Resilience4j、Sentinel</td></tr><tr><td>3</td><td>超时机制</td><td>超时时间的设置需要遵循漏斗原则</td></tr><tr><td>4</td><td>重试机制</td><td>RPC框架的默认重试机制、避免出现重试风暴</td></tr><tr><td>5</td><td>兼容性考虑</td><td>新逻辑-兼容-老数据、老逻辑-兼容-新数据</td></tr><tr><td>6</td><td>隔离</td><td>数据隔离、系统隔离、读写分离、线程池隔离等</td></tr></tbody></table><blockquote><p>小结: 在设计阶段需要重点关注详细设计方案的技术合理性和业务合理性,两个方面;</p></blockquote><h4 id="研发阶段"><a class="header-anchor" href="#研发阶段"></a>研发阶段</h4><p>这个阶段产出的是代码,对于代码codeReview是最后一个流程,在这个动作中，可以有三个需要关注的：</p><ol><li>技术经理统一代码风格</li><li>结对编程，这里的结对编程不是说一个人写，一个人在旁边看，而是一个人负责写，另外一个owner负责codeReview</li><li>单元测试的覆盖度，单元测试一定是必要的！在提测前发现问题，影响越小；</li></ol><blockquote><p>在这个阶段中，遇到最多的问题是写代码的同学对边界值、API不熟悉、代码混乱等，没有降低整体复杂度的意识;</p></blockquote><h4 id="测试阶段"><a class="header-anchor" href="#测试阶段"></a>测试阶段</h4><p>在测试阶段，容易忽略的是正常场景的回归；测试需要做到全流程全场景的覆盖，通过人工手动的去完成，是一个低效不稳定的方法；<br><B>测试的原则是尽可能的用机器完成自动化测试和全场景的覆盖，将宝贵的人力资源投入到必须用人力进行测试的环节</B></p><h4 id="上线阶段"><a class="header-anchor" href="#上线阶段"></a>上线阶段</h4><p>在上线需要关注的是两点：代码和配置</p><ol><li>代码<br>如果代码没上去，一切都是白搭，检查上线的内容</li><li>配置<br>对应的业务配置也需要调整</li></ol><h4 id="故障处理阶段"><a class="header-anchor" href="#故障处理阶段"></a>故障处理阶段</h4><p>故障处理阶段需要注意处理问题的先后顺序，原则上是按照下面这个流程进行处理</p><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png?raw=true" alt="故障处理流程.png"></p><p>第一点需要注意的是和业务方的沟通以及在问题发现时及时团队内同步；<br>第二点需要注意的是一定要正确定位到问题在进行修改，避免产生连锁问题;</p><h2 id="应对措施"><a class="header-anchor" href="#应对措施"></a>应对措施</h2><p>上述阐述了影响系统稳定性的几个原因，针对这些原因可以从以下几个方面来进行应对;</p><h3 id="制度-规范"><a class="header-anchor" href="#制度-规范"></a>制度/规范</h3><p>制度或者规范要能去落地才是好的制度,必须是要符合人的本性的;按研发流程划分主要分下图:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E5%88%B6%E5%BA%A6%E8%A7%84%E8%8C%83.png?raw=true" alt="制度规范"><br>在这几个环节过程中都会产生问题,但是问题的影响范围从大到小，解决问题消耗的资源从小到大；举一个例子，在需求评审阶段如果对于需求的理解出现偏差会导致返工,由于返工压缩工期又会增加系统的不稳定性;</p><h3 id="工具"><a class="header-anchor" href="#工具"></a>工具</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E5%B7%A5%E5%85%B7%20%20.png?raw=true" alt="工具"></p><p>工具可以为我们降低稳定性建设的资源投入,提高效率,主要分为<B>研发工具</B>和<B>故障排查工具</B></p><h3 id="预案"><a class="header-anchor" href="#预案"></a>预案</h3><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/1.%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/%E9%A2%84%E6%A1%88.png?raw=true" alt="预案"></p><p>出现问题是无法避免的,但是解决问题的方式方法是有一定的流程的,通常出现的问题是线上出现问题,在没有保存现场时,直接重启,导致无法找到故障原因、第二种是处理问题的顺序错误,应该先降低影响,在探寻原因;</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>一个简单的总结就是:</p><ol><li>做好需求的分析和设计</li><li>做好技术方案的评审</li><li>codereview以及单元测试</li><li>测试场景的覆盖</li><li>故障应对预案</li></ol><p>其实最后还应该有一个复盘阶段,但是个人在实际工作中感觉复盘是一项意义比较小的工作,有些坑还是要亲自跌倒了才能长记性;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E9%98%BF%E9%87%8C%E6%B5%85%E8%B0%88%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E5%B1%82%E9%9D%A2%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BF%9D%E9%9A%9C/">阿里浅谈系统实现层面稳定性保障</a><br><a href="https://developer.jdcloud.com/article/3894">万字长文浅谈系统稳定性建设</a><br><a href="https://www.infoq.cn/article/z4ssmnks3w4ebbustyo1">稳定性全系列（一）：如何做好系统稳定性建设</a><br><a href="https://cloud.tencent.com/developer/article/1758295">换个角度聊系统稳定性建设</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;系统的稳定性建设&lt;/h1&gt;
&lt;p&gt;系统的稳定性建设在工作中虽然已经做了很多相关的工作,但是没有形成系统性的思考,因此通过这篇文章记录一下相关的方法论;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/</summary>
      
    
    
    
    <category term="杂记" scheme="https://agmtopy.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="业务监控" scheme="https://agmtopy.gitee.io/tags/%E4%B8%9A%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>MAT使用指南</title>
    <link href="https://agmtopy.gitee.io/2025/05/05/12.JVM/21.MAT%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://agmtopy.gitee.io/2025/05/05/12.JVM/21.MAT%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2025-05-05T13:04:46.000Z</published>
    <updated>2025-05-06T13:27:12.325Z</updated>
    
    <content type="html"><![CDATA[<h1>MAT使用指南</h1><p>前言:将MAT常用的使用方法记录下来以备不时之需,后续补充也在这上面进行</p><h2 id="MAT使用过程中常见问题"><a class="header-anchor" href="#MAT使用过程中常见问题"></a>MAT使用过程中常见问题</h2><ol><li><p>JDK版本不匹配<br>目前MAT版本为1.16.0,需要JDK17以上版版本,如果要使用JDK8作为运行时环境需要下载1.7.0版本<br><a href="https://github.com/eclipse-mat/mat/releases/tag/R_1.7.0">R_1.7.0</a></p></li><li><p>运行目标版本不一致<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98.png?raw=true" alt="MAT_启动问题"><br>如果MAT的运行版本和目标版本不一致,会导致无法打开dump文件,需要在MAT的安装目录下找到<code>MemoryAnalyzer.ini</code>文件,修改如下:</p> <pre class="line-numbers language-none"><code class="language-none">-vm&#123;#你的jdk路径#&#125;\jdk-21.0.2\bin\javaw.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是必须将<code>-vm</code>配置放到<code>-vmargs</code>之前,否则会导致MAT无法启动</p></li><li><p>运行时内存不足<br>如果在使用MAT的过程中出现了<code>java.lang.OutOfMemoryError: Java heap space</code>的错误,可以在<code>MemoryAnalyzer.ini</code>中添加如下配置:</p><pre class="line-numbers language-none"><code class="language-none">-Xms512m-Xmx2048m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中<code>-Xms</code>表示初始内存大小,<code>-Xmx</code>表示最大内存大小,可以根据自己的机器配置进行调整,<B>注意MAT的内存大小一般设置为hprf文件的两倍</B></p></li><li><p>调整内存单位<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%BD%8D1.png?raw=true" alt="调整内存"><br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%BD%8D2.png?raw=true" alt="调整内存2"></p></li></ol><h2 id="MAT常用功能"><a class="header-anchor" href="#MAT常用功能"></a>MAT常用功能</h2><p><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_%E4%B8%BB%E7%95%8C%E9%9D%A2.png?raw=true" alt="MAT主界面"></p><h3 id="Histogram"><a class="header-anchor" href="#Histogram"></a>Histogram</h3><p>直方图:用于分析对象的数量和大小<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_Histogram.png?raw=true" alt="MAT_Histogram"><br>从上图中可以看到Object的数量和大小,shallow Heap表示对象本身占用的内存,retained Heap表示对象引用的内存,可以通过右键点击show object by class进行查看;<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_Histogram_income.png?raw=true" alt="MAT_Histogram_incomeing"></p><h3 id="dominator-tree"><a class="header-anchor" href="#dominator-tree"></a>dominator tree</h3><p>支配树:用于分析对象的引用关系和占用大小<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_dominator_tree.png?raw=true" alt="dominator tree"><br>dominator tree是MAT中最常用的功能,通过它可以很明显的分析出当前内存的占用情况,并且可以按照class,package,ClassLoad等进行分类;</p><ul><li><p>分组功能:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_dominator_tree1.png?raw=true" alt="dominator tree1"></p></li><li><p>GC Root引用功能:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_dominator_tree2.png?raw=true" alt="dominator tree2"></p></li><li><p>调用链功能:<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_dominator_tree3.png?raw=true" alt="dominator tree3"></p></li></ul><h3 id="Leak-Suspects-by-Snapshot-Comparison"><a class="header-anchor" href="#Leak-Suspects-by-Snapshot-Comparison"></a>Leak Suspects by Snapshot Comparison</h3><p>疑似内存泄漏视图:通过这个视图可以快速分析内存泄漏问题<br><img src="https://github.com/agmtopy/noteBook/blob/master/png/j-jvm/MAT_Leak%20Suspects%20by%20Snapshot%20Comparison.png?raw=true" alt="Leak Suspects"></p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://github.com/eclipse-mat/mat">MAT项目地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MAT使用指南&lt;/h1&gt;
&lt;p&gt;前言:将MAT常用的使用方法记录下来以备不时之需,后续补充也在这上面进行&lt;/p&gt;
&lt;h2 id=&quot;MAT使用过程中常见问题&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MAT使用过程中常见问题&quot;&gt;&lt;/a&gt;MAT使用过程</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Prompt工程实战</title>
    <link href="https://agmtopy.gitee.io/2025/03/22/25.AIGC/2.Prompt%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    <id>https://agmtopy.gitee.io/2025/03/22/25.AIGC/2.Prompt%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98/</id>
    <published>2025-03-22T06:29:45.000Z</published>
    <updated>2025-03-22T06:34:23.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prompt工程实战"><a class="header-anchor" href="#Prompt工程实战"></a>Prompt工程实战</h2><h3 id="什么是Prompt"><a class="header-anchor" href="#什么是Prompt"></a>什么是Prompt</h3><p>Prompt指的是在AI模型中输入的一段文本，用于指导模型的输出,Prompt</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prompt工程实战&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Prompt工程实战&quot;&gt;&lt;/a&gt;Prompt工程实战&lt;/h2&gt;
&lt;h3 id=&quot;什么是Prompt&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是Pr</summary>
      
    
    
    
    <category term="AI" scheme="https://agmtopy.gitee.io/categories/AI/"/>
    
    
    <category term="Prompt" scheme="https://agmtopy.gitee.io/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>RPC通信原理</title>
    <link href="https://agmtopy.gitee.io/2025/03/17/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://agmtopy.gitee.io/2025/03/17/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0-RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</id>
    <published>2025-03-17T12:51:01.000Z</published>
    <updated>2025-03-29T11:38:28.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《架构思考》-RPC通信原理"><a class="header-anchor" href="#《架构思考》-RPC通信原理"></a>《架构思考》-RPC通信原理</h2><h3 id="RPC调用流程"><a class="header-anchor" href="#RPC调用流程"></a>RPC调用流程</h3><ul><li>服务端、</li></ul><ol><li>网络模块</li><li>协议解码</li><li>反序列化</li><li>服务调用</li></ol><ul><li>客户端</li></ul><ol><li>调用接口方法</li><li>代理实现</li><li>序列化</li><li>协议编码</li><li>网络模块</li></ol><h3 id="Reactor模型"><a class="header-anchor" href="#Reactor模型"></a>Reactor模型</h3><p>Reactor模型</p><ul><li><p>Reactor单线程模型</p></li><li><p>Reactor多线程模型</p></li></ul><ol><li>MainReactor主线程<ul><li>单个线程,负责接收客户端连接</li></ul></li><li>SubReactor线程池</li></ol><ul><li>负责事件检测、I/O操作</li></ul><ol start="3"><li>worker线程池</li></ol><ul><li>负责业务处理</li></ul><p>优劣分析:MainReactor主线程与SubReactor线程池职责分工明确,MainReactor主线程只负责接收客户端连接,SubReactor线程池负责事件检测、I/O操作,worker线程池负责业务处理。<br>MainReactor主线程与SubReactor线程的数据交互简单,MainReactor主线程只需要把新连接传给SubReactor线程池即可,SubReactor线程池无需返回数据;<br>多个SubReactor线程能够应对更高的并发请求;<br>缺点:编程复杂度较高</p><p>小结:Reactor多线程模型也被称呼为1+M+N模型,1代表MainReactor主线程,M代表SubReactor线程池,N代表worker线程池。广泛应用于Ngix、Netty等高性能网络框架中。</p><h3 id="Netty框架"><a class="header-anchor" href="#Netty框架"></a>Netty框架</h3><ul><li>Netty模型</li></ul><ol><li>为什么要选择Netty,而不是选择NIO<ul><li>Netty api更加友好和强大</li><li>Netty自身线程安全</li><li>Netty拥有完整的高可用机制</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;《架构思考》-RPC通信原理&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#《架构思考》-RPC通信原理&quot;&gt;&lt;/a&gt;《架构思考》-RPC通信原理&lt;/h2&gt;
&lt;h3 id=&quot;RPC调用流程&quot;&gt;&lt;a class=&quot;header-anchor&quot; hr</summary>
      
    
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何深入理解ChatGPT等大语言模型-笔记</title>
    <link href="https://agmtopy.gitee.io/2025/03/07/25.AIGC/1.%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ChatGPT%E7%AD%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://agmtopy.gitee.io/2025/03/07/25.AIGC/1.%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ChatGPT%E7%AD%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B-%E7%AC%94%E8%AE%B0/</id>
    <published>2025-03-07T15:49:06.000Z</published>
    <updated>2025-03-22T06:32:29.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何深入理解ChatGPT等大语言模型-笔记"><a class="header-anchor" href="#如何深入理解ChatGPT等大语言模型-笔记"></a>如何深入理解ChatGPT等大语言模型-笔记</h2><p>根据Andrej Kaparthy分享的<a href="https://www.youtube.com/watch?v=7xTGNNLPyMI">Deep Dive into LLMs like ChatGPT</a>视频，以下是我在学习过程中的一些笔记：</p><h3 id="预训练阶段"><a class="header-anchor" href="#预训练阶段"></a>预训练阶段</h3><ul><li>数据收集阶段</li></ul><ol><li>收集数据,通过爬虫技术收集大量文本数据</li><li>对数据进行清洗,去除无用信息</li><li>压缩数据,形成词表(token)</li></ol><ul><li>构建神经网络模型</li></ul><ol><li>根据词表预测下一个词的概率</li><li>对概率进行调整,使其更加正确,也就是<B>神经网络训练的过程</B><br>这里使用的是Transformer模型,这个不太懂 TODO,后面在了解</li></ol><ul><li>推理过程<br>推理过程简单来说就是根据步骤2生成的模型,在结合输入的文本,预测下一个词的概率;</li></ul><h4 id="基础模型"><a class="header-anchor" href="#基础模型"></a>基础模型</h4><ol><li>基础模型也具备上下文学习能力</li></ol><h3 id="监督式-微调阶段"><a class="header-anchor" href="#监督式-微调阶段"></a>监督式-微调阶段</h3><p>由于基础模型只能做到预测下一个词语的能力,不能理解文本的含义,所以需要对基础模型进行微调<br>微调的方式是通过对话的方式来进行调整,然后将调整后的数据重新训练基础模型,使其具备对话的能力</p><p>类似的文档数据集,可以参考(Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT)[<a href="https://huggingface.co/datasets/Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT">https://huggingface.co/datasets/Congliu/Chinese-DeepSeek-R1-Distill-data-110k-SFT</a>]</p><p>微调阶段更重要的作用是修正基础模型的一些错误,使其更加准确,以及让模型知道自己的边界在哪里,从而解决<B>模型幻觉问题 </B></p><ul><li>模型需要分步思考<br>LLM模型在给出结果时,会依赖上一步输出的token,因此要避免一个步骤中就让模型给出最终的答案,而是分步思考,使用上一步的输出作为下一步的输入,这样可以减少模型幻觉问题或者让模型使用其他工具来实现;</li></ul><h3 id="强化学习阶段"><a class="header-anchor" href="#强化学习阶段"></a>强化学习阶段</h3><p><B>强化学习</B>指的是模型在给出答案后,会根据结果来增加能输出正确答题的路径的概率,减少错误答案的路径的概率,在不断的迭代中,模型会更加准确;<br>对于有明确答案的问题,可以使用LLM评判模型给出的答案是否正确,从而进行强化学习;<br>对于没有明确答案的问题,通常使用另外一个神经网络模型来模拟人类的评判标准,来进行评分,从而进行强化学习;<br>RLHF会有对抗问题,因为模型会想办法欺骗评判标准;</p><p>PS:这个分享教程的格式非常好,首先是分享的知识只划分为三个段落,每个段落完成后都会进行回溯,最后进行整体回溯;</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><p><a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fineweb-v1">FineWeb: decanting the web for the finest text data at scale</a><br><a href="https://tiktokenizer.vercel.app/?model=cl100k_base">Tiktokenizer</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何深入理解ChatGPT等大语言模型-笔记&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#如何深入理解ChatGPT等大语言模型-笔记&quot;&gt;&lt;/a&gt;如何深入理解ChatGPT等大语言模型-笔记&lt;/h2&gt;
&lt;p&gt;根据Andrej Kaparthy</summary>
      
    
    
    
    <category term="AI" scheme="https://agmtopy.gitee.io/categories/AI/"/>
    
    
    <category term="AI" scheme="https://agmtopy.gitee.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>第一章-前言</title>
    <link href="https://agmtopy.gitee.io/2024/12/12/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E8%A8%80/"/>
    <id>https://agmtopy.gitee.io/2024/12/12/24.%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%89%8D%E8%A8%80/</id>
    <published>2024-12-12T13:08:02.000Z</published>
    <updated>2025-03-17T12:50:27.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《架构思考》-前言"><a class="header-anchor" href="#《架构思考》-前言"></a>《架构思考》-前言</h2><h3 id="互联网架构演变历史"><a class="header-anchor" href="#互联网架构演变历史"></a>互联网架构演变历史</h3><h4 id="1-业务架构"><a class="header-anchor" href="#1-业务架构"></a>1. 业务架构</h4><p>1.1 单体架构<br>在互联网早期发展中,主要以单体架构为主,按照业务-&gt;应用层-&gt;数据层进行简单划分;<br>每一个业务系统就是一个单独的业务团队,数据和人员(组织关系)都是独立的,造成数据隔离和组织单体化的问题;</p><p>1.2 中台战略<br>由阿里提出来的,理念是<B>共享</B>,共享业务、系统、组织架构上的一种落地方式和实施办法;<br>关键字:共享、节约成本、协助;<br>中台战略主要分为数据中台和业务中台两层能力,如图所示:</p><p>#TODO</p><p>1.3 去中台战略</p><ol><li>中台的复用率不高,提炼和维护中台所花费的代价抵不上中台复用带来的价值</li></ol><h4 id="2-数据架构"><a class="header-anchor" href="#2-数据架构"></a>2. 数据架构</h4><ul><li>数据库架构</li></ul><ol><li><p>单体数据库架构<br>web项目通过JDBC直连单体数据库</p></li><li><p>主从读写<br>数据库采用读写分离架构,主库负责写操作,从库负责读操作;<br>涉及到的中间件:sharding-jdbc,mycat</p></li><li><p>分库分表<br>分库分表有两种方式:一种是横向切分,一种是纵向切分:</p></li></ol><ul><li><p>横向拆分指的是按照记录进行拆分</p></li><li><p>纵向拆分指的是按照字段进行拆分</p></li><li><p>高速缓存<br>引入redis来解决热数据的问题;<br>缓存带来的问题:</p></li></ul><ol><li>缓存击穿(单一key失效)</li><li>缓存穿透(无效key访问)</li><li>缓存雪崩(大量key失效)</li><li>缓存一致性</li></ol><ul><li>数据多样化</li></ul><ol><li>分布式文件系统:HDFS,FastDFS</li><li>nosql:mongodb,redis</li><li>搜索引擎:Elasticsearch</li></ol><h4 id="3-应用架构"><a class="header-anchor" href="#3-应用架构"></a>3. 应用架构</h4><ol><li><p>单机调优<br>上古时代使用tomcat或者jboos进行部署时,对单机进行调优,比如JVM参数优化、数据库连接池优化等;</p></li><li><p>动静分离<br>前端静态资源独立部署到前置服务器上</p></li><li><p>SOA架构<br>SOA架构需要引入ESB(企业服务总线)来进行整体调度</p></li><li><p>微服务架构<br>微服务架构是SOA架构的一种改进,微服务架构是一套系统和理念;</p></li></ol><h4 id="4-部署架构"><a class="header-anchor" href="#4-部署架构"></a>4. 部署架构</h4><ol><li><p>单机部署<br>小型项目直接部署到单机上</p></li><li><p>集群部署<br>集群部署主要是为了解决单机瓶颈问题,比如单机CPU、内存、IO瓶颈;</p></li><li><p>多层代理<br>多层代理使用负载均衡器来解决单机瓶颈问题;</p></li><li><p>异地访问<br>异地访问主要是为了解决跨地域访问延迟问题;</p></li><li><p>云平台<br>云平台主要是为了解决自建机房的成本问题,通常使用docker、k8s等技术;</p></li></ol><h4 id="5-架构思想"><a class="header-anchor" href="#5-架构思想"></a>5. 架构思想</h4><ol><li>知行合一,做之前,先思考意义</li><li>原生由于定制,约定大于配置</li><li>什么都要,最后什么都要不了</li><li>控制技术欲,不要瞎折腾</li><li>留下扩展,但是不要想到100年以后</li><li>没有最好的,只有最合适的</li><li>够用就好,用的越花,风险越大</li><li>简约最美</li></ol><h3 id="容器化技术概览"><a class="header-anchor" href="#容器化技术概览"></a>容器化技术概览</h3><p>应用部署方式的演变:从硬件虚拟化(操作系统虚拟化))到容器虚拟化(容器虚拟化的演变;</p><h4 id="什么是容器化"><a class="header-anchor" href="#什么是容器化"></a>什么是容器化</h4><blockquote><p>容器化是将应用程序或服务及其依赖或者配置,一起打包为容器映像的一种软件构建及部署技术;</p></blockquote><p><img src="" alt="容器化架构"></p><ul><li>什么是docker</li></ul><blockquote><p>docker是go语言研发的容器引擎,基于容器化技术和沙箱机制的应用部署技术;<br>可适用于自动化测试、打包、持续集成、发布等场景,以下是Docker的优点:</p></blockquote><ol><li>更高效的系统资源利用率</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>更轻松的迁移</li></ol><p>当然docker也有缺点:</p><ol><li>隔离性不如虚拟机</li><li>性能高于虚拟机,但是低于物理机</li></ol><p>docker的应用场景:<br>1.微服务部署场景<br>2. DevOps场景</p><p>额外需要注意的是,对docker文件的修改只会体现在当前层,对其他层的修改会采用标记删除-复制修改的方式进行;</p><h2 id="Zookeeper"><a class="header-anchor" href="#Zookeeper"></a>Zookeeper</h2><h3 id="Zookeeper基础及高级应用"><a class="header-anchor" href="#Zookeeper基础及高级应用"></a>Zookeeper基础及高级应用</h3><ul><li><p>Zookeeper数据模型<br>Zookeeper的数据模型是一个树形目录结构,类似于文件系统的目录结构,通过k-v的方式来进行存储,key是由’/'分割的路径;<br>每个Znode节点可以存储的数据大小为1MB,选择1Mb的原因是基于zookeeper作为分布式协调服务的高性能和稳定性考量,其设计初衷就是用于协调服务,而非存储大量数据;</p></li><li><p>Zookeeper节点类型</p></li></ul><ol><li>持久化节点(默认类型)</li><li>持久化顺序节点</li><li>临时节点</li><li>临时顺序节点<br>另外还有容器节点和超时节点等</li></ol><h4 id="Zookeeper应用场景"><a class="header-anchor" href="#Zookeeper应用场景"></a>Zookeeper应用场景</h4><ul><li>分布式锁</li></ul><blockquote><p>分布式锁指的是在分布式环境下,跨进程\跨主机\跨网络的共享资源,实现互斥访问,保证一致性;在Zookeeper中,锁就是一个数据节点;</p></blockquote><p>普通实现:通过注册<B>临时节点</B>,各个客户端抢占创建临时节点的方式,来获取锁,其他未抢占到该节点的客户端通过监听该节点的变化来重新获取锁;<br>这种方式存在的问题是: 羊群效应,指的是持有锁的客户端释放锁之后,其他所有客户端由于是通过watch机制监听该节点,导致所有客户端都会收到通知,然后重新发起竞争锁的请求,从而造成大量无效竞争;<br>解决方案是:通过临时顺序节点,每个客户端在创建锁的时候,都会创建一个临时顺序节点,然后通过监听前一个节点的变化来获取锁;</p><ul><li>分布式锁-读写锁</li></ul><blockquote><p>通过Zk实现分布式读写锁,是通过将临时顺序节点分为<B>读锁节点</B>和<B>写锁节点</B>来进行实现;</p></blockquote><ol><li>读请求时,通过判断当前读节点,如果没有比自己更小的节点或者比自己小的节点都是读节点,那么获取读锁成功,如果比自己小的节点中有写锁节点,那么获取读锁失败;</li><li>写请求时,通过判断当前写节点,如果没有比自己更小的节点,那么获取读锁成功,如果自己不是最小的节点,那么获取读锁失败;</li><li>读锁或者写锁完成操作后,都要进行释放;</li></ol><ul><li>配置中心</li></ul><blockquote><p>使用zookeeper作为配置中心,主要是通过客户端来监听配置节点的变化来实现;</p></blockquote><ul><li>注册中心</li></ul><blockquote><p>使用zookeeper作为注册中心,是通过客户端来注册服务节点,调用端监听服务节点的变化来实现;</p></blockquote><ul><li>Curator客户端的实现</li></ul><ol><li>InterProcessMutex:分布式可重入排他锁</li><li>InterProcessSemaphoreV2:分布式信号量</li></ol><h4 id="Zookeeper选举策略"><a class="header-anchor" href="#Zookeeper选举策略"></a>Zookeeper选举策略</h4><ul><li>ZAB协议</li></ul><p>Zookeeper的选举策略是基于ZAB协议来进行实现的,ZAB协议是一种对<B>Paxos算法</B>的简化实现,是专门未Zookeeper设计的支持崩溃恢复的原子广播协议;<br>基于该协议zk实现了一种主备模式(即Leader和Follower模式)的系统架构来保证集群中的各个节点的数据一致性;<br>在ZAB协议下,节点分为两个角色:<B>Leader</B>和<B>Follower</B>,第三个角色是Observer,Observer不参与投票;<br>Leader: 唯一，负责写操作和协调,一个zk集群中同一时刻只会有一个Leader,Leader发起并维护与各个follower和Observer的心跳,Leader通过心跳来维护集群中各个节点的状态,同时将写操作广播到各个节点<br>Follower: 多数，负责读操作并参与选举,同时Follower会响应Leader的心跳,并且接受Leader的写操作广播;Follower也可以响应客户端的写操作,然后将写操作转发给Leader,来进行完成;<br>Observer: 可选，专注于读操作，不参与选举,Observer的设计是为了提供读能力,因此被设计为数据是满足最终一致性的,因此可能会有读取数据延迟的问题,解决这个问题的方法是:1.强制Sync,2.客户端优先连接到Leader或者follower,3.对于强一致性的业务场景不使用Observer;</p><ul><li>ZAB协议的两种模式</li></ul><ol><li>崩溃恢复模式:一旦Leader服务器进入崩溃或者网络原因导致与集群中的过半follower失去连接,那么就会进入崩溃恢复模式;zk集群会进入选举阶段,通过投票的方式来选出新的Leader;</li><li>消息广播模式:Leader选出之后,就会进入消息广播模式;在该模式下,Leader会进行消息广播,需要注意的是<B>满足过半节点即可</B>,这是和Paxos算法的区别;</li></ol><ul><li>zk的选举过程<br>Zookeeper的选举过程分为两类,第一类是<B>服务器启动时的Leader选举流程</B>、<B>异常恢复场景Leader的选举过程</B><br>首先介绍几个概念:</li></ul><ol><li>zxid:zxid是一个64位的数字,高32位是epoch(leader纪元),低32位是当前leader纪元内事务ID,节点初始化时为0|0;</li><li>serverid:也被称为<B>myId</B>,代表服务器的ID,是一个32位的数字,初始化是通过myid文件进行初始化的;</li><li>Quorum:集群中过半的节点数量;</li></ol><p>leader选举流程大致可以分为以下几个步骤:</p><ol><li>集群启动时,每个节点都会初始化自己的zxid和serverid;</li><li>集群启动时,每个节点都会发起投票,投的都是自己,并且将投票信息广播出去</li><li>每个节点通过对比自己的(zxid,serverid)和接收到的投票信息,来确定自己的投票结果,并且将投票信息广播出去;</li><li>当某个节点收到的投票信息数量达到过半时,该节点就会成为Leader;</li><li>Leader选举完成后,Leader会进行消息广播;</li></ol><h2 id="Apollo配置中心"><a class="header-anchor" href="#Apollo配置中心"></a>Apollo配置中心</h2><p>Apollo是分布式配置中心,主要用于管理分布式系统的配置信息;</p><p>@TODO</p><h2 id="Skywalking…"><a class="header-anchor" href="#Skywalking…"></a>Skywalking…</h2><h3 id="微服务系统监控的三要素"><a class="header-anchor" href="#微服务系统监控的三要素"></a>微服务系统监控的三要素</h3><p>度量单位:QPS,RT,CPU使用率,接口调用量,接口成功率<br>日志:业务日志,数据日志,异常日志<br>链路追踪:记录一个请求的完整路径</p><h3 id="分布式链路的组成"><a class="header-anchor" href="#分布式链路的组成"></a>分布式链路的组成</h3><ol><li><B>数据采集阶段</B></li><li><B>数据持久化阶段</B></li><li><B>数据展示阶段</B></li></ol><h3 id="opentraceing规范"><a class="header-anchor" href="#opentraceing规范"></a>opentraceing规范</h3><ul><li>trace</li></ul><blockquote><p>一个Trace代表一个事务、请求或者是流程在分布式系统中的执行过程;OpenTracing中的一个Trace由多个Span组成,一个Spen代表系统中具有开始时间<br>和执行时长的逻辑单元,Span一般会有一个名称,一个Trace中的Span是首尾相连接的;</p></blockquote><ul><li>Span</li></ul><blockquote><p>Span代表系统中具有开始时间和执行时长的逻辑单元,Span之间通过嵌套或者顺序排列建立逻辑因果关系;</p></blockquote><h3 id="配置"><a class="header-anchor" href="#配置"></a>配置</h3><ol><li>使用javaagent的方式,在启动时添加参数,设置ServiceName;</li></ol><h2 id="网络编程"><a class="header-anchor" href="#网络编程"></a>网络编程</h2><h3 id="网络IO模型"><a class="header-anchor" href="#网络IO模型"></a>网络IO模型</h3><ol><li>同步阻塞IO<br>同步阻塞IO:由于是依赖于操作系统的IO操作,因此会导致线程阻塞,并且由于线程数量的限制,无法创建大量IO线程;</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;《架构思考》-前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#《架构思考》-前言&quot;&gt;&lt;/a&gt;《架构思考》-前言&lt;/h2&gt;
&lt;h3 id=&quot;互联网架构演变历史&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#互联网架构演变历</summary>
      
    
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="https://agmtopy.gitee.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>深入分析JavaParser原理之基础用法(一)</title>
    <link href="https://agmtopy.gitee.io/2024/09/13/23.JavaParser%E5%88%86%E6%9E%90/1.%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90JavaParser%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>https://agmtopy.gitee.io/2024/09/13/23.JavaParser%E5%88%86%E6%9E%90/1.%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90JavaParser%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</id>
    <published>2024-09-13T13:00:29.000Z</published>
    <updated>2024-10-21T16:46:45.113Z</updated>
    
    <content type="html"><![CDATA[<h1>深入分析JavaParser原理之基础用法(一)</h1><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>JavaParser是一个基于JavaCC的开源项目，它是一个解析器生成器和抽象语法树(AST)处理工具</p><h2 id="使用示例"><a class="header-anchor" href="#使用示例"></a>使用示例</h2><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;深入分析JavaParser原理之基础用法(一)&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;JavaParser是一个基于JavaCC的开源项目，它是一个解析器生成器和抽象语法树</summary>
      
    
    
    
    <category term="JavaParser" scheme="https://agmtopy.gitee.io/categories/JavaParser/"/>
    
    
    <category term="JavaParser" scheme="https://agmtopy.gitee.io/tags/JavaParser/"/>
    
  </entry>
  
  <entry>
    <title>JDK21对比JDK8语法升级指南</title>
    <link href="https://agmtopy.gitee.io/2024/04/01/12.JVM/51.jdk21%E5%AF%B9%E6%AF%94jdk8%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/"/>
    <id>https://agmtopy.gitee.io/2024/04/01/12.JVM/51.jdk21%E5%AF%B9%E6%AF%94jdk8%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/</id>
    <published>2024-04-01T14:06:00.000Z</published>
    <updated>2024-05-23T15:37:17.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK21对比JDK8语法升级指南"><a class="header-anchor" href="#JDK21对比JDK8语法升级指南"></a>JDK21对比JDK8语法升级指南</h2><p>JDK8经过JDK11(LTS)、JDK17(LTS)、JDK21(LTS)等多个长期支持JDK版本,目前最新版本已经到了JDK22(non lts),下一个长期支持版本为JDK25,因此长时间内JDK21都会是一个生产版本,下面从三个三个方面了解JDK8升级到JDK21中语法层面的内容:<B>新语法特性</B>、<B>新API</B>、<B>并发</B>;</p><h3 id="新语法特性"><a class="header-anchor" href="#新语法特性"></a>新语法特性</h3><ol><li><p>Record<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/RecordKeyword1.java">RecordKeyword1.java</a><br><a href="(https://openjdk.org/jeps/432)">JEP 432: Record Patterns (Second Preview)</a></p></li><li><p>instanceof增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Instanceof2.java">Instanceof2.java</a><br><a href="https://openjdk.org/jeps/394">JEP 394: Pattern Matching for instanceof</a></p></li><li><p>Sealed Classes:密封类<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Permits3.java">Permits3.java</a><br><a href="https://openjdk.org/jeps/397">JEP 397: Sealed Classes (Second Preview)</a></p></li><li><p>TextBlock:文本块增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/TextBlock4.java">TextBlock4.java</a><br><a href="https://openjdk.org/jeps/378">JEP 378: Text Blocks</a></p></li><li><p>switch增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Switch6.java">Switch6.java</a><br><a href="https://openjdk.org/jeps/361">JEP 361: Switch Expressions</a></p></li><li><p>var:局部变量类型<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/Var7.java">Var7.java</a><br><a href="https://openjdk.org/jeps/323">JEP 323: Local-Variable Syntax for Lambda Parameters</a></p></li><li><p>Interface Private Method<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newlanguagefeatures/InterfacePrivate8.java">InterfacePrivate8</a><br><a href="https://openjdk.org/jeps/213">JEP 213: Milling Project Coin</a></p></li></ol><h3 id="新API"><a class="header-anchor" href="#新API"></a>新API</h3><ol><li><p>Collection:集合新增方法<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/SequencedCollection1.java">SequencedCollection1.java</a><br>[<a href="https://openjdk.org/jeps/431">https://openjdk.org/jeps/431</a>](JEP 431: Sequenced Collections)</p></li><li><p>BigDecimal.Two<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/BigDecimalTwo4.java">BigDecimalTwo4.java</a></p></li><li><p>HexFormat:16进制转换<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/HexFormat5.java">HexFormat5.java</a></p></li><li><p>Stream.toList<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StreamToList6.java">StreamToList6.java</a></p></li><li><p>Stream.MapMulti:flatMap<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StreamToList6.java">StreamToList6.java</a></p></li><li><p>Collectors.Teeing:集合合并<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/CollectorsTeeing8.java">CollectorsTeeing8.java</a></p></li><li><p>String增强<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/StringIncrease9.java">StringIncrease9.java</a></p></li><li><p>Collectors.of:集合初始化<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/CollectionsFactoryMethods10.java">CollectionsFactoryMethods10.java</a></p></li><li><p>Flow API:实现响应式规范<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/MyPublisher11.java">MyPublisher11.java.java</a></p></li><li><p>Arrays.Mismatch:差集<br><a href="https://github.com/agmtopy/JDK21/blob/main/src/main/java/st/newapi/ArraysMismatch12.java">ArraysMismatch12.java</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDK21对比JDK8语法升级指南&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JDK21对比JDK8语法升级指南&quot;&gt;&lt;/a&gt;JDK21对比JDK8语法升级指南&lt;/h2&gt;
&lt;p&gt;JDK8经过JDK11(LTS)、JDK17(LTS)、JDK2</summary>
      
    
    
    
    <category term="JVM" scheme="https://agmtopy.gitee.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://agmtopy.gitee.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>1.高并发系统实战-如何解决缓存不同步</title>
    <link href="https://agmtopy.gitee.io/2024/02/27/21.%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/"/>
    <id>https://agmtopy.gitee.io/2024/02/27/21.%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/</id>
    <published>2024-02-27T13:35:37.000Z</published>
    <updated>2024-03-09T03:40:30.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高并发系统实战-如何解决缓存不同步"><a class="header-anchor" href="#高并发系统实战-如何解决缓存不同步"></a>高并发系统实战-如何解决缓存不同步</h2><p>使用缓存需要注意的地方:</p><ol><li>使用缓存需要考虑性价比</li><li>防止穿透缓存直接查询数据库场景</li><li>设置TTL</li></ol><p>缓存数据刷新场景:</p><ol><li><p>单条数据更新场景<br>常见的方法是通过’先更新数据库在删除缓存’的方式来进行出来,更严格的场景是通过延迟双删或者MQ的方式通知删除</p></li><li><p>避免大量临时缓存同时到期失效</p></li><li><p>对于高并发更新缓存的场景可以采用’singleflight(请求合并)'来进行优化</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高并发系统实战-如何解决缓存不同步&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#高并发系统实战-如何解决缓存不同步&quot;&gt;&lt;/a&gt;高并发系统实战-如何解决缓存不同步&lt;/h2&gt;
&lt;p&gt;使用缓存需要注意的地方:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用缓存需要</summary>
      
    
    
    
    <category term="极客时间" scheme="https://agmtopy.gitee.io/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
    
    <category term="高并发" scheme="https://agmtopy.gitee.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="缓存" scheme="https://agmtopy.gitee.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之美</title>
    <link href="https://agmtopy.gitee.io/2023/11/25/13.LeetCode/20.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E4%B8%80/"/>
    <id>https://agmtopy.gitee.io/2023/11/25/13.LeetCode/20.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E4%B8%80/</id>
    <published>2023-11-25T09:20:21.000Z</published>
    <updated>2023-11-27T15:00:12.072Z</updated>
    
    <content type="html"><![CDATA[<h1>数据结构与算法之美</h1><h2 id="链表"><a class="header-anchor" href="#链表"></a>链表</h2><p><img src="https://github.com/agmtopy/noteBook/blob/bcb7ec20e534a7a98747839531829e14b116a23b/png/J-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/S-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89.png?raw=true" alt="链表的定义"></p><p>链表的主要比较对象是数组,最大的差别在于内存空间是否连续不连续上,对于不连续的内存空间就需要<B>索引</B>或<B>下标</B>方式来标识;</p><p>回文串问题如何解决?</p><p>链表解决技巧:</p><ol><li>理解指针或引用的含义</li><li>警惕指针丢失和内存泄漏</li><li>哨兵概念,利用哨兵节点简化编程难度,用哨兵节点来屏蔽首尾节点的特殊处理逻辑</li><li>重点留意边界条件处理<br>如果链表为空时，代码是否能正常工作？<br>如果链表只包含一个结点时，代码是否能正常工作？<br>如果链表只包含两个结点时，代码是否能正常工作？<br>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li><li>画图举例操作</li></ol><p>练习题LeetCode对应编号：206，141，21，19，876</p><h2 id="栈"><a class="header-anchor" href="#栈"></a>栈</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;数据结构与算法之美&lt;/h1&gt;
&lt;h2 id=&quot;链表&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/agmtopy/noteBook/blob/bcb7ec2</summary>
      
    
    
    
    <category term="算法" scheme="https://agmtopy.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://agmtopy.gitee.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
