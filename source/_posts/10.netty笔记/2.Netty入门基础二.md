---
title: Netty入门基础二
date: 2020-07-29 23:53:47
categories: Netty
tags:
  - Netty
---

# Netty入门基础二
在上一篇文章中主要介绍了Netty是从何而来以及概念和组件，下面咱们来看一下如何实现一个简单的例子

分析Netty实例主要是为了展示服务器端的<B>业务逻辑</B>和<B>引导代码</B>两部分
服务端的业务逻辑处理主要分为两个部分一部分是对于<B>channel</B>的事件进行处理，另外一部分是对<B>业务数据</B>的处理
主要以RocketMQ中的[NettyRemotingServer](https://github.com/apache/rocketmq/blob/master/remoting/src/main/java/org/apache/rocketmq/remoting/netty/NettyRemotingServer.java)为主

### 引导代码

```java
ServerBootstrap childHandler =
    //1. 设置EventLoopGroup
    this.serverBootstrap.group(this.eventLoopGroupBoss, this.eventLoopGroupSelector)
        //2. 设置channel处理类型
        .channel(useEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)
        //3. 设置用于监听socket的属性
        .option(ChannelOption.SO_BACKLOG, 1024)
        .option(ChannelOption.SO_REUSEADDR, true)
        .option(ChannelOption.SO_KEEPALIVE, false)
        //4. 设置创建socket后再创建的socket
        .childOption(ChannelOption.TCP_NODELAY, true)
        .childOption(ChannelOption.SO_SNDBUF, nettyServerConfig.getServerSocketSndBufSize())
        .childOption(ChannelOption.SO_RCVBUF, nettyServerConfig.getServerSocketRcvBufSize())
        //5. 设置链接地址
        .localAddress(new InetSocketAddress(this.nettyServerConfig.getListenPort()))
        //6. 设置业务处理 Channel
        .childHandler(new ChannelInitializer<SocketChannel>() {
            @Override
            public void initChannel(SocketChannel ch) throws Exception {
                ch.pipeline()
                    .addLast(defaultEventExecutorGroup, HANDSHAKE_HANDLER_NAME, handshakeHandler)
                    .addLast(defaultEventExecutorGroup,
                        encoder,
                        new NettyDecoder(),
                        new IdleStateHandler(0, 0, nettyServerConfig.getServerChannelMaxIdleTimeSeconds()),
                        connectionManageHandler,
                        serverHandler
                    );
            }
        });
```

引导代码主要是分为以下几个步骤
1. 设置EventLoopGroup
2. 设置Channel处理类型
3. 设置监听socket的属性
4. 设置地址端口
5. 设置业务处理的Channel



### 业务逻辑

业务处理逻辑是由<B>ChannelInitializer</B>实现的，分别是添加了两个处理策略分别是

- HandshakeHandler handshakeHandler

- NettyServerHandler serverHandler

这两个策略都是继承于<B>SimpleChannelInboundHandler</B>,
HandshakeHandler只是处理入站链接是否需要TSL加密处理的，因此相关参数也比较简单
NettyServerHandler是真正的业务处理类,因此跟随了很多执行的策略配置参数等

```java
    //设置业务处理策略
    .addLast(defaultEventExecutorGroup,
        encoder,//设置解码器
        new NettyDecoder(),//设置编码器
        new IdleStateHandler(0, 0, nettyServerConfig.getServerChannelMaxIdleTimeSeconds()),
        connectionManageHandler,//设置双工处理策略
        serverHandler
    );
```
下面来分析以下SimpleChannelInboundHandler的设计


## 源码分析

### SimpleChannelInboundHandler
从上面可以看到业务的处理类都继承于<B>SimpleChannelInboundHandler</B>
![SimpleChannelInboundHandler的继承关系](https://i.loli.net/2021/11/18/GmHgT5OzsdwFfLk.jpg)






