---
title: 创建bean的流程
date: 2018-03-19 21:46:35
categories: spring
tags: spring源代码
---

# 创建bean的流程

通过上面几个流程的分析，终于来到了spring初始化bean的流程了。在这个过程中主要的功能有实列化bean对象、加载到缓存、前后置处理;

## 创建流程

```java
@Override
	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {
        
        //1.处理BeanDefinition
        RootBeanDefinition mbdToUse = mbd;
		Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
        mbdToUse.prepareMethodOverrides();

        //2. 尝试从BeanPostProcessors返回代理类对象
        // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
        if (bean != null) {
            return bean;
        }

        //创建bean
        Object beanInstance = doCreateBean(beanName, mbdToUse, args);
        return beanInstance;
	}
```
创建流程主要分为以下三步：
1. 对BeanDifinition属性在加载前进行处理
    1.1 解析指定 BeanDefinition 的 class
    1.2 处理override属性
2. 尝试在创建前调用前置处理返回bean
    2.1 主要是调用**InstantiationAwareBeanPostProcessor**接口(提前返回代理类，AOP就是基于此)
3. 开始初始化bean

```java

protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
        //构造方法初始化bean对象
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		final Object bean = instanceWrapper.getWrappedInstance();
		Class<?> beanType = instanceWrapper.getWrappedClass();

		// 解决单列模式循环加载bean，提前将初始化中的bean放入正在初始化的map中
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
		}

		// Initialize the bean instance.
        //初始化bean对象
		Object exposedObject = bean;
		try {
            //对bean进行填充将各个属性值注入，可能存在依赖于其他bean的属性
			populateBean(beanName, mbd, instanceWrapper);
            //调用初始化方法
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
        //解决循环依赖问题
		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
				}
			}
		}
		// Register bean as disposable.
		try {
            //注册bean
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
        //返回
		return exposedObject;
	}
```

1. 单列模式下清除容器
2. 构造方法初始化bean对象
3. 属性装配调用初始化方法
4. 解决循环依赖
5. 注册、返回bean


