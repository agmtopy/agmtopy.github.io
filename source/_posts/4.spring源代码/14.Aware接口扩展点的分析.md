---
title: Aware接口扩展点的分析
date: 2018-03-20 00:30:00
categories: spring
tags: spring源代码
---

# Aware接口扩展点的分析

**aware**字面上的意思为感知，在spring中就是感知容器、bean的时机并进行自定义扩展的

## 使用

![86lLsf.png](https://s1.ax1x.com/2020/03/20/86lLsf.png)

## 常用的Aware

类名|作用
--|--
LoadTimeWeaverAware|加载Spring Bean时织入第三方模块，如AspectJ
BeanClassLoaderAware|加载Spring Bean的类加载器
BootstrapContextAware|资源适配器BootstrapContext，如JCA,CCI
ResourceLoaderAware|底层访问资源的加载器
BeanFactoryAware|声明BeanFactory
PortletConfigAware|PortletConfig
PortletContextAware|PortletContext
ServletConfigAware|ServletConfig
ServletContextAware|ServletContext
MessageSourceAware|国际化
ApplicationEventPublisherAware|应用事件
NotificationPublisherAware|JMX通知
BeanNameAware|声明Spring Bean的名字

## 如何实现

- AbstractAutowireCapableBeanFactory

```java
private void invokeAwareMethods(final String beanName, final Object bean) {
		if (bean instanceof Aware) {
			if (bean instanceof BeanNameAware) {
				((BeanNameAware) bean).setBeanName(beanName);
			}
			if (bean instanceof BeanClassLoaderAware) {
				ClassLoader bcl = getBeanClassLoader();
				if (bcl != null) {
					((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
				}
			}
			if (bean instanceof BeanFactoryAware) {
				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
			}
		}
	}
```

```java
 */
	protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
		if (System.getSecurityManager() != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				invokeAwareMethods(beanName, bean);
				return null;
			}, getAccessControlContext());
		}
		else {
			invokeAwareMethods(beanName, bean);
		}
    }

```

在初始化bean的时候判断bean是否是aware子类本进行回调。对于其他aware子类也应该一样是在设定的业务回调点进行回调。

