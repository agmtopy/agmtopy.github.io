---
title: finishBeanFactoryInitialization加载bean流程
date: 2018-03-07 01:28:40
categories: spring
tags:
  - spring
---

# finishBeanFactoryInitialization加载流程

## finishBeanFactoryInitialization入口方法

### 代码展示
**finishBeanFactoryInitialization**是加载普通的spring bean方法，代码如下：
```java
	/**
	 * 在context中通过beanFactory完成对bean的初始化,
	 * 将会初始化剩余的全部作用域为单列的bean.
	 */
	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
		// 设置是否有名称转换服务.
		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
			beanFactory.setConversionService(
					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
		}

		// 如果没有bean的后置处理器就注册默认的插值解析器
		// （例如PropertyPlaceholderConfigurer bean）之前注册过的任何东西：
		// 此时，主要用于注释属性值的解析.
		if (!beanFactory.hasEmbeddedValueResolver()) {
			beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));
		}

		// 注册LoadTimeWeaverAware的处理.
		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
		for (String weaverAwareName : weaverAwareNames) {
			getBean(weaverAwareName);
		}

		// 停止使用临时ClassLoader进行类型匹配.
		beanFactory.setTempClassLoader(null);

		// 允许缓存所有bean定义元数据，不希望有进一步的更改.
		beanFactory.freezeConfiguration();

		// 开始实列化剩下的懒加载bean.
		beanFactory.preInstantiateSingletons();
	}
```

### 总结
可以看出在这段代码的前大部分还是对beanFactory在进行初始化bean之前，对beanFactory进行标记处理。最后一行的**beanFactory.preInstantiateSingletons()**才是开始进行bean的加载,继续查看代码,这里实际上调用了**DefaultListableBeanFactory.preInstantiateSingletons()**

## preInstantiateSingletons方法

### 代码展示
```java
	@Override
	public void preInstantiateSingletons() throws BeansException {
		if (logger.isTraceEnabled()) {
			logger.trace("Pre-instantiating singletons in " + this);
		}

		// 创建BeanDefinition的副本，一次进行注册.
		// 尽管这不是一些factory bean的初始化方式，但是这也是正常的
		List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

		// 进行所以非懒加载bean的初始化...
		for (String beanName : beanNames) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
					if (bean instanceof FactoryBean) {
						final FactoryBean<?> factory = (FactoryBean<?>) bean;
						boolean isEagerInit;
						if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
							isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)
											((SmartFactoryBean<?>) factory)::isEagerInit,
									getAccessControlContext());
						}
						else {
							isEagerInit = (factory instanceof SmartFactoryBean &&
									((SmartFactoryBean<?>) factory).isEagerInit());
						}
						if (isEagerInit) {
							getBean(beanName);
						}
					}
				}
				else {
					getBean(beanName);
				}
			}
		}
```
### 总结
分析代码可以看到**preInstantiateSingletons**主要是获取beanName和**RootBeanDefinition**,然后根据**BeanDefinition**是否是**延迟加载**、**单列**进行初始化。然后调用**getBean(String name)**,对于工厂类这里会加上前缀'&'这样获取到的就是BeanFactory而不是bean;

## getBean(String name)

### 代码展示

- getBean(String name)

```java
	@Override
	public Object getBean(String name) throws BeansException {
		return doGetBean(name, null, null, false);
	}
```

- AbstractBeanFactory.doGetBean(name, null, null, false)

```java
	protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

    //进行bean的名称转换
		final String beanName = transformedBeanName(name);
		Object bean;

		// 检查Bean是否已经进行手动注册过，如果注册过就进行返回.
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null && args == null) {
			if (logger.isTraceEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
							"' that is not fully initialized yet - a consequence of a circular reference");
				}
				else {
					logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
				}
			}
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

		else {
			// 初始化已经在初始化过程中的bean会抛出异常:
			// 通过循环的方式去判断.
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}

			// 检查beanFactory工厂中是否有BeanDefinition的定义.
			BeanFactory parentBeanFactory = getParentBeanFactory();
			if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
				// Not found -> check parent.
				String nameToLookup = originalBeanName(name);
				if (parentBeanFactory instanceof AbstractBeanFactory) {
					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
							nameToLookup, requiredType, args, typeCheckOnly);
				}
				else if (args != null) {
					// 将参数传递给父类.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else if (requiredType != null) {
					// No args -> delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
				else {
					return (T) parentBeanFactory.getBean(nameToLookup);
				}
			}

			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
			}

			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				checkMergedBeanDefinition(mbd, beanName, args);

				// 确保依赖bean的初始.
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
						}
						registerDependentBean(dep, beanName);
						try {
							getBean(dep);
						}
						catch (NoSuchBeanDefinitionException ex) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
						}
					}
				}

				// 创建bean实例.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, () -> {
						try {
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// 出现异常要预先移除bean
							// 因为在初始化的过程中为解决循环引用依赖提前将bean加载
              // 删除掉所以的临时引用.
							destroySingleton(beanName);
							throw ex;
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}

				else if (mbd.isPrototype()) {
					// 如果是原型模式就会创建一个新的实例.
					Object prototypeInstance = null;
					try {
						beforePrototypeCreation(beanName);
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						afterPrototypeCreation(beanName);
					}
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				else {
					String scopeName = mbd.getScope();
					final Scope scope = this.scopes.get(scopeName);
					if (scope == null) {
						throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
					}
					try {
						Object scopedInstance = scope.get(beanName, () -> {
							beforePrototypeCreation(beanName);
							try {
								return createBean(beanName, mbd, args);
							}
							finally {
								afterPrototypeCreation(beanName);
							}
						});
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
					}
					catch (IllegalStateException ex) {
						throw new BeanCreationException(beanName,
								"Scope '" + scopeName + "' is not active for the current thread; consider " +
								"defining a scoped proxy for this bean if you intend to refer to it from a singleton",
								ex);
					}
				}
			}
			catch (BeansException ex) {
				cleanupAfterBeanCreationFailure(beanName);
				throw ex;
			}
		// 检查所需类型是否与实际bean实例的类型匹配.
		if (requiredType != null && !requiredType.isInstance(bean)) {
			try {
				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
				if (convertedBean == null) {
					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
				}
				return convertedBean;
			}
			catch (TypeMismatchException ex) {
				if (logger.isTraceEnabled()) {
					logger.trace("Failed to convert bean '" + name + "' to required type '" +
							ClassUtils.getQualifiedName(requiredType) + "'", ex);
				}
				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			}
		}
		return (T) bean;

		}
```
### 总结
1. 判断是否创建过或者正在创建中
2. 根据名称检查当前beanFactory是否有BeanDefinition的定义，没有就检查父类
3. 进行bean依赖的加载
4. 对单列bean进行创建
5. 对原型bean进行创建
6. 检查返回的bean类型是否符合预期
在这段代码中主要是对bean创建前进行最后一次检查已经消除循环依赖的逻辑，不管是原型模式还是单列模式最后代码都是调用的**AbstractBeanFactory.createBean(String name)**的方法进行的创建

**registerDependentBean(dep, beanName);**这个方法会解决循环依赖的问题，如果A->B，B->A,当A进行初始化的时候会在这个方法中查询到A依赖了B,然后进行依赖的暂时解除，这个时候才会对B进行getBean(B)的方法。


## createBean()

### 代码展示
```java
	@Override
	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {

		if (logger.isTraceEnabled()) {
			logger.trace("Creating instance of bean '" + beanName + "'");
		}
		RootBeanDefinition mbdToUse = mbd;

		// 确保此时确实解析了BeanDefiniton
    //并且在无法动态存储的class、合并BeanDefinition
		Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
		if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
			mbdToUse = new RootBeanDefinition(mbd);
			mbdToUse.setBeanClass(resolvedClass);
		}

		// 准备覆盖方法.
		try {
			mbdToUse.prepareMethodOverrides();
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
					beanName, "Validation of method overrides failed", ex);
		}

		try {
			// 给BeanPostProcessor一个返回代理而不是实例的机会
			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
			if (bean != null) {
				return bean;
			}
		}
		catch (Throwable ex) {
			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
					"BeanPostProcessor before instantiation of bean failed", ex);
		}

		try {
			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
			if (logger.isTraceEnabled()) {
				logger.trace("Finished creating instance of bean '" + beanName + "'");
			}
			return beanInstance;
		}
		catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
			// A previously detected exception with proper bean creation context already,
			// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
			throw ex;
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex);
		}
	}

```

## 总结


在**CreateBean()**方法中，前面主要是对beanDefinition的检查。检查完毕之后调用两个方法**resolveBeforeInstantiation**、**doCreate()**

## resolveBeforeInstantiation方法

- **resolveBeforeInstantiation**是调用**InstantiationAwareBeanPostProcessor**子类尝试返回bean

- 代码展示

```java
	@Nullable
	protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {
		for (BeanPostProcessor bp : getBeanPostProcessors()) {
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
				if (result != null) {
					return result;
				}
			}
		}
		return null;
	}
```
- 演示结果
![3XclJx.png](https://s2.ax1x.com/2020/03/07/3XclJx.png)


## doCreate方法


### 代码展示

```java
	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		final Object bean = instanceWrapper.getWrappedInstance();
		Class<?> beanType = instanceWrapper.getWrappedClass();
		if (beanType != NullBean.class) {
			mbd.resolvedTargetType = beanType;
		}

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							"Post-processing of merged bean definition failed", ex);
				}
				mbd.postProcessed = true;
			}
		}

		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
			}
		}

		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								"Bean with name '" + beanName + "' has been injected into other beans [" +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								"] in its raw version as part of a circular reference, but has eventually been " +
								"wrapped. This means that said other beans do not use the final version of the " +
								"bean. This is often the result of over-eager type matching - consider using " +
								"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
					}
				}
			}
		}

		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
		}

		return exposedObject;
	}

```

### 分析
**doCreateBean**主要有以下几个方法：
1. createBeanInstance(beanName, mbd, args)
2. applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)
3. populateBean(beanName, mbd, instanceWrapper)
4. initializeBean(beanName, exposedObject, mbd)

#### createBeanInstance
**createBeanInstance** -> **instantiateBean(beanName, mbd)** -> **getInstantiationStrategy().instantiate(mbd, beanName, parent)** -> **BeanUtils.instantiateClass(constructorToUse)** ->**ctor.newInstance(argsWithDefaultValues)**
通过**class.newInstance()**可以看出这里用反射调用构造函数从而构造好一个bean

#### applyMergedBeanDefinitionPostProcessors这里是调用MergedBeanDefinitionPostProcessors的子类执行

#### populateBean

- 代码展示
```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
    //省略代码...
		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
						return;
					}
				}
			}
    //省略代码...
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

    for (BeanPostProcessor bp : getBeanPostProcessors()) {
          pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
      }
    }
  }
  //省略代码...
  applyPropertyValues(beanName, mbd, bw, pvs);
	
```

**populateBean**方法主要是执行InstantiationAwareBeanPostProcessor接口下的**postProcessAfterInstantiation**、**getBeanPostProcessors**

#### initializeBean

- 代码展示

```java
protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
			invokeAwareMethods(beanName, bean);
      //省略代码...
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
			//省略代码...
      invokeInitMethods(beanName, wrappedBean, mbd);
			//省略代码...
      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
  		return wrappedBean;
	}
```

主要有：
1. **invokeAwareMethods**的作用是如果bean继承了Aware接口，在赋值操作之前执行Aware接口中的方法
  i. BeanNameAware
  ii. BeanClassLoaderAware
  iii. BeanFactoryAware
2. **applyBeanPostProcessorsBeforeInitialization**执行**BeanPostProcessors**接口下before的方法
3. **invokeInitMethods**是执行指定的初始化方法
4. **applyBeanPostProcessorsAfterInitialization**执行**BeanPostProcessors**接口下的after方法


## 流程图
![3XXbuQ.png](https://s2.ax1x.com/2020/03/07/3XXbuQ.png)

## 总结：
1. **refresh()**中加载完成spring的组件后，执行加载普通bean方法，入口是**finishBeanFactoryInitialization**。
2. **finishBeanFactoryInitialization**中主要的工作分为两类：
    1. 检查环境和检查BeanDefiniation
    2. 加载bean。调用的方法是**getBean()**方法，**getBean()**方法调用的有是doGetBean()方法
3. **doGetBean()**方法主要做了两件事：
    1. 通过**registerDependentBean**解决循环依赖问题
    2. 调用**AbstractBeanFactory.createBean(String name)**加载bean
4. **AbstractBeanFactory.createBean(String name)**主要是依赖两个方法：
    1. resolveBeforeInstantiation方法通过这个方法尝试用**InstantiationAwareBeanPostProcessor**接口返回bean
    2. 如果第一步没有返回bean，就调用**doCreate()**方法
5. **doCreate()**内部主要有四个方法
    1. **createBeanInstance**这个方法是通过反射调用构造函数创建bean对象
    2. **applyMergedBeanDefinitionPostProcessors**执行MergedBeanDefinitionPostProcessors的一个操作
    3. **populateBean**这个方法主要是对**InstantiationAwareBeanPostProcessor**接口下的**postProcessAfterInstantiation**和**getBeanPostProcessors**以及进行一个赋值的操作
    4. **initializeBean**方法主要是执行：
      1. **Aware**下的**BeanNameAware**、**BeanClassLoaderAware**、**BeanFactoryAware**的操作
      2. **BeanPostProcessors**接口下的**before**方法
      3. **invokeInitMethods**执行指定的初始化方法
      4. **BeanPostProcessors**接口下的**after**方法
      
至此，普通bean的初始化过程加载完成。


> 参考资料
- [Spring AOP源码解读1 - 程序入口](https://www.jianshu.com/p/867991f3daa0)
- [Spring源码分析之Bean的加载 ](https://www.sohu.com/a/214717253_714863)