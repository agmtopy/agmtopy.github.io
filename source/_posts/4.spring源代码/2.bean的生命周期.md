---
title: Bean容器refresh的过程
date: 2018-03-05 22:47:31
categories: spring
tags:
  - spring
---

# bean的生命周期

bean的生命周期可以通过**AbstrctApplicationContext.refresh()**方法进行加载普通bean可以得出。

## refresh()

```java

@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// 准备此上下文以进行刷新.
			prepareRefresh();

			// 告诉子类刷新内部bean工厂.(获取beanFactory)
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// 准备在这种情况下使用的bean工厂.(对beanFactory进行预处理)
			prepareBeanFactory(beanFactory);

			try {
				// 在上下文子类中对bean工厂进行后置处理.
				postProcessBeanFactory(beanFactory);

				// 调用在上下文中注册为Bean的工厂处理器.
				invokeBeanFactoryPostProcessors(beanFactory);

				// 注册拦截Bean创建的Bean处理器.
				registerBeanPostProcessors(beanFactory);

				// 为此上下文初始化消息源.
				initMessageSource();

				// 为此上下文初始化事件广播器.
				initApplicationEventMulticaster();

				// 在特定上下文子类中初始化其他特殊bean.
				onRefresh();

				// 检查侦听器bean并注册它们.
				registerListeners();

				// 实例化所有剩余的（非延迟初始化）单例bean.
				finishBeanFactoryInitialization(beanFactory);

				// 最后一步：发布相应事件.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// 销毁已创建的单例以避免资源悬空.
				destroyBeans();

				// 重置“active”标志
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				//自检并重置spring中缓存的bean的元数据，因为可能不在使用
				resetCommonCaches();
			}
		}
	}
```
下面按照流程进一步分析refresh()方法

## 配置资源初始化环境
配置应用刷新上下文环境的方法主要有**prepareRefresh()**、**obtainFreshBeanFactory()**、**prepareBeanFactory(beanFactory)**

### prepareRefresh()

```java
	/**
	 * 准备此上下文以进行刷新，设置其启动日期和
	 * 活动标志，以及执行属性源的任何初始化.
	 */
	protected void prepareRefresh() {
		//切换到活动状态.
		this.startupDate = System.currentTimeMillis();
		this.closed.set(false);
		this.active.set(true);

		if (logger.isDebugEnabled()) {
			if (logger.isTraceEnabled()) {
				logger.trace("Refreshing " + this);
			}
			else {
				logger.debug("Refreshing " + getDisplayName());
			}
		}

		// 初始化ProperySources容器.
		initPropertySources();

		// 验证所有标记为必需的属性都是可解析的:
		// see ConfigurablePropertyResolver#setRequiredProperties
		getEnvironment().validateRequiredProperties();

		// ApplicationListeners设置为预处理
		if (this.earlyApplicationListeners == null) {
			this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
		}
		else {
			// 将ApplicationListeners重新设置成预处理状态.
			this.applicationListeners.clear();
			this.applicationListeners.addAll(this.earlyApplicationListeners);
		}

```
**prepareRefresh()**方法只是在清理上下文环境、设置启动事件以及初始化**PropertySources容器**等；
初始化**PropertySources**容器方法对应web应用底层是调用
```
    WebApplicationContextUtils.initServletPropertySources(getPropertySources(), servletContext, servletConfig)
```
实现将**servletContext**, **servletConfig**加载到**PropertySources容器**中的

- servletContext是web应用服务器为每一个应用创建的一个服务上下文对象
- servletConfig是操作一个servlet中的配置属性的接口

### obtainFreshBeanFactory()
**obtainFreshBeanFactory()**

```java
	protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
		refreshBeanFactory();
		return getBeanFactory();
	}
```
1. **refreshBeanFactory()**刷新beanFactory，底层是调用**DefaultListableBeanFactory.setSerializationId()**方法去刷新工厂集合
```java
    //这里使用的是ConcurrentHashMap
	private static final Map<String, Reference<DefaultListableBeanFactory>> serializableFactories =
			new ConcurrentHashMap<>(8);

	public void setSerializationId(@Nullable String serializationId) {
		if (serializationId != null) {
            //注意这里使用的是WeakReference保证了并发安全性
			serializableFactories.put(serializationId, new WeakReference<>(this));
		}
		else if (this.serializationId != null) {
			serializableFactories.remove(this.serializationId);
		}
		this.serializationId = serializationId;
	}

```

2. getBeanFactory()方法不同的实现都是返回**DefaultListableBeanFactory**


### prepareBeanFactory(beanFactory)

```java
	protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		// 告诉内部bean工厂使用上下文的类加载器等.
		beanFactory.setBeanClassLoader(getClassLoader());
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

		// 使用上下文回调配置Bean工厂.
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

		// BeanFactory接口不在普通工厂中注册设置为可解析类型.
		// MessageSource注册为Bean（并发现用于自动装配）.
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);

		// 注册早期的后置处理器以将内部bean检测为ApplicationListeners.
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

		// 如果发现LoadTimeWeaver，请准备织入。
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			// Set a temporary ClassLoader for type matching.
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}

		// 注册默认环境bean.
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
		}
	}

```
**prepareBeanFactory(beanFactory)**主要是给beanFactory设置各种预设的属性的

### 总结

对**配置资源初始化环境**的总结就是：
1. 清理环境，设置启动时间，装载servletContext和servletConfig
2. 获取**DefaultListableBeanFactory**
3. 给获取到的**DefaultListableBeanFactory**设置各种属性

## postProcessBeanFactory
  **postProcessBeanFactory**是用来在应用上下文中注册一些特殊的**BeanPostProrecessors**

### GenericWebApplicationContext分析
- 代码展示
```java
@Override
	protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		if (this.servletContext != null) {
			beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext));
			beanFactory.ignoreDependencyInterface(ServletContextAware.class);
		}
		WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);
		WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext);
	}
```

1. **ServletContextAwareProcessor**

- WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext)

```java
		public static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,
			@Nullable ServletContext sc) {

		beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope());
		beanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, new SessionScope());
		if (sc != null) {
			ServletContextScope appScope = new ServletContextScope(sc);
			beanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);
			// Register as ServletContext attribute, for ContextCleanupListener to detect it.
			sc.setAttribute(ServletContextScope.class.getName(), appScope);
		}

		beanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory());
		beanFactory.registerResolvableDependency(ServletResponse.class, new ResponseObjectFactory());
		beanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory());
		beanFactory.registerResolvableDependency(WebRequest.class, new WebRequestObjectFactory());
		if (jsfPresent) {
			FacesDependencyRegistrar.registerFacesDependencies(beanFactory);
		}
	}
```
2. 主要是用于注册web应用程序bean的注册范围增加**request**、**session**、**application**

- WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext)

```java
	public static void registerEnvironmentBeans(ConfigurableListableBeanFactory bf,
			@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {

		if (servletContext != null && !bf.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)) {
			bf.registerSingleton(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME, servletContext);
		}

		if (servletConfig != null && !bf.containsBean(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME)) {
			bf.registerSingleton(ConfigurableWebApplicationContext.SERVLET_CONFIG_BEAN_NAME, servletConfig);
		}
		//省略...
		bf.registerSingleton(WebApplicationContext.CONTEXT_PARAMETERS_BEAN_NAME,
			Collections.unmodifiableMap(parameterMap));
		}
		//省略...
		bf.registerSingleton(WebApplicationContext.CONTEXT_ATTRIBUTES_BEAN_NAME,
			Collections.unmodifiableMap(attributeMap));
		}
	}
```
3. 将**servletContext**、**servletConfig**、**contextParameters**、**contextParameters**注册到容器中

### 总结：postProcessBeanFactory方法就是在bean初始化之前将一些特殊的bean注册到容器中去，从而完成接下来的初始化操作

## invokeBeanFactoryPostProcessors
**invokeBeanFactoryPostProcessors**方法是执行实现**BeanFactoryPostProcessor**接口的方法

```java
	protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory,getBeanFactoryPostProcessors());

		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
		if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}
	}
```

**getBeanFactoryPostProcessors()**中返回的bean是在初始化化环境**prepareContext**中加载的

**invokeBeanFactoryPostProcessors**的代码：

```java
	public static void invokeBeanFactoryPostProcessors(
			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

		// Invoke BeanDefinitionRegistryPostProcessors first, if any.
		Set<String> processedBeans = new HashSet<>();

		if (beanFactory instanceof BeanDefinitionRegistry) {
			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
			List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
			List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();

			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					registryProcessors.add(registryProcessor);
				}
				else {
					regularPostProcessors.add(postProcessor);
				}
			}
			List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();
			//省略....
			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.

			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			boolean reiterate = true;
			while (reiterate) {
				sortPostProcessors(currentRegistryProcessors, beanFactory);
				registryProcessors.addAll(currentRegistryProcessors);
				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
				currentRegistryProcessors.clear();
			}

			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
			//省略....
		}
```

以上代码的作用就是
1. 先处理**BeanDefinitionRegistryPostProcessor**，按照PriorityOrdered > Ordered > 普通的顺序一次执行**postProcessBeanDefinitionRegistry**方法；
2. 再处理**BeanFactoryPostProcessors**，按照PriorityOrdered > Ordered > 普通的顺序一次执行**postProcessBeanFactory**方法；

### 总结
**invokeBeanFactoryPostProcessors**方法就是执行实现**BeanDefinitionRegistryPostProcessor**接口的**postProcessBeanDefinitionRegistry**以及执行实现**BeanFactoryPostProcessors**接口的**postProcessBeanFactory**方法

> 运行示例
![3LvlRO.png](https://s2.ax1x.com/2020/03/06/3LvlRO.png)


## registerBeanPostProcessors分析

- 代码示例

```java
	public static void registerBeanPostProcessors(
			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

		// Register BeanPostProcessorChecker that logs an info message when
		// a bean is created during BeanPostProcessor instantiation, i.e. when
		// a bean is not eligible for getting processed by all BeanPostProcessors.
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

		// Separate between BeanPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();

		// First, register the BeanPostProcessors that implement PriorityOrdered.
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

		//省略代码...
		// Next, register the BeanPostProcessors that implement Ordered.
		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
		sortPostProcessors(orderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, orderedPostProcessors);

		//省略代码...
		// Now, register all regular BeanPostProcessors.
		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

		//省略代码...
		// Re-register post-processor for detecting inner beans as ApplicationListeners,
		// moving it to the end of the processor chain (for picking up proxies etc).
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
	}
```
主要是往beanFactory中注册**BeanProcessor**的实现，在beanFactory中是用**CopyOnWriteArrayList**来作为缓存容器的。

```java
	/** AbstractBeanFactory内部是用CopyOnWriteArrayList来保证安全性的 */
	private final List<BeanPostProcessor> beanPostProcessors = new CopyOnWriteArrayList<>();
```

## initMessageSource()

**initMessageSource**是初始化消息源的，也就是进行初始化国际化配置相关的

## initApplicationEventMulticaster
**initApplicationEventMulticaster**进行初始化事件发布器。beanFactory中存在**ApplicationEventMulticaster**就进行注册，没有就注册**SimpleApplicationEventMulticaster**。

## onRefresh()

**onRefresh**,用于子类实现容器refresh的过程中执行其他特殊操作，这是一个模板方法，允许子类去扩展

## registerListeners
**registerListeners**注册监听器

```java
	protected void registerListeners() {
		// 首先注册指定的静态侦听器.
		for (ApplicationListener<?> listener : getApplicationListeners()) {
			getApplicationEventMulticaster().addApplicationListener(listener);
		}

		// 不要在这里初始化FactoryBeans：我们需要保留所有常规bean
		//否则后置处理器将无法对他们进行处理!
		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
		for (String listenerBeanName : listenerBeanNames) {
			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
		}

		// Publish early application events now that we finally have a multicaster...
		Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
		this.earlyApplicationEvents = null;
		if (earlyEventsToProcess != null) {
			for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
				getApplicationEventMulticaster().multicastEvent(earlyEvent);
			}
		}
	}
```

## finishBeanFactoryInitialization(beanFactory)

**finishBeanFactoryInitialization(beanFactory)**实列化剩下的bean,这个方法也是绝大多数bean初始化的方式。这个方法的解析放在下一篇文章


## finishRefresh

**finishRefresh**完成容器的刷新

```java
	protected void finishRefresh() {
		// 清除上下文级别的资源缓存（例如来自扫描的ASM元数据）.
		clearResourceCaches();

		// 为容器初始化处理器.注册一个LifecycleProcessor
		initLifecycleProcessor();

		// 对生命周期处理器进行刷新.
		getLifecycleProcessor().onRefresh();

		// 广播容器初始化完成的消息.
		publishEvent(new ContextRefreshedEvent(this));

		// 先LiveBeanView中注册ApplicationContext.
		LiveBeansView.registerApplicationContext(this);
	}
```

**initLifecycleProcessor**容器执行容器初始化周期过程中的控制

- 代码运行
![3OuocQ.png](https://s2.ax1x.com/2020/03/07/3OuocQ.png)


# 总结

1. 配置资源初始化环境
    1. 清理环境，设置启动时间，装载servletContext和servletConfig
	2. 获取DefaultListableBeanFactory
    3. 给DefaultListableBeanFactory设置各种属性
2. postProcessBeanFactory()
	1. 注册ServletContextAwareProcessor
	2. 主要是用于注册web应用程序bean的注册范围增加request、session、application
	3. 将servletContext、servletConfig、contextParameters、contextParameters注册到容器中
3. invokeBeanFactoryPostProcessors()
	1. 先处理BeanDefinitionRegistryPostProcessor，按照PriorityOrdered > Ordered > 普通的顺序一次执行postProcessBeanDefinitionRegistry方法
	2. 再处理BeanFactoryPostProcessors，按照PriorityOrdered > Ordered > 普通的顺序一次执行postProcessBeanFactory方法
4. registerBeanPostProcessors()
	1. 往beanFactory中注册BeanProcessor的实现
5. initMessageSource进行国际化配置处理
6. initApplicationEventMulticaster进行初始化事件发布器。beanFactory中存在ApplicationEventMulticaster就进行注册，没有就注册SimpleApplicationEventMulticaster
7. onRefresh,用于子类实现容器refresh的过程中执行其他特殊操作，这是一个模板方法，允许子类去扩展
8. registerListeners注册监听器
9. finishBeanFactoryInitialization()加载bean
10. finishRefresh完成容器的刷新

- 流程图
![3OMqYV.png](https://s2.ax1x.com/2020/03/07/3OMqYV.png)


> 参考资料
- [spring之BeanFactoryPostProcessor执行流程](https://www.jianshu.com/p/5323114c0d05)
- [解读Spring容器的refresh()](https://www.jianshu.com/p/1bc735c30c54)


