---
title: mybatis源代码分析(一)
date: 2018-04-14 23:15:52
categories: mybatis
tags:
    - mybatis
---

# mybatis源代码分析(一)

在近两年的工作中一直是在适用的是mybatis框架，进行数据库的相关操作。这次来进行对mybatis源代码的一个学习。回想一下第一份工作时还使用的是ibatis，着实有一些岁月了。下面来一步一步的进行分析

## 调试环境的搭建

参照芋大的代码，在设置maven的时候需要指定中央仓库这样稍微快一点

使用**AutoConstructorTest**进行测试


## mybatis的分层职责

组件|作用
--|--
sqlSession|接口层
配置解析|核心处理层
参数映射|核心处理层
SQL解析|核心处理层
SQl执行|核心处理层
结果集映射|核心处理层
插件|核心处理层
数据源模块|基础支持层
事务管理模块|基础支持层
缓存模块|基础支持层
Binding模块|基础支持层
反射模块|基础支持层
类型转化|基础支持层
日志模块|基础支持层
资源加载|基础支持层
解析器模块|基础支持层


## 核心基础组件

核心的基础组件：

1. **SqlSession**是抽象处理出来为JDBC生成的Connection对象的SqlSession对象，这样才能与数据库开启“沟通”，通过SqlSession可以实现增删改查的接口

![JEVXRK.png](https://s1.ax1x.com/2020/04/16/JEVXRK.png)

- 默认实现**DefaultSqlSession**

```java
  @Override
  public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      MappedStatement ms = configuration.getMappedStatement(statement);
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }

```
从上面的代码可以看出，sql的执行是交给了**executor**对象去执行的，该对象是**SqlSession**的一个属性。该属性是在**SqlSession**对象的构造方法中传入的。继续延着调用链查看调用者

2. **SqlSessionFactory**是获取**SqlSession**的的接口

```java
  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
    Transaction tx = null;
    try {
      final Environment environment = configuration.getEnvironment();
      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
      final Executor executor = configuration.newExecutor(tx, execType);
      return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
      closeTransaction(tx); // may have fetched a connection so lets call close()
      throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
```

从上述代码中可以看到**executor**对象是通过**comfiguration**对象获取到的。稍后分析**connfiguration**时进行分析该方法。

3. **SqlSessionManager**是组合**SqlSession**和**SqlSessionFactory**的工具类。通过这个类可以直接对数据库进行操作。该类会复用**SqlSessionManager的localSqlSession**的逻辑。