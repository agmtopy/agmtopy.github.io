---
title: shardingSphere理论基础
date: 2020-08-20 23:33:35
categories: ORM
tags:
    - ShardingSphere
---

# shardingSphere理论基础

## 理论
shardingSpgere实现JDBC规范，并在此基础上进行扩展

## 核心概念
数据分片按照拆分的方式分为水平拆分和垂直拆分

- 垂直拆分
> 垂直拆分指的是专库专用，将不同业务的表拆分到对应的库中。微服务架构下已基本实现垂直拆分

- 水平拆分
> 水平拆分指的是通过根据某种规则将数据放到指定的数据节点中，数据节点是由库和表组合而成的


### shardingSphere中的基本概念

名称|作用
--|--
逻辑表|在代码逻辑上对拆分表的总称
真实表|在分片的数据库中真实存在的物理表
数据节点|数据分片的最小单位,由数据源名称和数据表组成(shema.tableName)
绑定表|绑定表是shardingSphere中特有的概念，指的是分片规则一致的主表和子表。如果指定互为绑定表，在进行联表查询时将不会出现笛卡尔积
广播表|广播表类似于mycat中的全局表,适用于作为字典表

- shardingSphere支持的分片策略

名称|作用
--|--
精确分片算法|用于处理使用单一键作为分片键的=与IN进行分片的场景
范围分片算法|用于处理使用单一键作为分片键的BETWEEN AND、>、<、>=、<=进行分片的场景
复合分片算法|用于处理使用多键作为分片键进行分片的场景
Hint分片算法|用于处理使用Hint行分片的场景(使用外部数据进行分片)



### JDBC规范

- DataSource
> DataSource 在 JDBC 规范中代表的是一种数据源，核心作用是获取数据库连接对象 Connection。可以直接通过 DriverManager 获取 Connection

- Connection
> DataSource 的目的是获取 Connection 对象，我们可以把 Connection 理解为一种会话（Session）机制。Connection 代表一个数据库连接，负责完成与数据库之间的通信。所有 SQL 的执行都是在某个特定 Connection 环境中进行的，同时它还提供了一组重载方法，分别用于创建 Statement 和 PreparedStatement。

- Statement
> JDBC 规范中的 Statement 存在两种类型，一种是普通的 Statement，一种是支持预编译的 PreparedStatement

ps: PreparedStatement具体做了什么？

> 预编译指的是数据库的编译器会对sql进行提前编译，然后将预编译的结果缓存到数据库中。这样下次执行时就可以只用替换参数调用预编译的sql语句，从而提高sql的执行效率



- ResultSet
> 代表sql的执行结果

- 基于JDBC规范的流程图

Driver -> 创建DataSource -> 获取Connection -> 创建Statement -> 执行SQL语句 -> 处理ResultSet -> 关闭资源对象


- shardingshere基于适配器模式的JDBC重写实现方案

shardingshere通过继承jdbc预留的Wrapper接口，然后在wrapper中执行jdbc的增强。




## 功能
shardingSphere功能上可以划分为四大部分，<B>基础设施</B>、<B>分片引擎</B>、<B>分布式事务</B>、<B>治理与集成</B>

### 基础设施层

基础设施层包含<B>微内核架构</B>、<B>分布式主键</B>

### 分片引擎
分片引擎包括<B>数据分片</B>、<B>读写分离</B>

### 分布式事务
分布式事务包括<B>标准化事务处理接口</B>、<B>强一致性事务与柔性事务</B>

### 集成与治理
集成与治理包括<B>数据脱敏</B>、<B>配置中心</B>、<B>注册中心</B>、<B>链路跟踪</B>、<B>系统集成</B>


## 业务集成

### jdbc集成

```java
    public DataSource dataSource() throws SQLException {
        //创建分片规则配置类
        ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration();

        //创建分表规则配置类
        TableRuleConfiguration tableRuleConfig = new TableRuleConfiguration("t_user", "ds${0..1}.t_user");

        //创建分布式主键生成配置类
        Properties properties = new Properties();
        properties.setProperty("worker.id", "33");
        KeyGeneratorConfiguration keyGeneratorConfig = new KeyGeneratorConfiguration("SNOWFLAKE", "id", properties);
        tableRuleConfig.setKeyGeneratorConfig(keyGeneratorConfig);
        shardingRuleConfig.getTableRuleConfigs().add(tableRuleConfig);

        //分库规则
        shardingRuleConfig.setDefaultDatabaseShardingStrategyConfig(new InlineShardingStrategyConfiguration("id", "ds${id%2}"));

        //创建具体的DataSource
        return ShardingDataSourceFactory.createDataSource(createDataSourceMap(), shardingRuleConfig, new Properties());
    }
```


### orm框架集成

#### jpa框架

```yml
shardingsphere:
    datasource:
      names: ds0,ds1
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbcUrl: jdbc:mysql://127.0.0.1:3306/ds0?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT
        username: root
        password: ******
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbcUrl: jdbc:mysql://127.0.0.1:3306/ds1?useUnicode=true&characterEncoding=utf-8&serverTimezone=GMT
        username: root
        password: ******
      sharding:
        default-database-strategy: # 分库规则
          inline:
            sharding-column: vender_id
            algorithm-expression: ds${vender_id % 2}
        tables:
          t_user:  #t_user表
            key-generator-column-name: id  #主键
            actual-data-nodes: ds${0..1}.t_user${0..1}    #真实数据节点
            databaseStrategy: # 分库策略
              inline:
                sharding-column: vender_id # 分库键
                algorithm-expression: ds${vender_id % 2}
            tableStrategy: #分表策略
              inline: #行表达式
                shardingColumn: vender_id
                algorithmExpression: t_user${vender_id % 2}
```

#### javaConfig

```java
public DataSource getShardingDataSource() throws SQLException {
        ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration();
        //设置分库分表策略
        shardingRuleConfig.getTableRuleConfigs().add(getOrderTableRuleConfiguration());
        shardingRuleConfig.getTableRuleConfigs().add(getOrderItemTableRuleConfiguration());
        //设置绑定表
        shardingRuleConfig.getBindingTableGroups().add("t_order, t_order_item");
        //设置广播表
        shardingRuleConfig.getBroadcastTables().add("t_config");
        //设置分库默认策略
        shardingRuleConfig.setDefaultDatabaseShardingStrategyConfig(new InlineShardingStrategyConfiguration("user_id", "ds${user_id % 2}"));
        //设置分表默认策略
        shardingRuleConfig.setDefaultTableShardingStrategyConfig(new StandardShardingStrategyConfiguration("order_id", null));
        return ShardingDataSourceFactory.createDataSource(createDataSourceMap(), shardingRuleConfig, new Properties());
    }
```



## shardingSphere的配置

### 行内表达式

```bash
    ds${0..1}.user${1..1}
```

行内表达式是用来作为shardingSphere的配置信息的一种表达方式。

${begin..end} 标识的是从begin到end的一个区间

多个${expression}可以用点号来形成组合关系表达式

### 核心配置项
> shardingSphere的核心功能就是分库分表，核心功能是依赖配置的。掌握如何使用shardingsphere就是掌握如何进行配置。

#### ShardingRuleConfiguration
 
 










