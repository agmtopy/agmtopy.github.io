---
title: MQClientInstance类分析
date: 2019-03-27 22:53:20
categories: 消息队列
tags:
  - RocketMQ
---

# MQClientInstance类分析

**MQClientInstance**是位于**org.apache.rocketmq.client.impl.factory**下的一个为producer和consumer提供统一和**Broker**进行交互的底层工具类；

## 创建

- MQClientManager
```java
public MQClientInstance getOrCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) {
        String clientId = clientConfig.buildMQClientId();
        //判断当前client是否有过实例对象，有就取
        MQClientInstance instance = this.factoryTable.get(clientId);
        if (null == instance) {
            instance =
                new MQClientInstance(clientConfig.cloneClientConfig(),
                    this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);
            MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);
            if (prev != null) {
                instance = prev;
                log.warn("Returned Previous MQClientInstance for clientId:[{}]", clientId);
            } else {
                log.info("Created new MQClientInstance for clientId:[{}]", clientId);
            }
        }

        return instance;
    }
```

**MQClientInstance**的创建是通过**MQClientManager**来进行创建和管理的，通过将实例和**MQClientInstance**放入一个**ConcurrentHashMap**中。默认情况下每个进程内共享同一个MQClientInstance对象连接一个集群，如果要设置多个集群需要手动指定实例名称。

![GFEx1K.png](https://s1.ax1x.com/2020/03/28/GFEx1K.png)

## start()方法

```java
public void start() throws MQClientException {

        synchronized (this) {
            //判断服务状态
            switch (this.serviceState) {
                case CREATE_JUST://创建服务
                    this.serviceState = ServiceState.START_FAILED;
                    // 如果未指定Namesrv地址,尝试从远程服务器中获取地址
                    if (null == this.clientConfig.getNamesrvAddr()) {
                        this.mQClientAPIImpl.fetchNameServerAddr();
                    }
                    // Start request-response channel
                    this.mQClientAPIImpl.start();
                    // 启动各种定时任务
                    this.startScheduledTask();
                    // 启动拉去消息服务
                    this.pullMessageService.start();
                    // 启动负载服务
                    this.rebalanceService.start();
                    // 启动推送服务                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);
                    log.info("the client factory [{}] start OK", this.clientId);
                    this.serviceState = ServiceState.RUNNING;
                    break;
                case START_FAILED:
                    throw new MQClientException("The Factory object[" + this.getClientId() + "] has been created before, and failed.", null);
                default:
                    break;
            }
        }
    }
```
**MQClientInstance**主要是与**Broker**进行通信的，因此在启动后需要存储**NameServer**查询出来的**Topic**、**Broker**信息。在start()中使用了一下一个线程池去执行任务：
1. **startScheduledTask**2分钟去请求一次最新的NameServer地址、更新**Topic**信息、清理失效的**Broker**、保存消费者的**offset**
2. 启动拉消息的线程
3. 启动topic负载线程
4. 启动推送消息的线程


