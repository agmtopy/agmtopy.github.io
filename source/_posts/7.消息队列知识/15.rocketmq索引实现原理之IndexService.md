---
title: rocketmq索引实现原理之IndexService
date: 2021-10-13 00:23:46
categories: 消息队列
tags:
  - RocketMQ
---

# rocketmq索引实现原理之IndexService

在之前的文章中分析了消息是如果通过Commitlog的逻辑设计到MappedFile的与文件系统进行交付的过程，这篇文章来分析消息体是如何实现快速查找的以及底层实现
RocketMQ的索引相关的工作都是由Store包下的<B>IndexService</B>实现的,是设计上<B>IndexService</B>划分为2个部分
- 启动时加载
- 插入索引
- 索引文件及内容

## IndexService的启动时加载分析
<B>IndexService</B>的加载过程是由<B>load()</B>方法实现的,这个方法的被调用链是由
<B>BrokerController</B> -> <B>DefaultMessageStore</B> -> <B>IndexService</B>

![IndexService被调用链](https://i.loli.net/2021/10/17/KA9awWtHXcfGjRL.jpg)


### load()
<B>load()</B>构造方法主要是对原有的index文件分析然后生成IndexFile对象的过程

- load()
```java
    public boolean load(final boolean lastExitOK) {
        //1.查找指定文件目录下的文件列表
        File dir = new File(this.storeIndexPath);
        File[] files = dir.listFiles();
        if (files != null) {
            //2.按照文件名称进行升序
            Arrays.sort(files);
            for (File file : files) {
                try {
                    //3.根据index文件初始化indexFile对象
                    IndexFile f = new IndexFile(file.getPath(), this.hashSlotNum, this.indexNum, 0, 0);
                    //3.初始化indexFile对象的头文件信息
                    f.load();
                    //4.判断上次是否正常退出，未正常退出并且文件记录在日志保存点之后的进行舍弃
                    if (!lastExitOK && f.getEndTimestamp() > this.defaultMessageStore.getStoreCheckpoint().getIndexMsgTimestamp()) {
                        //4.1 舍弃未到保存点的数据
                        f.destroy(0);
                        continue;
                    }
                    log.info("load index file OK, " + f.getFileName());
                    //5.将文件装载到indexFileList中
                    this.indexFileList.add(f);
                } catch (IOException e | NumberFormatException e) {
                    //省略...
                }
            }
        }
        return true;
    }
```
这段代码就是对之前的indexFile文件进行加载，并且对在日志保存点之后的数据进行抛弃。


- IndexFile()

```java
    public IndexFile(final String fileName, final int hashSlotNum, final int indexNum,
        final long endPhyOffset, final long endTimestamp) throws IOException {
        //计算index文件大小 = 头信息长度 + 哈希slot数量*哈希slot长度 + index数量*index长度
        int fileTotalSize = IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);
        //创建mappedFile对象
        this.mappedFile = new MappedFile(fileName, fileTotalSize);

        //对属性进行赋值
        this.fileChannel = this.mappedFile.getFileChannel();
        this.mappedByteBuffer = this.mappedFile.getMappedByteBuffer();
        this.hashSlotNum = hashSlotNum;
        this.indexNum = indexNum;
        //处理文件头信息
        ByteBuffer byteBuffer = this.mappedByteBuffer.slice();
        this.indexHeader = new IndexHeader(byteBuffer);

        //初始化'空间位置'和'时间位置'
        if (endPhyOffset > 0) {
            this.indexHeader.setBeginPhyOffset(endPhyOffset);
            this.indexHeader.setEndPhyOffset(endPhyOffset);
        }
        if (endTimestamp > 0) {
            this.indexHeader.setBeginTimestamp(endTimestamp);
            this.indexHeader.setEndTimestamp(endTimestamp);
        }
    }
```

<B>IndexFile()</B>方法会根据文件名称创建一个index文件对象，这个方法中比较有意思的是会根据配置文件<B>解析</B>、<B>创建</B>头文件信息对象<B>IndexHeader</B>而且还是是通过<B>MappedFile</B>对象进行处理的


## IndexService的插入索引的过程
IndexService对外提供插入索引的方法是<B>buildIndex</B>,buildIndex()是通过<B>DefaultMessageStore</B>的<B>ReputMessageService</B>来进行触发的


- ReputMessageService

```java
    class ReputMessageService extends ServiceThread {
        
        //真正启动索引任务入口
        private void doReput() {
            //1.判断索引的offset是否小于commitLog中最小的offset
            //2.只处理需要进行索引操作的消息
            //3.根据消息组装消息后置处理器
            //4/5。处理主节点和从节点的差异
        }

        @Override
        public void run() {
            while (!this.isStopped()) {
                try {
                    Thread.sleep(1);
                    this.doReput();
                } catch (Exception e) {
                }
            }
        }
    }
```
在<B>ReputMessageService</B>可以看到是使用一个循环每隔1s去查询一次commitLog文件中需要进行后置处理的消息来进行处理

## 索引文件及内容
索引文件是放置在<B>${rootpath}/index</B>目录下的，文件名称按照yyyyMMddhhmmsssss的形式进行生成，默认大小为400MB,由三个部分组成
- header
- slot table
- index linked list
结构如下所示:

```
    |<-- 40 byte -->|<---   500w   --->|<---   2000w   --->|
    +---------------+------------------+-------------------+
    |    header     |   slot table     | index linked list |
    +---------------+------------------+-------------------+
```

- header结构



- slot table结构




- index linked list结构


## 参考资料
http://zjykzk.github.io/post/cs/rocketmq/store/