---
title: RocketMq源代码之NameServer
date: 2019-03-22 15:05:49
categories: 消息队列
tags:
  - RocketMQ
---

# RocketMq源代码之NameServer解析
周末继续阅读RocketMq的学习,在上周已经简单的把RocketMq的安装和使用学习了一下。本周主要来看一下NameServer的源代码和设计

## NameServer启动

### NamesrvController启动
```java
public static NamesrvController main0(String[] args) {

        try {
            //创建NamesrvController()
            NamesrvController controller = createNamesrvController(args);
            start(controller);
            String tip = "The Name Server boot success. serializeType=" + RemotingCommand.getSerializeTypeConfigInThisServer();
            log.info(tip);
            System.out.printf("%s%n", tip);
            return controller;
        } catch (Throwable e) {
            e.printStackTrace();
            System.exit(-1);
        }
        return null;
    }
```

**NamesrvStartup**中启动，调用main0() -> createNamesrvController()

主要代码逻辑在**createNamesrvController**中，主要执行**NamesrvController初始化**、**NamesrvController.start**

### NamesrvController初始化

**NamesrvController**初始化的步骤主要是：
1. 获取到**namesrvConfig**、**nettyServerConfig**
2. 根据配置生成**NamesrvController**

### NamesrvController.start()

```java
        //省略代码....
        //初始化controller
        boolean initResult = controller.initialize();

        //添加关闭的钩子函数
        Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable<Void>() {
            @Override
            public Void call() throws Exception {
                controller.shutdown();
                return null;
            }
        }));

        //省略代码....

        //start
        controller.start();

        return controller;
```

**NamesrvController.start()**主要做了两个工作：
1. 通过**controller.initialize()**设置好controller的配置环境
    1.1 开启Netty服务
    1.2 启动线程池（**remotingExecutor**、两个定时执行的线程，一个用来扫描失效的**Broker（scanNotActiveBroker）**，另一个用来打印配置信息（**printAllPeriodically**））
2. remotingServer.start() 
    2.1 使用netty开启服务
    2.2 **prepareSharableHandlers**中注册**NettyServerHandler**将**NettyRequestProcessor**注册到处理器中

## Namesrv的处理逻辑

Namesrv的处理逻辑主要是通过**NettyRequestProcessor**的子类**DefaultRequestProcessor**来进行实现的

- DefaultRequestProcessor

```java
 switch (request.getCode()) {
    case RequestCode.PUT_KV_CONFIG:
        return this.putKVConfig(ctx, request);
    case RequestCode.GET_KV_CONFIG:
        return this.getKVConfig(ctx, request);
    case RequestCode.DELETE_KV_CONFIG:
        return this.deleteKVConfig(ctx, request);
    case RequestCode.QUERY_DATA_VERSION:
        return queryBrokerTopicConfig(ctx, request);
    case RequestCode.REGISTER_BROKER:
        Version brokerVersion = MQVersion.value2Version(request.getVersion());
        if (brokerVersion.ordinal() >= MQVersion.Version.V3_0_11.ordinal()) {
            return this.registerBrokerWithFilterServer(ctx, request);
        } else {
            return this.registerBroker(ctx, request);
        }
    case RequestCode.UNREGISTER_BROKER:
        return this.unregisterBroker(ctx, request);
    case RequestCode.GET_ROUTEINTO_BY_TOPIC:
        return this.getRouteInfoByTopic(ctx, request);
    case RequestCode.GET_BROKER_CLUSTER_INFO:
        return this.getBrokerClusterInfo(ctx, request);
    case RequestCode.WIPE_WRITE_PERM_OF_BROKER:
        return this.wipeWritePermOfBroker(ctx, request);
    case RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER:
        return getAllTopicListFromNameserver(ctx, request);
    case RequestCode.DELETE_TOPIC_IN_NAMESRV:
        return deleteTopicInNamesrv(ctx, request);
    case RequestCode.GET_KVLIST_BY_NAMESPACE:
        return this.getKVListByNamespace(ctx, request);
    case RequestCode.GET_TOPICS_BY_CLUSTER:
        return this.getTopicsByCluster(ctx, request);
    case RequestCode.GET_SYSTEM_TOPIC_LIST_FROM_NS:
        return this.getSystemTopicListFromNs(ctx, request);
    case RequestCode.GET_UNIT_TOPIC_LIST:
        return this.getUnitTopicList(ctx, request);
    case RequestCode.GET_HAS_UNIT_SUB_TOPIC_LIST:
        return this.getHasUnitSubTopicList(ctx, request);
    case RequestCode.GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST:
        return this.getHasUnitSubUnUnitTopicList(ctx, request);
    case RequestCode.UPDATE_NAMESRV_CONFIG:
        return this.updateConfig(ctx, request);
    case RequestCode.GET_NAMESRV_CONFIG:
        return this.getConfig(ctx, request);
    default:
        break;
}
```

根据不同的请求返回不同的处理函数

## 消息的存储

NameSrv中信息都是存储在内存中的，而且每一个NameSrv保存的信息都是全量的。**RouteInfoManager**是保存这些信息的类

```java

public class RouteInfoManager {
    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);
    private final static long BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final HashMap<String/* topic */, List<QueueData>> topicQueueTable;
    private final HashMap<String/* brokerName */, BrokerData> brokerAddrTable;
    private final HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable;
    private final HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable;
    private final HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable;
}

```

在这里由于Namesev中的业务场景是**读多写少**，因此用**可重入的读写锁**来保证并发的安全性

# 总结
1. 加载配置文件转换为NameServerConfig、NettyConfig
2. 根据配置文件生成**NamesrvController**
3. 创建线程池和定时扫描线程
4. 开启**Netty**服务
5. 用**NettyRequestProcessor**处理请求
6. **RouteInfoManager**中存储信息


> 参考资料

- 《RocketMQ实战与原理解析》
- ![RocketMQ 系列文章](http://www.jiangxinlingdu.com/rocketmq/2018/05/10/mq-rpc.html)

