---
title: rocketmq常见问题
date: 2019-03-27 22:54:17
categories: 消息队列
tags:
  - RocketMQ
---

# rocketmq常见问题

## RocketMQ由哪些角色组成？
由**NameSrv**、**Broker**、**Consumer**、**Producer**组成

## RocketMQ的整体流程？
1. **NameSrv**首先启动
2. **Broker**启动后向NameSrv进行注册，并对外提供服务
3. **producer**向**NameSrv**查询向**Topic**提供写服务的**Broker**进行写入
4. **consumer**向**NameSrv**查询向**Topic**提供写服务的**Broker**进行消费

> 与**NameSrv**都是保持长连接的形式,**Broker**是定时发送心跳包(ip:端口、Topic信息)

## Namesrv的了解？
RocketMQ的**NameSrv**是提供给其他参与者的分布式协调服务，由于每台NameSrv都保存的是全量信息，因此支持横向扩展

## 如何配置NameSrv地址到生产者和消费者？
1. setNamesrvAddr()
2. java启动参数
3. **NAMESRV_ADDR**
4. HTTP站点解析

## 说说对**Broker**的理解

**Broker**将网络和存储等核心功能封装起来，对外提供了存/取消息的功能。
内部通过大量使用线程池，将消息的处理设计成为异步形式的，提高了性能。

1. 通过消息顺序写，建立索引随机读的方式
2. 根据MessageQueue进行负载
3. 支持主从部署
4. 高可靠是用同步刷盘机制来保证的

## **Broker**如何实现存储的？
逻辑上划分业务数据、系统数据
业务数据分别为**CommitLog**、**index**、**ConsumerQueue**、**config**(topic信息、filter等信息)
系统数据分别为abort、lock

收到请求后将请求封装成为正确的消息格式，然后找到commitlog文件，写入文件后更新index文件

## **producer**的理解

1. 通过NameSrv获取到**Broker-Topic**数据
2. 生产者端可以进行负载
3. 有三种发送方式（同步，异步，单向）


## **comsumer**的理解
1. 两种消费模式：集群和广播
2. 获取消息的模式：推送和拉取

## 如何实现消息的重发？
consumer端重置offset

## 顺序消息是什么？
顺序消息分为**普通顺序消息**和**全局顺序消息**，全局顺序消息是普通顺序消息下只有一个messageQueue的特例。
1.生产者端将消息有序的发送到MessageQueue
2.消费端保证一个消费组组内只有一个线程在进行消费(ConsumerOrderLister)

## 顺序消息在扩容时如何保证不停写的情况下扩容？
1. 保证key指定到原messageQueue
2. 消费完旧队列在消费新队列

## 什么是定时消息？
RocketMQ中提供了18个级别的定时消息，从**1s** -> **2h**
原理是：延时消息在发送到broker后会被存储到特定的延迟队列中,broker根据不同的延时级别创建不同的定时任务来根据延迟消费进度来从对应的延迟队列中拉去消息。然后根据延迟队列中的信息还原到真实的topic中。

## 什么是重试消息？
重试消息指的是消息在消费失败后提供的一种重试机制，消费失败的消息会被发回Broker的延迟队列中
主要流程：
1. consumerGroup消费失败后发送到broker
2. broker收到消息后将消息放到延迟消息队列中，到期后向consumer发送拉取请求
3. consumer重新消费消息，并将topice替换为原始的topic

## 多次消费失败后这么处理?
rocketmq多次消费失败后进入死信队列，应用可以订阅死信队列进行告警。

## RocketMQ的事务消息？
RocketMQ的事务消息是保证一方的本地事务和消息发送状态的状态是一个原子类型的操作，通过是基于base理论的，因此适用于长事务的场景

## RocketMQ如何实现高可用？
1. NameSrv无状态的多节点部署
2. broker可以用master-salve部署（2m-2s-async）

