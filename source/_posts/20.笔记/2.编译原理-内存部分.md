---
title: 编译原理-内存部分
date: 2022-03-07 20:42:49
categories: 笔记
tags:
  - 基础
---

# 编译原理-内存部分

这一篇主要是对后端编译器对内存布局的分析和笔记,之前的有关词法/语法方面的理论知识实在是太枯燥了,翻了又翻是在是难以理解,只能暂时放下那一部分的内容了.
在编译时主要将内存划分为两个部分<B>栈</B>、<B>堆</B>：
栈主要是作为程序的临时空间实现方法、局部变量的区域
堆主要是作为分配大对象的区域

## 存储组织

> 存储组织指的是内存区域，字节是内存中的最小编址单元.一个字节包含8个bit.多个连续的字节作为一块内存区域，并这块区域的第一个字节作为它的地址

这里需要注意的是向操作系统申请的一段连续的内存空间可能并不是连续的，内存地址是操作系统提供的，在底层是通过页表的形式将物理上不连续的空间组织成为逻辑上连续的一段内存地址

> 数据对象的存储分配受到目标机器的寻址约束影响很大。在很多机器中，执行整数加法的指令可能要求整数必须是位数相同(对齐)的。也就是说这些对象长度必须被4整除(4字节)。编译器可能会对数据进行指针对齐操作，对于空白的空间被称为<B>'补白'</B>

'指针对齐'其实是由于CPU决定的，当现代CPU决定以2的指数倍数进行数据读取计算时，就决定了数据-指针的位数了。'补白'的指针在进行运算时肯定是优与未进行'补白'的指针的



> 生成的目标代码在编译时刻就决定了编译后的大小了，因此编译器可以将可执行目标代码放到一个静态确定的区域:<B>代码区</B>

静态区域:
静态区域指的是在编译后就能确定内存分配的区域，例如代码区\JVM中的常量池等

动态区域:
动态区域指的是只能在运行时才能填充的内存区域，例如局部变量、堆区等


关于静态分配和动态分配分别表示的是<B>编译时刻</B>、<B>运行时刻</B>

动态分配主要有两种实现方式分别是
1. 栈式存储
    一个过程局部名字在栈中分配空间,通常支持过程调用/结果返回
2. 堆存储
    有一些数据结构的生命周期比较长，这些数据通常被放到一个可重复存储的"堆"中

> 为了支持堆区管理，通过设计"垃圾回收器"来是的在运行时刻能够检测出堆区的无用的数据结构，并且自动回收

GC的概念在很早的时候就出现了

## 栈空间

> 有些语言使用过程、函数或方法作为用户自定义动作的单元，通过在运行时刻按照栈结构进行管理。在调用一个过程的时候将存放这个过程的指针入栈，计算结束时出栈。这样能带来的好处是允许同时调用多个不交叠的过程










