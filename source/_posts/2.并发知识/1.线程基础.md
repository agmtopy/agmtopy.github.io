---
title: 线程基础
date: 2017-02-22 11:28:29
categories: java并发
tags:
  - 多线程
---

# 线程基础
介绍多线程中的基础知识，包含线程创建、线程运行状态和线程中断

## 线程创建

线程创建有且/只有一种方式，继承**Thread**类,重写 **Run()** 方法

```kotlin
    class TaskDemoKt: Thread() {
        override fun run() {
            super.run()
            println( currentThread().name + "执行任务")
        }
    }

    fun main(){
        val demoKt = TaskDemoKt()
        demoKt.start()
    }
```

通过实现Runnable接口、创建线程池、Timer类等方式底层都是这种方式实现的.下面分别翻一下这三种方式的源代码

- 实现Runnable接口

```java



```


- 创建线程池

```java



```


- 继承timer类


```java


```



## 线程执行的任务

1. 实现**Runable**接口
```java
    @Override
    public void run(){

    }
```

2. 实现**Callable<Objetc>**接口
```java
    new Callable<Object>() {
        @Override
        public Object call() throws Exception {
            return null;
        }
    }
```

3. 继承**ForkJoinTask**接口

```java
    new ForkJoinTask<Object>() {
        @Override
        public Object getRawResult() {
            return null;
        }

        @Override
        protected void setRawResult(Object value) {

        }

        @Override
        protected boolean exec() {
            return false;
        }
    }
```

3. 继承**ForkJoinTask**接口

```java
    new ForkJoinTask<Object>() {
        @Override
        public Object getRawResult() {
            return null;
        }

        @Override
        protected void setRawResult(Object value) {

        }

        @Override
        protected boolean exec() {
            return false;
        }
    }
```

通过实现Runnable接口的方式来执行任务比直接创建线程要好的多，这样可以复用线程。

## 线程创建

线程的状态可以分为
1. New(新创建)
2. Runnable(可运行)
3. Blocked(可阻塞)
4. Waiting(等待)
5. Timed Waiting(计时等待)
6. Terminated(被终止)

![线程状态](https://s2.ax1x.com/2020/02/23/31vE4A.png)

## 中断线程

在java中不提供强制停止线程的方式，因为线程的强制停止可能会造成数据异常或者业务中断，这是业务方和中断方都不愿意看到的方式。java提供的方式是希望线程之间可以相互的通知、相互协助。提供这个方式的是**interrupt**。

```java

    while(!Thread.currentThread().isInterrupted() && more work to do){

    }

```
判断线程条件和业务规则都满足时，才会继续执行。


在线程**sleep**期间，线程可以感受到中断信号，感受到中断信号后会清除中断位标志并且抛出**InterruptedException**异常。


## volatile不能作为线程标记位

volatile作为标记位的时候，当线程阻塞的时候，其他线程仍旧可以改变标记位的值，因此volatile不适合作为线程标记位。

## wait/notify/notifyAll()方法使用注意
1. wait()方法，必须在**synchronized**中持有锁后才能使用，因为必须持有对象的**monitor**锁，这样才能防止在执行前后线程被切换。
2. **sleep()**被定义在Thread中，wait/notify/notifyAll都要操作**monitor**,属于对象级的锁。
3. wait/notify与sleep的区别
    1. 相同点
    都让线程阻塞、都可响应InterruptException异常
    2. 不同点
    2.1 sleep不会释放monitor锁
    2.2 sleep方法必须定义一个等待时间，到期后可主动恢复，wait方法没时间参数意味着一直会等待下去
    2.3 wait/notify是Object的，sleep是Thread的方法
    2.4 wait必须在synchronized中使用




