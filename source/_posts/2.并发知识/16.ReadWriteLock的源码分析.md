---
title: ReadWriteLock的源码分析
date: 2021-11-02 16:24:34
categories: 并发
tags: ReadWriteLock
---

# ReadWriteLock的源码分析
 ReadWriteLock是JUC包下的定义的读写锁的接口,定义两个接口<B>readLock()</B>、<B>writeLock()</B>分别是返回读锁和返回一个写锁。
 ReadWriteLock默认有两个实现分别是<B>ReadWriteLockView</B>、<B>ReentrantReadWriteLock</B>。
 
 ReentrantReadWriteLock是默认的读写锁的实现
 ReadWriteLockView是<B>StampedLock</B>的内部类，StampedLock是JDK 1.8中对ReentrantReadWriteLock的一个增强的实现
 下面会先分析ReentrantReadWriteLock，在对StampedLock进行分析

## ReentrantReadWriteLock

> ReentrantReadWriteLock是实现ReadWriteLock接口,对外提供read()和wirte()方法。特点主要是支持公平锁选择、可重入、锁降级的分类

 ### 用例

这个用例是对ReentrantReadWriteLock提供的用例CachedData的简化版本

- CachedData

```kotlin
    class CachedData {
        private lateinit var data: String
        private var cacheValid: Boolean = false
        private var lock: ReentrantReadWriteLock = ReentrantReadWriteLock()

        fun processCacheData() {
            //获取读锁
            lock.readLock().lock()
            if (!cacheValid) {
                //获取写锁之前先要释放读锁
                lock.readLock().unlock()
                //获取写锁
                lock.writeLock().lock()
                try {
                    //再次检查标记,因为上一次检查标记是在获取写锁之前
                    if (!cacheValid) {
                        TimeUnit.SECONDS.sleep(2)
                        println(Thread.currentThread().name + " set data")
                        data = Thread.currentThread().name + " " + LocalDateTime.now().toString()
                        cacheValid = true
                    }
                    //重新获取读锁来完成锁降级
                    lock.readLock().lock()
                } finally {
                    lock.writeLock().unlock()
                }
            }

            try {
                println(Thread.currentThread().name + "打印data:" +  data)
            } finally {
                lock.readLock().unlock()
            }
        }
    }
```

- main

```kotlin
    fun main() {
        //创建线程池
        val poolExecutor = ThreadPoolExecutor(2, 2, 0, TimeUnit.SECONDS, SynchronousQueue())

        //创建任务
        var cache:CachedData = CachedData()

        var barrier:CyclicBarrier = CyclicBarrier(2)
        IntStream.range(0, 2).forEach{
            poolExecutor.submit{
                barrier.await()
                cache.processCacheData()
            }
        }
    }
```

- 执行结果

![执行结果](https://i.loli.net/2021/11/12/wNerlsGfKLpEhzd.jpg)
可以看到两个线程对data的写锁进行竞争,但是只有一个线程成功执行set方法,另外的一个线程只能执行读锁的操作
从现象上来看一个<B>ReentrantReadWriteLock</B>对外提供了读锁和写锁两个功能,下面就开始对代码进行详细的分析


### 构造函数

  ```java

    /**
     * Creates a new {@code ReentrantReadWriteLock} with
     * default (nonfair) ordering properties.
     */
    public ReentrantReadWriteLock() {
        this(false);
    }

    /**
     * Creates a new {@code ReentrantReadWriteLock} with
     * the given fairness policy.
     *
     * @param fair {@code true} if this lock should use a fair ordering policy
     */
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }

  ```

  可以看到无参的构造函数是非公平锁的策略,在构造方法中主要是创建了三个成员变量

  ```java
    ReentrantReadWriteLock{
        //公平锁类型
        final Sync sync;
        //内部读锁
        private final ReentrantReadWriteLock.ReadLock readerLock;
        //内部写锁
        private final ReentrantReadWriteLock.WriteLock writerLock;
    }
  ```


### 源码解析
    
- 获取锁的方法
    获取读锁/写锁就是直接返回内部的读锁/写锁变量

```java
    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
```

可以看到锁的类型分别是ReadLock和WriteLock,继续分析ReadLock/WriteLock


- ReadLock与WriteLock对比


- ReadLock

```java
    public static class ReadLock implements Lock, java.io.Serializable {
        private static final long serialVersionUID = -5992448646407690164L;
        private final Sync sync;

        protected ReadLock(ReentrantReadWriteLock lock) {
            sync = lock.sync;
        }

        public void lock() {
            sync.acquireShared(1);
        }

        public void lockInterruptibly() throws InterruptedException {
            sync.acquireSharedInterruptibly(1);
        }

        public boolean tryLock() {
            return sync.tryReadLock();
        }

        public boolean tryLock(long timeout, TimeUnit unit)
                throws InterruptedException {
            return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
        }

        public void unlock() {
            sync.releaseShared(1);
        }

        public Condition newCondition() {
            throw new UnsupportedOperationException();
        }

        public String toString() {
            int r = sync.getReadLockCount();
            return super.toString() +
                "[Read locks = " + r + "]";
        }
    }
```

- WriteLock

```java
    public static class WriteLock implements Lock, java.io.Serializable {
        private static final long serialVersionUID = -4992448646407690164L;
        //ReentrantReadWriteLock内部的AQS公平/非公平抽象类
        private final Sync sync;


        protected WriteLock(ReentrantReadWriteLock lock) {
            sync = lock.sync;
        }

        public void lock() {
            sync.acquire(1);
        }

        public void lockInterruptibly() throws InterruptedException {
            sync.acquireInterruptibly(1);
        }

        public boolean tryLock() {
            return sync.tryWriteLock();
        }

        public boolean tryLock(long timeout, TimeUnit unit)
                throws InterruptedException {
            return sync.tryAcquireNanos(1, unit.toNanos(timeout));
        }

        public void unlock() {
            sync.release(1);
        }

        public Condition newCondition() {
            return sync.newCondition();
        }

        public String toString() {
            Thread o = sync.getOwner();
            return super.toString() + ((o == null) ?
                                        "[Unlocked]" :
                                        "[Locked by thread " + o.getName() + "]");
        }

        //查询当前线程是否持有写锁
        public boolean isHeldByCurrentThread() {
            return sync.isHeldExclusively();
        }

        //当前写锁的锁定次数
        public int getHoldCount() {
            return sync.getWriteHoldCount();
        }
    }

```

通过对比可知<B>WriteLock</B>只是比<B>ReadLock</B>多两个方法

- isHeldByCurrentThread()
    查询当前线程是否持有写锁
- getHoldCount()
    当前写锁的锁定次数

同时可以看到不管是<B>WriteLock</B>、<B>ReadLock</B>都是使用<B>Sync</B>来实现的功能，下面详细的分析一下<B>Sync</B>类的实现


- <B>Sync</B>

```java
    abstract static class Sync extends AbstractQueuedSynchronizer {
        private transient ThreadLocalHoldCounter readHolds;
        private volatile int state;
        //构造函数
        Sync() {
            //创建ThreadLocalHoldCounter(记录线程持有的锁数量)
            readHolds = new ThreadLocalHoldCounter();
            //设置状态，调用AQS的setState()
            setState(getState()); // ensures visibility of readHolds
        }
        
    }
```

从上面代码可以看出<B>Sync</B>是继承自<B>AbstractQueuedSynchronizer</B>，在构造方法中创建<B>ThreadLocalHoldCounter</B>和调用AQS的<B>setState()</B>方法

有关<B>AbstractQueuedSynchronizer</B>的内容可以参考之前写的
[AbstractQueuedSynchronizer的源码分析](../../../../../2020/05/22/2.并发知识/13.AbstractQueuedSynchronizer的源码分析/)


- ThreadLocalHoldCounter
    ThreadLocalHoldCounter的代码如下所示
 
    - ThreadLocalHoldCounter
    ```java
        static final class ThreadLocalHoldCounter
            extends ThreadLocal<HoldCounter> {
            public HoldCounter initialValue() {
                return new HoldCounter();
            }
        }
    ```

    - HoldCounter

    ```java
        static final class HoldCounter {
            //初始为0
            int count;
            //使用id来标识Thread而不是引用,避免引用逃逸
            final long tid = LockSupport.getThreadId(Thread.currentThread());
        }
    ```

    ThreadLocalHoldCounter继承于ThreadLocal然后在初始化时用initialValue()方法返回一个<B>HoldCounter</B>引用
    HoldCounter是用来记录线程中加锁的统计与线程id相关联,这里关联线程引用是比较优秀的,通过<B>LockSupport.getThreadId</B>获取一个long类型的线程标识

    - LockSupport.getThreadId

    ```java
        static final long getThreadId(Thread thread) {
            //U是Unsafe类型的对象
            return U.getLong(thread, TID);
        }
    ```

    这里还有一个关键点是count是int类型的,因此最多支持65535个递归写锁和65535个读锁。 尝试超过这些限制导致Error从锁定方法抛出

    ![超过锁阈值](https://i.loli.net/2021/11/13/uon9IW6fcLxPRv5.jpg)




    






## StampedLock



## 总结


## 参考资料
[StampedLock的理解和使用](https://www.cnblogs.com/zxporz/p/11642176.html)
