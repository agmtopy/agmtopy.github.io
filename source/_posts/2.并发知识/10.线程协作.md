---
title: 线程协作
date: 2017-06-12 21:53:34
categories: java并发
tags:
  - 线程协作
---

# 线程协作
线程之间相互协作

## 信号量

线程（semaphore）之间信号量的作用是于标记当前资源能否被线程访问的信号。线程访问资源时尝试用**acquire**，访问完成使用**release**归还资源

## countDownLatch
**countDownLatch**的作用是多线程之间的倒计时器，用于多线程之间的协作。有两种用法：
1. 主线程等待其他线程运行完毕后执行
2. 其他线程等待主线程运行完毕后执行

- 演示代码
```java
    public static void main(String[] args) throws InterruptedException {
          private static final ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 2, 0, TimeUnit.SECONDS, new LinkedBlockingDeque<>(), new ThreadFactoryBuilder().setNameFormat("线程_%s").build());

        CountDownLatch count = new CountDownLatch(2);
        for (int i = 0; i < 2; i++) {
            threadPool.submit(() -> {
                String msg = String.format("%s开始执行...", Thread.currentThread().getName());
                System.out.println(msg);
                count.countDown();
            });
        }
        count.await();
        System.out.println(Thread.currentThread().getName() + "执行完毕...");
    }
````
![GZRSF1.png](https://s1.ax1x.com/2020/03/29/GZRSF1.png)


## CyclicBarriar
**CyclicBarriar**是一组线程到达某个状态后才开始执行,与**CountDownLatch**不同。**CountDownLatch**是达到count=0以后开始执行，是作用于**事件**驱动。**CyclicBarriar**是线程驱动，N个线程到达**wait**的状态统一开始执行。

- CyclicBarriar演示代码

```java
public class CyclicBarriarDemo {

    private static final ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, Integer.MAX_VALUE, 0, TimeUnit.SECONDS, new SynchronousQueue<>(), new ThreadFactoryBuilder().setNameFormat("线程_%s").build());

    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
        for (int i = 0; i < 6; i++) {
            int finalI1 = i;
            threadPool.submit(() -> {
                String msg1 = String.format("[%s]-小老鼠[%d]开始出洞", Thread.currentThread().getName(), finalI1);
                System.out.println(msg1);
                Integer sleepTime = ThreadLocalRandom.current().nextInt(10);
                try {
                    TimeUnit.SECONDS.sleep(sleepTime);
                    String msg2 = String.format("[%s]-小老鼠[%d]到达指定地点", Thread.currentThread().getName(), finalI1);
                    System.out.println(msg2);
                    cyclicBarrier.await();
                    String msg3 = String.format("[%s]-小老鼠[%d]合力获取到奶酪(🧀)", Thread.currentThread().getName(), finalI1);
                    System.out.println(msg3);
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
```

- 执行结果
![GZ57WR.png](https://s1.ax1x.com/2020/03/29/GZ57WR.png)

- 有启始动作的方法

```java
    CyclicBarrier cyclicBarrier = new CyclicBarrier(3,()->{
        String msg1 = String.format("[%s]-发现奶酪(🧀)", Thread.currentThread().getName());
        System.out.println(msg1);
    });
```

- 执行结果

![GZIufs.png](https://s1.ax1x.com/2020/03/29/GZIufs.png)

## Condittion

**Condittion**能让不同线程之间相互协作，等待满足条件后继续执行。

```java
public class ConditionDemo {
    private ReentrantLock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public static void main(String[] args) throws InterruptedException {
        ConditionDemo conditionDemo = new ConditionDemo();

        new Thread(() ->{
            try {
                conditionDemo.method1();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        conditionDemo.method0();
    }

    public void method0() throws InterruptedException {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + ":条件未准备完毕...");
            condition.await();
            System.out.println(Thread.currentThread().getName() + ":开始执行...");
        }
        finally {
            lock.unlock();
        }
    }

    public void method1() throws InterruptedException {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + ":条件准备完毕...");
            condition.signal();
        }finally {
            lock.unlock();
        }
    }
}
```

**Condition**是lock锁提供的一种可供线程之间进行交互的一种方法。由于**signal**底层会使用到当前线程和lock锁的持有线程进行对比，相等才会进行唤醒其他线程。



# 总结

- **semaphore**
信号量的作用是只有获得信号量的线程才能**执行**，其余线程只能等待持有信号量的线程释放后才有机会执行。

- **countDownLatch**是等待一组线程执行完毕后等待线程才可以执行，是事件触发

- **CyclicBarriar**是一组线程到达**wait()**状态以后才可以开始执行，触发动作是设定的一组线程都到达某个临界状态，并且可被复用，

