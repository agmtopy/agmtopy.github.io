---
title: 阻塞队列
date: 2017-04-07 20:58:53
categories: java并发
tags:
  - 阻塞队列
---

# 阻塞队列

## 阻塞队列的定义

**阻塞队列**是实现了BlockingQueue接口的之类，BlockingQueue的代码入下：
```java
    public interface BlockingQueue<E> extends Queue<E> 
```
**BlockingQueue**的特点是有阻塞能力：
1. **take()**的功能是移除头节点，当队列为空时，则阻塞
2. **put()**的功能是向对位添加元素，当队列满载时，则阻塞

BlocakingQueue的实现类有：
1. ArrayBlockingQueue
2. LinkedBlockingQueue
3. SynchronousQueue
4. DelayQueue
5. PriorityBlockingQueue
6. LinkedTransferQueue

![3jrGTI.png](https://s2.ax1x.com/2020/03/07/3jrGTI.png)

## 阻塞队列常用的方法
在阻塞队列中主要有8种方法，按照分类分为3大类：
1. **抛出异常** add、remove、element
2. **返回结果但是不抛出异常** offer、poll、peek
3. **阻塞** put、take

动作\失败处理方式|抛出异常|返回结果但是不抛出异常|阻塞
--|--|--|--
添加元素|add|offer|put
移除元素|remove|poll|take
返回头节点|element|peek|无

## 常见的阻塞队列
- ArrayBlockingQueue
 **ArrayBlockingQueue**是一个容量固定的有界阻塞队列，构造方法如下：
 ```java
    public ArrayBlockingQueue(int capacity, boolean fair) {
     //省略代码...
    }
 ```
 **fair**表示队列是公平的还是不公平的

 - LinkBlockingQueue
**LinkedBlockingQueue**是一个默认构造器创建的是无界阻塞队列也可以指定队列容量，构造方法如下：
```java
    public LinkedBlockingQueue() {
        this(Integer.MAX_VALUE);
    }

    public LinkedBlockingQueue(int capacity) {
        if (capacity <= 0) throw new IllegalArgumentException();
        this.capacity = capacity;
        last = head = new Node<E>(null);
    }
```

- SynchronousQueue
**SynchronousQueue**是一个内部容量为0的阻塞队列，导致每次取数据都要阻塞等待

- PriorityBlockingQueue
**PriorityBlockingQueue**是一个支持优先级排序的阻塞队列，是一个无界队列。构造方法
```java
    public PriorityBlockingQueue() {
        this(DEFAULT_INITIAL_CAPACITY, null);
    }

        public PriorityBlockingQueue(int initialCapacity) {
        this(initialCapacity, null);
    }

```

- DelayQueue

**DelayQueue**是一个延迟阻塞队列，构造函数为：
```java
    public DelayQueue() {}

    public DelayQueue(Collection<? extends E> c) {
        this.addAll(c);
    }

```

## 阻塞队列和非阻塞队列并发安全的原理是什么？

### ArrayBlockingQueue
 
```java
    /** Main lock guarding all access */
    final ReentrantLock lock;
    /** Condition for waiting takes */
    private final Condition notEmpty;
    /** Condition for waiting puts */
    private final Condition notFull;

    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
```
通过共用同一个lock来锁住队列后，用首尾两个**Condition**来分别锁住队列

### ConcurrentLinkedQueue

```java
public boolean offer(E e) {
        checkNotNull(e);
        final Node<E> newNode = new Node<E>(e);

        for (Node<E> t = tail, p = t;;) {
            Node<E> q = p.next;
            if (q == null) {
                // p is last node
                if (p.casNext(null, newNode)) {
                    // Successful CAS is the linearization point
                    // for e to become an element of this queue,
                    // and for newNode to become "live".
                    if (p != t) // hop two nodes at a time
                        casTail(t, newNode);  // Failure is OK.
                    return true;
                }
                // Lost CAS race to another thread; re-read next
            }
            else if (p == q)
                // We have fallen off list.  If tail is unchanged, it
                // will also be off-list, in which case we need to
                // jump to head, from which all live nodes are always
                // reachable.  Else the new tail is a better bet.
                p = (t != (t = tail)) ? t : head;
            else
                // Check for tail updates after two hops.
                p = (p != t && t != (t = tail)) ? t : q;
        }
    }
```

可以从方法中看出offer方法就是不停的重试加上CAS机制保证了并发的安全性，这是乐观锁的一种思想。适用用线程竞争不激烈的场景。

## 如何选择阻塞队列

如何选择阻塞队列可以中线程池来进行分析

### LinkedBlockingQueue
```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
    }

    public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
    }

```

可以看出固定线程数的线程池采用的是无限长度的队列作为缓存池

### SynchronousQueue

```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```
无最大线程数的线程池采用的是无容量的队列做为缓存池

### DelayedWorkQueue

```java
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
```

具有周期性执行的线程池采用的是延迟队列，从而实现周期性执行的功能

## 总结
因此选择队列也应该从业务的属性出发，在这几个方面进行取舍**长度**、**特点**、**性能**。从而选择最适合业务场景的队列。