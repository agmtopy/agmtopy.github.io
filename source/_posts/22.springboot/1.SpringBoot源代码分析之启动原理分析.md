---
title: SpringBoot源代码分析之启动原理分析
date: 2022-04-12 20:46:39
tags: SpringBoot
categories: SpringBoot
---


# SpringBoot源代码分析之启动原理分析

## 引言
这是一系列关于SpringBoot源代码的相关分析文章,主要参考《SpringBoot编程思想-核心篇》的章节,在参考SpringBoot源代码分析而来,希望对你有所帮助

## 准备工作

参考项目为地址为:https://github.com/agmtopy/SpringBootExample


## 启动类概览

在项目中,启动类为`SpringDemoApplication`,这个类应该是一切的开始,下面我们就来根据这个<B>run</B>方法来进行分析


- SpringDemoApplication
```java
    @SpringBootApplication
    public class SpringDemoApplication {

        public static void main(String[] args) {
            SpringApplication.run(SpringDemoApplication.class, args);
        }

    }
```

- 执行链路



可以看到执行链路为:


这里有一个小细节,在没有提前初始化SpringApplication()时是不能使用arthas进行插入代码,显示错误为图一

![图1](https://github.com/agmtopy/noteBook/blob/master/png/S-springboot%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/Arthas_SpringApplicationRun1.jpg?raw=true)

查看相关类信息也没有看到类加载

![图2](https://github.com/agmtopy/noteBook/blob/master/png/S-springboot%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/Arthas_SpringApplicationRun2.jpg?raw=true)

经过分析可以知道这时候<B>SpringApplication</B>类还没有加载

## SpringApplication.run()


- run()

```java
    
    //1. 构造方法  
    public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
		return new SpringApplication(primarySources).run(args);
	}

    //2. 构造方法
    public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
        //1. 初始化ResourceLoader
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, "PrimarySources must not be null");
		this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
		this.webApplicationType = WebApplicationType.deduceFromClasspath();
		this.bootstrapRegistryInitializers = new ArrayList<>(
				getSpringFactoriesInstances(BootstrapRegistryInitializer.class));
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		this.mainApplicationClass = deduceMainApplicationClass();
	}

```

run()方法最后是执行<B>SpringApplication</B>的初始化方法:

![图3]()

- run()

```java
	/**
	 * 运行Spring应用程序，创建并刷新新的容器
	 */
	public ConfigurableApplicationContext run(String... args) {
		//1. 执行需要在初始化开始时执行的钩子方法
		SpringApplicationHooks.hooks().preRun(this);
		//2. 获取初始化时间
		long startTime = System.nanoTime();
		//3.初始化BootStrapContext(引导上下文)
		DefaultBootstrapContext bootstrapContext = createBootstrapContext();
		ConfigurableApplicationContext context = null;
		//4. 配置head头属性
		configureHeadlessProperty();
		//5. 获取运行中的执行监听器
		SpringApplicationRunListeners listeners = getRunListeners(args);
		//6. 启动监听器
		listeners.starting(bootstrapContext, this.mainApplicationClass);
		try {
			//7. 初始化应用程序参数
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
			//8. 准备运行环境
			ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
			//9. 设置需要忽略的bean
			configureIgnoreBeanInfo(environment);
			//10. 打印Banner信息
			Banner printedBanner = printBanner(environment);
			//11. 创建ApplicationContext
			context = createApplicationContext();
			//12. 设置应用程序启动器(用于收集启动过程中的一些信息)
			context.setApplicationStartup(this.applicationStartup);
			//13. 准备启动ApplicationContext
			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
			//14. 判断是否需要重新刷新容器
			if (refreshContext(context)) {
				//15. 后置刷新容器方法
				afterRefresh(context, applicationArguments);
				//16. 记录时间
				Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);
				if (this.logStartupInfo) {
					new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(),
							timeTakenToStartup);
				}
				//17. 设置监听时间
				listeners.started(context, timeTakenToStartup);
				//18. 执行Runner方法
				callRunners(context, applicationArguments);
			}
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, listeners);
			throw new IllegalStateException(ex);
		}
		try {
			if (context.isRunning()) {
				Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);
				listeners.ready(context, timeTakenToReady);
			}
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, null);
			throw new IllegalStateException(ex);
		}
		//19. 执行后置Hook后置方法
		SpringApplicationHooks.hooks().postRun(this, context);
		return context;
	}
```

可以看到run方法的执行过程分为几个阶段:

- <B>前置准备阶段</B>
	- 执行前置钩子方法(步骤一)
	- 初始化引导上下文(步骤二\步骤三\步骤四)
	- 设置启动监听器 (步骤五\步骤六)

- <B>启动容器阶段</B>
	- 初始化应用参数(步骤七\八\九\十)
	- 创建容器(步骤十一\十二\十三)

- <B>刷新容器阶段</B>
	- 刷新容器(步骤十四)
	- 创建容器(步骤十五)

- <B>执行后置方法阶段</B>
	- 执行Runner(步骤十八)
	- 执行hook(步骤十九)


## 前置准备阶段

<B>前置准备阶段</B>主要是设置一些容器上下文和钩子函数,下面详细分析一下这几个功能的实现

### 执行前置钩子方法

```java
	//设置钩子方法
	SpringApplicationHooks.hooks().preRun(this);
```

这个方法是在针对于AOT的启动过程中提供的钩子方法,最早应用于<B>v3.0.0-M4</B>版本中,[commit](https://github.com/spring-projects/spring-boot/commit/9cd17f8a14eab8007c372c045a6b9295a3a56126?diff=unified)

下面来继续分析<B>SpringApplicationHooks</B>的执行流程


```java
final class SpringApplicationHooks {

	private static final ThreadLocal<Hooks> hooks = ThreadLocal.withInitial(Hooks::new);

	static void withHook(Hook hook, Runnable action) {
		//....
	}
	
	//钩子接口
	interface Hook {
		default void preRun(SpringApplication application) {
		}

		default void postRun(SpringApplication application, ConfigurableApplicationContext context) {
		}

		default boolean preRefresh(SpringApplication application, ConfigurableApplicationContext context) {
			return true;
		}
	}
}
```

<B>SpringApplicationHooks</B>主要是由两个部分组成:
 - 本身的线程变量属性<B>hooks</B>和设置方法<B>withHook</B>
 - <B>hook</B>接口定义的方法:<B>preRun():开始执行</B>、<B>postRun():run()方法执行完成后执行</B>、<B>preRefresh():指定刷新前执行</B>

目前hook有两个实现类,在SpringApplicationHooks中默认实现的<B>hooks</B>以及在AOT模块中的实现类<B>AotProcessorHook</B>

下面对<B>Hook</B>的方法的调用过程进行分析

- preRun

![preRun调用过程]()






